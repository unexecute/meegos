function t(t, e, n, r) {
    Object.defineProperty(t, e, {
        get: n,
        set: r,
        enumerable: !0,
        configurable: !0
    })
}
function e(t) {
    return t && t.__esModule ? t.default : t
}
var n = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {};
function r(t, e) {
    return Object.keys(e).forEach((function(n) {
        "default" === n || "__esModule" === n || t.hasOwnProperty(n) || Object.defineProperty(t, n, {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        })
    }
    )),
    t
}
var i = {}
  , s = {}
  , o = n.parcelRequire5e0a;
null == o && ((o = function(t) {
    if (t in i)
        return i[t].exports;
    if (t in s) {
        var e = s[t];
        delete s[t];
        var n = {
            id: t,
            exports: {}
        };
        return i[t] = n,
        e.call(n.exports, n, n.exports),
        n.exports
    }
    var r = new Error("Cannot find module '" + t + "'");
    throw r.code = "MODULE_NOT_FOUND",
    r
}
).register = function(t, e) {
    s[t] = e
}
,
n.parcelRequire5e0a = o),
o.register("27Lyk", (function(e, n) {
    var r, i;
    t(e.exports, "register", (()=>r), (t=>r = t)),
    t(e.exports, "resolve", (()=>i), (t=>i = t));
    var s = {};
    r = function(t) {
        for (var e = Object.keys(t), n = 0; n < e.length; n++)
            s[e[n]] = t[e[n]]
    }
    ,
    i = function(t) {
        var e = s[t];
        if (null == e)
            throw new Error("Could not resolve bundle with id " + t);
        return e
    }
}
)),
o.register("1b2ls", (function(e, n) {
    /**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
    var r, i, s;
    t(e.exports, "Fragment", (()=>r), (t=>r = t)),
    t(e.exports, "jsx", (()=>i), (t=>i = t)),
    t(e.exports, "jsxs", (()=>s), (t=>s = t));
    var a = o("acw62")
      , l = Symbol.for("react.element")
      , c = Symbol.for("react.fragment")
      , u = Object.prototype.hasOwnProperty
      , h = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
      , d = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function f(t, e, n) {
        var r, i = {}, s = null, o = null;
        for (r in void 0 !== n && (s = "" + n),
        void 0 !== e.key && (s = "" + e.key),
        void 0 !== e.ref && (o = e.ref),
        e)
            u.call(e, r) && !d.hasOwnProperty(r) && (i[r] = e[r]);
        if (t && t.defaultProps)
            for (r in e = t.defaultProps)
                void 0 === i[r] && (i[r] = e[r]);
        return {
            $$typeof: l,
            type: t,
            key: s,
            ref: o,
            props: i,
            _owner: h.current
        }
    }
    r = c,
    i = f,
    s = f
}
)),
o.register("acw62", (function(t, e) {
    t.exports = o("2pUnB")
}
)),
o.register("2pUnB", (function(e, n) {
    /**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
    var r, i, s, o, a, l, c, u, h, d, f, p, m, g, y, b, v, w, x, E, _, A, S, T, k, I, M, C, P, O, N, R, D, B, L;
    t(e.exports, "Children", (()=>r), (t=>r = t)),
    t(e.exports, "Component", (()=>i), (t=>i = t)),
    t(e.exports, "Fragment", (()=>s), (t=>s = t)),
    t(e.exports, "Profiler", (()=>o), (t=>o = t)),
    t(e.exports, "PureComponent", (()=>a), (t=>a = t)),
    t(e.exports, "StrictMode", (()=>l), (t=>l = t)),
    t(e.exports, "Suspense", (()=>c), (t=>c = t)),
    t(e.exports, "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", (()=>u), (t=>u = t)),
    t(e.exports, "cloneElement", (()=>h), (t=>h = t)),
    t(e.exports, "createContext", (()=>d), (t=>d = t)),
    t(e.exports, "createElement", (()=>f), (t=>f = t)),
    t(e.exports, "createFactory", (()=>p), (t=>p = t)),
    t(e.exports, "createRef", (()=>m), (t=>m = t)),
    t(e.exports, "forwardRef", (()=>g), (t=>g = t)),
    t(e.exports, "isValidElement", (()=>y), (t=>y = t)),
    t(e.exports, "lazy", (()=>b), (t=>b = t)),
    t(e.exports, "memo", (()=>v), (t=>v = t)),
    t(e.exports, "startTransition", (()=>w), (t=>w = t)),
    t(e.exports, "unstable_act", (()=>x), (t=>x = t)),
    t(e.exports, "useCallback", (()=>E), (t=>E = t)),
    t(e.exports, "useContext", (()=>_), (t=>_ = t)),
    t(e.exports, "useDebugValue", (()=>A), (t=>A = t)),
    t(e.exports, "useDeferredValue", (()=>S), (t=>S = t)),
    t(e.exports, "useEffect", (()=>T), (t=>T = t)),
    t(e.exports, "useId", (()=>k), (t=>k = t)),
    t(e.exports, "useImperativeHandle", (()=>I), (t=>I = t)),
    t(e.exports, "useInsertionEffect", (()=>M), (t=>M = t)),
    t(e.exports, "useLayoutEffect", (()=>C), (t=>C = t)),
    t(e.exports, "useMemo", (()=>P), (t=>P = t)),
    t(e.exports, "useReducer", (()=>O), (t=>O = t)),
    t(e.exports, "useRef", (()=>N), (t=>N = t)),
    t(e.exports, "useState", (()=>R), (t=>R = t)),
    t(e.exports, "useSyncExternalStore", (()=>D), (t=>D = t)),
    t(e.exports, "useTransition", (()=>B), (t=>B = t)),
    t(e.exports, "version", (()=>L), (t=>L = t));
    var F = Symbol.for("react.element")
      , j = Symbol.for("react.portal")
      , U = Symbol.for("react.fragment")
      , z = Symbol.for("react.strict_mode")
      , V = Symbol.for("react.profiler")
      , W = Symbol.for("react.provider")
      , Y = Symbol.for("react.context")
      , H = Symbol.for("react.forward_ref")
      , $ = Symbol.for("react.suspense")
      , G = Symbol.for("react.memo")
      , X = Symbol.for("react.lazy")
      , q = Symbol.iterator;
    var K = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , Q = Object.assign
      , Z = {};
    function J(t, e, n) {
        this.props = t,
        this.context = e,
        this.refs = Z,
        this.updater = n || K
    }
    function tt() {}
    function et(t, e, n) {
        this.props = t,
        this.context = e,
        this.refs = Z,
        this.updater = n || K
    }
    J.prototype.isReactComponent = {},
    J.prototype.setState = function(t, e) {
        if ("object" != typeof t && "function" != typeof t && null != t)
            throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, t, e, "setState")
    }
    ,
    J.prototype.forceUpdate = function(t) {
        this.updater.enqueueForceUpdate(this, t, "forceUpdate")
    }
    ,
    tt.prototype = J.prototype;
    var nt = et.prototype = new tt;
    nt.constructor = et,
    Q(nt, J.prototype),
    nt.isPureReactComponent = !0;
    var rt = Array.isArray
      , it = Object.prototype.hasOwnProperty
      , st = {
        current: null
    }
      , ot = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function at(t, e, n) {
        var r, i = {}, s = null, o = null;
        if (null != e)
            for (r in void 0 !== e.ref && (o = e.ref),
            void 0 !== e.key && (s = "" + e.key),
            e)
                it.call(e, r) && !ot.hasOwnProperty(r) && (i[r] = e[r]);
        var a = arguments.length - 2;
        if (1 === a)
            i.children = n;
        else if (1 < a) {
            for (var l = Array(a), c = 0; c < a; c++)
                l[c] = arguments[c + 2];
            i.children = l
        }
        if (t && t.defaultProps)
            for (r in a = t.defaultProps)
                void 0 === i[r] && (i[r] = a[r]);
        return {
            $$typeof: F,
            type: t,
            key: s,
            ref: o,
            props: i,
            _owner: st.current
        }
    }
    function lt(t) {
        return "object" == typeof t && null !== t && t.$$typeof === F
    }
    var ct = /\/+/g;
    function ut(t, e) {
        return "object" == typeof t && null !== t && null != t.key ? function(t) {
            var e = {
                "=": "=0",
                ":": "=2"
            };
            return "$" + t.replace(/[=:]/g, (function(t) {
                return e[t]
            }
            ))
        }("" + t.key) : e.toString(36)
    }
    function ht(t, e, n, r, i) {
        var s = typeof t;
        "undefined" !== s && "boolean" !== s || (t = null);
        var o = !1;
        if (null === t)
            o = !0;
        else
            switch (s) {
            case "string":
            case "number":
                o = !0;
                break;
            case "object":
                switch (t.$$typeof) {
                case F:
                case j:
                    o = !0
                }
            }
        if (o)
            return i = i(o = t),
            t = "" === r ? "." + ut(o, 0) : r,
            rt(i) ? (n = "",
            null != t && (n = t.replace(ct, "$&/") + "/"),
            ht(i, e, n, "", (function(t) {
                return t
            }
            ))) : null != i && (lt(i) && (i = function(t, e) {
                return {
                    $$typeof: F,
                    type: t.type,
                    key: e,
                    ref: t.ref,
                    props: t.props,
                    _owner: t._owner
                }
            }(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(ct, "$&/") + "/") + t)),
            e.push(i)),
            1;
        if (o = 0,
        r = "" === r ? "." : r + ":",
        rt(t))
            for (var a = 0; a < t.length; a++) {
                var l = r + ut(s = t[a], a);
                o += ht(s, e, n, l, i)
            }
        else if (l = function(t) {
            return null === t || "object" != typeof t ? null : "function" == typeof (t = q && t[q] || t["@@iterator"]) ? t : null
        }(t),
        "function" == typeof l)
            for (t = l.call(t),
            a = 0; !(s = t.next()).done; )
                o += ht(s = s.value, e, n, l = r + ut(s, a++), i);
        else if ("object" === s)
            throw e = String(t),
            Error("Objects are not valid as a React child (found: " + ("[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
        return o
    }
    function dt(t, e, n) {
        if (null == t)
            return t;
        var r = []
          , i = 0;
        return ht(t, r, "", "", (function(t) {
            return e.call(n, t, i++)
        }
        )),
        r
    }
    function ft(t) {
        if (-1 === t._status) {
            var e = t._result;
            (e = e()).then((function(e) {
                0 !== t._status && -1 !== t._status || (t._status = 1,
                t._result = e)
            }
            ), (function(e) {
                0 !== t._status && -1 !== t._status || (t._status = 2,
                t._result = e)
            }
            )),
            -1 === t._status && (t._status = 0,
            t._result = e)
        }
        if (1 === t._status)
            return t._result.default;
        throw t._result
    }
    var pt = {
        current: null
    }
      , mt = {
        transition: null
    };
    r = {
        map: dt,
        forEach: function(t, e, n) {
            dt(t, (function() {
                e.apply(this, arguments)
            }
            ), n)
        },
        count: function(t) {
            var e = 0;
            return dt(t, (function() {
                e++
            }
            )),
            e
        },
        toArray: function(t) {
            return dt(t, (function(t) {
                return t
            }
            )) || []
        },
        only: function(t) {
            if (!lt(t))
                throw Error("React.Children.only expected to receive a single React element child.");
            return t
        }
    },
    i = J,
    s = U,
    o = V,
    a = et,
    l = z,
    c = $,
    u = {
        ReactCurrentDispatcher: pt,
        ReactCurrentBatchConfig: mt,
        ReactCurrentOwner: st
    },
    h = function(t, e, n) {
        if (null == t)
            throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
        var r = Q({}, t.props)
          , i = t.key
          , s = t.ref
          , o = t._owner;
        if (null != e) {
            if (void 0 !== e.ref && (s = e.ref,
            o = st.current),
            void 0 !== e.key && (i = "" + e.key),
            t.type && t.type.defaultProps)
                var a = t.type.defaultProps;
            for (l in e)
                it.call(e, l) && !ot.hasOwnProperty(l) && (r[l] = void 0 === e[l] && void 0 !== a ? a[l] : e[l])
        }
        var l = arguments.length - 2;
        if (1 === l)
            r.children = n;
        else if (1 < l) {
            a = Array(l);
            for (var c = 0; c < l; c++)
                a[c] = arguments[c + 2];
            r.children = a
        }
        return {
            $$typeof: F,
            type: t.type,
            key: i,
            ref: s,
            props: r,
            _owner: o
        }
    }
    ,
    d = function(t) {
        return (t = {
            $$typeof: Y,
            _currentValue: t,
            _currentValue2: t,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
        }).Provider = {
            $$typeof: W,
            _context: t
        },
        t.Consumer = t
    }
    ,
    f = at,
    p = function(t) {
        var e = at.bind(null, t);
        return e.type = t,
        e
    }
    ,
    m = function() {
        return {
            current: null
        }
    }
    ,
    g = function(t) {
        return {
            $$typeof: H,
            render: t
        }
    }
    ,
    y = lt,
    b = function(t) {
        return {
            $$typeof: X,
            _payload: {
                _status: -1,
                _result: t
            },
            _init: ft
        }
    }
    ,
    v = function(t, e) {
        return {
            $$typeof: G,
            type: t,
            compare: void 0 === e ? null : e
        }
    }
    ,
    w = function(t) {
        var e = mt.transition;
        mt.transition = {};
        try {
            t()
        } finally {
            mt.transition = e
        }
    }
    ,
    x = function() {
        throw Error("act(...) is not supported in production builds of React.")
    }
    ,
    E = function(t, e) {
        return pt.current.useCallback(t, e)
    }
    ,
    _ = function(t) {
        return pt.current.useContext(t)
    }
    ,
    A = function() {}
    ,
    S = function(t) {
        return pt.current.useDeferredValue(t)
    }
    ,
    T = function(t, e) {
        return pt.current.useEffect(t, e)
    }
    ,
    k = function() {
        return pt.current.useId()
    }
    ,
    I = function(t, e, n) {
        return pt.current.useImperativeHandle(t, e, n)
    }
    ,
    M = function(t, e) {
        return pt.current.useInsertionEffect(t, e)
    }
    ,
    C = function(t, e) {
        return pt.current.useLayoutEffect(t, e)
    }
    ,
    P = function(t, e) {
        return pt.current.useMemo(t, e)
    }
    ,
    O = function(t, e, n) {
        return pt.current.useReducer(t, e, n)
    }
    ,
    N = function(t) {
        return pt.current.useRef(t)
    }
    ,
    R = function(t) {
        return pt.current.useState(t)
    }
    ,
    D = function(t, e, n) {
        return pt.current.useSyncExternalStore(t, e, n)
    }
    ,
    B = function() {
        return pt.current.useTransition()
    }
    ,
    L = "18.2.0"
}
)),
o.register("Xw6Mv", (function(e, n) {
    /**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
    var r, i, s, a, l, c, u, h, d, f, p, m;
    t(e.exports, "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", (()=>r), (t=>r = t)),
    t(e.exports, "createPortal", (()=>i), (t=>i = t)),
    t(e.exports, "createRoot", (()=>s), (t=>s = t)),
    t(e.exports, "findDOMNode", (()=>a), (t=>a = t)),
    t(e.exports, "flushSync", (()=>l), (t=>l = t)),
    t(e.exports, "hydrate", (()=>c), (t=>c = t)),
    t(e.exports, "hydrateRoot", (()=>u), (t=>u = t)),
    t(e.exports, "render", (()=>h), (t=>h = t)),
    t(e.exports, "unmountComponentAtNode", (()=>d), (t=>d = t)),
    t(e.exports, "unstable_batchedUpdates", (()=>f), (t=>f = t)),
    t(e.exports, "unstable_renderSubtreeIntoContainer", (()=>p), (t=>p = t)),
    t(e.exports, "version", (()=>m), (t=>m = t));
    var g = o("acw62")
      , y = o("fO90s");
    function b(t) {
        for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)
            e += "&args[]=" + encodeURIComponent(arguments[n]);
        return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var v = new Set
      , w = {};
    function x(t, e) {
        E(t, e),
        E(t + "Capture", e)
    }
    function E(t, e) {
        for (w[t] = e,
        t = 0; t < e.length; t++)
            v.add(e[t])
    }
    var _ = !("undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement)
      , A = Object.prototype.hasOwnProperty
      , S = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
      , T = {}
      , k = {};
    function I(t, e, n, r, i, s, o) {
        this.acceptsBooleans = 2 === e || 3 === e || 4 === e,
        this.attributeName = r,
        this.attributeNamespace = i,
        this.mustUseProperty = n,
        this.propertyName = t,
        this.type = e,
        this.sanitizeURL = s,
        this.removeEmptyString = o
    }
    var M = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(t) {
        M[t] = new I(t,0,!1,t,null,!1,!1)
    }
    )),
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function(t) {
        var e = t[0];
        M[e] = new I(e,1,!1,t[1],null,!1,!1)
    }
    )),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach((function(t) {
        M[t] = new I(t,2,!1,t.toLowerCase(),null,!1,!1)
    }
    )),
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function(t) {
        M[t] = new I(t,2,!1,t,null,!1,!1)
    }
    )),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(t) {
        M[t] = new I(t,3,!1,t.toLowerCase(),null,!1,!1)
    }
    )),
    ["checked", "multiple", "muted", "selected"].forEach((function(t) {
        M[t] = new I(t,3,!0,t,null,!1,!1)
    }
    )),
    ["capture", "download"].forEach((function(t) {
        M[t] = new I(t,4,!1,t,null,!1,!1)
    }
    )),
    ["cols", "rows", "size", "span"].forEach((function(t) {
        M[t] = new I(t,6,!1,t,null,!1,!1)
    }
    )),
    ["rowSpan", "start"].forEach((function(t) {
        M[t] = new I(t,5,!1,t.toLowerCase(),null,!1,!1)
    }
    ));
    var C = /[\-:]([a-z])/g;
    function P(t) {
        return t[1].toUpperCase()
    }
    function O(t, e, n, r) {
        var i = M.hasOwnProperty(e) ? M[e] : null;
        (null !== i ? 0 !== i.type : r || !(2 < e.length) || "o" !== e[0] && "O" !== e[0] || "n" !== e[1] && "N" !== e[1]) && (function(t, e, n, r) {
            if (null == e || function(t, e, n, r) {
                if (null !== n && 0 === n.type)
                    return !1;
                switch (typeof e) {
                case "function":
                case "symbol":
                    return !0;
                case "boolean":
                    return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (t = t.toLowerCase().slice(0, 5)) && "aria-" !== t);
                default:
                    return !1
                }
            }(t, e, n, r))
                return !0;
            if (r)
                return !1;
            if (null !== n)
                switch (n.type) {
                case 3:
                    return !e;
                case 4:
                    return !1 === e;
                case 5:
                    return isNaN(e);
                case 6:
                    return isNaN(e) || 1 > e
                }
            return !1
        }(e, n, i, r) && (n = null),
        r || null === i ? function(t) {
            return !!A.call(k, t) || !A.call(T, t) && (S.test(t) ? k[t] = !0 : (T[t] = !0,
            !1))
        }(e) && (null === n ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = null === n ? 3 !== i.type && "" : n : (e = i.attributeName,
        r = i.attributeNamespace,
        null === n ? t.removeAttribute(e) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n,
        r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))))
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(t) {
        var e = t.replace(C, P);
        M[e] = new I(e,1,!1,t,null,!1,!1)
    }
    )),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(t) {
        var e = t.replace(C, P);
        M[e] = new I(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)
    }
    )),
    ["xml:base", "xml:lang", "xml:space"].forEach((function(t) {
        var e = t.replace(C, P);
        M[e] = new I(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)
    }
    )),
    ["tabIndex", "crossOrigin"].forEach((function(t) {
        M[t] = new I(t,1,!1,t.toLowerCase(),null,!1,!1)
    }
    )),
    M.xlinkHref = new I("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),
    ["src", "href", "action", "formAction"].forEach((function(t) {
        M[t] = new I(t,1,!1,t.toLowerCase(),null,!0,!0)
    }
    ));
    var N = g.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , R = Symbol.for("react.element")
      , D = Symbol.for("react.portal")
      , B = Symbol.for("react.fragment")
      , L = Symbol.for("react.strict_mode")
      , F = Symbol.for("react.profiler")
      , j = Symbol.for("react.provider")
      , U = Symbol.for("react.context")
      , z = Symbol.for("react.forward_ref")
      , V = Symbol.for("react.suspense")
      , W = Symbol.for("react.suspense_list")
      , Y = Symbol.for("react.memo")
      , H = Symbol.for("react.lazy");
    Symbol.for("react.scope"),
    Symbol.for("react.debug_trace_mode");
    var $ = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden"),
    Symbol.for("react.cache"),
    Symbol.for("react.tracing_marker");
    var G = Symbol.iterator;
    function X(t) {
        return null === t || "object" != typeof t ? null : "function" == typeof (t = G && t[G] || t["@@iterator"]) ? t : null
    }
    var q, K = Object.assign;
    function Q(t) {
        if (void 0 === q)
            try {
                throw Error()
            } catch (t) {
                var e = t.stack.trim().match(/\n( *(at )?)/);
                q = e && e[1] || ""
            }
        return "\n" + q + t
    }
    var Z = !1;
    function J(t, e) {
        if (!t || Z)
            return "";
        Z = !0;
        var n = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (e)
                if (e = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(e.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                "object" == typeof Reflect && Reflect.construct) {
                    try {
                        Reflect.construct(e, [])
                    } catch (t) {
                        var r = t
                    }
                    Reflect.construct(t, [], e)
                } else {
                    try {
                        e.call()
                    } catch (t) {
                        r = t
                    }
                    t.call(e.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (t) {
                    r = t
                }
                t()
            }
        } catch (e) {
            if (e && r && "string" == typeof e.stack) {
                for (var i = e.stack.split("\n"), s = r.stack.split("\n"), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a]; )
                    a--;
                for (; 1 <= o && 0 <= a; o--,
                a--)
                    if (i[o] !== s[a]) {
                        if (1 !== o || 1 !== a)
                            do {
                                if (o--,
                                0 > --a || i[o] !== s[a]) {
                                    var l = "\n" + i[o].replace(" at new ", " at ");
                                    return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)),
                                    l
                                }
                            } while (1 <= o && 0 <= a);
                        break
                    }
            }
        } finally {
            Z = !1,
            Error.prepareStackTrace = n
        }
        return (t = t ? t.displayName || t.name : "") ? Q(t) : ""
    }
    function tt(t) {
        switch (t.tag) {
        case 5:
            return Q(t.type);
        case 16:
            return Q("Lazy");
        case 13:
            return Q("Suspense");
        case 19:
            return Q("SuspenseList");
        case 0:
        case 2:
        case 15:
            return t = J(t.type, !1);
        case 11:
            return t = J(t.type.render, !1);
        case 1:
            return t = J(t.type, !0);
        default:
            return ""
        }
    }
    function et(t) {
        if (null == t)
            return null;
        if ("function" == typeof t)
            return t.displayName || t.name || null;
        if ("string" == typeof t)
            return t;
        switch (t) {
        case B:
            return "Fragment";
        case D:
            return "Portal";
        case F:
            return "Profiler";
        case L:
            return "StrictMode";
        case V:
            return "Suspense";
        case W:
            return "SuspenseList"
        }
        if ("object" == typeof t)
            switch (t.$$typeof) {
            case U:
                return (t.displayName || "Context") + ".Consumer";
            case j:
                return (t._context.displayName || "Context") + ".Provider";
            case z:
                var e = t.render;
                return (t = t.displayName) || (t = "" !== (t = e.displayName || e.name || "") ? "ForwardRef(" + t + ")" : "ForwardRef"),
                t;
            case Y:
                return null !== (e = t.displayName || null) ? e : et(t.type) || "Memo";
            case H:
                e = t._payload,
                t = t._init;
                try {
                    return et(t(e))
                } catch (t) {}
            }
        return null
    }
    function nt(t) {
        var e = t.type;
        switch (t.tag) {
        case 24:
            return "Cache";
        case 9:
            return (e.displayName || "Context") + ".Consumer";
        case 10:
            return (e._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return t = (t = e.render).displayName || t.name || "",
            e.displayName || ("" !== t ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return e;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return et(e);
        case 8:
            return e === L ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if ("function" == typeof e)
                return e.displayName || e.name || null;
            if ("string" == typeof e)
                return e
        }
        return null
    }
    function rt(t) {
        switch (typeof t) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
        case "object":
            return t;
        default:
            return ""
        }
    }
    function it(t) {
        var e = t.type;
        return (t = t.nodeName) && "input" === t.toLowerCase() && ("checkbox" === e || "radio" === e)
    }
    function st(t) {
        t._valueTracker || (t._valueTracker = function(t) {
            var e = it(t) ? "checked" : "value"
              , n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e)
              , r = "" + t[e];
            if (!t.hasOwnProperty(e) && void 0 !== n && "function" == typeof n.get && "function" == typeof n.set) {
                var i = n.get
                  , s = n.set;
                return Object.defineProperty(t, e, {
                    configurable: !0,
                    get: function() {
                        return i.call(this)
                    },
                    set: function(t) {
                        r = "" + t,
                        s.call(this, t)
                    }
                }),
                Object.defineProperty(t, e, {
                    enumerable: n.enumerable
                }),
                {
                    getValue: function() {
                        return r
                    },
                    setValue: function(t) {
                        r = "" + t
                    },
                    stopTracking: function() {
                        t._valueTracker = null,
                        delete t[e]
                    }
                }
            }
        }(t))
    }
    function ot(t) {
        if (!t)
            return !1;
        var e = t._valueTracker;
        if (!e)
            return !0;
        var n = e.getValue()
          , r = "";
        return t && (r = it(t) ? t.checked ? "true" : "false" : t.value),
        (t = r) !== n && (e.setValue(t),
        !0)
    }
    function at(t) {
        if (void 0 === (t = t || ("undefined" != typeof document ? document : void 0)))
            return null;
        try {
            return t.activeElement || t.body
        } catch (e) {
            return t.body
        }
    }
    function lt(t, e) {
        var n = e.checked;
        return K({}, e, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: null != n ? n : t._wrapperState.initialChecked
        })
    }
    function ct(t, e) {
        var n = null == e.defaultValue ? "" : e.defaultValue
          , r = null != e.checked ? e.checked : e.defaultChecked;
        n = rt(null != e.value ? e.value : n),
        t._wrapperState = {
            initialChecked: r,
            initialValue: n,
            controlled: "checkbox" === e.type || "radio" === e.type ? null != e.checked : null != e.value
        }
    }
    function ut(t, e) {
        null != (e = e.checked) && O(t, "checked", e, !1)
    }
    function ht(t, e) {
        ut(t, e);
        var n = rt(e.value)
          , r = e.type;
        if (null != n)
            "number" === r ? (0 === n && "" === t.value || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
        else if ("submit" === r || "reset" === r)
            return void t.removeAttribute("value");
        e.hasOwnProperty("value") ? ft(t, e.type, n) : e.hasOwnProperty("defaultValue") && ft(t, e.type, rt(e.defaultValue)),
        null == e.checked && null != e.defaultChecked && (t.defaultChecked = !!e.defaultChecked)
    }
    function dt(t, e, n) {
        if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
            var r = e.type;
            if (!("submit" !== r && "reset" !== r || void 0 !== e.value && null !== e.value))
                return;
            e = "" + t._wrapperState.initialValue,
            n || e === t.value || (t.value = e),
            t.defaultValue = e
        }
        "" !== (n = t.name) && (t.name = ""),
        t.defaultChecked = !!t._wrapperState.initialChecked,
        "" !== n && (t.name = n)
    }
    function ft(t, e, n) {
        "number" === e && at(t.ownerDocument) === t || (null == n ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n))
    }
    var pt = Array.isArray;
    function mt(t, e, n, r) {
        if (t = t.options,
        e) {
            e = {};
            for (var i = 0; i < n.length; i++)
                e["$" + n[i]] = !0;
            for (n = 0; n < t.length; n++)
                i = e.hasOwnProperty("$" + t[n].value),
                t[n].selected !== i && (t[n].selected = i),
                i && r && (t[n].defaultSelected = !0)
        } else {
            for (n = "" + rt(n),
            e = null,
            i = 0; i < t.length; i++) {
                if (t[i].value === n)
                    return t[i].selected = !0,
                    void (r && (t[i].defaultSelected = !0));
                null !== e || t[i].disabled || (e = t[i])
            }
            null !== e && (e.selected = !0)
        }
    }
    function gt(t, e) {
        if (null != e.dangerouslySetInnerHTML)
            throw Error(b(91));
        return K({}, e, {
            value: void 0,
            defaultValue: void 0,
            children: "" + t._wrapperState.initialValue
        })
    }
    function yt(t, e) {
        var n = e.value;
        if (null == n) {
            if (n = e.children,
            e = e.defaultValue,
            null != n) {
                if (null != e)
                    throw Error(b(92));
                if (pt(n)) {
                    if (1 < n.length)
                        throw Error(b(93));
                    n = n[0]
                }
                e = n
            }
            null == e && (e = ""),
            n = e
        }
        t._wrapperState = {
            initialValue: rt(n)
        }
    }
    function bt(t, e) {
        var n = rt(e.value)
          , r = rt(e.defaultValue);
        null != n && ((n = "" + n) !== t.value && (t.value = n),
        null == e.defaultValue && t.defaultValue !== n && (t.defaultValue = n)),
        null != r && (t.defaultValue = "" + r)
    }
    function vt(t) {
        var e = t.textContent;
        e === t._wrapperState.initialValue && "" !== e && null !== e && (t.value = e)
    }
    function wt(t) {
        switch (t) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
        }
    }
    function xt(t, e) {
        return null == t || "http://www.w3.org/1999/xhtml" === t ? wt(e) : "http://www.w3.org/2000/svg" === t && "foreignObject" === e ? "http://www.w3.org/1999/xhtml" : t
    }
    var Et, _t, At = (_t = function(t, e) {
        if ("http://www.w3.org/2000/svg" !== t.namespaceURI || "innerHTML"in t)
            t.innerHTML = e;
        else {
            for ((Et = Et || document.createElement("div")).innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
            e = Et.firstChild; t.firstChild; )
                t.removeChild(t.firstChild);
            for (; e.firstChild; )
                t.appendChild(e.firstChild)
        }
    }
    ,
    "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function(t, e, n, r) {
        MSApp.execUnsafeLocalFunction((function() {
            return _t(t, e)
        }
        ))
    }
    : _t);
    function St(t, e) {
        if (e) {
            var n = t.firstChild;
            if (n && n === t.lastChild && 3 === n.nodeType)
                return void (n.nodeValue = e)
        }
        t.textContent = e
    }
    var Tt = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }
      , kt = ["Webkit", "ms", "Moz", "O"];
    function It(t, e, n) {
        return null == e || "boolean" == typeof e || "" === e ? "" : n || "number" != typeof e || 0 === e || Tt.hasOwnProperty(t) && Tt[t] ? ("" + e).trim() : e + "px"
    }
    function Mt(t, e) {
        for (var n in t = t.style,
        e)
            if (e.hasOwnProperty(n)) {
                var r = 0 === n.indexOf("--")
                  , i = It(n, e[n], r);
                "float" === n && (n = "cssFloat"),
                r ? t.setProperty(n, i) : t[n] = i
            }
    }
    Object.keys(Tt).forEach((function(t) {
        kt.forEach((function(e) {
            e = e + t.charAt(0).toUpperCase() + t.substring(1),
            Tt[e] = Tt[t]
        }
        ))
    }
    ));
    var Ct = K({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function Pt(t, e) {
        if (e) {
            if (Ct[t] && (null != e.children || null != e.dangerouslySetInnerHTML))
                throw Error(b(137, t));
            if (null != e.dangerouslySetInnerHTML) {
                if (null != e.children)
                    throw Error(b(60));
                if ("object" != typeof e.dangerouslySetInnerHTML || !("__html"in e.dangerouslySetInnerHTML))
                    throw Error(b(61))
            }
            if (null != e.style && "object" != typeof e.style)
                throw Error(b(62))
        }
    }
    function Ot(t, e) {
        if (-1 === t.indexOf("-"))
            return "string" == typeof e.is;
        switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var Nt = null;
    function Rt(t) {
        return (t = t.target || t.srcElement || window).correspondingUseElement && (t = t.correspondingUseElement),
        3 === t.nodeType ? t.parentNode : t
    }
    var Dt = null
      , Bt = null
      , Lt = null;
    function Ft(t) {
        if (t = Oi(t)) {
            if ("function" != typeof Dt)
                throw Error(b(280));
            var e = t.stateNode;
            e && (e = Ri(e),
            Dt(t.stateNode, t.type, e))
        }
    }
    function jt(t) {
        Bt ? Lt ? Lt.push(t) : Lt = [t] : Bt = t
    }
    function Ut() {
        if (Bt) {
            var t = Bt
              , e = Lt;
            if (Lt = Bt = null,
            Ft(t),
            e)
                for (t = 0; t < e.length; t++)
                    Ft(e[t])
        }
    }
    function zt(t, e) {
        return t(e)
    }
    function Vt() {}
    var Wt = !1;
    function Yt(t, e, n) {
        if (Wt)
            return t(e, n);
        Wt = !0;
        try {
            return zt(t, e, n)
        } finally {
            Wt = !1,
            (null !== Bt || null !== Lt) && (Vt(),
            Ut())
        }
    }
    function Ht(t, e) {
        var n = t.stateNode;
        if (null === n)
            return null;
        var r = Ri(n);
        if (null === r)
            return null;
        n = r[e];
        t: switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (r = !r.disabled) || (r = !("button" === (t = t.type) || "input" === t || "select" === t || "textarea" === t)),
            t = !r;
            break t;
        default:
            t = !1
        }
        if (t)
            return null;
        if (n && "function" != typeof n)
            throw Error(b(231, e, typeof n));
        return n
    }
    var $t = !1;
    if (_)
        try {
            var Gt = {};
            Object.defineProperty(Gt, "passive", {
                get: function() {
                    $t = !0
                }
            }),
            window.addEventListener("test", Gt, Gt),
            window.removeEventListener("test", Gt, Gt)
        } catch (_t) {
            $t = !1
        }
    function Xt(t, e, n, r, i, s, o, a, l) {
        var c = Array.prototype.slice.call(arguments, 3);
        try {
            e.apply(n, c)
        } catch (t) {
            this.onError(t)
        }
    }
    var qt = !1
      , Kt = null
      , Qt = !1
      , Zt = null
      , Jt = {
        onError: function(t) {
            qt = !0,
            Kt = t
        }
    };
    function te(t, e, n, r, i, s, o, a, l) {
        qt = !1,
        Kt = null,
        Xt.apply(Jt, arguments)
    }
    function ee(t) {
        var e = t
          , n = t;
        if (t.alternate)
            for (; e.return; )
                e = e.return;
        else {
            t = e;
            do {
                0 != (4098 & (e = t).flags) && (n = e.return),
                t = e.return
            } while (t)
        }
        return 3 === e.tag ? n : null
    }
    function ne(t) {
        if (13 === t.tag) {
            var e = t.memoizedState;
            if (null === e && (null !== (t = t.alternate) && (e = t.memoizedState)),
            null !== e)
                return e.dehydrated
        }
        return null
    }
    function re(t) {
        if (ee(t) !== t)
            throw Error(b(188))
    }
    function ie(t) {
        return null !== (t = function(t) {
            var e = t.alternate;
            if (!e) {
                if (null === (e = ee(t)))
                    throw Error(b(188));
                return e !== t ? null : t
            }
            for (var n = t, r = e; ; ) {
                var i = n.return;
                if (null === i)
                    break;
                var s = i.alternate;
                if (null === s) {
                    if (null !== (r = i.return)) {
                        n = r;
                        continue
                    }
                    break
                }
                if (i.child === s.child) {
                    for (s = i.child; s; ) {
                        if (s === n)
                            return re(i),
                            t;
                        if (s === r)
                            return re(i),
                            e;
                        s = s.sibling
                    }
                    throw Error(b(188))
                }
                if (n.return !== r.return)
                    n = i,
                    r = s;
                else {
                    for (var o = !1, a = i.child; a; ) {
                        if (a === n) {
                            o = !0,
                            n = i,
                            r = s;
                            break
                        }
                        if (a === r) {
                            o = !0,
                            r = i,
                            n = s;
                            break
                        }
                        a = a.sibling
                    }
                    if (!o) {
                        for (a = s.child; a; ) {
                            if (a === n) {
                                o = !0,
                                n = s,
                                r = i;
                                break
                            }
                            if (a === r) {
                                o = !0,
                                r = s,
                                n = i;
                                break
                            }
                            a = a.sibling
                        }
                        if (!o)
                            throw Error(b(189))
                    }
                }
                if (n.alternate !== r)
                    throw Error(b(190))
            }
            if (3 !== n.tag)
                throw Error(b(188));
            return n.stateNode.current === n ? t : e
        }(t)) ? se(t) : null
    }
    function se(t) {
        if (5 === t.tag || 6 === t.tag)
            return t;
        for (t = t.child; null !== t; ) {
            var e = se(t);
            if (null !== e)
                return e;
            t = t.sibling
        }
        return null
    }
    var oe = y.unstable_scheduleCallback
      , ae = y.unstable_cancelCallback
      , le = y.unstable_shouldYield
      , ce = y.unstable_requestPaint
      , ue = y.unstable_now
      , he = y.unstable_getCurrentPriorityLevel
      , de = y.unstable_ImmediatePriority
      , fe = y.unstable_UserBlockingPriority
      , pe = y.unstable_NormalPriority
      , me = y.unstable_LowPriority
      , ge = y.unstable_IdlePriority
      , ye = null
      , be = null;
    var ve = Math.clz32 ? Math.clz32 : function(t) {
        return t >>>= 0,
        0 === t ? 32 : 31 - (we(t) / xe | 0) | 0
    }
      , we = Math.log
      , xe = Math.LN2;
    var Ee = 64
      , _e = 4194304;
    function Ae(t) {
        switch (t & -t) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return 4194240 & t;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return 130023424 & t;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return t
        }
    }
    function Se(t, e) {
        var n = t.pendingLanes;
        if (0 === n)
            return 0;
        var r = 0
          , i = t.suspendedLanes
          , s = t.pingedLanes
          , o = 268435455 & n;
        if (0 !== o) {
            var a = o & ~i;
            0 !== a ? r = Ae(a) : 0 !== (s &= o) && (r = Ae(s))
        } else
            0 !== (o = n & ~i) ? r = Ae(o) : 0 !== s && (r = Ae(s));
        if (0 === r)
            return 0;
        if (0 !== e && e !== r && 0 == (e & i) && ((i = r & -r) >= (s = e & -e) || 16 === i && 0 != (4194240 & s)))
            return e;
        if (0 != (4 & r) && (r |= 16 & n),
        0 !== (e = t.entangledLanes))
            for (t = t.entanglements,
            e &= r; 0 < e; )
                i = 1 << (n = 31 - ve(e)),
                r |= t[n],
                e &= ~i;
        return r
    }
    function Te(t, e) {
        switch (t) {
        case 1:
        case 2:
        case 4:
            return e + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return e + 5e3;
        default:
            return -1
        }
    }
    function ke(t) {
        return 0 !== (t = -1073741825 & t.pendingLanes) ? t : 1073741824 & t ? 1073741824 : 0
    }
    function Ie() {
        var t = Ee;
        return 0 == (4194240 & (Ee <<= 1)) && (Ee = 64),
        t
    }
    function Me(t) {
        for (var e = [], n = 0; 31 > n; n++)
            e.push(t);
        return e
    }
    function Ce(t, e, n) {
        t.pendingLanes |= e,
        536870912 !== e && (t.suspendedLanes = 0,
        t.pingedLanes = 0),
        (t = t.eventTimes)[e = 31 - ve(e)] = n
    }
    function Pe(t, e) {
        var n = t.entangledLanes |= e;
        for (t = t.entanglements; n; ) {
            var r = 31 - ve(n)
              , i = 1 << r;
            i & e | t[r] & e && (t[r] |= e),
            n &= ~i
        }
    }
    var Oe = 0;
    function Ne(t) {
        return 1 < (t &= -t) ? 4 < t ? 0 != (268435455 & t) ? 16 : 536870912 : 4 : 1
    }
    var Re, De, Be, Le, Fe, je = !1, Ue = [], ze = null, Ve = null, We = null, Ye = new Map, He = new Map, $e = [], Ge = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Xe(t, e) {
        switch (t) {
        case "focusin":
        case "focusout":
            ze = null;
            break;
        case "dragenter":
        case "dragleave":
            Ve = null;
            break;
        case "mouseover":
        case "mouseout":
            We = null;
            break;
        case "pointerover":
        case "pointerout":
            Ye.delete(e.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            He.delete(e.pointerId)
        }
    }
    function qe(t, e, n, r, i, s) {
        return null === t || t.nativeEvent !== s ? (t = {
            blockedOn: e,
            domEventName: n,
            eventSystemFlags: r,
            nativeEvent: s,
            targetContainers: [i]
        },
        null !== e && (null !== (e = Oi(e)) && De(e)),
        t) : (t.eventSystemFlags |= r,
        e = t.targetContainers,
        null !== i && -1 === e.indexOf(i) && e.push(i),
        t)
    }
    function Ke(t) {
        var e = Pi(t.target);
        if (null !== e) {
            var n = ee(e);
            if (null !== n)
                if (13 === (e = n.tag)) {
                    if (null !== (e = ne(n)))
                        return t.blockedOn = e,
                        void Fe(t.priority, (function() {
                            Be(n)
                        }
                        ))
                } else if (3 === e && n.stateNode.current.memoizedState.isDehydrated)
                    return void (t.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
        }
        t.blockedOn = null
    }
    function Qe(t) {
        if (null !== t.blockedOn)
            return !1;
        for (var e = t.targetContainers; 0 < e.length; ) {
            var n = cn(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
            if (null !== n)
                return null !== (e = Oi(n)) && De(e),
                t.blockedOn = n,
                !1;
            var r = new (n = t.nativeEvent).constructor(n.type,n);
            Nt = r,
            n.target.dispatchEvent(r),
            Nt = null,
            e.shift()
        }
        return !0
    }
    function Ze(t, e, n) {
        Qe(t) && n.delete(e)
    }
    function Je() {
        je = !1,
        null !== ze && Qe(ze) && (ze = null),
        null !== Ve && Qe(Ve) && (Ve = null),
        null !== We && Qe(We) && (We = null),
        Ye.forEach(Ze),
        He.forEach(Ze)
    }
    function tn(t, e) {
        t.blockedOn === e && (t.blockedOn = null,
        je || (je = !0,
        y.unstable_scheduleCallback(y.unstable_NormalPriority, Je)))
    }
    function en(t) {
        function e(e) {
            return tn(e, t)
        }
        if (0 < Ue.length) {
            tn(Ue[0], t);
            for (var n = 1; n < Ue.length; n++) {
                var r = Ue[n];
                r.blockedOn === t && (r.blockedOn = null)
            }
        }
        for (null !== ze && tn(ze, t),
        null !== Ve && tn(Ve, t),
        null !== We && tn(We, t),
        Ye.forEach(e),
        He.forEach(e),
        n = 0; n < $e.length; n++)
            (r = $e[n]).blockedOn === t && (r.blockedOn = null);
        for (; 0 < $e.length && null === (n = $e[0]).blockedOn; )
            Ke(n),
            null === n.blockedOn && $e.shift()
    }
    var nn = N.ReactCurrentBatchConfig
      , rn = !0;
    function sn(t, e, n, r) {
        var i = Oe
          , s = nn.transition;
        nn.transition = null;
        try {
            Oe = 1,
            an(t, e, n, r)
        } finally {
            Oe = i,
            nn.transition = s
        }
    }
    function on(t, e, n, r) {
        var i = Oe
          , s = nn.transition;
        nn.transition = null;
        try {
            Oe = 4,
            an(t, e, n, r)
        } finally {
            Oe = i,
            nn.transition = s
        }
    }
    function an(t, e, n, r) {
        if (rn) {
            var i = cn(t, e, n, r);
            if (null === i)
                ri(t, e, r, ln, n),
                Xe(t, r);
            else if (function(t, e, n, r, i) {
                switch (e) {
                case "focusin":
                    return ze = qe(ze, t, e, n, r, i),
                    !0;
                case "dragenter":
                    return Ve = qe(Ve, t, e, n, r, i),
                    !0;
                case "mouseover":
                    return We = qe(We, t, e, n, r, i),
                    !0;
                case "pointerover":
                    var s = i.pointerId;
                    return Ye.set(s, qe(Ye.get(s) || null, t, e, n, r, i)),
                    !0;
                case "gotpointercapture":
                    return s = i.pointerId,
                    He.set(s, qe(He.get(s) || null, t, e, n, r, i)),
                    !0
                }
                return !1
            }(i, t, e, n, r))
                r.stopPropagation();
            else if (Xe(t, r),
            4 & e && -1 < Ge.indexOf(t)) {
                for (; null !== i; ) {
                    var s = Oi(i);
                    if (null !== s && Re(s),
                    null === (s = cn(t, e, n, r)) && ri(t, e, r, ln, n),
                    s === i)
                        break;
                    i = s
                }
                null !== i && r.stopPropagation()
            } else
                ri(t, e, r, null, n)
        }
    }
    var ln = null;
    function cn(t, e, n, r) {
        if (ln = null,
        null !== (t = Pi(t = Rt(r))))
            if (null === (e = ee(t)))
                t = null;
            else if (13 === (n = e.tag)) {
                if (null !== (t = ne(e)))
                    return t;
                t = null
            } else if (3 === n) {
                if (e.stateNode.current.memoizedState.isDehydrated)
                    return 3 === e.tag ? e.stateNode.containerInfo : null;
                t = null
            } else
                e !== t && (t = null);
        return ln = t,
        null
    }
    function un(t) {
        switch (t) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (he()) {
            case de:
                return 1;
            case fe:
                return 4;
            case pe:
            case me:
                return 16;
            case ge:
                return 536870912;
            default:
                return 16
            }
        default:
            return 16
        }
    }
    var hn = null
      , dn = null
      , fn = null;
    function pn() {
        if (fn)
            return fn;
        var t, e, n = dn, r = n.length, i = "value"in hn ? hn.value : hn.textContent, s = i.length;
        for (t = 0; t < r && n[t] === i[t]; t++)
            ;
        var o = r - t;
        for (e = 1; e <= o && n[r - e] === i[s - e]; e++)
            ;
        return fn = i.slice(t, 1 < e ? 1 - e : void 0)
    }
    function mn(t) {
        var e = t.keyCode;
        return "charCode"in t ? 0 === (t = t.charCode) && 13 === e && (t = 13) : t = e,
        10 === t && (t = 13),
        32 <= t || 13 === t ? t : 0
    }
    function gn() {
        return !0
    }
    function yn() {
        return !1
    }
    function bn(t) {
        function e(e, n, r, i, s) {
            for (var o in this._reactName = e,
            this._targetInst = r,
            this.type = n,
            this.nativeEvent = i,
            this.target = s,
            this.currentTarget = null,
            t)
                t.hasOwnProperty(o) && (e = t[o],
                this[o] = e ? e(i) : i[o]);
            return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? gn : yn,
            this.isPropagationStopped = yn,
            this
        }
        return K(e.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var t = this.nativeEvent;
                t && (t.preventDefault ? t.preventDefault() : "unknown" != typeof t.returnValue && (t.returnValue = !1),
                this.isDefaultPrevented = gn)
            },
            stopPropagation: function() {
                var t = this.nativeEvent;
                t && (t.stopPropagation ? t.stopPropagation() : "unknown" != typeof t.cancelBubble && (t.cancelBubble = !0),
                this.isPropagationStopped = gn)
            },
            persist: function() {},
            isPersistent: gn
        }),
        e
    }
    var vn, wn, xn, En = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(t) {
            return t.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, _n = bn(En), An = K({}, En, {
        view: 0,
        detail: 0
    }), Sn = bn(An), Tn = K({}, An, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Fn,
        button: 0,
        buttons: 0,
        relatedTarget: function(t) {
            return void 0 === t.relatedTarget ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
        },
        movementX: function(t) {
            return "movementX"in t ? t.movementX : (t !== xn && (xn && "mousemove" === t.type ? (vn = t.screenX - xn.screenX,
            wn = t.screenY - xn.screenY) : wn = vn = 0,
            xn = t),
            vn)
        },
        movementY: function(t) {
            return "movementY"in t ? t.movementY : wn
        }
    }), kn = bn(Tn), In = bn(K({}, Tn, {
        dataTransfer: 0
    })), Mn = bn(K({}, An, {
        relatedTarget: 0
    })), Cn = bn(K({}, En, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })), Pn = K({}, En, {
        clipboardData: function(t) {
            return "clipboardData"in t ? t.clipboardData : window.clipboardData
        }
    }), On = bn(Pn), Nn = bn(K({}, En, {
        data: 0
    })), Rn = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, Dn = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, Bn = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function Ln(t) {
        var e = this.nativeEvent;
        return e.getModifierState ? e.getModifierState(t) : !!(t = Bn[t]) && !!e[t]
    }
    function Fn() {
        return Ln
    }
    var jn = K({}, An, {
        key: function(t) {
            if (t.key) {
                var e = Rn[t.key] || t.key;
                if ("Unidentified" !== e)
                    return e
            }
            return "keypress" === t.type ? 13 === (t = mn(t)) ? "Enter" : String.fromCharCode(t) : "keydown" === t.type || "keyup" === t.type ? Dn[t.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Fn,
        charCode: function(t) {
            return "keypress" === t.type ? mn(t) : 0
        },
        keyCode: function(t) {
            return "keydown" === t.type || "keyup" === t.type ? t.keyCode : 0
        },
        which: function(t) {
            return "keypress" === t.type ? mn(t) : "keydown" === t.type || "keyup" === t.type ? t.keyCode : 0
        }
    })
      , Un = bn(jn)
      , zn = bn(K({}, Tn, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }))
      , Vn = bn(K({}, An, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Fn
    }))
      , Wn = bn(K({}, En, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }))
      , Yn = K({}, Tn, {
        deltaX: function(t) {
            return "deltaX"in t ? t.deltaX : "wheelDeltaX"in t ? -t.wheelDeltaX : 0
        },
        deltaY: function(t) {
            return "deltaY"in t ? t.deltaY : "wheelDeltaY"in t ? -t.wheelDeltaY : "wheelDelta"in t ? -t.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , Hn = bn(Yn)
      , $n = [9, 13, 27, 32]
      , Gn = _ && "CompositionEvent"in window
      , Xn = null;
    _ && "documentMode"in document && (Xn = document.documentMode);
    var qn = _ && "TextEvent"in window && !Xn
      , Kn = _ && (!Gn || Xn && 8 < Xn && 11 >= Xn)
      , Qn = String.fromCharCode(32)
      , Zn = !1;
    function Jn(t, e) {
        switch (t) {
        case "keyup":
            return -1 !== $n.indexOf(e.keyCode);
        case "keydown":
            return 229 !== e.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function tr(t) {
        return "object" == typeof (t = t.detail) && "data"in t ? t.data : null
    }
    var er = !1;
    var nr = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function rr(t) {
        var e = t && t.nodeName && t.nodeName.toLowerCase();
        return "input" === e ? !!nr[t.type] : "textarea" === e
    }
    function ir(t, e, n, r) {
        jt(r),
        0 < (e = si(e, "onChange")).length && (n = new _n("onChange","change",null,n,r),
        t.push({
            event: n,
            listeners: e
        }))
    }
    var sr = null
      , or = null;
    function ar(t) {
        Qr(t, 0)
    }
    function lr(t) {
        if (ot(Ni(t)))
            return t
    }
    function cr(t, e) {
        if ("change" === t)
            return e
    }
    var ur = !1;
    if (_) {
        var hr;
        if (_) {
            var dr = "oninput"in document;
            if (!dr) {
                var fr = document.createElement("div");
                fr.setAttribute("oninput", "return;"),
                dr = "function" == typeof fr.oninput
            }
            hr = dr
        } else
            hr = !1;
        ur = hr && (!document.documentMode || 9 < document.documentMode)
    }
    function pr() {
        sr && (sr.detachEvent("onpropertychange", mr),
        or = sr = null)
    }
    function mr(t) {
        if ("value" === t.propertyName && lr(or)) {
            var e = [];
            ir(e, or, t, Rt(t)),
            Yt(ar, e)
        }
    }
    function gr(t, e, n) {
        "focusin" === t ? (pr(),
        or = n,
        (sr = e).attachEvent("onpropertychange", mr)) : "focusout" === t && pr()
    }
    function yr(t) {
        if ("selectionchange" === t || "keyup" === t || "keydown" === t)
            return lr(or)
    }
    function br(t, e) {
        if ("click" === t)
            return lr(e)
    }
    function vr(t, e) {
        if ("input" === t || "change" === t)
            return lr(e)
    }
    var wr = "function" == typeof Object.is ? Object.is : function(t, e) {
        return t === e && (0 !== t || 1 / t == 1 / e) || t != t && e != e
    }
    ;
    function xr(t, e) {
        if (wr(t, e))
            return !0;
        if ("object" != typeof t || null === t || "object" != typeof e || null === e)
            return !1;
        var n = Object.keys(t)
          , r = Object.keys(e);
        if (n.length !== r.length)
            return !1;
        for (r = 0; r < n.length; r++) {
            var i = n[r];
            if (!A.call(e, i) || !wr(t[i], e[i]))
                return !1
        }
        return !0
    }
    function Er(t) {
        for (; t && t.firstChild; )
            t = t.firstChild;
        return t
    }
    function _r(t, e) {
        var n, r = Er(t);
        for (t = 0; r; ) {
            if (3 === r.nodeType) {
                if (n = t + r.textContent.length,
                t <= e && n >= e)
                    return {
                        node: r,
                        offset: e - t
                    };
                t = n
            }
            t: {
                for (; r; ) {
                    if (r.nextSibling) {
                        r = r.nextSibling;
                        break t
                    }
                    r = r.parentNode
                }
                r = void 0
            }
            r = Er(r)
        }
    }
    function Ar(t, e) {
        return !(!t || !e) && (t === e || (!t || 3 !== t.nodeType) && (e && 3 === e.nodeType ? Ar(t, e.parentNode) : "contains"in t ? t.contains(e) : !!t.compareDocumentPosition && !!(16 & t.compareDocumentPosition(e))))
    }
    function Sr() {
        for (var t = window, e = at(); e instanceof t.HTMLIFrameElement; ) {
            try {
                var n = "string" == typeof e.contentWindow.location.href
            } catch (t) {
                n = !1
            }
            if (!n)
                break;
            e = at((t = e.contentWindow).document)
        }
        return e
    }
    function Tr(t) {
        var e = t && t.nodeName && t.nodeName.toLowerCase();
        return e && ("input" === e && ("text" === t.type || "search" === t.type || "tel" === t.type || "url" === t.type || "password" === t.type) || "textarea" === e || "true" === t.contentEditable)
    }
    function kr(t) {
        var e = Sr()
          , n = t.focusedElem
          , r = t.selectionRange;
        if (e !== n && n && n.ownerDocument && Ar(n.ownerDocument.documentElement, n)) {
            if (null !== r && Tr(n))
                if (e = r.start,
                void 0 === (t = r.end) && (t = e),
                "selectionStart"in n)
                    n.selectionStart = e,
                    n.selectionEnd = Math.min(t, n.value.length);
                else if ((t = (e = n.ownerDocument || document) && e.defaultView || window).getSelection) {
                    t = t.getSelection();
                    var i = n.textContent.length
                      , s = Math.min(r.start, i);
                    r = void 0 === r.end ? s : Math.min(r.end, i),
                    !t.extend && s > r && (i = r,
                    r = s,
                    s = i),
                    i = _r(n, s);
                    var o = _r(n, r);
                    i && o && (1 !== t.rangeCount || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && ((e = e.createRange()).setStart(i.node, i.offset),
                    t.removeAllRanges(),
                    s > r ? (t.addRange(e),
                    t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                    t.addRange(e)))
                }
            for (e = [],
            t = n; t = t.parentNode; )
                1 === t.nodeType && e.push({
                    element: t,
                    left: t.scrollLeft,
                    top: t.scrollTop
                });
            for ("function" == typeof n.focus && n.focus(),
            n = 0; n < e.length; n++)
                (t = e[n]).element.scrollLeft = t.left,
                t.element.scrollTop = t.top
        }
    }
    var Ir = _ && "documentMode"in document && 11 >= document.documentMode
      , Mr = null
      , Cr = null
      , Pr = null
      , Or = !1;
    function Nr(t, e, n) {
        var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
        Or || null == Mr || Mr !== at(r) || ("selectionStart"in (r = Mr) && Tr(r) ? r = {
            start: r.selectionStart,
            end: r.selectionEnd
        } : r = {
            anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
            anchorOffset: r.anchorOffset,
            focusNode: r.focusNode,
            focusOffset: r.focusOffset
        },
        Pr && xr(Pr, r) || (Pr = r,
        0 < (r = si(Cr, "onSelect")).length && (e = new _n("onSelect","select",null,e,n),
        t.push({
            event: e,
            listeners: r
        }),
        e.target = Mr)))
    }
    function Rr(t, e) {
        var n = {};
        return n[t.toLowerCase()] = e.toLowerCase(),
        n["Webkit" + t] = "webkit" + e,
        n["Moz" + t] = "moz" + e,
        n
    }
    var Dr = {
        animationend: Rr("Animation", "AnimationEnd"),
        animationiteration: Rr("Animation", "AnimationIteration"),
        animationstart: Rr("Animation", "AnimationStart"),
        transitionend: Rr("Transition", "TransitionEnd")
    }
      , Br = {}
      , Lr = {};
    function Fr(t) {
        if (Br[t])
            return Br[t];
        if (!Dr[t])
            return t;
        var e, n = Dr[t];
        for (e in n)
            if (n.hasOwnProperty(e) && e in Lr)
                return Br[t] = n[e];
        return t
    }
    _ && (Lr = document.createElement("div").style,
    "AnimationEvent"in window || (delete Dr.animationend.animation,
    delete Dr.animationiteration.animation,
    delete Dr.animationstart.animation),
    "TransitionEvent"in window || delete Dr.transitionend.transition);
    var jr = Fr("animationend")
      , Ur = Fr("animationiteration")
      , zr = Fr("animationstart")
      , Vr = Fr("transitionend")
      , Wr = new Map
      , Yr = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function Hr(t, e) {
        Wr.set(t, e),
        x(e, [t])
    }
    for (var $r = 0; $r < Yr.length; $r++) {
        var Gr = Yr[$r];
        Hr(Gr.toLowerCase(), "on" + (Gr[0].toUpperCase() + Gr.slice(1)))
    }
    Hr(jr, "onAnimationEnd"),
    Hr(Ur, "onAnimationIteration"),
    Hr(zr, "onAnimationStart"),
    Hr("dblclick", "onDoubleClick"),
    Hr("focusin", "onFocus"),
    Hr("focusout", "onBlur"),
    Hr(Vr, "onTransitionEnd"),
    E("onMouseEnter", ["mouseout", "mouseover"]),
    E("onMouseLeave", ["mouseout", "mouseover"]),
    E("onPointerEnter", ["pointerout", "pointerover"]),
    E("onPointerLeave", ["pointerout", "pointerover"]),
    x("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    x("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    x("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    x("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    x("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    x("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Xr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , qr = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xr));
    function Kr(t, e, n) {
        var r = t.type || "unknown-event";
        t.currentTarget = n,
        function(t, e, n, r, i, s, o, a, l) {
            if (te.apply(this, arguments),
            qt) {
                if (!qt)
                    throw Error(b(198));
                var c = Kt;
                qt = !1,
                Kt = null,
                Qt || (Qt = !0,
                Zt = c)
            }
        }(r, e, void 0, t),
        t.currentTarget = null
    }
    function Qr(t, e) {
        e = 0 != (4 & e);
        for (var n = 0; n < t.length; n++) {
            var r = t[n]
              , i = r.event;
            r = r.listeners;
            t: {
                var s = void 0;
                if (e)
                    for (var o = r.length - 1; 0 <= o; o--) {
                        var a = r[o]
                          , l = a.instance
                          , c = a.currentTarget;
                        if (a = a.listener,
                        l !== s && i.isPropagationStopped())
                            break t;
                        Kr(i, a, c),
                        s = l
                    }
                else
                    for (o = 0; o < r.length; o++) {
                        if (l = (a = r[o]).instance,
                        c = a.currentTarget,
                        a = a.listener,
                        l !== s && i.isPropagationStopped())
                            break t;
                        Kr(i, a, c),
                        s = l
                    }
            }
        }
        if (Qt)
            throw t = Zt,
            Qt = !1,
            Zt = null,
            t
    }
    function Zr(t, e) {
        var n = e[Ii];
        void 0 === n && (n = e[Ii] = new Set);
        var r = t + "__bubble";
        n.has(r) || (ni(e, t, 2, !1),
        n.add(r))
    }
    function Jr(t, e, n) {
        var r = 0;
        e && (r |= 4),
        ni(n, t, r, e)
    }
    var ti = "_reactListening" + Math.random().toString(36).slice(2);
    function ei(t) {
        if (!t[ti]) {
            t[ti] = !0,
            v.forEach((function(e) {
                "selectionchange" !== e && (qr.has(e) || Jr(e, !1, t),
                Jr(e, !0, t))
            }
            ));
            var e = 9 === t.nodeType ? t : t.ownerDocument;
            null === e || e[ti] || (e[ti] = !0,
            Jr("selectionchange", !1, e))
        }
    }
    function ni(t, e, n, r) {
        switch (un(e)) {
        case 1:
            var i = sn;
            break;
        case 4:
            i = on;
            break;
        default:
            i = an
        }
        n = i.bind(null, e, n, t),
        i = void 0,
        !$t || "touchstart" !== e && "touchmove" !== e && "wheel" !== e || (i = !0),
        r ? void 0 !== i ? t.addEventListener(e, n, {
            capture: !0,
            passive: i
        }) : t.addEventListener(e, n, !0) : void 0 !== i ? t.addEventListener(e, n, {
            passive: i
        }) : t.addEventListener(e, n, !1)
    }
    function ri(t, e, n, r, i) {
        var s = r;
        if (0 == (1 & e) && 0 == (2 & e) && null !== r)
            t: for (; ; ) {
                if (null === r)
                    return;
                var o = r.tag;
                if (3 === o || 4 === o) {
                    var a = r.stateNode.containerInfo;
                    if (a === i || 8 === a.nodeType && a.parentNode === i)
                        break;
                    if (4 === o)
                        for (o = r.return; null !== o; ) {
                            var l = o.tag;
                            if ((3 === l || 4 === l) && ((l = o.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i))
                                return;
                            o = o.return
                        }
                    for (; null !== a; ) {
                        if (null === (o = Pi(a)))
                            return;
                        if (5 === (l = o.tag) || 6 === l) {
                            r = s = o;
                            continue t
                        }
                        a = a.parentNode
                    }
                }
                r = r.return
            }
        Yt((function() {
            var r = s
              , i = Rt(n)
              , o = [];
            t: {
                var a = Wr.get(t);
                if (void 0 !== a) {
                    var l = _n
                      , c = t;
                    switch (t) {
                    case "keypress":
                        if (0 === mn(n))
                            break t;
                    case "keydown":
                    case "keyup":
                        l = Un;
                        break;
                    case "focusin":
                        c = "focus",
                        l = Mn;
                        break;
                    case "focusout":
                        c = "blur",
                        l = Mn;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        l = Mn;
                        break;
                    case "click":
                        if (2 === n.button)
                            break t;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        l = kn;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        l = In;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        l = Vn;
                        break;
                    case jr:
                    case Ur:
                    case zr:
                        l = Cn;
                        break;
                    case Vr:
                        l = Wn;
                        break;
                    case "scroll":
                        l = Sn;
                        break;
                    case "wheel":
                        l = Hn;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        l = On;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        l = zn
                    }
                    var u = 0 != (4 & e)
                      , h = !u && "scroll" === t
                      , d = u ? null !== a ? a + "Capture" : null : a;
                    u = [];
                    for (var f, p = r; null !== p; ) {
                        var m = (f = p).stateNode;
                        if (5 === f.tag && null !== m && (f = m,
                        null !== d && (null != (m = Ht(p, d)) && u.push(ii(p, m, f)))),
                        h)
                            break;
                        p = p.return
                    }
                    0 < u.length && (a = new l(a,c,null,n,i),
                    o.push({
                        event: a,
                        listeners: u
                    }))
                }
            }
            if (0 == (7 & e)) {
                if (l = "mouseout" === t || "pointerout" === t,
                (!(a = "mouseover" === t || "pointerover" === t) || n === Nt || !(c = n.relatedTarget || n.fromElement) || !Pi(c) && !c[ki]) && (l || a) && (a = i.window === i ? i : (a = i.ownerDocument) ? a.defaultView || a.parentWindow : window,
                l ? (l = r,
                null !== (c = (c = n.relatedTarget || n.toElement) ? Pi(c) : null) && (c !== (h = ee(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null,
                c = r),
                l !== c)) {
                    if (u = kn,
                    m = "onMouseLeave",
                    d = "onMouseEnter",
                    p = "mouse",
                    "pointerout" !== t && "pointerover" !== t || (u = zn,
                    m = "onPointerLeave",
                    d = "onPointerEnter",
                    p = "pointer"),
                    h = null == l ? a : Ni(l),
                    f = null == c ? a : Ni(c),
                    (a = new u(m,p + "leave",l,n,i)).target = h,
                    a.relatedTarget = f,
                    m = null,
                    Pi(i) === r && ((u = new u(d,p + "enter",c,n,i)).target = f,
                    u.relatedTarget = h,
                    m = u),
                    h = m,
                    l && c)
                        t: {
                            for (d = c,
                            p = 0,
                            f = u = l; f; f = oi(f))
                                p++;
                            for (f = 0,
                            m = d; m; m = oi(m))
                                f++;
                            for (; 0 < p - f; )
                                u = oi(u),
                                p--;
                            for (; 0 < f - p; )
                                d = oi(d),
                                f--;
                            for (; p--; ) {
                                if (u === d || null !== d && u === d.alternate)
                                    break t;
                                u = oi(u),
                                d = oi(d)
                            }
                            u = null
                        }
                    else
                        u = null;
                    null !== l && ai(o, a, l, u, !1),
                    null !== c && null !== h && ai(o, h, c, u, !0)
                }
                if ("select" === (l = (a = r ? Ni(r) : window).nodeName && a.nodeName.toLowerCase()) || "input" === l && "file" === a.type)
                    var g = cr;
                else if (rr(a))
                    if (ur)
                        g = vr;
                    else {
                        g = yr;
                        var y = gr
                    }
                else
                    (l = a.nodeName) && "input" === l.toLowerCase() && ("checkbox" === a.type || "radio" === a.type) && (g = br);
                switch (g && (g = g(t, r)) ? ir(o, g, n, i) : (y && y(t, a, r),
                "focusout" === t && (y = a._wrapperState) && y.controlled && "number" === a.type && ft(a, "number", a.value)),
                y = r ? Ni(r) : window,
                t) {
                case "focusin":
                    (rr(y) || "true" === y.contentEditable) && (Mr = y,
                    Cr = r,
                    Pr = null);
                    break;
                case "focusout":
                    Pr = Cr = Mr = null;
                    break;
                case "mousedown":
                    Or = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Or = !1,
                    Nr(o, n, i);
                    break;
                case "selectionchange":
                    if (Ir)
                        break;
                case "keydown":
                case "keyup":
                    Nr(o, n, i)
                }
                var b;
                if (Gn)
                    t: {
                        switch (t) {
                        case "compositionstart":
                            var v = "onCompositionStart";
                            break t;
                        case "compositionend":
                            v = "onCompositionEnd";
                            break t;
                        case "compositionupdate":
                            v = "onCompositionUpdate";
                            break t
                        }
                        v = void 0
                    }
                else
                    er ? Jn(t, n) && (v = "onCompositionEnd") : "keydown" === t && 229 === n.keyCode && (v = "onCompositionStart");
                v && (Kn && "ko" !== n.locale && (er || "onCompositionStart" !== v ? "onCompositionEnd" === v && er && (b = pn()) : (dn = "value"in (hn = i) ? hn.value : hn.textContent,
                er = !0)),
                0 < (y = si(r, v)).length && (v = new Nn(v,t,null,n,i),
                o.push({
                    event: v,
                    listeners: y
                }),
                b ? v.data = b : null !== (b = tr(n)) && (v.data = b))),
                (b = qn ? function(t, e) {
                    switch (t) {
                    case "compositionend":
                        return tr(e);
                    case "keypress":
                        return 32 !== e.which ? null : (Zn = !0,
                        Qn);
                    case "textInput":
                        return (t = e.data) === Qn && Zn ? null : t;
                    default:
                        return null
                    }
                }(t, n) : function(t, e) {
                    if (er)
                        return "compositionend" === t || !Gn && Jn(t, e) ? (t = pn(),
                        fn = dn = hn = null,
                        er = !1,
                        t) : null;
                    switch (t) {
                    case "paste":
                    default:
                        return null;
                    case "keypress":
                        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
                            if (e.char && 1 < e.char.length)
                                return e.char;
                            if (e.which)
                                return String.fromCharCode(e.which)
                        }
                        return null;
                    case "compositionend":
                        return Kn && "ko" !== e.locale ? null : e.data
                    }
                }(t, n)) && (0 < (r = si(r, "onBeforeInput")).length && (i = new Nn("onBeforeInput","beforeinput",null,n,i),
                o.push({
                    event: i,
                    listeners: r
                }),
                i.data = b))
            }
            Qr(o, e)
        }
        ))
    }
    function ii(t, e, n) {
        return {
            instance: t,
            listener: e,
            currentTarget: n
        }
    }
    function si(t, e) {
        for (var n = e + "Capture", r = []; null !== t; ) {
            var i = t
              , s = i.stateNode;
            5 === i.tag && null !== s && (i = s,
            null != (s = Ht(t, n)) && r.unshift(ii(t, s, i)),
            null != (s = Ht(t, e)) && r.push(ii(t, s, i))),
            t = t.return
        }
        return r
    }
    function oi(t) {
        if (null === t)
            return null;
        do {
            t = t.return
        } while (t && 5 !== t.tag);
        return t || null
    }
    function ai(t, e, n, r, i) {
        for (var s = e._reactName, o = []; null !== n && n !== r; ) {
            var a = n
              , l = a.alternate
              , c = a.stateNode;
            if (null !== l && l === r)
                break;
            5 === a.tag && null !== c && (a = c,
            i ? null != (l = Ht(n, s)) && o.unshift(ii(n, l, a)) : i || null != (l = Ht(n, s)) && o.push(ii(n, l, a))),
            n = n.return
        }
        0 !== o.length && t.push({
            event: e,
            listeners: o
        })
    }
    var li = /\r\n?/g
      , ci = /\u0000|\uFFFD/g;
    function ui(t) {
        return ("string" == typeof t ? t : "" + t).replace(li, "\n").replace(ci, "")
    }
    function hi(t, e, n) {
        if (e = ui(e),
        ui(t) !== e && n)
            throw Error(b(425))
    }
    function di() {}
    var fi = null
      , pi = null;
    function mi(t, e) {
        return "textarea" === t || "noscript" === t || "string" == typeof e.children || "number" == typeof e.children || "object" == typeof e.dangerouslySetInnerHTML && null !== e.dangerouslySetInnerHTML && null != e.dangerouslySetInnerHTML.__html
    }
    var gi = "function" == typeof setTimeout ? setTimeout : void 0
      , yi = "function" == typeof clearTimeout ? clearTimeout : void 0
      , bi = "function" == typeof Promise ? Promise : void 0
      , vi = "function" == typeof queueMicrotask ? queueMicrotask : void 0 !== bi ? function(t) {
        return bi.resolve(null).then(t).catch(wi)
    }
    : gi;
    function wi(t) {
        setTimeout((function() {
            throw t
        }
        ))
    }
    function xi(t, e) {
        var n = e
          , r = 0;
        do {
            var i = n.nextSibling;
            if (t.removeChild(n),
            i && 8 === i.nodeType)
                if ("/$" === (n = i.data)) {
                    if (0 === r)
                        return t.removeChild(i),
                        void en(e);
                    r--
                } else
                    "$" !== n && "$?" !== n && "$!" !== n || r++;
            n = i
        } while (n);
        en(e)
    }
    function Ei(t) {
        for (; null != t; t = t.nextSibling) {
            var e = t.nodeType;
            if (1 === e || 3 === e)
                break;
            if (8 === e) {
                if ("$" === (e = t.data) || "$!" === e || "$?" === e)
                    break;
                if ("/$" === e)
                    return null
            }
        }
        return t
    }
    function _i(t) {
        t = t.previousSibling;
        for (var e = 0; t; ) {
            if (8 === t.nodeType) {
                var n = t.data;
                if ("$" === n || "$!" === n || "$?" === n) {
                    if (0 === e)
                        return t;
                    e--
                } else
                    "/$" === n && e++
            }
            t = t.previousSibling
        }
        return null
    }
    var Ai = Math.random().toString(36).slice(2)
      , Si = "__reactFiber$" + Ai
      , Ti = "__reactProps$" + Ai
      , ki = "__reactContainer$" + Ai
      , Ii = "__reactEvents$" + Ai
      , Mi = "__reactListeners$" + Ai
      , Ci = "__reactHandles$" + Ai;
    function Pi(t) {
        var e = t[Si];
        if (e)
            return e;
        for (var n = t.parentNode; n; ) {
            if (e = n[ki] || n[Si]) {
                if (n = e.alternate,
                null !== e.child || null !== n && null !== n.child)
                    for (t = _i(t); null !== t; ) {
                        if (n = t[Si])
                            return n;
                        t = _i(t)
                    }
                return e
            }
            n = (t = n).parentNode
        }
        return null
    }
    function Oi(t) {
        return !(t = t[Si] || t[ki]) || 5 !== t.tag && 6 !== t.tag && 13 !== t.tag && 3 !== t.tag ? null : t
    }
    function Ni(t) {
        if (5 === t.tag || 6 === t.tag)
            return t.stateNode;
        throw Error(b(33))
    }
    function Ri(t) {
        return t[Ti] || null
    }
    var Di = []
      , Bi = -1;
    function Li(t) {
        return {
            current: t
        }
    }
    function Fi(t) {
        0 > Bi || (t.current = Di[Bi],
        Di[Bi] = null,
        Bi--)
    }
    function ji(t, e) {
        Bi++,
        Di[Bi] = t.current,
        t.current = e
    }
    var Ui = {}
      , zi = Li(Ui)
      , Vi = Li(!1)
      , Wi = Ui;
    function Yi(t, e) {
        var n = t.type.contextTypes;
        if (!n)
            return Ui;
        var r = t.stateNode;
        if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
            return r.__reactInternalMemoizedMaskedChildContext;
        var i, s = {};
        for (i in n)
            s[i] = e[i];
        return r && ((t = t.stateNode).__reactInternalMemoizedUnmaskedChildContext = e,
        t.__reactInternalMemoizedMaskedChildContext = s),
        s
    }
    function Hi(t) {
        return null != (t = t.childContextTypes)
    }
    function $i() {
        Fi(Vi),
        Fi(zi)
    }
    function Gi(t, e, n) {
        if (zi.current !== Ui)
            throw Error(b(168));
        ji(zi, e),
        ji(Vi, n)
    }
    function Xi(t, e, n) {
        var r = t.stateNode;
        if (e = e.childContextTypes,
        "function" != typeof r.getChildContext)
            return n;
        for (var i in r = r.getChildContext())
            if (!(i in e))
                throw Error(b(108, nt(t) || "Unknown", i));
        return K({}, n, r)
    }
    function qi(t) {
        return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Ui,
        Wi = zi.current,
        ji(zi, t),
        ji(Vi, Vi.current),
        !0
    }
    function Ki(t, e, n) {
        var r = t.stateNode;
        if (!r)
            throw Error(b(169));
        n ? (t = Xi(t, e, Wi),
        r.__reactInternalMemoizedMergedChildContext = t,
        Fi(Vi),
        Fi(zi),
        ji(zi, t)) : Fi(Vi),
        ji(Vi, n)
    }
    var Qi = null
      , Zi = !1
      , Ji = !1;
    function ts(t) {
        null === Qi ? Qi = [t] : Qi.push(t)
    }
    function es() {
        if (!Ji && null !== Qi) {
            Ji = !0;
            var t = 0
              , e = Oe;
            try {
                var n = Qi;
                for (Oe = 1; t < n.length; t++) {
                    var r = n[t];
                    do {
                        r = r(!0)
                    } while (null !== r)
                }
                Qi = null,
                Zi = !1
            } catch (e) {
                throw null !== Qi && (Qi = Qi.slice(t + 1)),
                oe(de, es),
                e
            } finally {
                Oe = e,
                Ji = !1
            }
        }
        return null
    }
    var ns = []
      , rs = 0
      , is = null
      , ss = 0
      , os = []
      , as = 0
      , ls = null
      , cs = 1
      , us = "";
    function hs(t, e) {
        ns[rs++] = ss,
        ns[rs++] = is,
        is = t,
        ss = e
    }
    function ds(t, e, n) {
        os[as++] = cs,
        os[as++] = us,
        os[as++] = ls,
        ls = t;
        var r = cs;
        t = us;
        var i = 32 - ve(r) - 1;
        r &= ~(1 << i),
        n += 1;
        var s = 32 - ve(e) + i;
        if (30 < s) {
            var o = i - i % 5;
            s = (r & (1 << o) - 1).toString(32),
            r >>= o,
            i -= o,
            cs = 1 << 32 - ve(e) + i | n << i | r,
            us = s + t
        } else
            cs = 1 << s | n << i | r,
            us = t
    }
    function fs(t) {
        null !== t.return && (hs(t, 1),
        ds(t, 1, 0))
    }
    function ps(t) {
        for (; t === is; )
            is = ns[--rs],
            ns[rs] = null,
            ss = ns[--rs],
            ns[rs] = null;
        for (; t === ls; )
            ls = os[--as],
            os[as] = null,
            us = os[--as],
            os[as] = null,
            cs = os[--as],
            os[as] = null
    }
    var ms = null
      , gs = null
      , ys = !1
      , bs = null;
    function vs(t, e) {
        var n = Hc(5, null, null, 0);
        n.elementType = "DELETED",
        n.stateNode = e,
        n.return = t,
        null === (e = t.deletions) ? (t.deletions = [n],
        t.flags |= 16) : e.push(n)
    }
    function ws(t, e) {
        switch (t.tag) {
        case 5:
            var n = t.type;
            return null !== (e = 1 !== e.nodeType || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e) && (t.stateNode = e,
            ms = t,
            gs = Ei(e.firstChild),
            !0);
        case 6:
            return null !== (e = "" === t.pendingProps || 3 !== e.nodeType ? null : e) && (t.stateNode = e,
            ms = t,
            gs = null,
            !0);
        case 13:
            return null !== (e = 8 !== e.nodeType ? null : e) && (n = null !== ls ? {
                id: cs,
                overflow: us
            } : null,
            t.memoizedState = {
                dehydrated: e,
                treeContext: n,
                retryLane: 1073741824
            },
            (n = Hc(18, null, null, 0)).stateNode = e,
            n.return = t,
            t.child = n,
            ms = t,
            gs = null,
            !0);
        default:
            return !1
        }
    }
    function xs(t) {
        return 0 != (1 & t.mode) && 0 == (128 & t.flags)
    }
    function Es(t) {
        if (ys) {
            var e = gs;
            if (e) {
                var n = e;
                if (!ws(t, e)) {
                    if (xs(t))
                        throw Error(b(418));
                    e = Ei(n.nextSibling);
                    var r = ms;
                    e && ws(t, e) ? vs(r, n) : (t.flags = -4097 & t.flags | 2,
                    ys = !1,
                    ms = t)
                }
            } else {
                if (xs(t))
                    throw Error(b(418));
                t.flags = -4097 & t.flags | 2,
                ys = !1,
                ms = t
            }
        }
    }
    function _s(t) {
        for (t = t.return; null !== t && 5 !== t.tag && 3 !== t.tag && 13 !== t.tag; )
            t = t.return;
        ms = t
    }
    function As(t) {
        if (t !== ms)
            return !1;
        if (!ys)
            return _s(t),
            ys = !0,
            !1;
        var e;
        if ((e = 3 !== t.tag) && !(e = 5 !== t.tag) && (e = "head" !== (e = t.type) && "body" !== e && !mi(t.type, t.memoizedProps)),
        e && (e = gs)) {
            if (xs(t))
                throw Ss(),
                Error(b(418));
            for (; e; )
                vs(t, e),
                e = Ei(e.nextSibling)
        }
        if (_s(t),
        13 === t.tag) {
            if (!(t = null !== (t = t.memoizedState) ? t.dehydrated : null))
                throw Error(b(317));
            t: {
                for (t = t.nextSibling,
                e = 0; t; ) {
                    if (8 === t.nodeType) {
                        var n = t.data;
                        if ("/$" === n) {
                            if (0 === e) {
                                gs = Ei(t.nextSibling);
                                break t
                            }
                            e--
                        } else
                            "$" !== n && "$!" !== n && "$?" !== n || e++
                    }
                    t = t.nextSibling
                }
                gs = null
            }
        } else
            gs = ms ? Ei(t.stateNode.nextSibling) : null;
        return !0
    }
    function Ss() {
        for (var t = gs; t; )
            t = Ei(t.nextSibling)
    }
    function Ts() {
        gs = ms = null,
        ys = !1
    }
    function ks(t) {
        null === bs ? bs = [t] : bs.push(t)
    }
    var Is = N.ReactCurrentBatchConfig;
    function Ms(t, e) {
        if (t && t.defaultProps) {
            for (var n in e = K({}, e),
            t = t.defaultProps)
                void 0 === e[n] && (e[n] = t[n]);
            return e
        }
        return e
    }
    var Cs = Li(null)
      , Ps = null
      , Os = null
      , Ns = null;
    function Rs() {
        Ns = Os = Ps = null
    }
    function Ds(t) {
        var e = Cs.current;
        Fi(Cs),
        t._currentValue = e
    }
    function Bs(t, e, n) {
        for (; null !== t; ) {
            var r = t.alternate;
            if ((t.childLanes & e) !== e ? (t.childLanes |= e,
            null !== r && (r.childLanes |= e)) : null !== r && (r.childLanes & e) !== e && (r.childLanes |= e),
            t === n)
                break;
            t = t.return
        }
    }
    function Ls(t, e) {
        Ps = t,
        Ns = Os = null,
        null !== (t = t.dependencies) && null !== t.firstContext && (0 != (t.lanes & e) && (Na = !0),
        t.firstContext = null)
    }
    function Fs(t) {
        var e = t._currentValue;
        if (Ns !== t)
            if (t = {
                context: t,
                memoizedValue: e,
                next: null
            },
            null === Os) {
                if (null === Ps)
                    throw Error(b(308));
                Os = t,
                Ps.dependencies = {
                    lanes: 0,
                    firstContext: t
                }
            } else
                Os = Os.next = t;
        return e
    }
    var js = null;
    function Us(t) {
        null === js ? js = [t] : js.push(t)
    }
    function zs(t, e, n, r) {
        var i = e.interleaved;
        return null === i ? (n.next = n,
        Us(e)) : (n.next = i.next,
        i.next = n),
        e.interleaved = n,
        Vs(t, r)
    }
    function Vs(t, e) {
        t.lanes |= e;
        var n = t.alternate;
        for (null !== n && (n.lanes |= e),
        n = t,
        t = t.return; null !== t; )
            t.childLanes |= e,
            null !== (n = t.alternate) && (n.childLanes |= e),
            n = t,
            t = t.return;
        return 3 === n.tag ? n.stateNode : null
    }
    var Ws = !1;
    function Ys(t) {
        t.updateQueue = {
            baseState: t.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function Hs(t, e) {
        t = t.updateQueue,
        e.updateQueue === t && (e.updateQueue = {
            baseState: t.baseState,
            firstBaseUpdate: t.firstBaseUpdate,
            lastBaseUpdate: t.lastBaseUpdate,
            shared: t.shared,
            effects: t.effects
        })
    }
    function $s(t, e) {
        return {
            eventTime: t,
            lane: e,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Gs(t, e, n) {
        var r = t.updateQueue;
        if (null === r)
            return null;
        if (r = r.shared,
        0 != (2 & Vl)) {
            var i = r.pending;
            return null === i ? e.next = e : (e.next = i.next,
            i.next = e),
            r.pending = e,
            Vs(t, n)
        }
        return null === (i = r.interleaved) ? (e.next = e,
        Us(r)) : (e.next = i.next,
        i.next = e),
        r.interleaved = e,
        Vs(t, n)
    }
    function Xs(t, e, n) {
        if (null !== (e = e.updateQueue) && (e = e.shared,
        0 != (4194240 & n))) {
            var r = e.lanes;
            n |= r &= t.pendingLanes,
            e.lanes = n,
            Pe(t, n)
        }
    }
    function qs(t, e) {
        var n = t.updateQueue
          , r = t.alternate;
        if (null !== r && n === (r = r.updateQueue)) {
            var i = null
              , s = null;
            if (null !== (n = n.firstBaseUpdate)) {
                do {
                    var o = {
                        eventTime: n.eventTime,
                        lane: n.lane,
                        tag: n.tag,
                        payload: n.payload,
                        callback: n.callback,
                        next: null
                    };
                    null === s ? i = s = o : s = s.next = o,
                    n = n.next
                } while (null !== n);
                null === s ? i = s = e : s = s.next = e
            } else
                i = s = e;
            return n = {
                baseState: r.baseState,
                firstBaseUpdate: i,
                lastBaseUpdate: s,
                shared: r.shared,
                effects: r.effects
            },
            void (t.updateQueue = n)
        }
        null === (t = n.lastBaseUpdate) ? n.firstBaseUpdate = e : t.next = e,
        n.lastBaseUpdate = e
    }
    function Ks(t, e, n, r) {
        var i = t.updateQueue;
        Ws = !1;
        var s = i.firstBaseUpdate
          , o = i.lastBaseUpdate
          , a = i.shared.pending;
        if (null !== a) {
            i.shared.pending = null;
            var l = a
              , c = l.next;
            l.next = null,
            null === o ? s = c : o.next = c,
            o = l;
            var u = t.alternate;
            null !== u && ((a = (u = u.updateQueue).lastBaseUpdate) !== o && (null === a ? u.firstBaseUpdate = c : a.next = c,
            u.lastBaseUpdate = l))
        }
        if (null !== s) {
            var h = i.baseState;
            for (o = 0,
            u = c = l = null,
            a = s; ; ) {
                var d = a.lane
                  , f = a.eventTime;
                if ((r & d) === d) {
                    null !== u && (u = u.next = {
                        eventTime: f,
                        lane: 0,
                        tag: a.tag,
                        payload: a.payload,
                        callback: a.callback,
                        next: null
                    });
                    t: {
                        var p = t
                          , m = a;
                        switch (d = e,
                        f = n,
                        m.tag) {
                        case 1:
                            if ("function" == typeof (p = m.payload)) {
                                h = p.call(f, h, d);
                                break t
                            }
                            h = p;
                            break t;
                        case 3:
                            p.flags = -65537 & p.flags | 128;
                        case 0:
                            if (null == (d = "function" == typeof (p = m.payload) ? p.call(f, h, d) : p))
                                break t;
                            h = K({}, h, d);
                            break t;
                        case 2:
                            Ws = !0
                        }
                    }
                    null !== a.callback && 0 !== a.lane && (t.flags |= 64,
                    null === (d = i.effects) ? i.effects = [a] : d.push(a))
                } else
                    f = {
                        eventTime: f,
                        lane: d,
                        tag: a.tag,
                        payload: a.payload,
                        callback: a.callback,
                        next: null
                    },
                    null === u ? (c = u = f,
                    l = h) : u = u.next = f,
                    o |= d;
                if (null === (a = a.next)) {
                    if (null === (a = i.shared.pending))
                        break;
                    a = (d = a).next,
                    d.next = null,
                    i.lastBaseUpdate = d,
                    i.shared.pending = null
                }
            }
            if (null === u && (l = h),
            i.baseState = l,
            i.firstBaseUpdate = c,
            i.lastBaseUpdate = u,
            null !== (e = i.shared.interleaved)) {
                i = e;
                do {
                    o |= i.lane,
                    i = i.next
                } while (i !== e)
            } else
                null === s && (i.shared.lanes = 0);
            Kl |= o,
            t.lanes = o,
            t.memoizedState = h
        }
    }
    function Qs(t, e, n) {
        if (t = e.effects,
        e.effects = null,
        null !== t)
            for (e = 0; e < t.length; e++) {
                var r = t[e]
                  , i = r.callback;
                if (null !== i) {
                    if (r.callback = null,
                    r = n,
                    "function" != typeof i)
                        throw Error(b(191, i));
                    i.call(r)
                }
            }
    }
    var Zs = (new g.Component).refs;
    function Js(t, e, n, r) {
        n = null == (n = n(r, e = t.memoizedState)) ? e : K({}, e, n),
        t.memoizedState = n,
        0 === t.lanes && (t.updateQueue.baseState = n)
    }
    var to = {
        isMounted: function(t) {
            return !!(t = t._reactInternals) && ee(t) === t
        },
        enqueueSetState: function(t, e, n) {
            t = t._reactInternals;
            var r = pc()
              , i = mc(t)
              , s = $s(r, i);
            s.payload = e,
            null != n && (s.callback = n),
            null !== (e = Gs(t, s, i)) && (gc(e, t, i, r),
            Xs(e, t, i))
        },
        enqueueReplaceState: function(t, e, n) {
            t = t._reactInternals;
            var r = pc()
              , i = mc(t)
              , s = $s(r, i);
            s.tag = 1,
            s.payload = e,
            null != n && (s.callback = n),
            null !== (e = Gs(t, s, i)) && (gc(e, t, i, r),
            Xs(e, t, i))
        },
        enqueueForceUpdate: function(t, e) {
            t = t._reactInternals;
            var n = pc()
              , r = mc(t)
              , i = $s(n, r);
            i.tag = 2,
            null != e && (i.callback = e),
            null !== (e = Gs(t, i, r)) && (gc(e, t, r, n),
            Xs(e, t, r))
        }
    };
    function eo(t, e, n, r, i, s, o) {
        return "function" == typeof (t = t.stateNode).shouldComponentUpdate ? t.shouldComponentUpdate(r, s, o) : !e.prototype || !e.prototype.isPureReactComponent || (!xr(n, r) || !xr(i, s))
    }
    function no(t, e, n) {
        var r = !1
          , i = Ui
          , s = e.contextType;
        return "object" == typeof s && null !== s ? s = Fs(s) : (i = Hi(e) ? Wi : zi.current,
        s = (r = null != (r = e.contextTypes)) ? Yi(t, i) : Ui),
        e = new e(n,s),
        t.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null,
        e.updater = to,
        t.stateNode = e,
        e._reactInternals = t,
        r && ((t = t.stateNode).__reactInternalMemoizedUnmaskedChildContext = i,
        t.__reactInternalMemoizedMaskedChildContext = s),
        e
    }
    function ro(t, e, n, r) {
        t = e.state,
        "function" == typeof e.componentWillReceiveProps && e.componentWillReceiveProps(n, r),
        "function" == typeof e.UNSAFE_componentWillReceiveProps && e.UNSAFE_componentWillReceiveProps(n, r),
        e.state !== t && to.enqueueReplaceState(e, e.state, null)
    }
    function io(t, e, n, r) {
        var i = t.stateNode;
        i.props = n,
        i.state = t.memoizedState,
        i.refs = Zs,
        Ys(t);
        var s = e.contextType;
        "object" == typeof s && null !== s ? i.context = Fs(s) : (s = Hi(e) ? Wi : zi.current,
        i.context = Yi(t, s)),
        i.state = t.memoizedState,
        "function" == typeof (s = e.getDerivedStateFromProps) && (Js(t, e, s, n),
        i.state = t.memoizedState),
        "function" == typeof e.getDerivedStateFromProps || "function" == typeof i.getSnapshotBeforeUpdate || "function" != typeof i.UNSAFE_componentWillMount && "function" != typeof i.componentWillMount || (e = i.state,
        "function" == typeof i.componentWillMount && i.componentWillMount(),
        "function" == typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(),
        e !== i.state && to.enqueueReplaceState(i, i.state, null),
        Ks(t, n, i, r),
        i.state = t.memoizedState),
        "function" == typeof i.componentDidMount && (t.flags |= 4194308)
    }
    function so(t, e, n) {
        if (null !== (t = n.ref) && "function" != typeof t && "object" != typeof t) {
            if (n._owner) {
                if (n = n._owner) {
                    if (1 !== n.tag)
                        throw Error(b(309));
                    var r = n.stateNode
                }
                if (!r)
                    throw Error(b(147, t));
                var i = r
                  , s = "" + t;
                return null !== e && null !== e.ref && "function" == typeof e.ref && e.ref._stringRef === s ? e.ref : (e = function(t) {
                    var e = i.refs;
                    e === Zs && (e = i.refs = {}),
                    null === t ? delete e[s] : e[s] = t
                }
                ,
                e._stringRef = s,
                e)
            }
            if ("string" != typeof t)
                throw Error(b(284));
            if (!n._owner)
                throw Error(b(290, t))
        }
        return t
    }
    function oo(t, e) {
        throw t = Object.prototype.toString.call(e),
        Error(b(31, "[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
    }
    function ao(t) {
        return (0,
        t._init)(t._payload)
    }
    function lo(t) {
        function e(e, n) {
            if (t) {
                var r = e.deletions;
                null === r ? (e.deletions = [n],
                e.flags |= 16) : r.push(n)
            }
        }
        function n(n, r) {
            if (!t)
                return null;
            for (; null !== r; )
                e(n, r),
                r = r.sibling;
            return null
        }
        function r(t, e) {
            for (t = new Map; null !== e; )
                null !== e.key ? t.set(e.key, e) : t.set(e.index, e),
                e = e.sibling;
            return t
        }
        function i(t, e) {
            return (t = Gc(t, e)).index = 0,
            t.sibling = null,
            t
        }
        function s(e, n, r) {
            return e.index = r,
            t ? null !== (r = e.alternate) ? (r = r.index) < n ? (e.flags |= 2,
            n) : r : (e.flags |= 2,
            n) : (e.flags |= 1048576,
            n)
        }
        function o(e) {
            return t && null === e.alternate && (e.flags |= 2),
            e
        }
        function a(t, e, n, r) {
            return null === e || 6 !== e.tag ? ((e = Qc(n, t.mode, r)).return = t,
            e) : ((e = i(e, n)).return = t,
            e)
        }
        function l(t, e, n, r) {
            var s = n.type;
            return s === B ? u(t, e, n.props.children, r, n.key) : null !== e && (e.elementType === s || "object" == typeof s && null !== s && s.$$typeof === H && ao(s) === e.type) ? ((r = i(e, n.props)).ref = so(t, e, n),
            r.return = t,
            r) : ((r = Xc(n.type, n.key, n.props, null, t.mode, r)).ref = so(t, e, n),
            r.return = t,
            r)
        }
        function c(t, e, n, r) {
            return null === e || 4 !== e.tag || e.stateNode.containerInfo !== n.containerInfo || e.stateNode.implementation !== n.implementation ? ((e = Zc(n, t.mode, r)).return = t,
            e) : ((e = i(e, n.children || [])).return = t,
            e)
        }
        function u(t, e, n, r, s) {
            return null === e || 7 !== e.tag ? ((e = qc(n, t.mode, r, s)).return = t,
            e) : ((e = i(e, n)).return = t,
            e)
        }
        function h(t, e, n) {
            if ("string" == typeof e && "" !== e || "number" == typeof e)
                return (e = Qc("" + e, t.mode, n)).return = t,
                e;
            if ("object" == typeof e && null !== e) {
                switch (e.$$typeof) {
                case R:
                    return (n = Xc(e.type, e.key, e.props, null, t.mode, n)).ref = so(t, null, e),
                    n.return = t,
                    n;
                case D:
                    return (e = Zc(e, t.mode, n)).return = t,
                    e;
                case H:
                    return h(t, (0,
                    e._init)(e._payload), n)
                }
                if (pt(e) || X(e))
                    return (e = qc(e, t.mode, n, null)).return = t,
                    e;
                oo(t, e)
            }
            return null
        }
        function d(t, e, n, r) {
            var i = null !== e ? e.key : null;
            if ("string" == typeof n && "" !== n || "number" == typeof n)
                return null !== i ? null : a(t, e, "" + n, r);
            if ("object" == typeof n && null !== n) {
                switch (n.$$typeof) {
                case R:
                    return n.key === i ? l(t, e, n, r) : null;
                case D:
                    return n.key === i ? c(t, e, n, r) : null;
                case H:
                    return d(t, e, (i = n._init)(n._payload), r)
                }
                if (pt(n) || X(n))
                    return null !== i ? null : u(t, e, n, r, null);
                oo(t, n)
            }
            return null
        }
        function f(t, e, n, r, i) {
            if ("string" == typeof r && "" !== r || "number" == typeof r)
                return a(e, t = t.get(n) || null, "" + r, i);
            if ("object" == typeof r && null !== r) {
                switch (r.$$typeof) {
                case R:
                    return l(e, t = t.get(null === r.key ? n : r.key) || null, r, i);
                case D:
                    return c(e, t = t.get(null === r.key ? n : r.key) || null, r, i);
                case H:
                    return f(t, e, n, (0,
                    r._init)(r._payload), i)
                }
                if (pt(r) || X(r))
                    return u(e, t = t.get(n) || null, r, i, null);
                oo(e, r)
            }
            return null
        }
        function p(i, o, a, l) {
            for (var c = null, u = null, p = o, m = o = 0, g = null; null !== p && m < a.length; m++) {
                p.index > m ? (g = p,
                p = null) : g = p.sibling;
                var y = d(i, p, a[m], l);
                if (null === y) {
                    null === p && (p = g);
                    break
                }
                t && p && null === y.alternate && e(i, p),
                o = s(y, o, m),
                null === u ? c = y : u.sibling = y,
                u = y,
                p = g
            }
            if (m === a.length)
                return n(i, p),
                ys && hs(i, m),
                c;
            if (null === p) {
                for (; m < a.length; m++)
                    null !== (p = h(i, a[m], l)) && (o = s(p, o, m),
                    null === u ? c = p : u.sibling = p,
                    u = p);
                return ys && hs(i, m),
                c
            }
            for (p = r(i, p); m < a.length; m++)
                null !== (g = f(p, i, m, a[m], l)) && (t && null !== g.alternate && p.delete(null === g.key ? m : g.key),
                o = s(g, o, m),
                null === u ? c = g : u.sibling = g,
                u = g);
            return t && p.forEach((function(t) {
                return e(i, t)
            }
            )),
            ys && hs(i, m),
            c
        }
        function m(i, o, a, l) {
            var c = X(a);
            if ("function" != typeof c)
                throw Error(b(150));
            if (null == (a = c.call(a)))
                throw Error(b(151));
            for (var u = c = null, p = o, m = o = 0, g = null, y = a.next(); null !== p && !y.done; m++,
            y = a.next()) {
                p.index > m ? (g = p,
                p = null) : g = p.sibling;
                var v = d(i, p, y.value, l);
                if (null === v) {
                    null === p && (p = g);
                    break
                }
                t && p && null === v.alternate && e(i, p),
                o = s(v, o, m),
                null === u ? c = v : u.sibling = v,
                u = v,
                p = g
            }
            if (y.done)
                return n(i, p),
                ys && hs(i, m),
                c;
            if (null === p) {
                for (; !y.done; m++,
                y = a.next())
                    null !== (y = h(i, y.value, l)) && (o = s(y, o, m),
                    null === u ? c = y : u.sibling = y,
                    u = y);
                return ys && hs(i, m),
                c
            }
            for (p = r(i, p); !y.done; m++,
            y = a.next())
                null !== (y = f(p, i, m, y.value, l)) && (t && null !== y.alternate && p.delete(null === y.key ? m : y.key),
                o = s(y, o, m),
                null === u ? c = y : u.sibling = y,
                u = y);
            return t && p.forEach((function(t) {
                return e(i, t)
            }
            )),
            ys && hs(i, m),
            c
        }
        return function t(r, s, a, l) {
            if ("object" == typeof a && null !== a && a.type === B && null === a.key && (a = a.props.children),
            "object" == typeof a && null !== a) {
                switch (a.$$typeof) {
                case R:
                    t: {
                        for (var c = a.key, u = s; null !== u; ) {
                            if (u.key === c) {
                                if ((c = a.type) === B) {
                                    if (7 === u.tag) {
                                        n(r, u.sibling),
                                        (s = i(u, a.props.children)).return = r,
                                        r = s;
                                        break t
                                    }
                                } else if (u.elementType === c || "object" == typeof c && null !== c && c.$$typeof === H && ao(c) === u.type) {
                                    n(r, u.sibling),
                                    (s = i(u, a.props)).ref = so(r, u, a),
                                    s.return = r,
                                    r = s;
                                    break t
                                }
                                n(r, u);
                                break
                            }
                            e(r, u),
                            u = u.sibling
                        }
                        a.type === B ? ((s = qc(a.props.children, r.mode, l, a.key)).return = r,
                        r = s) : ((l = Xc(a.type, a.key, a.props, null, r.mode, l)).ref = so(r, s, a),
                        l.return = r,
                        r = l)
                    }
                    return o(r);
                case D:
                    t: {
                        for (u = a.key; null !== s; ) {
                            if (s.key === u) {
                                if (4 === s.tag && s.stateNode.containerInfo === a.containerInfo && s.stateNode.implementation === a.implementation) {
                                    n(r, s.sibling),
                                    (s = i(s, a.children || [])).return = r,
                                    r = s;
                                    break t
                                }
                                n(r, s);
                                break
                            }
                            e(r, s),
                            s = s.sibling
                        }
                        (s = Zc(a, r.mode, l)).return = r,
                        r = s
                    }
                    return o(r);
                case H:
                    return t(r, s, (u = a._init)(a._payload), l)
                }
                if (pt(a))
                    return p(r, s, a, l);
                if (X(a))
                    return m(r, s, a, l);
                oo(r, a)
            }
            return "string" == typeof a && "" !== a || "number" == typeof a ? (a = "" + a,
            null !== s && 6 === s.tag ? (n(r, s.sibling),
            (s = i(s, a)).return = r,
            r = s) : (n(r, s),
            (s = Qc(a, r.mode, l)).return = r,
            r = s),
            o(r)) : n(r, s)
        }
    }
    var co = lo(!0)
      , uo = lo(!1)
      , ho = {}
      , fo = Li(ho)
      , po = Li(ho)
      , mo = Li(ho);
    function go(t) {
        if (t === ho)
            throw Error(b(174));
        return t
    }
    function yo(t, e) {
        switch (ji(mo, e),
        ji(po, t),
        ji(fo, ho),
        t = e.nodeType) {
        case 9:
        case 11:
            e = (e = e.documentElement) ? e.namespaceURI : xt(null, "");
            break;
        default:
            e = xt(e = (t = 8 === t ? e.parentNode : e).namespaceURI || null, t = t.tagName)
        }
        Fi(fo),
        ji(fo, e)
    }
    function bo() {
        Fi(fo),
        Fi(po),
        Fi(mo)
    }
    function vo(t) {
        go(mo.current);
        var e = go(fo.current)
          , n = xt(e, t.type);
        e !== n && (ji(po, t),
        ji(fo, n))
    }
    function wo(t) {
        po.current === t && (Fi(fo),
        Fi(po))
    }
    var xo = Li(0);
    function Eo(t) {
        for (var e = t; null !== e; ) {
            if (13 === e.tag) {
                var n = e.memoizedState;
                if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data))
                    return e
            } else if (19 === e.tag && void 0 !== e.memoizedProps.revealOrder) {
                if (0 != (128 & e.flags))
                    return e
            } else if (null !== e.child) {
                e.child.return = e,
                e = e.child;
                continue
            }
            if (e === t)
                break;
            for (; null === e.sibling; ) {
                if (null === e.return || e.return === t)
                    return null;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
        return null
    }
    var _o = [];
    function Ao() {
        for (var t = 0; t < _o.length; t++)
            _o[t]._workInProgressVersionPrimary = null;
        _o.length = 0
    }
    var So = N.ReactCurrentDispatcher
      , To = N.ReactCurrentBatchConfig
      , ko = 0
      , Io = null
      , Mo = null
      , Co = null
      , Po = !1
      , Oo = !1
      , No = 0
      , Ro = 0;
    function Do() {
        throw Error(b(321))
    }
    function Bo(t, e) {
        if (null === e)
            return !1;
        for (var n = 0; n < e.length && n < t.length; n++)
            if (!wr(t[n], e[n]))
                return !1;
        return !0
    }
    function Lo(t, e, n, r, i, s) {
        if (ko = s,
        Io = e,
        e.memoizedState = null,
        e.updateQueue = null,
        e.lanes = 0,
        So.current = null === t || null === t.memoizedState ? wa : xa,
        t = n(r, i),
        Oo) {
            s = 0;
            do {
                if (Oo = !1,
                No = 0,
                25 <= s)
                    throw Error(b(301));
                s += 1,
                Co = Mo = null,
                e.updateQueue = null,
                So.current = Ea,
                t = n(r, i)
            } while (Oo)
        }
        if (So.current = va,
        e = null !== Mo && null !== Mo.next,
        ko = 0,
        Co = Mo = Io = null,
        Po = !1,
        e)
            throw Error(b(300));
        return t
    }
    function Fo() {
        var t = 0 !== No;
        return No = 0,
        t
    }
    function jo() {
        var t = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return null === Co ? Io.memoizedState = Co = t : Co = Co.next = t,
        Co
    }
    function Uo() {
        if (null === Mo) {
            var t = Io.alternate;
            t = null !== t ? t.memoizedState : null
        } else
            t = Mo.next;
        var e = null === Co ? Io.memoizedState : Co.next;
        if (null !== e)
            Co = e,
            Mo = t;
        else {
            if (null === t)
                throw Error(b(310));
            t = {
                memoizedState: (Mo = t).memoizedState,
                baseState: Mo.baseState,
                baseQueue: Mo.baseQueue,
                queue: Mo.queue,
                next: null
            },
            null === Co ? Io.memoizedState = Co = t : Co = Co.next = t
        }
        return Co
    }
    function zo(t, e) {
        return "function" == typeof e ? e(t) : e
    }
    function Vo(t) {
        var e = Uo()
          , n = e.queue;
        if (null === n)
            throw Error(b(311));
        n.lastRenderedReducer = t;
        var r = Mo
          , i = r.baseQueue
          , s = n.pending;
        if (null !== s) {
            if (null !== i) {
                var o = i.next;
                i.next = s.next,
                s.next = o
            }
            r.baseQueue = i = s,
            n.pending = null
        }
        if (null !== i) {
            s = i.next,
            r = r.baseState;
            var a = o = null
              , l = null
              , c = s;
            do {
                var u = c.lane;
                if ((ko & u) === u)
                    null !== l && (l = l.next = {
                        lane: 0,
                        action: c.action,
                        hasEagerState: c.hasEagerState,
                        eagerState: c.eagerState,
                        next: null
                    }),
                    r = c.hasEagerState ? c.eagerState : t(r, c.action);
                else {
                    var h = {
                        lane: u,
                        action: c.action,
                        hasEagerState: c.hasEagerState,
                        eagerState: c.eagerState,
                        next: null
                    };
                    null === l ? (a = l = h,
                    o = r) : l = l.next = h,
                    Io.lanes |= u,
                    Kl |= u
                }
                c = c.next
            } while (null !== c && c !== s);
            null === l ? o = r : l.next = a,
            wr(r, e.memoizedState) || (Na = !0),
            e.memoizedState = r,
            e.baseState = o,
            e.baseQueue = l,
            n.lastRenderedState = r
        }
        if (null !== (t = n.interleaved)) {
            i = t;
            do {
                s = i.lane,
                Io.lanes |= s,
                Kl |= s,
                i = i.next
            } while (i !== t)
        } else
            null === i && (n.lanes = 0);
        return [e.memoizedState, n.dispatch]
    }
    function Wo(t) {
        var e = Uo()
          , n = e.queue;
        if (null === n)
            throw Error(b(311));
        n.lastRenderedReducer = t;
        var r = n.dispatch
          , i = n.pending
          , s = e.memoizedState;
        if (null !== i) {
            n.pending = null;
            var o = i = i.next;
            do {
                s = t(s, o.action),
                o = o.next
            } while (o !== i);
            wr(s, e.memoizedState) || (Na = !0),
            e.memoizedState = s,
            null === e.baseQueue && (e.baseState = s),
            n.lastRenderedState = s
        }
        return [s, r]
    }
    function Yo() {}
    function Ho(t, e) {
        var n = Io
          , r = Uo()
          , i = e()
          , s = !wr(r.memoizedState, i);
        if (s && (r.memoizedState = i,
        Na = !0),
        r = r.queue,
        ra(Xo.bind(null, n, r, t), [t]),
        r.getSnapshot !== e || s || null !== Co && 1 & Co.memoizedState.tag) {
            if (n.flags |= 2048,
            Zo(9, Go.bind(null, n, r, i, e), void 0, null),
            null === Wl)
                throw Error(b(349));
            0 != (30 & ko) || $o(n, e, i)
        }
        return i
    }
    function $o(t, e, n) {
        t.flags |= 16384,
        t = {
            getSnapshot: e,
            value: n
        },
        null === (e = Io.updateQueue) ? (e = {
            lastEffect: null,
            stores: null
        },
        Io.updateQueue = e,
        e.stores = [t]) : null === (n = e.stores) ? e.stores = [t] : n.push(t)
    }
    function Go(t, e, n, r) {
        e.value = n,
        e.getSnapshot = r,
        qo(e) && Ko(t)
    }
    function Xo(t, e, n) {
        return n((function() {
            qo(e) && Ko(t)
        }
        ))
    }
    function qo(t) {
        var e = t.getSnapshot;
        t = t.value;
        try {
            var n = e();
            return !wr(t, n)
        } catch (t) {
            return !0
        }
    }
    function Ko(t) {
        var e = Vs(t, 1);
        null !== e && gc(e, t, 1, -1)
    }
    function Qo(t) {
        var e = jo();
        return "function" == typeof t && (t = t()),
        e.memoizedState = e.baseState = t,
        t = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: zo,
            lastRenderedState: t
        },
        e.queue = t,
        t = t.dispatch = ma.bind(null, Io, t),
        [e.memoizedState, t]
    }
    function Zo(t, e, n, r) {
        return t = {
            tag: t,
            create: e,
            destroy: n,
            deps: r,
            next: null
        },
        null === (e = Io.updateQueue) ? (e = {
            lastEffect: null,
            stores: null
        },
        Io.updateQueue = e,
        e.lastEffect = t.next = t) : null === (n = e.lastEffect) ? e.lastEffect = t.next = t : (r = n.next,
        n.next = t,
        t.next = r,
        e.lastEffect = t),
        t
    }
    function Jo() {
        return Uo().memoizedState
    }
    function ta(t, e, n, r) {
        var i = jo();
        Io.flags |= t,
        i.memoizedState = Zo(1 | e, n, void 0, void 0 === r ? null : r)
    }
    function ea(t, e, n, r) {
        var i = Uo();
        r = void 0 === r ? null : r;
        var s = void 0;
        if (null !== Mo) {
            var o = Mo.memoizedState;
            if (s = o.destroy,
            null !== r && Bo(r, o.deps))
                return void (i.memoizedState = Zo(e, n, s, r))
        }
        Io.flags |= t,
        i.memoizedState = Zo(1 | e, n, s, r)
    }
    function na(t, e) {
        return ta(8390656, 8, t, e)
    }
    function ra(t, e) {
        return ea(2048, 8, t, e)
    }
    function ia(t, e) {
        return ea(4, 2, t, e)
    }
    function sa(t, e) {
        return ea(4, 4, t, e)
    }
    function oa(t, e) {
        return "function" == typeof e ? (t = t(),
        e(t),
        function() {
            e(null)
        }
        ) : null != e ? (t = t(),
        e.current = t,
        function() {
            e.current = null
        }
        ) : void 0
    }
    function aa(t, e, n) {
        return n = null != n ? n.concat([t]) : null,
        ea(4, 4, oa.bind(null, e, t), n)
    }
    function la() {}
    function ca(t, e) {
        var n = Uo();
        e = void 0 === e ? null : e;
        var r = n.memoizedState;
        return null !== r && null !== e && Bo(e, r[1]) ? r[0] : (n.memoizedState = [t, e],
        t)
    }
    function ua(t, e) {
        var n = Uo();
        e = void 0 === e ? null : e;
        var r = n.memoizedState;
        return null !== r && null !== e && Bo(e, r[1]) ? r[0] : (t = t(),
        n.memoizedState = [t, e],
        t)
    }
    function ha(t, e, n) {
        return 0 == (21 & ko) ? (t.baseState && (t.baseState = !1,
        Na = !0),
        t.memoizedState = n) : (wr(n, e) || (n = Ie(),
        Io.lanes |= n,
        Kl |= n,
        t.baseState = !0),
        e)
    }
    function da(t, e) {
        var n = Oe;
        Oe = 0 !== n && 4 > n ? n : 4,
        t(!0);
        var r = To.transition;
        To.transition = {};
        try {
            t(!1),
            e()
        } finally {
            Oe = n,
            To.transition = r
        }
    }
    function fa() {
        return Uo().memoizedState
    }
    function pa(t, e, n) {
        var r = mc(t);
        if (n = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        ga(t))
            ya(e, n);
        else if (null !== (n = zs(t, e, n, r))) {
            gc(n, t, r, pc()),
            ba(n, e, r)
        }
    }
    function ma(t, e, n) {
        var r = mc(t)
          , i = {
            lane: r,
            action: n,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (ga(t))
            ya(e, i);
        else {
            var s = t.alternate;
            if (0 === t.lanes && (null === s || 0 === s.lanes) && null !== (s = e.lastRenderedReducer))
                try {
                    var o = e.lastRenderedState
                      , a = s(o, n);
                    if (i.hasEagerState = !0,
                    i.eagerState = a,
                    wr(a, o)) {
                        var l = e.interleaved;
                        return null === l ? (i.next = i,
                        Us(e)) : (i.next = l.next,
                        l.next = i),
                        void (e.interleaved = i)
                    }
                } catch (t) {}
            null !== (n = zs(t, e, i, r)) && (gc(n, t, r, i = pc()),
            ba(n, e, r))
        }
    }
    function ga(t) {
        var e = t.alternate;
        return t === Io || null !== e && e === Io
    }
    function ya(t, e) {
        Oo = Po = !0;
        var n = t.pending;
        null === n ? e.next = e : (e.next = n.next,
        n.next = e),
        t.pending = e
    }
    function ba(t, e, n) {
        if (0 != (4194240 & n)) {
            var r = e.lanes;
            n |= r &= t.pendingLanes,
            e.lanes = n,
            Pe(t, n)
        }
    }
    var va = {
        readContext: Fs,
        useCallback: Do,
        useContext: Do,
        useEffect: Do,
        useImperativeHandle: Do,
        useInsertionEffect: Do,
        useLayoutEffect: Do,
        useMemo: Do,
        useReducer: Do,
        useRef: Do,
        useState: Do,
        useDebugValue: Do,
        useDeferredValue: Do,
        useTransition: Do,
        useMutableSource: Do,
        useSyncExternalStore: Do,
        useId: Do,
        unstable_isNewReconciler: !1
    }
      , wa = {
        readContext: Fs,
        useCallback: function(t, e) {
            return jo().memoizedState = [t, void 0 === e ? null : e],
            t
        },
        useContext: Fs,
        useEffect: na,
        useImperativeHandle: function(t, e, n) {
            return n = null != n ? n.concat([t]) : null,
            ta(4194308, 4, oa.bind(null, e, t), n)
        },
        useLayoutEffect: function(t, e) {
            return ta(4194308, 4, t, e)
        },
        useInsertionEffect: function(t, e) {
            return ta(4, 2, t, e)
        },
        useMemo: function(t, e) {
            var n = jo();
            return e = void 0 === e ? null : e,
            t = t(),
            n.memoizedState = [t, e],
            t
        },
        useReducer: function(t, e, n) {
            var r = jo();
            return e = void 0 !== n ? n(e) : e,
            r.memoizedState = r.baseState = e,
            t = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: t,
                lastRenderedState: e
            },
            r.queue = t,
            t = t.dispatch = pa.bind(null, Io, t),
            [r.memoizedState, t]
        },
        useRef: function(t) {
            return t = {
                current: t
            },
            jo().memoizedState = t
        },
        useState: Qo,
        useDebugValue: la,
        useDeferredValue: function(t) {
            return jo().memoizedState = t
        },
        useTransition: function() {
            var t = Qo(!1)
              , e = t[0];
            return t = da.bind(null, t[1]),
            jo().memoizedState = t,
            [e, t]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(t, e, n) {
            var r = Io
              , i = jo();
            if (ys) {
                if (void 0 === n)
                    throw Error(b(407));
                n = n()
            } else {
                if (n = e(),
                null === Wl)
                    throw Error(b(349));
                0 != (30 & ko) || $o(r, e, n)
            }
            i.memoizedState = n;
            var s = {
                value: n,
                getSnapshot: e
            };
            return i.queue = s,
            na(Xo.bind(null, r, s, t), [t]),
            r.flags |= 2048,
            Zo(9, Go.bind(null, r, s, n, e), void 0, null),
            n
        },
        useId: function() {
            var t = jo()
              , e = Wl.identifierPrefix;
            if (ys) {
                var n = us;
                e = ":" + e + "R" + (n = (cs & ~(1 << 32 - ve(cs) - 1)).toString(32) + n),
                0 < (n = No++) && (e += "H" + n.toString(32)),
                e += ":"
            } else
                e = ":" + e + "r" + (n = Ro++).toString(32) + ":";
            return t.memoizedState = e
        },
        unstable_isNewReconciler: !1
    }
      , xa = {
        readContext: Fs,
        useCallback: ca,
        useContext: Fs,
        useEffect: ra,
        useImperativeHandle: aa,
        useInsertionEffect: ia,
        useLayoutEffect: sa,
        useMemo: ua,
        useReducer: Vo,
        useRef: Jo,
        useState: function() {
            return Vo(zo)
        },
        useDebugValue: la,
        useDeferredValue: function(t) {
            return ha(Uo(), Mo.memoizedState, t)
        },
        useTransition: function() {
            return [Vo(zo)[0], Uo().memoizedState]
        },
        useMutableSource: Yo,
        useSyncExternalStore: Ho,
        useId: fa,
        unstable_isNewReconciler: !1
    }
      , Ea = {
        readContext: Fs,
        useCallback: ca,
        useContext: Fs,
        useEffect: ra,
        useImperativeHandle: aa,
        useInsertionEffect: ia,
        useLayoutEffect: sa,
        useMemo: ua,
        useReducer: Wo,
        useRef: Jo,
        useState: function() {
            return Wo(zo)
        },
        useDebugValue: la,
        useDeferredValue: function(t) {
            var e = Uo();
            return null === Mo ? e.memoizedState = t : ha(e, Mo.memoizedState, t)
        },
        useTransition: function() {
            return [Wo(zo)[0], Uo().memoizedState]
        },
        useMutableSource: Yo,
        useSyncExternalStore: Ho,
        useId: fa,
        unstable_isNewReconciler: !1
    };
    function _a(t, e) {
        try {
            var n = ""
              , r = e;
            do {
                n += tt(r),
                r = r.return
            } while (r);
            var i = n
        } catch (t) {
            i = "\nError generating stack: " + t.message + "\n" + t.stack
        }
        return {
            value: t,
            source: e,
            stack: i,
            digest: null
        }
    }
    function Aa(t, e, n) {
        return {
            value: t,
            source: null,
            stack: null != n ? n : null,
            digest: null != e ? e : null
        }
    }
    function Sa(t, e) {
        try {
            console.error(e.value)
        } catch (t) {
            setTimeout((function() {
                throw t
            }
            ))
        }
    }
    var Ta = "function" == typeof WeakMap ? WeakMap : Map;
    function ka(t, e, n) {
        (n = $s(-1, n)).tag = 3,
        n.payload = {
            element: null
        };
        var r = e.value;
        return n.callback = function() {
            ic || (ic = !0,
            sc = r),
            Sa(0, e)
        }
        ,
        n
    }
    function Ia(t, e, n) {
        (n = $s(-1, n)).tag = 3;
        var r = t.type.getDerivedStateFromError;
        if ("function" == typeof r) {
            var i = e.value;
            n.payload = function() {
                return r(i)
            }
            ,
            n.callback = function() {
                Sa(0, e)
            }
        }
        var s = t.stateNode;
        return null !== s && "function" == typeof s.componentDidCatch && (n.callback = function() {
            Sa(0, e),
            "function" != typeof r && (null === oc ? oc = new Set([this]) : oc.add(this));
            var t = e.stack;
            this.componentDidCatch(e.value, {
                componentStack: null !== t ? t : ""
            })
        }
        ),
        n
    }
    function Ma(t, e, n) {
        var r = t.pingCache;
        if (null === r) {
            r = t.pingCache = new Ta;
            var i = new Set;
            r.set(e, i)
        } else
            void 0 === (i = r.get(e)) && (i = new Set,
            r.set(e, i));
        i.has(n) || (i.add(n),
        t = jc.bind(null, t, e, n),
        e.then(t, t))
    }
    function Ca(t) {
        do {
            var e;
            if ((e = 13 === t.tag) && (e = null === (e = t.memoizedState) || null !== e.dehydrated),
            e)
                return t;
            t = t.return
        } while (null !== t);
        return null
    }
    function Pa(t, e, n, r, i) {
        return 0 == (1 & t.mode) ? (t === e ? t.flags |= 65536 : (t.flags |= 128,
        n.flags |= 131072,
        n.flags &= -52805,
        1 === n.tag && (null === n.alternate ? n.tag = 17 : ((e = $s(-1, 1)).tag = 2,
        Gs(n, e, 1))),
        n.lanes |= 1),
        t) : (t.flags |= 65536,
        t.lanes = i,
        t)
    }
    var Oa = N.ReactCurrentOwner
      , Na = !1;
    function Ra(t, e, n, r) {
        e.child = null === t ? uo(e, null, n, r) : co(e, t.child, n, r)
    }
    function Da(t, e, n, r, i) {
        n = n.render;
        var s = e.ref;
        return Ls(e, i),
        r = Lo(t, e, n, r, s, i),
        n = Fo(),
        null === t || Na ? (ys && n && fs(e),
        e.flags |= 1,
        Ra(t, e, r, i),
        e.child) : (e.updateQueue = t.updateQueue,
        e.flags &= -2053,
        t.lanes &= ~i,
        il(t, e, i))
    }
    function Ba(t, e, n, r, i) {
        if (null === t) {
            var s = n.type;
            return "function" != typeof s || $c(s) || void 0 !== s.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((t = Xc(n.type, null, r, e, e.mode, i)).ref = e.ref,
            t.return = e,
            e.child = t) : (e.tag = 15,
            e.type = s,
            La(t, e, s, r, i))
        }
        if (s = t.child,
        0 == (t.lanes & i)) {
            var o = s.memoizedProps;
            if ((n = null !== (n = n.compare) ? n : xr)(o, r) && t.ref === e.ref)
                return il(t, e, i)
        }
        return e.flags |= 1,
        (t = Gc(s, r)).ref = e.ref,
        t.return = e,
        e.child = t
    }
    function La(t, e, n, r, i) {
        if (null !== t) {
            var s = t.memoizedProps;
            if (xr(s, r) && t.ref === e.ref) {
                if (Na = !1,
                e.pendingProps = r = s,
                0 == (t.lanes & i))
                    return e.lanes = t.lanes,
                    il(t, e, i);
                0 != (131072 & t.flags) && (Na = !0)
            }
        }
        return Ua(t, e, n, r, i)
    }
    function Fa(t, e, n) {
        var r = e.pendingProps
          , i = r.children
          , s = null !== t ? t.memoizedState : null;
        if ("hidden" === r.mode)
            if (0 == (1 & e.mode))
                e.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                ji(Gl, $l),
                $l |= n;
            else {
                if (0 == (1073741824 & n))
                    return t = null !== s ? s.baseLanes | n : n,
                    e.lanes = e.childLanes = 1073741824,
                    e.memoizedState = {
                        baseLanes: t,
                        cachePool: null,
                        transitions: null
                    },
                    e.updateQueue = null,
                    ji(Gl, $l),
                    $l |= t,
                    null;
                e.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                r = null !== s ? s.baseLanes : n,
                ji(Gl, $l),
                $l |= r
            }
        else
            null !== s ? (r = s.baseLanes | n,
            e.memoizedState = null) : r = n,
            ji(Gl, $l),
            $l |= r;
        return Ra(t, e, i, n),
        e.child
    }
    function ja(t, e) {
        var n = e.ref;
        (null === t && null !== n || null !== t && t.ref !== n) && (e.flags |= 512,
        e.flags |= 2097152)
    }
    function Ua(t, e, n, r, i) {
        var s = Hi(n) ? Wi : zi.current;
        return s = Yi(e, s),
        Ls(e, i),
        n = Lo(t, e, n, r, s, i),
        r = Fo(),
        null === t || Na ? (ys && r && fs(e),
        e.flags |= 1,
        Ra(t, e, n, i),
        e.child) : (e.updateQueue = t.updateQueue,
        e.flags &= -2053,
        t.lanes &= ~i,
        il(t, e, i))
    }
    function za(t, e, n, r, i) {
        if (Hi(n)) {
            var s = !0;
            qi(e)
        } else
            s = !1;
        if (Ls(e, i),
        null === e.stateNode)
            rl(t, e),
            no(e, n, r),
            io(e, n, r, i),
            r = !0;
        else if (null === t) {
            var o = e.stateNode
              , a = e.memoizedProps;
            o.props = a;
            var l = o.context
              , c = n.contextType;
            "object" == typeof c && null !== c ? c = Fs(c) : c = Yi(e, c = Hi(n) ? Wi : zi.current);
            var u = n.getDerivedStateFromProps
              , h = "function" == typeof u || "function" == typeof o.getSnapshotBeforeUpdate;
            h || "function" != typeof o.UNSAFE_componentWillReceiveProps && "function" != typeof o.componentWillReceiveProps || (a !== r || l !== c) && ro(e, o, r, c),
            Ws = !1;
            var d = e.memoizedState;
            o.state = d,
            Ks(e, r, o, i),
            l = e.memoizedState,
            a !== r || d !== l || Vi.current || Ws ? ("function" == typeof u && (Js(e, n, u, r),
            l = e.memoizedState),
            (a = Ws || eo(e, n, a, r, d, l, c)) ? (h || "function" != typeof o.UNSAFE_componentWillMount && "function" != typeof o.componentWillMount || ("function" == typeof o.componentWillMount && o.componentWillMount(),
            "function" == typeof o.UNSAFE_componentWillMount && o.UNSAFE_componentWillMount()),
            "function" == typeof o.componentDidMount && (e.flags |= 4194308)) : ("function" == typeof o.componentDidMount && (e.flags |= 4194308),
            e.memoizedProps = r,
            e.memoizedState = l),
            o.props = r,
            o.state = l,
            o.context = c,
            r = a) : ("function" == typeof o.componentDidMount && (e.flags |= 4194308),
            r = !1)
        } else {
            o = e.stateNode,
            Hs(t, e),
            a = e.memoizedProps,
            c = e.type === e.elementType ? a : Ms(e.type, a),
            o.props = c,
            h = e.pendingProps,
            d = o.context,
            "object" == typeof (l = n.contextType) && null !== l ? l = Fs(l) : l = Yi(e, l = Hi(n) ? Wi : zi.current);
            var f = n.getDerivedStateFromProps;
            (u = "function" == typeof f || "function" == typeof o.getSnapshotBeforeUpdate) || "function" != typeof o.UNSAFE_componentWillReceiveProps && "function" != typeof o.componentWillReceiveProps || (a !== h || d !== l) && ro(e, o, r, l),
            Ws = !1,
            d = e.memoizedState,
            o.state = d,
            Ks(e, r, o, i);
            var p = e.memoizedState;
            a !== h || d !== p || Vi.current || Ws ? ("function" == typeof f && (Js(e, n, f, r),
            p = e.memoizedState),
            (c = Ws || eo(e, n, c, r, d, p, l) || !1) ? (u || "function" != typeof o.UNSAFE_componentWillUpdate && "function" != typeof o.componentWillUpdate || ("function" == typeof o.componentWillUpdate && o.componentWillUpdate(r, p, l),
            "function" == typeof o.UNSAFE_componentWillUpdate && o.UNSAFE_componentWillUpdate(r, p, l)),
            "function" == typeof o.componentDidUpdate && (e.flags |= 4),
            "function" == typeof o.getSnapshotBeforeUpdate && (e.flags |= 1024)) : ("function" != typeof o.componentDidUpdate || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 4),
            "function" != typeof o.getSnapshotBeforeUpdate || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 1024),
            e.memoizedProps = r,
            e.memoizedState = p),
            o.props = r,
            o.state = p,
            o.context = l,
            r = c) : ("function" != typeof o.componentDidUpdate || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 4),
            "function" != typeof o.getSnapshotBeforeUpdate || a === t.memoizedProps && d === t.memoizedState || (e.flags |= 1024),
            r = !1)
        }
        return Va(t, e, n, r, s, i)
    }
    function Va(t, e, n, r, i, s) {
        ja(t, e);
        var o = 0 != (128 & e.flags);
        if (!r && !o)
            return i && Ki(e, n, !1),
            il(t, e, s);
        r = e.stateNode,
        Oa.current = e;
        var a = o && "function" != typeof n.getDerivedStateFromError ? null : r.render();
        return e.flags |= 1,
        null !== t && o ? (e.child = co(e, t.child, null, s),
        e.child = co(e, null, a, s)) : Ra(t, e, a, s),
        e.memoizedState = r.state,
        i && Ki(e, n, !0),
        e.child
    }
    function Wa(t) {
        var e = t.stateNode;
        e.pendingContext ? Gi(0, e.pendingContext, e.pendingContext !== e.context) : e.context && Gi(0, e.context, !1),
        yo(t, e.containerInfo)
    }
    function Ya(t, e, n, r, i) {
        return Ts(),
        ks(i),
        e.flags |= 256,
        Ra(t, e, n, r),
        e.child
    }
    var Ha, $a, Ga, Xa, qa = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function Ka(t) {
        return {
            baseLanes: t,
            cachePool: null,
            transitions: null
        }
    }
    function Qa(t, e, n) {
        var r, i = e.pendingProps, s = xo.current, o = !1, a = 0 != (128 & e.flags);
        if ((r = a) || (r = (null === t || null !== t.memoizedState) && 0 != (2 & s)),
        r ? (o = !0,
        e.flags &= -129) : null !== t && null === t.memoizedState || (s |= 1),
        ji(xo, 1 & s),
        null === t)
            return Es(e),
            null !== (t = e.memoizedState) && null !== (t = t.dehydrated) ? (0 == (1 & e.mode) ? e.lanes = 1 : "$!" === t.data ? e.lanes = 8 : e.lanes = 1073741824,
            null) : (a = i.children,
            t = i.fallback,
            o ? (i = e.mode,
            o = e.child,
            a = {
                mode: "hidden",
                children: a
            },
            0 == (1 & i) && null !== o ? (o.childLanes = 0,
            o.pendingProps = a) : o = Kc(a, i, 0, null),
            t = qc(t, i, n, null),
            o.return = e,
            t.return = e,
            o.sibling = t,
            e.child = o,
            e.child.memoizedState = Ka(n),
            e.memoizedState = qa,
            t) : Za(e, a));
        if (null !== (s = t.memoizedState) && null !== (r = s.dehydrated))
            return function(t, e, n, r, i, s, o) {
                if (n)
                    return 256 & e.flags ? (e.flags &= -257,
                    Ja(t, e, o, r = Aa(Error(b(422))))) : null !== e.memoizedState ? (e.child = t.child,
                    e.flags |= 128,
                    null) : (s = r.fallback,
                    i = e.mode,
                    r = Kc({
                        mode: "visible",
                        children: r.children
                    }, i, 0, null),
                    (s = qc(s, i, o, null)).flags |= 2,
                    r.return = e,
                    s.return = e,
                    r.sibling = s,
                    e.child = r,
                    0 != (1 & e.mode) && co(e, t.child, null, o),
                    e.child.memoizedState = Ka(o),
                    e.memoizedState = qa,
                    s);
                if (0 == (1 & e.mode))
                    return Ja(t, e, o, null);
                if ("$!" === i.data) {
                    if (r = i.nextSibling && i.nextSibling.dataset)
                        var a = r.dgst;
                    return r = a,
                    Ja(t, e, o, r = Aa(s = Error(b(419)), r, void 0))
                }
                if (a = 0 != (o & t.childLanes),
                Na || a) {
                    if (null !== (r = Wl)) {
                        switch (o & -o) {
                        case 4:
                            i = 2;
                            break;
                        case 16:
                            i = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            i = 32;
                            break;
                        case 536870912:
                            i = 268435456;
                            break;
                        default:
                            i = 0
                        }
                        0 !== (i = 0 != (i & (r.suspendedLanes | o)) ? 0 : i) && i !== s.retryLane && (s.retryLane = i,
                        Vs(t, i),
                        gc(r, t, i, -1))
                    }
                    return Mc(),
                    Ja(t, e, o, r = Aa(Error(b(421))))
                }
                return "$?" === i.data ? (e.flags |= 128,
                e.child = t.child,
                e = zc.bind(null, t),
                i._reactRetry = e,
                null) : (t = s.treeContext,
                gs = Ei(i.nextSibling),
                ms = e,
                ys = !0,
                bs = null,
                null !== t && (os[as++] = cs,
                os[as++] = us,
                os[as++] = ls,
                cs = t.id,
                us = t.overflow,
                ls = e),
                e = Za(e, r.children),
                e.flags |= 4096,
                e)
            }(t, e, a, i, r, s, n);
        if (o) {
            o = i.fallback,
            a = e.mode,
            r = (s = t.child).sibling;
            var l = {
                mode: "hidden",
                children: i.children
            };
            return 0 == (1 & a) && e.child !== s ? ((i = e.child).childLanes = 0,
            i.pendingProps = l,
            e.deletions = null) : (i = Gc(s, l)).subtreeFlags = 14680064 & s.subtreeFlags,
            null !== r ? o = Gc(r, o) : (o = qc(o, a, n, null)).flags |= 2,
            o.return = e,
            i.return = e,
            i.sibling = o,
            e.child = i,
            i = o,
            o = e.child,
            a = null === (a = t.child.memoizedState) ? Ka(n) : {
                baseLanes: a.baseLanes | n,
                cachePool: null,
                transitions: a.transitions
            },
            o.memoizedState = a,
            o.childLanes = t.childLanes & ~n,
            e.memoizedState = qa,
            i
        }
        return t = (o = t.child).sibling,
        i = Gc(o, {
            mode: "visible",
            children: i.children
        }),
        0 == (1 & e.mode) && (i.lanes = n),
        i.return = e,
        i.sibling = null,
        null !== t && (null === (n = e.deletions) ? (e.deletions = [t],
        e.flags |= 16) : n.push(t)),
        e.child = i,
        e.memoizedState = null,
        i
    }
    function Za(t, e) {
        return (e = Kc({
            mode: "visible",
            children: e
        }, t.mode, 0, null)).return = t,
        t.child = e
    }
    function Ja(t, e, n, r) {
        return null !== r && ks(r),
        co(e, t.child, null, n),
        (t = Za(e, e.pendingProps.children)).flags |= 2,
        e.memoizedState = null,
        t
    }
    function tl(t, e, n) {
        t.lanes |= e;
        var r = t.alternate;
        null !== r && (r.lanes |= e),
        Bs(t.return, e, n)
    }
    function el(t, e, n, r, i) {
        var s = t.memoizedState;
        null === s ? t.memoizedState = {
            isBackwards: e,
            rendering: null,
            renderingStartTime: 0,
            last: r,
            tail: n,
            tailMode: i
        } : (s.isBackwards = e,
        s.rendering = null,
        s.renderingStartTime = 0,
        s.last = r,
        s.tail = n,
        s.tailMode = i)
    }
    function nl(t, e, n) {
        var r = e.pendingProps
          , i = r.revealOrder
          , s = r.tail;
        if (Ra(t, e, r.children, n),
        0 != (2 & (r = xo.current)))
            r = 1 & r | 2,
            e.flags |= 128;
        else {
            if (null !== t && 0 != (128 & t.flags))
                t: for (t = e.child; null !== t; ) {
                    if (13 === t.tag)
                        null !== t.memoizedState && tl(t, n, e);
                    else if (19 === t.tag)
                        tl(t, n, e);
                    else if (null !== t.child) {
                        t.child.return = t,
                        t = t.child;
                        continue
                    }
                    if (t === e)
                        break t;
                    for (; null === t.sibling; ) {
                        if (null === t.return || t.return === e)
                            break t;
                        t = t.return
                    }
                    t.sibling.return = t.return,
                    t = t.sibling
                }
            r &= 1
        }
        if (ji(xo, r),
        0 == (1 & e.mode))
            e.memoizedState = null;
        else
            switch (i) {
            case "forwards":
                for (n = e.child,
                i = null; null !== n; )
                    null !== (t = n.alternate) && null === Eo(t) && (i = n),
                    n = n.sibling;
                null === (n = i) ? (i = e.child,
                e.child = null) : (i = n.sibling,
                n.sibling = null),
                el(e, !1, i, n, s);
                break;
            case "backwards":
                for (n = null,
                i = e.child,
                e.child = null; null !== i; ) {
                    if (null !== (t = i.alternate) && null === Eo(t)) {
                        e.child = i;
                        break
                    }
                    t = i.sibling,
                    i.sibling = n,
                    n = i,
                    i = t
                }
                el(e, !0, n, null, s);
                break;
            case "together":
                el(e, !1, null, null, void 0);
                break;
            default:
                e.memoizedState = null
            }
        return e.child
    }
    function rl(t, e) {
        0 == (1 & e.mode) && null !== t && (t.alternate = null,
        e.alternate = null,
        e.flags |= 2)
    }
    function il(t, e, n) {
        if (null !== t && (e.dependencies = t.dependencies),
        Kl |= e.lanes,
        0 == (n & e.childLanes))
            return null;
        if (null !== t && e.child !== t.child)
            throw Error(b(153));
        if (null !== e.child) {
            for (n = Gc(t = e.child, t.pendingProps),
            e.child = n,
            n.return = e; null !== t.sibling; )
                t = t.sibling,
                (n = n.sibling = Gc(t, t.pendingProps)).return = e;
            n.sibling = null
        }
        return e.child
    }
    function sl(t, e) {
        if (!ys)
            switch (t.tailMode) {
            case "hidden":
                e = t.tail;
                for (var n = null; null !== e; )
                    null !== e.alternate && (n = e),
                    e = e.sibling;
                null === n ? t.tail = null : n.sibling = null;
                break;
            case "collapsed":
                n = t.tail;
                for (var r = null; null !== n; )
                    null !== n.alternate && (r = n),
                    n = n.sibling;
                null === r ? e || null === t.tail ? t.tail = null : t.tail.sibling = null : r.sibling = null
            }
    }
    function ol(t) {
        var e = null !== t.alternate && t.alternate.child === t.child
          , n = 0
          , r = 0;
        if (e)
            for (var i = t.child; null !== i; )
                n |= i.lanes | i.childLanes,
                r |= 14680064 & i.subtreeFlags,
                r |= 14680064 & i.flags,
                i.return = t,
                i = i.sibling;
        else
            for (i = t.child; null !== i; )
                n |= i.lanes | i.childLanes,
                r |= i.subtreeFlags,
                r |= i.flags,
                i.return = t,
                i = i.sibling;
        return t.subtreeFlags |= r,
        t.childLanes = n,
        e
    }
    function al(t, e, n) {
        var r = e.pendingProps;
        switch (ps(e),
        e.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return ol(e),
            null;
        case 1:
        case 17:
            return Hi(e.type) && $i(),
            ol(e),
            null;
        case 3:
            return r = e.stateNode,
            bo(),
            Fi(Vi),
            Fi(zi),
            Ao(),
            r.pendingContext && (r.context = r.pendingContext,
            r.pendingContext = null),
            null !== t && null !== t.child || (As(e) ? e.flags |= 4 : null === t || t.memoizedState.isDehydrated && 0 == (256 & e.flags) || (e.flags |= 1024,
            null !== bs && (wc(bs),
            bs = null))),
            $a(t, e),
            ol(e),
            null;
        case 5:
            wo(e);
            var i = go(mo.current);
            if (n = e.type,
            null !== t && null != e.stateNode)
                Ga(t, e, n, r, i),
                t.ref !== e.ref && (e.flags |= 512,
                e.flags |= 2097152);
            else {
                if (!r) {
                    if (null === e.stateNode)
                        throw Error(b(166));
                    return ol(e),
                    null
                }
                if (t = go(fo.current),
                As(e)) {
                    r = e.stateNode,
                    n = e.type;
                    var s = e.memoizedProps;
                    switch (r[Si] = e,
                    r[Ti] = s,
                    t = 0 != (1 & e.mode),
                    n) {
                    case "dialog":
                        Zr("cancel", r),
                        Zr("close", r);
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Zr("load", r);
                        break;
                    case "video":
                    case "audio":
                        for (i = 0; i < Xr.length; i++)
                            Zr(Xr[i], r);
                        break;
                    case "source":
                        Zr("error", r);
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Zr("error", r),
                        Zr("load", r);
                        break;
                    case "details":
                        Zr("toggle", r);
                        break;
                    case "input":
                        ct(r, s),
                        Zr("invalid", r);
                        break;
                    case "select":
                        r._wrapperState = {
                            wasMultiple: !!s.multiple
                        },
                        Zr("invalid", r);
                        break;
                    case "textarea":
                        yt(r, s),
                        Zr("invalid", r)
                    }
                    for (var o in Pt(n, s),
                    i = null,
                    s)
                        if (s.hasOwnProperty(o)) {
                            var a = s[o];
                            "children" === o ? "string" == typeof a ? r.textContent !== a && (!0 !== s.suppressHydrationWarning && hi(r.textContent, a, t),
                            i = ["children", a]) : "number" == typeof a && r.textContent !== "" + a && (!0 !== s.suppressHydrationWarning && hi(r.textContent, a, t),
                            i = ["children", "" + a]) : w.hasOwnProperty(o) && null != a && "onScroll" === o && Zr("scroll", r)
                        }
                    switch (n) {
                    case "input":
                        st(r),
                        dt(r, s, !0);
                        break;
                    case "textarea":
                        st(r),
                        vt(r);
                        break;
                    case "select":
                    case "option":
                        break;
                    default:
                        "function" == typeof s.onClick && (r.onclick = di)
                    }
                    r = i,
                    e.updateQueue = r,
                    null !== r && (e.flags |= 4)
                } else {
                    o = 9 === i.nodeType ? i : i.ownerDocument,
                    "http://www.w3.org/1999/xhtml" === t && (t = wt(n)),
                    "http://www.w3.org/1999/xhtml" === t ? "script" === n ? ((t = o.createElement("div")).innerHTML = "<script><\/script>",
                    t = t.removeChild(t.firstChild)) : "string" == typeof r.is ? t = o.createElement(n, {
                        is: r.is
                    }) : (t = o.createElement(n),
                    "select" === n && (o = t,
                    r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : t = o.createElementNS(t, n),
                    t[Si] = e,
                    t[Ti] = r,
                    Ha(t, e, !1, !1),
                    e.stateNode = t;
                    t: {
                        switch (o = Ot(n, r),
                        n) {
                        case "dialog":
                            Zr("cancel", t),
                            Zr("close", t),
                            i = r;
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            Zr("load", t),
                            i = r;
                            break;
                        case "video":
                        case "audio":
                            for (i = 0; i < Xr.length; i++)
                                Zr(Xr[i], t);
                            i = r;
                            break;
                        case "source":
                            Zr("error", t),
                            i = r;
                            break;
                        case "img":
                        case "image":
                        case "link":
                            Zr("error", t),
                            Zr("load", t),
                            i = r;
                            break;
                        case "details":
                            Zr("toggle", t),
                            i = r;
                            break;
                        case "input":
                            ct(t, r),
                            i = lt(t, r),
                            Zr("invalid", t);
                            break;
                        case "option":
                        default:
                            i = r;
                            break;
                        case "select":
                            t._wrapperState = {
                                wasMultiple: !!r.multiple
                            },
                            i = K({}, r, {
                                value: void 0
                            }),
                            Zr("invalid", t);
                            break;
                        case "textarea":
                            yt(t, r),
                            i = gt(t, r),
                            Zr("invalid", t)
                        }
                        for (s in Pt(n, i),
                        a = i)
                            if (a.hasOwnProperty(s)) {
                                var l = a[s];
                                "style" === s ? Mt(t, l) : "dangerouslySetInnerHTML" === s ? null != (l = l ? l.__html : void 0) && At(t, l) : "children" === s ? "string" == typeof l ? ("textarea" !== n || "" !== l) && St(t, l) : "number" == typeof l && St(t, "" + l) : "suppressContentEditableWarning" !== s && "suppressHydrationWarning" !== s && "autoFocus" !== s && (w.hasOwnProperty(s) ? null != l && "onScroll" === s && Zr("scroll", t) : null != l && O(t, s, l, o))
                            }
                        switch (n) {
                        case "input":
                            st(t),
                            dt(t, r, !1);
                            break;
                        case "textarea":
                            st(t),
                            vt(t);
                            break;
                        case "option":
                            null != r.value && t.setAttribute("value", "" + rt(r.value));
                            break;
                        case "select":
                            t.multiple = !!r.multiple,
                            null != (s = r.value) ? mt(t, !!r.multiple, s, !1) : null != r.defaultValue && mt(t, !!r.multiple, r.defaultValue, !0);
                            break;
                        default:
                            "function" == typeof i.onClick && (t.onclick = di)
                        }
                        switch (n) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                            r = !!r.autoFocus;
                            break t;
                        case "img":
                            r = !0;
                            break t;
                        default:
                            r = !1
                        }
                    }
                    r && (e.flags |= 4)
                }
                null !== e.ref && (e.flags |= 512,
                e.flags |= 2097152)
            }
            return ol(e),
            null;
        case 6:
            if (t && null != e.stateNode)
                Xa(t, e, t.memoizedProps, r);
            else {
                if ("string" != typeof r && null === e.stateNode)
                    throw Error(b(166));
                if (n = go(mo.current),
                go(fo.current),
                As(e)) {
                    if (r = e.stateNode,
                    n = e.memoizedProps,
                    r[Si] = e,
                    (s = r.nodeValue !== n) && null !== (t = ms))
                        switch (t.tag) {
                        case 3:
                            hi(r.nodeValue, n, 0 != (1 & t.mode));
                            break;
                        case 5:
                            !0 !== t.memoizedProps.suppressHydrationWarning && hi(r.nodeValue, n, 0 != (1 & t.mode))
                        }
                    s && (e.flags |= 4)
                } else
                    (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[Si] = e,
                    e.stateNode = r
            }
            return ol(e),
            null;
        case 13:
            if (Fi(xo),
            r = e.memoizedState,
            null === t || null !== t.memoizedState && null !== t.memoizedState.dehydrated) {
                if (ys && null !== gs && 0 != (1 & e.mode) && 0 == (128 & e.flags))
                    Ss(),
                    Ts(),
                    e.flags |= 98560,
                    s = !1;
                else if (s = As(e),
                null !== r && null !== r.dehydrated) {
                    if (null === t) {
                        if (!s)
                            throw Error(b(318));
                        if (!(s = null !== (s = e.memoizedState) ? s.dehydrated : null))
                            throw Error(b(317));
                        s[Si] = e
                    } else
                        Ts(),
                        0 == (128 & e.flags) && (e.memoizedState = null),
                        e.flags |= 4;
                    ol(e),
                    s = !1
                } else
                    null !== bs && (wc(bs),
                    bs = null),
                    s = !0;
                if (!s)
                    return 65536 & e.flags ? e : null
            }
            return 0 != (128 & e.flags) ? (e.lanes = n,
            e) : ((r = null !== r) !== (null !== t && null !== t.memoizedState) && r && (e.child.flags |= 8192,
            0 != (1 & e.mode) && (null === t || 0 != (1 & xo.current) ? 0 === Xl && (Xl = 3) : Mc())),
            null !== e.updateQueue && (e.flags |= 4),
            ol(e),
            null);
        case 4:
            return bo(),
            $a(t, e),
            null === t && ei(e.stateNode.containerInfo),
            ol(e),
            null;
        case 10:
            return Ds(e.type._context),
            ol(e),
            null;
        case 19:
            if (Fi(xo),
            null === (s = e.memoizedState))
                return ol(e),
                null;
            if (r = 0 != (128 & e.flags),
            null === (o = s.rendering))
                if (r)
                    sl(s, !1);
                else {
                    if (0 !== Xl || null !== t && 0 != (128 & t.flags))
                        for (t = e.child; null !== t; ) {
                            if (null !== (o = Eo(t))) {
                                for (e.flags |= 128,
                                sl(s, !1),
                                null !== (r = o.updateQueue) && (e.updateQueue = r,
                                e.flags |= 4),
                                e.subtreeFlags = 0,
                                r = n,
                                n = e.child; null !== n; )
                                    t = r,
                                    (s = n).flags &= 14680066,
                                    null === (o = s.alternate) ? (s.childLanes = 0,
                                    s.lanes = t,
                                    s.child = null,
                                    s.subtreeFlags = 0,
                                    s.memoizedProps = null,
                                    s.memoizedState = null,
                                    s.updateQueue = null,
                                    s.dependencies = null,
                                    s.stateNode = null) : (s.childLanes = o.childLanes,
                                    s.lanes = o.lanes,
                                    s.child = o.child,
                                    s.subtreeFlags = 0,
                                    s.deletions = null,
                                    s.memoizedProps = o.memoizedProps,
                                    s.memoizedState = o.memoizedState,
                                    s.updateQueue = o.updateQueue,
                                    s.type = o.type,
                                    t = o.dependencies,
                                    s.dependencies = null === t ? null : {
                                        lanes: t.lanes,
                                        firstContext: t.firstContext
                                    }),
                                    n = n.sibling;
                                return ji(xo, 1 & xo.current | 2),
                                e.child
                            }
                            t = t.sibling
                        }
                    null !== s.tail && ue() > nc && (e.flags |= 128,
                    r = !0,
                    sl(s, !1),
                    e.lanes = 4194304)
                }
            else {
                if (!r)
                    if (null !== (t = Eo(o))) {
                        if (e.flags |= 128,
                        r = !0,
                        null !== (n = t.updateQueue) && (e.updateQueue = n,
                        e.flags |= 4),
                        sl(s, !0),
                        null === s.tail && "hidden" === s.tailMode && !o.alternate && !ys)
                            return ol(e),
                            null
                    } else
                        2 * ue() - s.renderingStartTime > nc && 1073741824 !== n && (e.flags |= 128,
                        r = !0,
                        sl(s, !1),
                        e.lanes = 4194304);
                s.isBackwards ? (o.sibling = e.child,
                e.child = o) : (null !== (n = s.last) ? n.sibling = o : e.child = o,
                s.last = o)
            }
            return null !== s.tail ? (e = s.tail,
            s.rendering = e,
            s.tail = e.sibling,
            s.renderingStartTime = ue(),
            e.sibling = null,
            n = xo.current,
            ji(xo, r ? 1 & n | 2 : 1 & n),
            e) : (ol(e),
            null);
        case 22:
        case 23:
            return Sc(),
            r = null !== e.memoizedState,
            null !== t && null !== t.memoizedState !== r && (e.flags |= 8192),
            r && 0 != (1 & e.mode) ? 0 != (1073741824 & $l) && (ol(e),
            6 & e.subtreeFlags && (e.flags |= 8192)) : ol(e),
            null;
        case 24:
        case 25:
            return null
        }
        throw Error(b(156, e.tag))
    }
    function ll(t, e) {
        switch (ps(e),
        e.tag) {
        case 1:
            return Hi(e.type) && $i(),
            65536 & (t = e.flags) ? (e.flags = -65537 & t | 128,
            e) : null;
        case 3:
            return bo(),
            Fi(Vi),
            Fi(zi),
            Ao(),
            0 != (65536 & (t = e.flags)) && 0 == (128 & t) ? (e.flags = -65537 & t | 128,
            e) : null;
        case 5:
            return wo(e),
            null;
        case 13:
            if (Fi(xo),
            null !== (t = e.memoizedState) && null !== t.dehydrated) {
                if (null === e.alternate)
                    throw Error(b(340));
                Ts()
            }
            return 65536 & (t = e.flags) ? (e.flags = -65537 & t | 128,
            e) : null;
        case 19:
            return Fi(xo),
            null;
        case 4:
            return bo(),
            null;
        case 10:
            return Ds(e.type._context),
            null;
        case 22:
        case 23:
            return Sc(),
            null;
        default:
            return null
        }
    }
    Ha = function(t, e) {
        for (var n = e.child; null !== n; ) {
            if (5 === n.tag || 6 === n.tag)
                t.appendChild(n.stateNode);
            else if (4 !== n.tag && null !== n.child) {
                n.child.return = n,
                n = n.child;
                continue
            }
            if (n === e)
                break;
            for (; null === n.sibling; ) {
                if (null === n.return || n.return === e)
                    return;
                n = n.return
            }
            n.sibling.return = n.return,
            n = n.sibling
        }
    }
    ,
    $a = function() {}
    ,
    Ga = function(t, e, n, r) {
        var i = t.memoizedProps;
        if (i !== r) {
            t = e.stateNode,
            go(fo.current);
            var s, o = null;
            switch (n) {
            case "input":
                i = lt(t, i),
                r = lt(t, r),
                o = [];
                break;
            case "select":
                i = K({}, i, {
                    value: void 0
                }),
                r = K({}, r, {
                    value: void 0
                }),
                o = [];
                break;
            case "textarea":
                i = gt(t, i),
                r = gt(t, r),
                o = [];
                break;
            default:
                "function" != typeof i.onClick && "function" == typeof r.onClick && (t.onclick = di)
            }
            for (c in Pt(n, r),
            n = null,
            i)
                if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && null != i[c])
                    if ("style" === c) {
                        var a = i[c];
                        for (s in a)
                            a.hasOwnProperty(s) && (n || (n = {}),
                            n[s] = "")
                    } else
                        "dangerouslySetInnerHTML" !== c && "children" !== c && "suppressContentEditableWarning" !== c && "suppressHydrationWarning" !== c && "autoFocus" !== c && (w.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null));
            for (c in r) {
                var l = r[c];
                if (a = null != i ? i[c] : void 0,
                r.hasOwnProperty(c) && l !== a && (null != l || null != a))
                    if ("style" === c)
                        if (a) {
                            for (s in a)
                                !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}),
                                n[s] = "");
                            for (s in l)
                                l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}),
                                n[s] = l[s])
                        } else
                            n || (o || (o = []),
                            o.push(c, n)),
                            n = l;
                    else
                        "dangerouslySetInnerHTML" === c ? (l = l ? l.__html : void 0,
                        a = a ? a.__html : void 0,
                        null != l && a !== l && (o = o || []).push(c, l)) : "children" === c ? "string" != typeof l && "number" != typeof l || (o = o || []).push(c, "" + l) : "suppressContentEditableWarning" !== c && "suppressHydrationWarning" !== c && (w.hasOwnProperty(c) ? (null != l && "onScroll" === c && Zr("scroll", t),
                        o || a === l || (o = [])) : (o = o || []).push(c, l))
            }
            n && (o = o || []).push("style", n);
            var c = o;
            (e.updateQueue = c) && (e.flags |= 4)
        }
    }
    ,
    Xa = function(t, e, n, r) {
        n !== r && (e.flags |= 4)
    }
    ;
    var cl = !1
      , ul = !1
      , hl = "function" == typeof WeakSet ? WeakSet : Set
      , dl = null;
    function fl(t, e) {
        var n = t.ref;
        if (null !== n)
            if ("function" == typeof n)
                try {
                    n(null)
                } catch (n) {
                    Fc(t, e, n)
                }
            else
                n.current = null
    }
    function pl(t, e, n) {
        try {
            n()
        } catch (n) {
            Fc(t, e, n)
        }
    }
    var ml = !1;
    function gl(t, e, n) {
        var r = e.updateQueue;
        if (null !== (r = null !== r ? r.lastEffect : null)) {
            var i = r = r.next;
            do {
                if ((i.tag & t) === t) {
                    var s = i.destroy;
                    i.destroy = void 0,
                    void 0 !== s && pl(e, n, s)
                }
                i = i.next
            } while (i !== r)
        }
    }
    function yl(t, e) {
        if (null !== (e = null !== (e = e.updateQueue) ? e.lastEffect : null)) {
            var n = e = e.next;
            do {
                if ((n.tag & t) === t) {
                    var r = n.create;
                    n.destroy = r()
                }
                n = n.next
            } while (n !== e)
        }
    }
    function bl(t) {
        var e = t.ref;
        if (null !== e) {
            var n = t.stateNode;
            t.tag,
            t = n,
            "function" == typeof e ? e(t) : e.current = t
        }
    }
    function vl(t) {
        var e = t.alternate;
        null !== e && (t.alternate = null,
        vl(e)),
        t.child = null,
        t.deletions = null,
        t.sibling = null,
        5 === t.tag && (null !== (e = t.stateNode) && (delete e[Si],
        delete e[Ti],
        delete e[Ii],
        delete e[Mi],
        delete e[Ci])),
        t.stateNode = null,
        t.return = null,
        t.dependencies = null,
        t.memoizedProps = null,
        t.memoizedState = null,
        t.pendingProps = null,
        t.stateNode = null,
        t.updateQueue = null
    }
    function wl(t) {
        return 5 === t.tag || 3 === t.tag || 4 === t.tag
    }
    function xl(t) {
        t: for (; ; ) {
            for (; null === t.sibling; ) {
                if (null === t.return || wl(t.return))
                    return null;
                t = t.return
            }
            for (t.sibling.return = t.return,
            t = t.sibling; 5 !== t.tag && 6 !== t.tag && 18 !== t.tag; ) {
                if (2 & t.flags)
                    continue t;
                if (null === t.child || 4 === t.tag)
                    continue t;
                t.child.return = t,
                t = t.child
            }
            if (!(2 & t.flags))
                return t.stateNode
        }
    }
    function El(t, e, n) {
        var r = t.tag;
        if (5 === r || 6 === r)
            t = t.stateNode,
            e ? 8 === n.nodeType ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (8 === n.nodeType ? (e = n.parentNode).insertBefore(t, n) : (e = n).appendChild(t),
            null != (n = n._reactRootContainer) || null !== e.onclick || (e.onclick = di));
        else if (4 !== r && null !== (t = t.child))
            for (El(t, e, n),
            t = t.sibling; null !== t; )
                El(t, e, n),
                t = t.sibling
    }
    function _l(t, e, n) {
        var r = t.tag;
        if (5 === r || 6 === r)
            t = t.stateNode,
            e ? n.insertBefore(t, e) : n.appendChild(t);
        else if (4 !== r && null !== (t = t.child))
            for (_l(t, e, n),
            t = t.sibling; null !== t; )
                _l(t, e, n),
                t = t.sibling
    }
    var Al = null
      , Sl = !1;
    function Tl(t, e, n) {
        for (n = n.child; null !== n; )
            kl(t, e, n),
            n = n.sibling
    }
    function kl(t, e, n) {
        if (be && "function" == typeof be.onCommitFiberUnmount)
            try {
                be.onCommitFiberUnmount(ye, n)
            } catch (t) {}
        switch (n.tag) {
        case 5:
            ul || fl(n, e);
        case 6:
            var r = Al
              , i = Sl;
            Al = null,
            Tl(t, e, n),
            Sl = i,
            null !== (Al = r) && (Sl ? (t = Al,
            n = n.stateNode,
            8 === t.nodeType ? t.parentNode.removeChild(n) : t.removeChild(n)) : Al.removeChild(n.stateNode));
            break;
        case 18:
            null !== Al && (Sl ? (t = Al,
            n = n.stateNode,
            8 === t.nodeType ? xi(t.parentNode, n) : 1 === t.nodeType && xi(t, n),
            en(t)) : xi(Al, n.stateNode));
            break;
        case 4:
            r = Al,
            i = Sl,
            Al = n.stateNode.containerInfo,
            Sl = !0,
            Tl(t, e, n),
            Al = r,
            Sl = i;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!ul && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) {
                i = r = r.next;
                do {
                    var s = i
                      , o = s.destroy;
                    s = s.tag,
                    void 0 !== o && (0 != (2 & s) || 0 != (4 & s)) && pl(n, e, o),
                    i = i.next
                } while (i !== r)
            }
            Tl(t, e, n);
            break;
        case 1:
            if (!ul && (fl(n, e),
            "function" == typeof (r = n.stateNode).componentWillUnmount))
                try {
                    r.props = n.memoizedProps,
                    r.state = n.memoizedState,
                    r.componentWillUnmount()
                } catch (t) {
                    Fc(n, e, t)
                }
            Tl(t, e, n);
            break;
        case 21:
            Tl(t, e, n);
            break;
        case 22:
            1 & n.mode ? (ul = (r = ul) || null !== n.memoizedState,
            Tl(t, e, n),
            ul = r) : Tl(t, e, n);
            break;
        default:
            Tl(t, e, n)
        }
    }
    function Il(t) {
        var e = t.updateQueue;
        if (null !== e) {
            t.updateQueue = null;
            var n = t.stateNode;
            null === n && (n = t.stateNode = new hl),
            e.forEach((function(e) {
                var r = Vc.bind(null, t, e);
                n.has(e) || (n.add(e),
                e.then(r, r))
            }
            ))
        }
    }
    function Ml(t, e) {
        var n = e.deletions;
        if (null !== n)
            for (var r = 0; r < n.length; r++) {
                var i = n[r];
                try {
                    var s = t
                      , o = e
                      , a = o;
                    t: for (; null !== a; ) {
                        switch (a.tag) {
                        case 5:
                            Al = a.stateNode,
                            Sl = !1;
                            break t;
                        case 3:
                        case 4:
                            Al = a.stateNode.containerInfo,
                            Sl = !0;
                            break t
                        }
                        a = a.return
                    }
                    if (null === Al)
                        throw Error(b(160));
                    kl(s, o, i),
                    Al = null,
                    Sl = !1;
                    var l = i.alternate;
                    null !== l && (l.return = null),
                    i.return = null
                } catch (t) {
                    Fc(i, e, t)
                }
            }
        if (12854 & e.subtreeFlags)
            for (e = e.child; null !== e; )
                Cl(e, t),
                e = e.sibling
    }
    function Cl(t, e) {
        var n = t.alternate
          , r = t.flags;
        switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (Ml(e, t),
            Pl(t),
            4 & r) {
                try {
                    gl(3, t, t.return),
                    yl(3, t)
                } catch (e) {
                    Fc(t, t.return, e)
                }
                try {
                    gl(5, t, t.return)
                } catch (e) {
                    Fc(t, t.return, e)
                }
            }
            break;
        case 1:
            Ml(e, t),
            Pl(t),
            512 & r && null !== n && fl(n, n.return);
            break;
        case 5:
            if (Ml(e, t),
            Pl(t),
            512 & r && null !== n && fl(n, n.return),
            32 & t.flags) {
                var i = t.stateNode;
                try {
                    St(i, "")
                } catch (e) {
                    Fc(t, t.return, e)
                }
            }
            if (4 & r && null != (i = t.stateNode)) {
                var s = t.memoizedProps
                  , o = null !== n ? n.memoizedProps : s
                  , a = t.type
                  , l = t.updateQueue;
                if (t.updateQueue = null,
                null !== l)
                    try {
                        "input" === a && "radio" === s.type && null != s.name && ut(i, s),
                        Ot(a, o);
                        var c = Ot(a, s);
                        for (o = 0; o < l.length; o += 2) {
                            var u = l[o]
                              , h = l[o + 1];
                            "style" === u ? Mt(i, h) : "dangerouslySetInnerHTML" === u ? At(i, h) : "children" === u ? St(i, h) : O(i, u, h, c)
                        }
                        switch (a) {
                        case "input":
                            ht(i, s);
                            break;
                        case "textarea":
                            bt(i, s);
                            break;
                        case "select":
                            var d = i._wrapperState.wasMultiple;
                            i._wrapperState.wasMultiple = !!s.multiple;
                            var f = s.value;
                            null != f ? mt(i, !!s.multiple, f, !1) : d !== !!s.multiple && (null != s.defaultValue ? mt(i, !!s.multiple, s.defaultValue, !0) : mt(i, !!s.multiple, s.multiple ? [] : "", !1))
                        }
                        i[Ti] = s
                    } catch (e) {
                        Fc(t, t.return, e)
                    }
            }
            break;
        case 6:
            if (Ml(e, t),
            Pl(t),
            4 & r) {
                if (null === t.stateNode)
                    throw Error(b(162));
                i = t.stateNode,
                s = t.memoizedProps;
                try {
                    i.nodeValue = s
                } catch (e) {
                    Fc(t, t.return, e)
                }
            }
            break;
        case 3:
            if (Ml(e, t),
            Pl(t),
            4 & r && null !== n && n.memoizedState.isDehydrated)
                try {
                    en(e.containerInfo)
                } catch (e) {
                    Fc(t, t.return, e)
                }
            break;
        case 4:
        default:
            Ml(e, t),
            Pl(t);
            break;
        case 13:
            Ml(e, t),
            Pl(t),
            8192 & (i = t.child).flags && (s = null !== i.memoizedState,
            i.stateNode.isHidden = s,
            !s || null !== i.alternate && null !== i.alternate.memoizedState || (ec = ue())),
            4 & r && Il(t);
            break;
        case 22:
            if (u = null !== n && null !== n.memoizedState,
            1 & t.mode ? (ul = (c = ul) || u,
            Ml(e, t),
            ul = c) : Ml(e, t),
            Pl(t),
            8192 & r) {
                if (c = null !== t.memoizedState,
                (t.stateNode.isHidden = c) && !u && 0 != (1 & t.mode))
                    for (dl = t,
                    u = t.child; null !== u; ) {
                        for (h = dl = u; null !== dl; ) {
                            switch (f = (d = dl).child,
                            d.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                gl(4, d, d.return);
                                break;
                            case 1:
                                fl(d, d.return);
                                var p = d.stateNode;
                                if ("function" == typeof p.componentWillUnmount) {
                                    r = d,
                                    n = d.return;
                                    try {
                                        e = r,
                                        p.props = e.memoizedProps,
                                        p.state = e.memoizedState,
                                        p.componentWillUnmount()
                                    } catch (t) {
                                        Fc(r, n, t)
                                    }
                                }
                                break;
                            case 5:
                                fl(d, d.return);
                                break;
                            case 22:
                                if (null !== d.memoizedState) {
                                    Dl(h);
                                    continue
                                }
                            }
                            null !== f ? (f.return = d,
                            dl = f) : Dl(h)
                        }
                        u = u.sibling
                    }
                t: for (u = null,
                h = t; ; ) {
                    if (5 === h.tag) {
                        if (null === u) {
                            u = h;
                            try {
                                i = h.stateNode,
                                c ? "function" == typeof (s = i.style).setProperty ? s.setProperty("display", "none", "important") : s.display = "none" : (a = h.stateNode,
                                o = null != (l = h.memoizedProps.style) && l.hasOwnProperty("display") ? l.display : null,
                                a.style.display = It("display", o))
                            } catch (e) {
                                Fc(t, t.return, e)
                            }
                        }
                    } else if (6 === h.tag) {
                        if (null === u)
                            try {
                                h.stateNode.nodeValue = c ? "" : h.memoizedProps
                            } catch (e) {
                                Fc(t, t.return, e)
                            }
                    } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === t) && null !== h.child) {
                        h.child.return = h,
                        h = h.child;
                        continue
                    }
                    if (h === t)
                        break t;
                    for (; null === h.sibling; ) {
                        if (null === h.return || h.return === t)
                            break t;
                        u === h && (u = null),
                        h = h.return
                    }
                    u === h && (u = null),
                    h.sibling.return = h.return,
                    h = h.sibling
                }
            }
            break;
        case 19:
            Ml(e, t),
            Pl(t),
            4 & r && Il(t);
        case 21:
        }
    }
    function Pl(t) {
        var e = t.flags;
        if (2 & e) {
            try {
                t: {
                    for (var n = t.return; null !== n; ) {
                        if (wl(n)) {
                            var r = n;
                            break t
                        }
                        n = n.return
                    }
                    throw Error(b(160))
                }
                switch (r.tag) {
                case 5:
                    var i = r.stateNode;
                    32 & r.flags && (St(i, ""),
                    r.flags &= -33),
                    _l(t, xl(t), i);
                    break;
                case 3:
                case 4:
                    var s = r.stateNode.containerInfo;
                    El(t, xl(t), s);
                    break;
                default:
                    throw Error(b(161))
                }
            } catch (e) {
                Fc(t, t.return, e)
            }
            t.flags &= -3
        }
        4096 & e && (t.flags &= -4097)
    }
    function Ol(t, e, n) {
        dl = t,
        Nl(t, e, n)
    }
    function Nl(t, e, n) {
        for (var r = 0 != (1 & t.mode); null !== dl; ) {
            var i = dl
              , s = i.child;
            if (22 === i.tag && r) {
                var o = null !== i.memoizedState || cl;
                if (!o) {
                    var a = i.alternate
                      , l = null !== a && null !== a.memoizedState || ul;
                    a = cl;
                    var c = ul;
                    if (cl = o,
                    (ul = l) && !c)
                        for (dl = i; null !== dl; )
                            l = (o = dl).child,
                            22 === o.tag && null !== o.memoizedState ? Bl(i) : null !== l ? (l.return = o,
                            dl = l) : Bl(i);
                    for (; null !== s; )
                        dl = s,
                        Nl(s, e, n),
                        s = s.sibling;
                    dl = i,
                    cl = a,
                    ul = c
                }
                Rl(t)
            } else
                0 != (8772 & i.subtreeFlags) && null !== s ? (s.return = i,
                dl = s) : Rl(t)
        }
    }
    function Rl(t) {
        for (; null !== dl; ) {
            var e = dl;
            if (0 != (8772 & e.flags)) {
                var n = e.alternate;
                try {
                    if (0 != (8772 & e.flags))
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            ul || yl(5, e);
                            break;
                        case 1:
                            var r = e.stateNode;
                            if (4 & e.flags && !ul)
                                if (null === n)
                                    r.componentDidMount();
                                else {
                                    var i = e.elementType === e.type ? n.memoizedProps : Ms(e.type, n.memoizedProps);
                                    r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                }
                            var s = e.updateQueue;
                            null !== s && Qs(e, s, r);
                            break;
                        case 3:
                            var o = e.updateQueue;
                            if (null !== o) {
                                if (n = null,
                                null !== e.child)
                                    switch (e.child.tag) {
                                    case 5:
                                    case 1:
                                        n = e.child.stateNode
                                    }
                                Qs(e, o, n)
                            }
                            break;
                        case 5:
                            var a = e.stateNode;
                            if (null === n && 4 & e.flags) {
                                n = a;
                                var l = e.memoizedProps;
                                switch (e.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    l.autoFocus && n.focus();
                                    break;
                                case "img":
                                    l.src && (n.src = l.src)
                                }
                            }
                            break;
                        case 6:
                        case 4:
                        case 12:
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        case 13:
                            if (null === e.memoizedState) {
                                var c = e.alternate;
                                if (null !== c) {
                                    var u = c.memoizedState;
                                    if (null !== u) {
                                        var h = u.dehydrated;
                                        null !== h && en(h)
                                    }
                                }
                            }
                            break;
                        default:
                            throw Error(b(163))
                        }
                    ul || 512 & e.flags && bl(e)
                } catch (t) {
                    Fc(e, e.return, t)
                }
            }
            if (e === t) {
                dl = null;
                break
            }
            if (null !== (n = e.sibling)) {
                n.return = e.return,
                dl = n;
                break
            }
            dl = e.return
        }
    }
    function Dl(t) {
        for (; null !== dl; ) {
            var e = dl;
            if (e === t) {
                dl = null;
                break
            }
            var n = e.sibling;
            if (null !== n) {
                n.return = e.return,
                dl = n;
                break
            }
            dl = e.return
        }
    }
    function Bl(t) {
        for (; null !== dl; ) {
            var e = dl;
            try {
                switch (e.tag) {
                case 0:
                case 11:
                case 15:
                    var n = e.return;
                    try {
                        yl(4, e)
                    } catch (t) {
                        Fc(e, n, t)
                    }
                    break;
                case 1:
                    var r = e.stateNode;
                    if ("function" == typeof r.componentDidMount) {
                        var i = e.return;
                        try {
                            r.componentDidMount()
                        } catch (t) {
                            Fc(e, i, t)
                        }
                    }
                    var s = e.return;
                    try {
                        bl(e)
                    } catch (t) {
                        Fc(e, s, t)
                    }
                    break;
                case 5:
                    var o = e.return;
                    try {
                        bl(e)
                    } catch (t) {
                        Fc(e, o, t)
                    }
                }
            } catch (t) {
                Fc(e, e.return, t)
            }
            if (e === t) {
                dl = null;
                break
            }
            var a = e.sibling;
            if (null !== a) {
                a.return = e.return,
                dl = a;
                break
            }
            dl = e.return
        }
    }
    var Ll, Fl = Math.ceil, jl = N.ReactCurrentDispatcher, Ul = N.ReactCurrentOwner, zl = N.ReactCurrentBatchConfig, Vl = 0, Wl = null, Yl = null, Hl = 0, $l = 0, Gl = Li(0), Xl = 0, ql = null, Kl = 0, Ql = 0, Zl = 0, Jl = null, tc = null, ec = 0, nc = 1 / 0, rc = null, ic = !1, sc = null, oc = null, ac = !1, lc = null, cc = 0, uc = 0, hc = null, dc = -1, fc = 0;
    function pc() {
        return 0 != (6 & Vl) ? ue() : -1 !== dc ? dc : dc = ue()
    }
    function mc(t) {
        return 0 == (1 & t.mode) ? 1 : 0 != (2 & Vl) && 0 !== Hl ? Hl & -Hl : null !== Is.transition ? (0 === fc && (fc = Ie()),
        fc) : 0 !== (t = Oe) ? t : t = void 0 === (t = window.event) ? 16 : un(t.type)
    }
    function gc(t, e, n, r) {
        if (50 < uc)
            throw uc = 0,
            hc = null,
            Error(b(185));
        Ce(t, n, r),
        0 != (2 & Vl) && t === Wl || (t === Wl && (0 == (2 & Vl) && (Ql |= n),
        4 === Xl && xc(t, Hl)),
        yc(t, r),
        1 === n && 0 === Vl && 0 == (1 & e.mode) && (nc = ue() + 500,
        Zi && es()))
    }
    function yc(t, e) {
        var n = t.callbackNode;
        !function(t, e) {
            for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s; ) {
                var o = 31 - ve(s)
                  , a = 1 << o
                  , l = i[o];
                -1 === l ? 0 != (a & n) && 0 == (a & r) || (i[o] = Te(a, e)) : l <= e && (t.expiredLanes |= a),
                s &= ~a
            }
        }(t, e);
        var r = Se(t, t === Wl ? Hl : 0);
        if (0 === r)
            null !== n && ae(n),
            t.callbackNode = null,
            t.callbackPriority = 0;
        else if (e = r & -r,
        t.callbackPriority !== e) {
            if (null != n && ae(n),
            1 === e)
                0 === t.tag ? function(t) {
                    Zi = !0,
                    ts(t)
                }(Ec.bind(null, t)) : ts(Ec.bind(null, t)),
                vi((function() {
                    0 == (6 & Vl) && es()
                }
                )),
                n = null;
            else {
                switch (Ne(r)) {
                case 1:
                    n = de;
                    break;
                case 4:
                    n = fe;
                    break;
                case 16:
                default:
                    n = pe;
                    break;
                case 536870912:
                    n = ge
                }
                n = Wc(n, bc.bind(null, t))
            }
            t.callbackPriority = e,
            t.callbackNode = n
        }
    }
    function bc(t, e) {
        if (dc = -1,
        fc = 0,
        0 != (6 & Vl))
            throw Error(b(327));
        var n = t.callbackNode;
        if (Bc() && t.callbackNode !== n)
            return null;
        var r = Se(t, t === Wl ? Hl : 0);
        if (0 === r)
            return null;
        if (0 != (30 & r) || 0 != (r & t.expiredLanes) || e)
            e = Cc(t, r);
        else {
            e = r;
            var i = Vl;
            Vl |= 2;
            var s = Ic();
            for (Wl === t && Hl === e || (rc = null,
            nc = ue() + 500,
            Tc(t, e)); ; )
                try {
                    Oc();
                    break
                } catch (e) {
                    kc(t, e)
                }
            Rs(),
            jl.current = s,
            Vl = i,
            null !== Yl ? e = 0 : (Wl = null,
            Hl = 0,
            e = Xl)
        }
        if (0 !== e) {
            if (2 === e && (0 !== (i = ke(t)) && (r = i,
            e = vc(t, i))),
            1 === e)
                throw n = ql,
                Tc(t, 0),
                xc(t, r),
                yc(t, ue()),
                n;
            if (6 === e)
                xc(t, r);
            else {
                if (i = t.current.alternate,
                0 == (30 & r) && !function(t) {
                    for (var e = t; ; ) {
                        if (16384 & e.flags) {
                            var n = e.updateQueue;
                            if (null !== n && null !== (n = n.stores))
                                for (var r = 0; r < n.length; r++) {
                                    var i = n[r]
                                      , s = i.getSnapshot;
                                    i = i.value;
                                    try {
                                        if (!wr(s(), i))
                                            return !1
                                    } catch (t) {
                                        return !1
                                    }
                                }
                        }
                        if (n = e.child,
                        16384 & e.subtreeFlags && null !== n)
                            n.return = e,
                            e = n;
                        else {
                            if (e === t)
                                break;
                            for (; null === e.sibling; ) {
                                if (null === e.return || e.return === t)
                                    return !0;
                                e = e.return
                            }
                            e.sibling.return = e.return,
                            e = e.sibling
                        }
                    }
                    return !0
                }(i) && (2 === (e = Cc(t, r)) && (0 !== (s = ke(t)) && (r = s,
                e = vc(t, s))),
                1 === e))
                    throw n = ql,
                    Tc(t, 0),
                    xc(t, r),
                    yc(t, ue()),
                    n;
                switch (t.finishedWork = i,
                t.finishedLanes = r,
                e) {
                case 0:
                case 1:
                    throw Error(b(345));
                case 2:
                case 5:
                    Dc(t, tc, rc);
                    break;
                case 3:
                    if (xc(t, r),
                    (130023424 & r) === r && 10 < (e = ec + 500 - ue())) {
                        if (0 !== Se(t, 0))
                            break;
                        if (((i = t.suspendedLanes) & r) !== r) {
                            pc(),
                            t.pingedLanes |= t.suspendedLanes & i;
                            break
                        }
                        t.timeoutHandle = gi(Dc.bind(null, t, tc, rc), e);
                        break
                    }
                    Dc(t, tc, rc);
                    break;
                case 4:
                    if (xc(t, r),
                    (4194240 & r) === r)
                        break;
                    for (e = t.eventTimes,
                    i = -1; 0 < r; ) {
                        var o = 31 - ve(r);
                        s = 1 << o,
                        (o = e[o]) > i && (i = o),
                        r &= ~s
                    }
                    if (r = i,
                    10 < (r = (120 > (r = ue() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Fl(r / 1960)) - r)) {
                        t.timeoutHandle = gi(Dc.bind(null, t, tc, rc), r);
                        break
                    }
                    Dc(t, tc, rc);
                    break;
                default:
                    throw Error(b(329))
                }
            }
        }
        return yc(t, ue()),
        t.callbackNode === n ? bc.bind(null, t) : null
    }
    function vc(t, e) {
        var n = Jl;
        return t.current.memoizedState.isDehydrated && (Tc(t, e).flags |= 256),
        2 !== (t = Cc(t, e)) && (e = tc,
        tc = n,
        null !== e && wc(e)),
        t
    }
    function wc(t) {
        null === tc ? tc = t : tc.push.apply(tc, t)
    }
    function xc(t, e) {
        for (e &= ~Zl,
        e &= ~Ql,
        t.suspendedLanes |= e,
        t.pingedLanes &= ~e,
        t = t.expirationTimes; 0 < e; ) {
            var n = 31 - ve(e)
              , r = 1 << n;
            t[n] = -1,
            e &= ~r
        }
    }
    function Ec(t) {
        if (0 != (6 & Vl))
            throw Error(b(327));
        Bc();
        var e = Se(t, 0);
        if (0 == (1 & e))
            return yc(t, ue()),
            null;
        var n = Cc(t, e);
        if (0 !== t.tag && 2 === n) {
            var r = ke(t);
            0 !== r && (e = r,
            n = vc(t, r))
        }
        if (1 === n)
            throw n = ql,
            Tc(t, 0),
            xc(t, e),
            yc(t, ue()),
            n;
        if (6 === n)
            throw Error(b(345));
        return t.finishedWork = t.current.alternate,
        t.finishedLanes = e,
        Dc(t, tc, rc),
        yc(t, ue()),
        null
    }
    function _c(t, e) {
        var n = Vl;
        Vl |= 1;
        try {
            return t(e)
        } finally {
            0 === (Vl = n) && (nc = ue() + 500,
            Zi && es())
        }
    }
    function Ac(t) {
        null !== lc && 0 === lc.tag && 0 == (6 & Vl) && Bc();
        var e = Vl;
        Vl |= 1;
        var n = zl.transition
          , r = Oe;
        try {
            if (zl.transition = null,
            Oe = 1,
            t)
                return t()
        } finally {
            Oe = r,
            zl.transition = n,
            0 == (6 & (Vl = e)) && es()
        }
    }
    function Sc() {
        $l = Gl.current,
        Fi(Gl)
    }
    function Tc(t, e) {
        t.finishedWork = null,
        t.finishedLanes = 0;
        var n = t.timeoutHandle;
        if (-1 !== n && (t.timeoutHandle = -1,
        yi(n)),
        null !== Yl)
            for (n = Yl.return; null !== n; ) {
                var r = n;
                switch (ps(r),
                r.tag) {
                case 1:
                    null != (r = r.type.childContextTypes) && $i();
                    break;
                case 3:
                    bo(),
                    Fi(Vi),
                    Fi(zi),
                    Ao();
                    break;
                case 5:
                    wo(r);
                    break;
                case 4:
                    bo();
                    break;
                case 13:
                case 19:
                    Fi(xo);
                    break;
                case 10:
                    Ds(r.type._context);
                    break;
                case 22:
                case 23:
                    Sc()
                }
                n = n.return
            }
        if (Wl = t,
        Yl = t = Gc(t.current, null),
        Hl = $l = e,
        Xl = 0,
        ql = null,
        Zl = Ql = Kl = 0,
        tc = Jl = null,
        null !== js) {
            for (e = 0; e < js.length; e++)
                if (null !== (r = (n = js[e]).interleaved)) {
                    n.interleaved = null;
                    var i = r.next
                      , s = n.pending;
                    if (null !== s) {
                        var o = s.next;
                        s.next = i,
                        r.next = o
                    }
                    n.pending = r
                }
            js = null
        }
        return t
    }
    function kc(t, e) {
        for (; ; ) {
            var n = Yl;
            try {
                if (Rs(),
                So.current = va,
                Po) {
                    for (var r = Io.memoizedState; null !== r; ) {
                        var i = r.queue;
                        null !== i && (i.pending = null),
                        r = r.next
                    }
                    Po = !1
                }
                if (ko = 0,
                Co = Mo = Io = null,
                Oo = !1,
                No = 0,
                Ul.current = null,
                null === n || null === n.return) {
                    Xl = 1,
                    ql = e,
                    Yl = null;
                    break
                }
                t: {
                    var s = t
                      , o = n.return
                      , a = n
                      , l = e;
                    if (e = Hl,
                    a.flags |= 32768,
                    null !== l && "object" == typeof l && "function" == typeof l.then) {
                        var c = l
                          , u = a
                          , h = u.tag;
                        if (0 == (1 & u.mode) && (0 === h || 11 === h || 15 === h)) {
                            var d = u.alternate;
                            d ? (u.updateQueue = d.updateQueue,
                            u.memoizedState = d.memoizedState,
                            u.lanes = d.lanes) : (u.updateQueue = null,
                            u.memoizedState = null)
                        }
                        var f = Ca(o);
                        if (null !== f) {
                            f.flags &= -257,
                            Pa(f, o, a, 0, e),
                            1 & f.mode && Ma(s, c, e),
                            l = c;
                            var p = (e = f).updateQueue;
                            if (null === p) {
                                var m = new Set;
                                m.add(l),
                                e.updateQueue = m
                            } else
                                p.add(l);
                            break t
                        }
                        if (0 == (1 & e)) {
                            Ma(s, c, e),
                            Mc();
                            break t
                        }
                        l = Error(b(426))
                    } else if (ys && 1 & a.mode) {
                        var g = Ca(o);
                        if (null !== g) {
                            0 == (65536 & g.flags) && (g.flags |= 256),
                            Pa(g, o, a, 0, e),
                            ks(_a(l, a));
                            break t
                        }
                    }
                    s = l = _a(l, a),
                    4 !== Xl && (Xl = 2),
                    null === Jl ? Jl = [s] : Jl.push(s),
                    s = o;
                    do {
                        switch (s.tag) {
                        case 3:
                            s.flags |= 65536,
                            e &= -e,
                            s.lanes |= e,
                            qs(s, ka(0, l, e));
                            break t;
                        case 1:
                            a = l;
                            var y = s.type
                              , v = s.stateNode;
                            if (0 == (128 & s.flags) && ("function" == typeof y.getDerivedStateFromError || null !== v && "function" == typeof v.componentDidCatch && (null === oc || !oc.has(v)))) {
                                s.flags |= 65536,
                                e &= -e,
                                s.lanes |= e,
                                qs(s, Ia(s, a, e));
                                break t
                            }
                        }
                        s = s.return
                    } while (null !== s)
                }
                Rc(n)
            } catch (t) {
                e = t,
                Yl === n && null !== n && (Yl = n = n.return);
                continue
            }
            break
        }
    }
    function Ic() {
        var t = jl.current;
        return jl.current = va,
        null === t ? va : t
    }
    function Mc() {
        0 !== Xl && 3 !== Xl && 2 !== Xl || (Xl = 4),
        null === Wl || 0 == (268435455 & Kl) && 0 == (268435455 & Ql) || xc(Wl, Hl)
    }
    function Cc(t, e) {
        var n = Vl;
        Vl |= 2;
        var r = Ic();
        for (Wl === t && Hl === e || (rc = null,
        Tc(t, e)); ; )
            try {
                Pc();
                break
            } catch (e) {
                kc(t, e)
            }
        if (Rs(),
        Vl = n,
        jl.current = r,
        null !== Yl)
            throw Error(b(261));
        return Wl = null,
        Hl = 0,
        Xl
    }
    function Pc() {
        for (; null !== Yl; )
            Nc(Yl)
    }
    function Oc() {
        for (; null !== Yl && !le(); )
            Nc(Yl)
    }
    function Nc(t) {
        var e = Ll(t.alternate, t, $l);
        t.memoizedProps = t.pendingProps,
        null === e ? Rc(t) : Yl = e,
        Ul.current = null
    }
    function Rc(t) {
        var e = t;
        do {
            var n = e.alternate;
            if (t = e.return,
            0 == (32768 & e.flags)) {
                if (null !== (n = al(n, e, $l)))
                    return void (Yl = n)
            } else {
                if (null !== (n = ll(n, e)))
                    return n.flags &= 32767,
                    void (Yl = n);
                if (null === t)
                    return Xl = 6,
                    void (Yl = null);
                t.flags |= 32768,
                t.subtreeFlags = 0,
                t.deletions = null
            }
            if (null !== (e = e.sibling))
                return void (Yl = e);
            Yl = e = t
        } while (null !== e);
        0 === Xl && (Xl = 5)
    }
    function Dc(t, e, n) {
        var r = Oe
          , i = zl.transition;
        try {
            zl.transition = null,
            Oe = 1,
            function(t, e, n, r) {
                do {
                    Bc()
                } while (null !== lc);
                if (0 != (6 & Vl))
                    throw Error(b(327));
                n = t.finishedWork;
                var i = t.finishedLanes;
                if (null === n)
                    return null;
                if (t.finishedWork = null,
                t.finishedLanes = 0,
                n === t.current)
                    throw Error(b(177));
                t.callbackNode = null,
                t.callbackPriority = 0;
                var s = n.lanes | n.childLanes;
                if (function(t, e) {
                    var n = t.pendingLanes & ~e;
                    t.pendingLanes = e,
                    t.suspendedLanes = 0,
                    t.pingedLanes = 0,
                    t.expiredLanes &= e,
                    t.mutableReadLanes &= e,
                    t.entangledLanes &= e,
                    e = t.entanglements;
                    var r = t.eventTimes;
                    for (t = t.expirationTimes; 0 < n; ) {
                        var i = 31 - ve(n)
                          , s = 1 << i;
                        e[i] = 0,
                        r[i] = -1,
                        t[i] = -1,
                        n &= ~s
                    }
                }(t, s),
                t === Wl && (Yl = Wl = null,
                Hl = 0),
                0 == (2064 & n.subtreeFlags) && 0 == (2064 & n.flags) || ac || (ac = !0,
                Wc(pe, (function() {
                    return Bc(),
                    null
                }
                ))),
                s = 0 != (15990 & n.flags),
                0 != (15990 & n.subtreeFlags) || s) {
                    s = zl.transition,
                    zl.transition = null;
                    var o = Oe;
                    Oe = 1;
                    var a = Vl;
                    Vl |= 4,
                    Ul.current = null,
                    function(t, e) {
                        if (fi = rn,
                        Tr(t = Sr())) {
                            if ("selectionStart"in t)
                                var n = {
                                    start: t.selectionStart,
                                    end: t.selectionEnd
                                };
                            else
                                t: {
                                    var r = (n = (n = t.ownerDocument) && n.defaultView || window).getSelection && n.getSelection();
                                    if (r && 0 !== r.rangeCount) {
                                        n = r.anchorNode;
                                        var i = r.anchorOffset
                                          , s = r.focusNode;
                                        r = r.focusOffset;
                                        try {
                                            n.nodeType,
                                            s.nodeType
                                        } catch (t) {
                                            n = null;
                                            break t
                                        }
                                        var o = 0
                                          , a = -1
                                          , l = -1
                                          , c = 0
                                          , u = 0
                                          , h = t
                                          , d = null;
                                        e: for (; ; ) {
                                            for (var f; h !== n || 0 !== i && 3 !== h.nodeType || (a = o + i),
                                            h !== s || 0 !== r && 3 !== h.nodeType || (l = o + r),
                                            3 === h.nodeType && (o += h.nodeValue.length),
                                            null !== (f = h.firstChild); )
                                                d = h,
                                                h = f;
                                            for (; ; ) {
                                                if (h === t)
                                                    break e;
                                                if (d === n && ++c === i && (a = o),
                                                d === s && ++u === r && (l = o),
                                                null !== (f = h.nextSibling))
                                                    break;
                                                d = (h = d).parentNode
                                            }
                                            h = f
                                        }
                                        n = -1 === a || -1 === l ? null : {
                                            start: a,
                                            end: l
                                        }
                                    } else
                                        n = null
                                }
                            n = n || {
                                start: 0,
                                end: 0
                            }
                        } else
                            n = null;
                        for (pi = {
                            focusedElem: t,
                            selectionRange: n
                        },
                        rn = !1,
                        dl = e; null !== dl; )
                            if (t = (e = dl).child,
                            0 != (1028 & e.subtreeFlags) && null !== t)
                                t.return = e,
                                dl = t;
                            else
                                for (; null !== dl; ) {
                                    e = dl;
                                    try {
                                        var p = e.alternate;
                                        if (0 != (1024 & e.flags))
                                            switch (e.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                            case 5:
                                            case 6:
                                            case 4:
                                            case 17:
                                                break;
                                            case 1:
                                                if (null !== p) {
                                                    var m = p.memoizedProps
                                                      , g = p.memoizedState
                                                      , y = e.stateNode
                                                      , v = y.getSnapshotBeforeUpdate(e.elementType === e.type ? m : Ms(e.type, m), g);
                                                    y.__reactInternalSnapshotBeforeUpdate = v
                                                }
                                                break;
                                            case 3:
                                                var w = e.stateNode.containerInfo;
                                                1 === w.nodeType ? w.textContent = "" : 9 === w.nodeType && w.documentElement && w.removeChild(w.documentElement);
                                                break;
                                            default:
                                                throw Error(b(163))
                                            }
                                    } catch (t) {
                                        Fc(e, e.return, t)
                                    }
                                    if (null !== (t = e.sibling)) {
                                        t.return = e.return,
                                        dl = t;
                                        break
                                    }
                                    dl = e.return
                                }
                        p = ml,
                        ml = !1
                    }(t, n),
                    Cl(n, t),
                    kr(pi),
                    rn = !!fi,
                    pi = fi = null,
                    t.current = n,
                    Ol(n, t, i),
                    ce(),
                    Vl = a,
                    Oe = o,
                    zl.transition = s
                } else
                    t.current = n;
                if (ac && (ac = !1,
                lc = t,
                cc = i),
                s = t.pendingLanes,
                0 === s && (oc = null),
                function(t) {
                    if (be && "function" == typeof be.onCommitFiberRoot)
                        try {
                            be.onCommitFiberRoot(ye, t, void 0, 128 == (128 & t.current.flags))
                        } catch (t) {}
                }(n.stateNode),
                yc(t, ue()),
                null !== e)
                    for (r = t.onRecoverableError,
                    n = 0; n < e.length; n++)
                        i = e[n],
                        r(i.value, {
                            componentStack: i.stack,
                            digest: i.digest
                        });
                if (ic)
                    throw ic = !1,
                    t = sc,
                    sc = null,
                    t;
                0 != (1 & cc) && 0 !== t.tag && Bc(),
                s = t.pendingLanes,
                0 != (1 & s) ? t === hc ? uc++ : (uc = 0,
                hc = t) : uc = 0,
                es()
            }(t, e, n, r)
        } finally {
            zl.transition = i,
            Oe = r
        }
        return null
    }
    function Bc() {
        if (null !== lc) {
            var t = Ne(cc)
              , e = zl.transition
              , n = Oe;
            try {
                if (zl.transition = null,
                Oe = 16 > t ? 16 : t,
                null === lc)
                    var r = !1;
                else {
                    if (t = lc,
                    lc = null,
                    cc = 0,
                    0 != (6 & Vl))
                        throw Error(b(331));
                    var i = Vl;
                    for (Vl |= 4,
                    dl = t.current; null !== dl; ) {
                        var s = dl
                          , o = s.child;
                        if (0 != (16 & dl.flags)) {
                            var a = s.deletions;
                            if (null !== a) {
                                for (var l = 0; l < a.length; l++) {
                                    var c = a[l];
                                    for (dl = c; null !== dl; ) {
                                        var u = dl;
                                        switch (u.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            gl(8, u, s)
                                        }
                                        var h = u.child;
                                        if (null !== h)
                                            h.return = u,
                                            dl = h;
                                        else
                                            for (; null !== dl; ) {
                                                var d = (u = dl).sibling
                                                  , f = u.return;
                                                if (vl(u),
                                                u === c) {
                                                    dl = null;
                                                    break
                                                }
                                                if (null !== d) {
                                                    d.return = f,
                                                    dl = d;
                                                    break
                                                }
                                                dl = f
                                            }
                                    }
                                }
                                var p = s.alternate;
                                if (null !== p) {
                                    var m = p.child;
                                    if (null !== m) {
                                        p.child = null;
                                        do {
                                            var g = m.sibling;
                                            m.sibling = null,
                                            m = g
                                        } while (null !== m)
                                    }
                                }
                                dl = s
                            }
                        }
                        if (0 != (2064 & s.subtreeFlags) && null !== o)
                            o.return = s,
                            dl = o;
                        else
                            t: for (; null !== dl; ) {
                                if (0 != (2048 & (s = dl).flags))
                                    switch (s.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        gl(9, s, s.return)
                                    }
                                var y = s.sibling;
                                if (null !== y) {
                                    y.return = s.return,
                                    dl = y;
                                    break t
                                }
                                dl = s.return
                            }
                    }
                    var v = t.current;
                    for (dl = v; null !== dl; ) {
                        var w = (o = dl).child;
                        if (0 != (2064 & o.subtreeFlags) && null !== w)
                            w.return = o,
                            dl = w;
                        else
                            t: for (o = v; null !== dl; ) {
                                if (0 != (2048 & (a = dl).flags))
                                    try {
                                        switch (a.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            yl(9, a)
                                        }
                                    } catch (t) {
                                        Fc(a, a.return, t)
                                    }
                                if (a === o) {
                                    dl = null;
                                    break t
                                }
                                var x = a.sibling;
                                if (null !== x) {
                                    x.return = a.return,
                                    dl = x;
                                    break t
                                }
                                dl = a.return
                            }
                    }
                    if (Vl = i,
                    es(),
                    be && "function" == typeof be.onPostCommitFiberRoot)
                        try {
                            be.onPostCommitFiberRoot(ye, t)
                        } catch (t) {}
                    r = !0
                }
                return r
            } finally {
                Oe = n,
                zl.transition = e
            }
        }
        return !1
    }
    function Lc(t, e, n) {
        t = Gs(t, e = ka(0, e = _a(n, e), 1), 1),
        e = pc(),
        null !== t && (Ce(t, 1, e),
        yc(t, e))
    }
    function Fc(t, e, n) {
        if (3 === t.tag)
            Lc(t, t, n);
        else
            for (; null !== e; ) {
                if (3 === e.tag) {
                    Lc(e, t, n);
                    break
                }
                if (1 === e.tag) {
                    var r = e.stateNode;
                    if ("function" == typeof e.type.getDerivedStateFromError || "function" == typeof r.componentDidCatch && (null === oc || !oc.has(r))) {
                        e = Gs(e, t = Ia(e, t = _a(n, t), 1), 1),
                        t = pc(),
                        null !== e && (Ce(e, 1, t),
                        yc(e, t));
                        break
                    }
                }
                e = e.return
            }
    }
    function jc(t, e, n) {
        var r = t.pingCache;
        null !== r && r.delete(e),
        e = pc(),
        t.pingedLanes |= t.suspendedLanes & n,
        Wl === t && (Hl & n) === n && (4 === Xl || 3 === Xl && (130023424 & Hl) === Hl && 500 > ue() - ec ? Tc(t, 0) : Zl |= n),
        yc(t, e)
    }
    function Uc(t, e) {
        0 === e && (0 == (1 & t.mode) ? e = 1 : (e = _e,
        0 == (130023424 & (_e <<= 1)) && (_e = 4194304)));
        var n = pc();
        null !== (t = Vs(t, e)) && (Ce(t, e, n),
        yc(t, n))
    }
    function zc(t) {
        var e = t.memoizedState
          , n = 0;
        null !== e && (n = e.retryLane),
        Uc(t, n)
    }
    function Vc(t, e) {
        var n = 0;
        switch (t.tag) {
        case 13:
            var r = t.stateNode
              , i = t.memoizedState;
            null !== i && (n = i.retryLane);
            break;
        case 19:
            r = t.stateNode;
            break;
        default:
            throw Error(b(314))
        }
        null !== r && r.delete(e),
        Uc(t, n)
    }
    function Wc(t, e) {
        return oe(t, e)
    }
    function Yc(t, e, n, r) {
        this.tag = t,
        this.key = n,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = e,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = r,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Hc(t, e, n, r) {
        return new Yc(t,e,n,r)
    }
    function $c(t) {
        return !(!(t = t.prototype) || !t.isReactComponent)
    }
    function Gc(t, e) {
        var n = t.alternate;
        return null === n ? ((n = Hc(t.tag, e, t.key, t.mode)).elementType = t.elementType,
        n.type = t.type,
        n.stateNode = t.stateNode,
        n.alternate = t,
        t.alternate = n) : (n.pendingProps = e,
        n.type = t.type,
        n.flags = 0,
        n.subtreeFlags = 0,
        n.deletions = null),
        n.flags = 14680064 & t.flags,
        n.childLanes = t.childLanes,
        n.lanes = t.lanes,
        n.child = t.child,
        n.memoizedProps = t.memoizedProps,
        n.memoizedState = t.memoizedState,
        n.updateQueue = t.updateQueue,
        e = t.dependencies,
        n.dependencies = null === e ? null : {
            lanes: e.lanes,
            firstContext: e.firstContext
        },
        n.sibling = t.sibling,
        n.index = t.index,
        n.ref = t.ref,
        n
    }
    function Xc(t, e, n, r, i, s) {
        var o = 2;
        if (r = t,
        "function" == typeof t)
            $c(t) && (o = 1);
        else if ("string" == typeof t)
            o = 5;
        else
            t: switch (t) {
            case B:
                return qc(n.children, i, s, e);
            case L:
                o = 8,
                i |= 8;
                break;
            case F:
                return (t = Hc(12, n, e, 2 | i)).elementType = F,
                t.lanes = s,
                t;
            case V:
                return (t = Hc(13, n, e, i)).elementType = V,
                t.lanes = s,
                t;
            case W:
                return (t = Hc(19, n, e, i)).elementType = W,
                t.lanes = s,
                t;
            case $:
                return Kc(n, i, s, e);
            default:
                if ("object" == typeof t && null !== t)
                    switch (t.$$typeof) {
                    case j:
                        o = 10;
                        break t;
                    case U:
                        o = 9;
                        break t;
                    case z:
                        o = 11;
                        break t;
                    case Y:
                        o = 14;
                        break t;
                    case H:
                        o = 16,
                        r = null;
                        break t
                    }
                throw Error(b(130, null == t ? t : typeof t, ""))
            }
        return (e = Hc(o, n, e, i)).elementType = t,
        e.type = r,
        e.lanes = s,
        e
    }
    function qc(t, e, n, r) {
        return (t = Hc(7, t, r, e)).lanes = n,
        t
    }
    function Kc(t, e, n, r) {
        return (t = Hc(22, t, r, e)).elementType = $,
        t.lanes = n,
        t.stateNode = {
            isHidden: !1
        },
        t
    }
    function Qc(t, e, n) {
        return (t = Hc(6, t, null, e)).lanes = n,
        t
    }
    function Zc(t, e, n) {
        return (e = Hc(4, null !== t.children ? t.children : [], t.key, e)).lanes = n,
        e.stateNode = {
            containerInfo: t.containerInfo,
            pendingChildren: null,
            implementation: t.implementation
        },
        e
    }
    function Jc(t, e, n, r, i) {
        this.tag = e,
        this.containerInfo = t,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = Me(0),
        this.expirationTimes = Me(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = Me(0),
        this.identifierPrefix = r,
        this.onRecoverableError = i,
        this.mutableSourceEagerHydrationData = null
    }
    function tu(t, e, n, r, i, s, o, a, l) {
        return t = new Jc(t,e,n,a,l),
        1 === e ? (e = 1,
        !0 === s && (e |= 8)) : e = 0,
        s = Hc(3, null, null, e),
        t.current = s,
        s.stateNode = t,
        s.memoizedState = {
            element: r,
            isDehydrated: n,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
        },
        Ys(s),
        t
    }
    function eu(t) {
        if (!t)
            return Ui;
        t: {
            if (ee(t = t._reactInternals) !== t || 1 !== t.tag)
                throw Error(b(170));
            var e = t;
            do {
                switch (e.tag) {
                case 3:
                    e = e.stateNode.context;
                    break t;
                case 1:
                    if (Hi(e.type)) {
                        e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                        break t
                    }
                }
                e = e.return
            } while (null !== e);
            throw Error(b(171))
        }
        if (1 === t.tag) {
            var n = t.type;
            if (Hi(n))
                return Xi(t, n, e)
        }
        return e
    }
    function nu(t, e, n, r, i, s, o, a, l) {
        return (t = tu(n, r, !0, t, 0, s, 0, a, l)).context = eu(null),
        n = t.current,
        (s = $s(r = pc(), i = mc(n))).callback = null != e ? e : null,
        Gs(n, s, i),
        t.current.lanes = i,
        Ce(t, i, r),
        yc(t, r),
        t
    }
    function ru(t, e, n, r) {
        var i = e.current
          , s = pc()
          , o = mc(i);
        return n = eu(n),
        null === e.context ? e.context = n : e.pendingContext = n,
        (e = $s(s, o)).payload = {
            element: t
        },
        null !== (r = void 0 === r ? null : r) && (e.callback = r),
        null !== (t = Gs(i, e, o)) && (gc(t, i, o, s),
        Xs(t, i, o)),
        o
    }
    function iu(t) {
        return (t = t.current).child ? (t.child.tag,
        t.child.stateNode) : null
    }
    function su(t, e) {
        if (null !== (t = t.memoizedState) && null !== t.dehydrated) {
            var n = t.retryLane;
            t.retryLane = 0 !== n && n < e ? n : e
        }
    }
    function ou(t, e) {
        su(t, e),
        (t = t.alternate) && su(t, e)
    }
    Ll = function(t, e, n) {
        if (null !== t)
            if (t.memoizedProps !== e.pendingProps || Vi.current)
                Na = !0;
            else {
                if (0 == (t.lanes & n) && 0 == (128 & e.flags))
                    return Na = !1,
                    function(t, e, n) {
                        switch (e.tag) {
                        case 3:
                            Wa(e),
                            Ts();
                            break;
                        case 5:
                            vo(e);
                            break;
                        case 1:
                            Hi(e.type) && qi(e);
                            break;
                        case 4:
                            yo(e, e.stateNode.containerInfo);
                            break;
                        case 10:
                            var r = e.type._context
                              , i = e.memoizedProps.value;
                            ji(Cs, r._currentValue),
                            r._currentValue = i;
                            break;
                        case 13:
                            if (null !== (r = e.memoizedState))
                                return null !== r.dehydrated ? (ji(xo, 1 & xo.current),
                                e.flags |= 128,
                                null) : 0 != (n & e.child.childLanes) ? Qa(t, e, n) : (ji(xo, 1 & xo.current),
                                null !== (t = il(t, e, n)) ? t.sibling : null);
                            ji(xo, 1 & xo.current);
                            break;
                        case 19:
                            if (r = 0 != (n & e.childLanes),
                            0 != (128 & t.flags)) {
                                if (r)
                                    return nl(t, e, n);
                                e.flags |= 128
                            }
                            if (null !== (i = e.memoizedState) && (i.rendering = null,
                            i.tail = null,
                            i.lastEffect = null),
                            ji(xo, xo.current),
                            r)
                                break;
                            return null;
                        case 22:
                        case 23:
                            return e.lanes = 0,
                            Fa(t, e, n)
                        }
                        return il(t, e, n)
                    }(t, e, n);
                Na = 0 != (131072 & t.flags)
            }
        else
            Na = !1,
            ys && 0 != (1048576 & e.flags) && ds(e, ss, e.index);
        switch (e.lanes = 0,
        e.tag) {
        case 2:
            var r = e.type;
            rl(t, e),
            t = e.pendingProps;
            var i = Yi(e, zi.current);
            Ls(e, n),
            i = Lo(null, e, r, t, i, n);
            var s = Fo();
            return e.flags |= 1,
            "object" == typeof i && null !== i && "function" == typeof i.render && void 0 === i.$$typeof ? (e.tag = 1,
            e.memoizedState = null,
            e.updateQueue = null,
            Hi(r) ? (s = !0,
            qi(e)) : s = !1,
            e.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null,
            Ys(e),
            i.updater = to,
            e.stateNode = i,
            i._reactInternals = e,
            io(e, r, t, n),
            e = Va(null, e, r, !0, s, n)) : (e.tag = 0,
            ys && s && fs(e),
            Ra(null, e, i, n),
            e = e.child),
            e;
        case 16:
            r = e.elementType;
            t: {
                switch (rl(t, e),
                t = e.pendingProps,
                r = (i = r._init)(r._payload),
                e.type = r,
                i = e.tag = function(t) {
                    if ("function" == typeof t)
                        return $c(t) ? 1 : 0;
                    if (null != t) {
                        if ((t = t.$$typeof) === z)
                            return 11;
                        if (t === Y)
                            return 14
                    }
                    return 2
                }(r),
                t = Ms(r, t),
                i) {
                case 0:
                    e = Ua(null, e, r, t, n);
                    break t;
                case 1:
                    e = za(null, e, r, t, n);
                    break t;
                case 11:
                    e = Da(null, e, r, t, n);
                    break t;
                case 14:
                    e = Ba(null, e, r, Ms(r.type, t), n);
                    break t
                }
                throw Error(b(306, r, ""))
            }
            return e;
        case 0:
            return r = e.type,
            i = e.pendingProps,
            Ua(t, e, r, i = e.elementType === r ? i : Ms(r, i), n);
        case 1:
            return r = e.type,
            i = e.pendingProps,
            za(t, e, r, i = e.elementType === r ? i : Ms(r, i), n);
        case 3:
            t: {
                if (Wa(e),
                null === t)
                    throw Error(b(387));
                r = e.pendingProps,
                i = (s = e.memoizedState).element,
                Hs(t, e),
                Ks(e, r, null, n);
                var o = e.memoizedState;
                if (r = o.element,
                s.isDehydrated) {
                    if (s = {
                        element: r,
                        isDehydrated: !1,
                        cache: o.cache,
                        pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                        transitions: o.transitions
                    },
                    e.updateQueue.baseState = s,
                    e.memoizedState = s,
                    256 & e.flags) {
                        e = Ya(t, e, r, n, i = _a(Error(b(423)), e));
                        break t
                    }
                    if (r !== i) {
                        e = Ya(t, e, r, n, i = _a(Error(b(424)), e));
                        break t
                    }
                    for (gs = Ei(e.stateNode.containerInfo.firstChild),
                    ms = e,
                    ys = !0,
                    bs = null,
                    n = uo(e, null, r, n),
                    e.child = n; n; )
                        n.flags = -3 & n.flags | 4096,
                        n = n.sibling
                } else {
                    if (Ts(),
                    r === i) {
                        e = il(t, e, n);
                        break t
                    }
                    Ra(t, e, r, n)
                }
                e = e.child
            }
            return e;
        case 5:
            return vo(e),
            null === t && Es(e),
            r = e.type,
            i = e.pendingProps,
            s = null !== t ? t.memoizedProps : null,
            o = i.children,
            mi(r, i) ? o = null : null !== s && mi(r, s) && (e.flags |= 32),
            ja(t, e),
            Ra(t, e, o, n),
            e.child;
        case 6:
            return null === t && Es(e),
            null;
        case 13:
            return Qa(t, e, n);
        case 4:
            return yo(e, e.stateNode.containerInfo),
            r = e.pendingProps,
            null === t ? e.child = co(e, null, r, n) : Ra(t, e, r, n),
            e.child;
        case 11:
            return r = e.type,
            i = e.pendingProps,
            Da(t, e, r, i = e.elementType === r ? i : Ms(r, i), n);
        case 7:
            return Ra(t, e, e.pendingProps, n),
            e.child;
        case 8:
        case 12:
            return Ra(t, e, e.pendingProps.children, n),
            e.child;
        case 10:
            t: {
                if (r = e.type._context,
                i = e.pendingProps,
                s = e.memoizedProps,
                o = i.value,
                ji(Cs, r._currentValue),
                r._currentValue = o,
                null !== s)
                    if (wr(s.value, o)) {
                        if (s.children === i.children && !Vi.current) {
                            e = il(t, e, n);
                            break t
                        }
                    } else
                        for (null !== (s = e.child) && (s.return = e); null !== s; ) {
                            var a = s.dependencies;
                            if (null !== a) {
                                o = s.child;
                                for (var l = a.firstContext; null !== l; ) {
                                    if (l.context === r) {
                                        if (1 === s.tag) {
                                            (l = $s(-1, n & -n)).tag = 2;
                                            var c = s.updateQueue;
                                            if (null !== c) {
                                                var u = (c = c.shared).pending;
                                                null === u ? l.next = l : (l.next = u.next,
                                                u.next = l),
                                                c.pending = l
                                            }
                                        }
                                        s.lanes |= n,
                                        null !== (l = s.alternate) && (l.lanes |= n),
                                        Bs(s.return, n, e),
                                        a.lanes |= n;
                                        break
                                    }
                                    l = l.next
                                }
                            } else if (10 === s.tag)
                                o = s.type === e.type ? null : s.child;
                            else if (18 === s.tag) {
                                if (null === (o = s.return))
                                    throw Error(b(341));
                                o.lanes |= n,
                                null !== (a = o.alternate) && (a.lanes |= n),
                                Bs(o, n, e),
                                o = s.sibling
                            } else
                                o = s.child;
                            if (null !== o)
                                o.return = s;
                            else
                                for (o = s; null !== o; ) {
                                    if (o === e) {
                                        o = null;
                                        break
                                    }
                                    if (null !== (s = o.sibling)) {
                                        s.return = o.return,
                                        o = s;
                                        break
                                    }
                                    o = o.return
                                }
                            s = o
                        }
                Ra(t, e, i.children, n),
                e = e.child
            }
            return e;
        case 9:
            return i = e.type,
            r = e.pendingProps.children,
            Ls(e, n),
            r = r(i = Fs(i)),
            e.flags |= 1,
            Ra(t, e, r, n),
            e.child;
        case 14:
            return i = Ms(r = e.type, e.pendingProps),
            Ba(t, e, r, i = Ms(r.type, i), n);
        case 15:
            return La(t, e, e.type, e.pendingProps, n);
        case 17:
            return r = e.type,
            i = e.pendingProps,
            i = e.elementType === r ? i : Ms(r, i),
            rl(t, e),
            e.tag = 1,
            Hi(r) ? (t = !0,
            qi(e)) : t = !1,
            Ls(e, n),
            no(e, r, i),
            io(e, r, i, n),
            Va(null, e, r, !0, t, n);
        case 19:
            return nl(t, e, n);
        case 22:
            return Fa(t, e, n)
        }
        throw Error(b(156, e.tag))
    }
    ;
    var au = "function" == typeof reportError ? reportError : function(t) {
        console.error(t)
    }
    ;
    function lu(t) {
        this._internalRoot = t
    }
    function cu(t) {
        this._internalRoot = t
    }
    function uu(t) {
        return !(!t || 1 !== t.nodeType && 9 !== t.nodeType && 11 !== t.nodeType)
    }
    function hu(t) {
        return !(!t || 1 !== t.nodeType && 9 !== t.nodeType && 11 !== t.nodeType && (8 !== t.nodeType || " react-mount-point-unstable " !== t.nodeValue))
    }
    function du() {}
    function fu(t, e, n, r, i) {
        var s = n._reactRootContainer;
        if (s) {
            var o = s;
            if ("function" == typeof i) {
                var a = i;
                i = function() {
                    var t = iu(o);
                    a.call(t)
                }
            }
            ru(e, o, t, i)
        } else
            o = function(t, e, n, r, i) {
                if (i) {
                    if ("function" == typeof r) {
                        var s = r;
                        r = function() {
                            var t = iu(o);
                            s.call(t)
                        }
                    }
                    var o = nu(e, r, t, 0, null, !1, 0, "", du);
                    return t._reactRootContainer = o,
                    t[ki] = o.current,
                    ei(8 === t.nodeType ? t.parentNode : t),
                    Ac(),
                    o
                }
                for (; i = t.lastChild; )
                    t.removeChild(i);
                if ("function" == typeof r) {
                    var a = r;
                    r = function() {
                        var t = iu(l);
                        a.call(t)
                    }
                }
                var l = tu(t, 0, !1, null, 0, !1, 0, "", du);
                return t._reactRootContainer = l,
                t[ki] = l.current,
                ei(8 === t.nodeType ? t.parentNode : t),
                Ac((function() {
                    ru(e, l, n, r)
                }
                )),
                l
            }(n, e, t, i, r);
        return iu(o)
    }
    cu.prototype.render = lu.prototype.render = function(t) {
        var e = this._internalRoot;
        if (null === e)
            throw Error(b(409));
        ru(t, e, null, null)
    }
    ,
    cu.prototype.unmount = lu.prototype.unmount = function() {
        var t = this._internalRoot;
        if (null !== t) {
            this._internalRoot = null;
            var e = t.containerInfo;
            Ac((function() {
                ru(null, t, null, null)
            }
            )),
            e[ki] = null
        }
    }
    ,
    cu.prototype.unstable_scheduleHydration = function(t) {
        if (t) {
            var e = Le();
            t = {
                blockedOn: null,
                target: t,
                priority: e
            };
            for (var n = 0; n < $e.length && 0 !== e && e < $e[n].priority; n++)
                ;
            $e.splice(n, 0, t),
            0 === n && Ke(t)
        }
    }
    ,
    Re = function(t) {
        switch (t.tag) {
        case 3:
            var e = t.stateNode;
            if (e.current.memoizedState.isDehydrated) {
                var n = Ae(e.pendingLanes);
                0 !== n && (Pe(e, 1 | n),
                yc(e, ue()),
                0 == (6 & Vl) && (nc = ue() + 500,
                es()))
            }
            break;
        case 13:
            Ac((function() {
                var e = Vs(t, 1);
                if (null !== e) {
                    var n = pc();
                    gc(e, t, 1, n)
                }
            }
            )),
            ou(t, 1)
        }
    }
    ,
    De = function(t) {
        if (13 === t.tag) {
            var e = Vs(t, 134217728);
            if (null !== e)
                gc(e, t, 134217728, pc());
            ou(t, 134217728)
        }
    }
    ,
    Be = function(t) {
        if (13 === t.tag) {
            var e = mc(t)
              , n = Vs(t, e);
            if (null !== n)
                gc(n, t, e, pc());
            ou(t, e)
        }
    }
    ,
    Le = function() {
        return Oe
    }
    ,
    Fe = function(t, e) {
        var n = Oe;
        try {
            return Oe = t,
            e()
        } finally {
            Oe = n
        }
    }
    ,
    Dt = function(t, e, n) {
        switch (e) {
        case "input":
            if (ht(t, n),
            e = n.name,
            "radio" === n.type && null != e) {
                for (n = t; n.parentNode; )
                    n = n.parentNode;
                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
                e = 0; e < n.length; e++) {
                    var r = n[e];
                    if (r !== t && r.form === t.form) {
                        var i = Ri(r);
                        if (!i)
                            throw Error(b(90));
                        ot(r),
                        ht(r, i)
                    }
                }
            }
            break;
        case "textarea":
            bt(t, n);
            break;
        case "select":
            null != (e = n.value) && mt(t, !!n.multiple, e, !1)
        }
    }
    ,
    zt = _c,
    Vt = Ac;
    var pu = {
        usingClientEntryPoint: !1,
        Events: [Oi, Ni, Ri, jt, Ut, _c]
    }
      , mu = {
        findFiberByHostInstance: Pi,
        bundleType: 0,
        version: "18.2.0",
        rendererPackageName: "react-dom"
    }
      , gu = {
        bundleType: mu.bundleType,
        version: mu.version,
        rendererPackageName: mu.rendererPackageName,
        rendererConfig: mu.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: N.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(t) {
            return null === (t = ie(t)) ? null : t.stateNode
        },
        findFiberByHostInstance: mu.findFiberByHostInstance || function() {
            return null
        }
        ,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
    };
    if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var yu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!yu.isDisabled && yu.supportsFiber)
            try {
                ye = yu.inject(gu),
                be = yu
            } catch (_t) {}
    }
    r = pu,
    i = function(t, e) {
        var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!uu(e))
            throw Error(b(200));
        return function(t, e, n) {
            var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
            return {
                $$typeof: D,
                key: null == r ? null : "" + r,
                children: t,
                containerInfo: e,
                implementation: n
            }
        }(t, e, null, n)
    }
    ,
    s = function(t, e) {
        if (!uu(t))
            throw Error(b(299));
        var n = !1
          , r = ""
          , i = au;
        return null != e && (!0 === e.unstable_strictMode && (n = !0),
        void 0 !== e.identifierPrefix && (r = e.identifierPrefix),
        void 0 !== e.onRecoverableError && (i = e.onRecoverableError)),
        e = tu(t, 1, !1, null, 0, n, 0, r, i),
        t[ki] = e.current,
        ei(8 === t.nodeType ? t.parentNode : t),
        new lu(e)
    }
    ,
    a = function(t) {
        if (null == t)
            return null;
        if (1 === t.nodeType)
            return t;
        var e = t._reactInternals;
        if (void 0 === e) {
            if ("function" == typeof t.render)
                throw Error(b(188));
            throw t = Object.keys(t).join(","),
            Error(b(268, t))
        }
        return t = null === (t = ie(e)) ? null : t.stateNode
    }
    ,
    l = function(t) {
        return Ac(t)
    }
    ,
    c = function(t, e, n) {
        if (!hu(e))
            throw Error(b(200));
        return fu(null, t, e, !0, n)
    }
    ,
    u = function(t, e, n) {
        if (!uu(t))
            throw Error(b(405));
        var r = null != n && n.hydratedSources || null
          , i = !1
          , s = ""
          , o = au;
        if (null != n && (!0 === n.unstable_strictMode && (i = !0),
        void 0 !== n.identifierPrefix && (s = n.identifierPrefix),
        void 0 !== n.onRecoverableError && (o = n.onRecoverableError)),
        e = nu(e, null, t, 1, null != n ? n : null, i, 0, s, o),
        t[ki] = e.current,
        ei(t),
        r)
            for (t = 0; t < r.length; t++)
                i = (i = (n = r[t])._getVersion)(n._source),
                null == e.mutableSourceEagerHydrationData ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i);
        return new cu(e)
    }
    ,
    h = function(t, e, n) {
        if (!hu(e))
            throw Error(b(200));
        return fu(null, t, e, !1, n)
    }
    ,
    d = function(t) {
        if (!hu(t))
            throw Error(b(40));
        return !!t._reactRootContainer && (Ac((function() {
            fu(null, null, t, !1, (function() {
                t._reactRootContainer = null,
                t[ki] = null
            }
            ))
        }
        )),
        !0)
    }
    ,
    f = _c,
    p = function(t, e, n, r) {
        if (!hu(n))
            throw Error(b(200));
        if (null == t || void 0 === t._reactInternals)
            throw Error(b(38));
        return fu(t, e, n, !1, r)
    }
    ,
    m = "18.2.0-next-9e3b772b8-20220608"
}
)),
o.register("fO90s", (function(t, e) {
    t.exports = o("gcnCG")
}
)),
o.register("gcnCG", (function(e, n) {
    /**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
    var r, i, s, o, a, l, c, u, h, d, f, p, m, g, y, b, v, w, x;
    function E(t, e) {
        var n = t.length;
        t.push(e);
        t: for (; 0 < n; ) {
            var r = n - 1 >>> 1
              , i = t[r];
            if (!(0 < S(i, e)))
                break t;
            t[r] = e,
            t[n] = i,
            n = r
        }
    }
    function _(t) {
        return 0 === t.length ? null : t[0]
    }
    function A(t) {
        if (0 === t.length)
            return null;
        var e = t[0]
          , n = t.pop();
        if (n !== e) {
            t[0] = n;
            t: for (var r = 0, i = t.length, s = i >>> 1; r < s; ) {
                var o = 2 * (r + 1) - 1
                  , a = t[o]
                  , l = o + 1
                  , c = t[l];
                if (0 > S(a, n))
                    l < i && 0 > S(c, a) ? (t[r] = c,
                    t[l] = n,
                    r = l) : (t[r] = a,
                    t[o] = n,
                    r = o);
                else {
                    if (!(l < i && 0 > S(c, n)))
                        break t;
                    t[r] = c,
                    t[l] = n,
                    r = l
                }
            }
        }
        return e
    }
    function S(t, e) {
        var n = t.sortIndex - e.sortIndex;
        return 0 !== n ? n : t.id - e.id
    }
    if (t(e.exports, "unstable_now", (()=>r), (t=>r = t)),
    t(e.exports, "unstable_IdlePriority", (()=>i), (t=>i = t)),
    t(e.exports, "unstable_ImmediatePriority", (()=>s), (t=>s = t)),
    t(e.exports, "unstable_LowPriority", (()=>o), (t=>o = t)),
    t(e.exports, "unstable_NormalPriority", (()=>a), (t=>a = t)),
    t(e.exports, "unstable_Profiling", (()=>l), (t=>l = t)),
    t(e.exports, "unstable_UserBlockingPriority", (()=>c), (t=>c = t)),
    t(e.exports, "unstable_cancelCallback", (()=>u), (t=>u = t)),
    t(e.exports, "unstable_continueExecution", (()=>h), (t=>h = t)),
    t(e.exports, "unstable_forceFrameRate", (()=>d), (t=>d = t)),
    t(e.exports, "unstable_getCurrentPriorityLevel", (()=>f), (t=>f = t)),
    t(e.exports, "unstable_getFirstCallbackNode", (()=>p), (t=>p = t)),
    t(e.exports, "unstable_next", (()=>m), (t=>m = t)),
    t(e.exports, "unstable_pauseExecution", (()=>g), (t=>g = t)),
    t(e.exports, "unstable_requestPaint", (()=>y), (t=>y = t)),
    t(e.exports, "unstable_runWithPriority", (()=>b), (t=>b = t)),
    t(e.exports, "unstable_scheduleCallback", (()=>v), (t=>v = t)),
    t(e.exports, "unstable_shouldYield", (()=>w), (t=>w = t)),
    t(e.exports, "unstable_wrapCallback", (()=>x), (t=>x = t)),
    "object" == typeof performance && "function" == typeof performance.now) {
        var T = performance;
        r = function() {
            return T.now()
        }
    } else {
        var k = Date
          , I = k.now();
        r = function() {
            return k.now() - I
        }
    }
    var M = []
      , C = []
      , P = 1
      , O = null
      , N = 3
      , R = !1
      , D = !1
      , B = !1
      , L = "function" == typeof setTimeout ? setTimeout : null
      , F = "function" == typeof clearTimeout ? clearTimeout : null
      , j = "undefined" != typeof setImmediate ? setImmediate : null;
    function U(t) {
        for (var e = _(C); null !== e; ) {
            if (null === e.callback)
                A(C);
            else {
                if (!(e.startTime <= t))
                    break;
                A(C),
                e.sortIndex = e.expirationTime,
                E(M, e)
            }
            e = _(C)
        }
    }
    function z(t) {
        if (B = !1,
        U(t),
        !D)
            if (null !== _(M))
                D = !0,
                J(V);
            else {
                var e = _(C);
                null !== e && tt(z, e.startTime - t)
            }
    }
    function V(t, e) {
        D = !1,
        B && (B = !1,
        F($),
        $ = -1),
        R = !0;
        var n = N;
        try {
            for (U(e),
            O = _(M); null !== O && (!(O.expirationTime > e) || t && !q()); ) {
                var i = O.callback;
                if ("function" == typeof i) {
                    O.callback = null,
                    N = O.priorityLevel;
                    var s = i(O.expirationTime <= e);
                    e = r(),
                    "function" == typeof s ? O.callback = s : O === _(M) && A(M),
                    U(e)
                } else
                    A(M);
                O = _(M)
            }
            if (null !== O)
                var o = !0;
            else {
                var a = _(C);
                null !== a && tt(z, a.startTime - e),
                o = !1
            }
            return o
        } finally {
            O = null,
            N = n,
            R = !1
        }
    }
    "undefined" != typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    var W, Y = !1, H = null, $ = -1, G = 5, X = -1;
    function q() {
        return !(r() - X < G)
    }
    function K() {
        if (null !== H) {
            var t = r();
            X = t;
            var e = !0;
            try {
                e = H(!0, t)
            } finally {
                e ? W() : (Y = !1,
                H = null)
            }
        } else
            Y = !1
    }
    if ("function" == typeof j)
        W = function() {
            j(K)
        }
        ;
    else if ("undefined" != typeof MessageChannel) {
        var Q = new MessageChannel
          , Z = Q.port2;
        Q.port1.onmessage = K,
        W = function() {
            Z.postMessage(null)
        }
    } else
        W = function() {
            L(K, 0)
        }
        ;
    function J(t) {
        H = t,
        Y || (Y = !0,
        W())
    }
    function tt(t, e) {
        $ = L((function() {
            t(r())
        }
        ), e)
    }
    i = 5,
    s = 1,
    o = 4,
    a = 3,
    l = null,
    c = 2,
    u = function(t) {
        t.callback = null
    }
    ,
    h = function() {
        D || R || (D = !0,
        J(V))
    }
    ,
    d = function(t) {
        0 > t || 125 < t ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : G = 0 < t ? Math.floor(1e3 / t) : 5
    }
    ,
    f = function() {
        return N
    }
    ,
    p = function() {
        return _(M)
    }
    ,
    m = function(t) {
        switch (N) {
        case 1:
        case 2:
        case 3:
            var e = 3;
            break;
        default:
            e = N
        }
        var n = N;
        N = e;
        try {
            return t()
        } finally {
            N = n
        }
    }
    ,
    g = function() {}
    ,
    y = function() {}
    ,
    b = function(t, e) {
        switch (t) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            t = 3
        }
        var n = N;
        N = t;
        try {
            return e()
        } finally {
            N = n
        }
    }
    ,
    v = function(t, e, n) {
        var i = r();
        switch ("object" == typeof n && null !== n ? n = "number" == typeof (n = n.delay) && 0 < n ? i + n : i : n = i,
        t) {
        case 1:
            var s = -1;
            break;
        case 2:
            s = 250;
            break;
        case 5:
            s = 1073741823;
            break;
        case 4:
            s = 1e4;
            break;
        default:
            s = 5e3
        }
        return t = {
            id: P++,
            callback: e,
            priorityLevel: t,
            startTime: n,
            expirationTime: s = n + s,
            sortIndex: -1
        },
        n > i ? (t.sortIndex = n,
        E(C, t),
        null === _(M) && t === _(C) && (B ? (F($),
        $ = -1) : B = !0,
        tt(z, n - i))) : (t.sortIndex = s,
        E(M, t),
        D || R || (D = !0,
        J(V))),
        t
    }
    ,
    w = q,
    x = function(t) {
        var e = N;
        return function() {
            var n = N;
            N = e;
            try {
                return t.apply(this, arguments)
            } finally {
                N = n
            }
        }
    }
}
)),
o.register("6ZWSX", (function(e, n) {
    /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
    var r, i, s, a;
    t(e.exports, "Buffer", (()=>r), (t=>r = t)),
    t(e.exports, "SlowBuffer", (()=>i), (t=>i = t)),
    t(e.exports, "INSPECT_MAX_BYTES", (()=>s), (t=>s = t)),
    t(e.exports, "kMaxLength", (()=>a), (t=>a = t));
    var l = o("kuxul")
      , c = o("9NvM5");
    const u = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
    r = f,
    i = function(t) {
        +t != t && (t = 0);
        return f.alloc(+t)
    }
    ,
    s = 50;
    const h = 2147483647;
    function d(t) {
        if (t > h)
            throw new RangeError('The value "' + t + '" is invalid for option "size"');
        const e = new Uint8Array(t);
        return Object.setPrototypeOf(e, f.prototype),
        e
    }
    function f(t, e, n) {
        if ("number" == typeof t) {
            if ("string" == typeof e)
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return g(t)
        }
        return p(t, e, n)
    }
    function p(t, e, n) {
        if ("string" == typeof t)
            return function(t, e) {
                "string" == typeof e && "" !== e || (e = "utf8");
                if (!f.isEncoding(e))
                    throw new TypeError("Unknown encoding: " + e);
                const n = 0 | w(t, e);
                let r = d(n);
                const i = r.write(t, e);
                i !== n && (r = r.slice(0, i));
                return r
            }(t, e);
        if (ArrayBuffer.isView(t))
            return function(t) {
                if (tt(t, Uint8Array)) {
                    const e = new Uint8Array(t);
                    return b(e.buffer, e.byteOffset, e.byteLength)
                }
                return y(t)
            }(t);
        if (null == t)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
        if (tt(t, ArrayBuffer) || t && tt(t.buffer, ArrayBuffer))
            return b(t, e, n);
        if ("undefined" != typeof SharedArrayBuffer && (tt(t, SharedArrayBuffer) || t && tt(t.buffer, SharedArrayBuffer)))
            return b(t, e, n);
        if ("number" == typeof t)
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const r = t.valueOf && t.valueOf();
        if (null != r && r !== t)
            return f.from(r, e, n);
        const i = function(t) {
            if (f.isBuffer(t)) {
                const e = 0 | v(t.length)
                  , n = d(e);
                return 0 === n.length || t.copy(n, 0, 0, e),
                n
            }
            if (void 0 !== t.length)
                return "number" != typeof t.length || et(t.length) ? d(0) : y(t);
            if ("Buffer" === t.type && Array.isArray(t.data))
                return y(t.data)
        }(t);
        if (i)
            return i;
        if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive])
            return f.from(t[Symbol.toPrimitive]("string"), e, n);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
    }
    function m(t) {
        if ("number" != typeof t)
            throw new TypeError('"size" argument must be of type number');
        if (t < 0)
            throw new RangeError('The value "' + t + '" is invalid for option "size"')
    }
    function g(t) {
        return m(t),
        d(t < 0 ? 0 : 0 | v(t))
    }
    function y(t) {
        const e = t.length < 0 ? 0 : 0 | v(t.length)
          , n = d(e);
        for (let r = 0; r < e; r += 1)
            n[r] = 255 & t[r];
        return n
    }
    function b(t, e, n) {
        if (e < 0 || t.byteLength < e)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (t.byteLength < e + (n || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let r;
        return r = void 0 === e && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t,e) : new Uint8Array(t,e,n),
        Object.setPrototypeOf(r, f.prototype),
        r
    }
    function v(t) {
        if (t >= h)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + h.toString(16) + " bytes");
        return 0 | t
    }
    function w(t, e) {
        if (f.isBuffer(t))
            return t.length;
        if (ArrayBuffer.isView(t) || tt(t, ArrayBuffer))
            return t.byteLength;
        if ("string" != typeof t)
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
        const n = t.length
          , r = arguments.length > 2 && !0 === arguments[2];
        if (!r && 0 === n)
            return 0;
        let i = !1;
        for (; ; )
            switch (e) {
            case "ascii":
            case "latin1":
            case "binary":
                return n;
            case "utf8":
            case "utf-8":
                return Q(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return 2 * n;
            case "hex":
                return n >>> 1;
            case "base64":
                return Z(t).length;
            default:
                if (i)
                    return r ? -1 : Q(t).length;
                e = ("" + e).toLowerCase(),
                i = !0
            }
    }
    function x(t, e, n) {
        let r = !1;
        if ((void 0 === e || e < 0) && (e = 0),
        e > this.length)
            return "";
        if ((void 0 === n || n > this.length) && (n = this.length),
        n <= 0)
            return "";
        if ((n >>>= 0) <= (e >>>= 0))
            return "";
        for (t || (t = "utf8"); ; )
            switch (t) {
            case "hex":
                return D(this, e, n);
            case "utf8":
            case "utf-8":
                return P(this, e, n);
            case "ascii":
                return N(this, e, n);
            case "latin1":
            case "binary":
                return R(this, e, n);
            case "base64":
                return C(this, e, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return B(this, e, n);
            default:
                if (r)
                    throw new TypeError("Unknown encoding: " + t);
                t = (t + "").toLowerCase(),
                r = !0
            }
    }
    function E(t, e, n) {
        const r = t[e];
        t[e] = t[n],
        t[n] = r
    }
    function _(t, e, n, r, i) {
        if (0 === t.length)
            return -1;
        if ("string" == typeof n ? (r = n,
        n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648),
        et(n = +n) && (n = i ? 0 : t.length - 1),
        n < 0 && (n = t.length + n),
        n >= t.length) {
            if (i)
                return -1;
            n = t.length - 1
        } else if (n < 0) {
            if (!i)
                return -1;
            n = 0
        }
        if ("string" == typeof e && (e = f.from(e, r)),
        f.isBuffer(e))
            return 0 === e.length ? -1 : A(t, e, n, r, i);
        if ("number" == typeof e)
            return e &= 255,
            "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : A(t, [e], n, r, i);
        throw new TypeError("val must be string, number or Buffer")
    }
    function A(t, e, n, r, i) {
        let s, o = 1, a = t.length, l = e.length;
        if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
            if (t.length < 2 || e.length < 2)
                return -1;
            o = 2,
            a /= 2,
            l /= 2,
            n /= 2
        }
        function c(t, e) {
            return 1 === o ? t[e] : t.readUInt16BE(e * o)
        }
        if (i) {
            let r = -1;
            for (s = n; s < a; s++)
                if (c(t, s) === c(e, -1 === r ? 0 : s - r)) {
                    if (-1 === r && (r = s),
                    s - r + 1 === l)
                        return r * o
                } else
                    -1 !== r && (s -= s - r),
                    r = -1
        } else
            for (n + l > a && (n = a - l),
            s = n; s >= 0; s--) {
                let n = !0;
                for (let r = 0; r < l; r++)
                    if (c(t, s + r) !== c(e, r)) {
                        n = !1;
                        break
                    }
                if (n)
                    return s
            }
        return -1
    }
    function S(t, e, n, r) {
        n = Number(n) || 0;
        const i = t.length - n;
        r ? (r = Number(r)) > i && (r = i) : r = i;
        const s = e.length;
        let o;
        for (r > s / 2 && (r = s / 2),
        o = 0; o < r; ++o) {
            const r = parseInt(e.substr(2 * o, 2), 16);
            if (et(r))
                return o;
            t[n + o] = r
        }
        return o
    }
    function T(t, e, n, r) {
        return J(Q(e, t.length - n), t, n, r)
    }
    function k(t, e, n, r) {
        return J(function(t) {
            const e = [];
            for (let n = 0; n < t.length; ++n)
                e.push(255 & t.charCodeAt(n));
            return e
        }(e), t, n, r)
    }
    function I(t, e, n, r) {
        return J(Z(e), t, n, r)
    }
    function M(t, e, n, r) {
        return J(function(t, e) {
            let n, r, i;
            const s = [];
            for (let o = 0; o < t.length && !((e -= 2) < 0); ++o)
                n = t.charCodeAt(o),
                r = n >> 8,
                i = n % 256,
                s.push(i),
                s.push(r);
            return s
        }(e, t.length - n), t, n, r)
    }
    function C(t, e, n) {
        return 0 === e && n === t.length ? l.fromByteArray(t) : l.fromByteArray(t.slice(e, n))
    }
    function P(t, e, n) {
        n = Math.min(t.length, n);
        const r = [];
        let i = e;
        for (; i < n; ) {
            const e = t[i];
            let s = null
              , o = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
            if (i + o <= n) {
                let n, r, a, l;
                switch (o) {
                case 1:
                    e < 128 && (s = e);
                    break;
                case 2:
                    n = t[i + 1],
                    128 == (192 & n) && (l = (31 & e) << 6 | 63 & n,
                    l > 127 && (s = l));
                    break;
                case 3:
                    n = t[i + 1],
                    r = t[i + 2],
                    128 == (192 & n) && 128 == (192 & r) && (l = (15 & e) << 12 | (63 & n) << 6 | 63 & r,
                    l > 2047 && (l < 55296 || l > 57343) && (s = l));
                    break;
                case 4:
                    n = t[i + 1],
                    r = t[i + 2],
                    a = t[i + 3],
                    128 == (192 & n) && 128 == (192 & r) && 128 == (192 & a) && (l = (15 & e) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & a,
                    l > 65535 && l < 1114112 && (s = l))
                }
            }
            null === s ? (s = 65533,
            o = 1) : s > 65535 && (s -= 65536,
            r.push(s >>> 10 & 1023 | 55296),
            s = 56320 | 1023 & s),
            r.push(s),
            i += o
        }
        return function(t) {
            const e = t.length;
            if (e <= O)
                return String.fromCharCode.apply(String, t);
            let n = ""
              , r = 0;
            for (; r < e; )
                n += String.fromCharCode.apply(String, t.slice(r, r += O));
            return n
        }(r)
    }
    a = h,
    f.TYPED_ARRAY_SUPPORT = function() {
        try {
            const t = new Uint8Array(1)
              , e = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(e, Uint8Array.prototype),
            Object.setPrototypeOf(t, e),
            42 === t.foo()
        } catch (t) {
            return !1
        }
    }(),
    f.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),
    Object.defineProperty(f.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (f.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(f.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (f.isBuffer(this))
                return this.byteOffset
        }
    }),
    f.poolSize = 8192,
    f.from = function(t, e, n) {
        return p(t, e, n)
    }
    ,
    Object.setPrototypeOf(f.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(f, Uint8Array),
    f.alloc = function(t, e, n) {
        return function(t, e, n) {
            return m(t),
            t <= 0 ? d(t) : void 0 !== e ? "string" == typeof n ? d(t).fill(e, n) : d(t).fill(e) : d(t)
        }(t, e, n)
    }
    ,
    f.allocUnsafe = function(t) {
        return g(t)
    }
    ,
    f.allocUnsafeSlow = function(t) {
        return g(t)
    }
    ,
    f.isBuffer = function(t) {
        return null != t && !0 === t._isBuffer && t !== f.prototype
    }
    ,
    f.compare = function(t, e) {
        if (tt(t, Uint8Array) && (t = f.from(t, t.offset, t.byteLength)),
        tt(e, Uint8Array) && (e = f.from(e, e.offset, e.byteLength)),
        !f.isBuffer(t) || !f.isBuffer(e))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (t === e)
            return 0;
        let n = t.length
          , r = e.length;
        for (let i = 0, s = Math.min(n, r); i < s; ++i)
            if (t[i] !== e[i]) {
                n = t[i],
                r = e[i];
                break
            }
        return n < r ? -1 : r < n ? 1 : 0
    }
    ,
    f.isEncoding = function(t) {
        switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    f.concat = function(t, e) {
        if (!Array.isArray(t))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t.length)
            return f.alloc(0);
        let n;
        if (void 0 === e)
            for (e = 0,
            n = 0; n < t.length; ++n)
                e += t[n].length;
        const r = f.allocUnsafe(e);
        let i = 0;
        for (n = 0; n < t.length; ++n) {
            let e = t[n];
            if (tt(e, Uint8Array))
                i + e.length > r.length ? (f.isBuffer(e) || (e = f.from(e)),
                e.copy(r, i)) : Uint8Array.prototype.set.call(r, e, i);
            else {
                if (!f.isBuffer(e))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                e.copy(r, i)
            }
            i += e.length
        }
        return r
    }
    ,
    f.byteLength = w,
    f.prototype._isBuffer = !0,
    f.prototype.swap16 = function() {
        const t = this.length;
        if (t % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let e = 0; e < t; e += 2)
            E(this, e, e + 1);
        return this
    }
    ,
    f.prototype.swap32 = function() {
        const t = this.length;
        if (t % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let e = 0; e < t; e += 4)
            E(this, e, e + 3),
            E(this, e + 1, e + 2);
        return this
    }
    ,
    f.prototype.swap64 = function() {
        const t = this.length;
        if (t % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let e = 0; e < t; e += 8)
            E(this, e, e + 7),
            E(this, e + 1, e + 6),
            E(this, e + 2, e + 5),
            E(this, e + 3, e + 4);
        return this
    }
    ,
    f.prototype.toString = function() {
        const t = this.length;
        return 0 === t ? "" : 0 === arguments.length ? P(this, 0, t) : x.apply(this, arguments)
    }
    ,
    f.prototype.toLocaleString = f.prototype.toString,
    f.prototype.equals = function(t) {
        if (!f.isBuffer(t))
            throw new TypeError("Argument must be a Buffer");
        return this === t || 0 === f.compare(this, t)
    }
    ,
    f.prototype.inspect = function() {
        let t = "";
        const e = s;
        return t = this.toString("hex", 0, e).replace(/(.{2})/g, "$1 ").trim(),
        this.length > e && (t += " ... "),
        "<Buffer " + t + ">"
    }
    ,
    u && (f.prototype[u] = f.prototype.inspect),
    f.prototype.compare = function(t, e, n, r, i) {
        if (tt(t, Uint8Array) && (t = f.from(t, t.offset, t.byteLength)),
        !f.isBuffer(t))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
        if (void 0 === e && (e = 0),
        void 0 === n && (n = t ? t.length : 0),
        void 0 === r && (r = 0),
        void 0 === i && (i = this.length),
        e < 0 || n > t.length || r < 0 || i > this.length)
            throw new RangeError("out of range index");
        if (r >= i && e >= n)
            return 0;
        if (r >= i)
            return -1;
        if (e >= n)
            return 1;
        if (this === t)
            return 0;
        let s = (i >>>= 0) - (r >>>= 0)
          , o = (n >>>= 0) - (e >>>= 0);
        const a = Math.min(s, o)
          , l = this.slice(r, i)
          , c = t.slice(e, n);
        for (let t = 0; t < a; ++t)
            if (l[t] !== c[t]) {
                s = l[t],
                o = c[t];
                break
            }
        return s < o ? -1 : o < s ? 1 : 0
    }
    ,
    f.prototype.includes = function(t, e, n) {
        return -1 !== this.indexOf(t, e, n)
    }
    ,
    f.prototype.indexOf = function(t, e, n) {
        return _(this, t, e, n, !0)
    }
    ,
    f.prototype.lastIndexOf = function(t, e, n) {
        return _(this, t, e, n, !1)
    }
    ,
    f.prototype.write = function(t, e, n, r) {
        if (void 0 === e)
            r = "utf8",
            n = this.length,
            e = 0;
        else if (void 0 === n && "string" == typeof e)
            r = e,
            n = this.length,
            e = 0;
        else {
            if (!isFinite(e))
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            e >>>= 0,
            isFinite(n) ? (n >>>= 0,
            void 0 === r && (r = "utf8")) : (r = n,
            n = void 0)
        }
        const i = this.length - e;
        if ((void 0 === n || n > i) && (n = i),
        t.length > 0 && (n < 0 || e < 0) || e > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        r || (r = "utf8");
        let s = !1;
        for (; ; )
            switch (r) {
            case "hex":
                return S(this, t, e, n);
            case "utf8":
            case "utf-8":
                return T(this, t, e, n);
            case "ascii":
            case "latin1":
            case "binary":
                return k(this, t, e, n);
            case "base64":
                return I(this, t, e, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return M(this, t, e, n);
            default:
                if (s)
                    throw new TypeError("Unknown encoding: " + r);
                r = ("" + r).toLowerCase(),
                s = !0
            }
    }
    ,
    f.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    const O = 4096;
    function N(t, e, n) {
        let r = "";
        n = Math.min(t.length, n);
        for (let i = e; i < n; ++i)
            r += String.fromCharCode(127 & t[i]);
        return r
    }
    function R(t, e, n) {
        let r = "";
        n = Math.min(t.length, n);
        for (let i = e; i < n; ++i)
            r += String.fromCharCode(t[i]);
        return r
    }
    function D(t, e, n) {
        const r = t.length;
        (!e || e < 0) && (e = 0),
        (!n || n < 0 || n > r) && (n = r);
        let i = "";
        for (let r = e; r < n; ++r)
            i += nt[t[r]];
        return i
    }
    function B(t, e, n) {
        const r = t.slice(e, n);
        let i = "";
        for (let t = 0; t < r.length - 1; t += 2)
            i += String.fromCharCode(r[t] + 256 * r[t + 1]);
        return i
    }
    function L(t, e, n) {
        if (t % 1 != 0 || t < 0)
            throw new RangeError("offset is not uint");
        if (t + e > n)
            throw new RangeError("Trying to access beyond buffer length")
    }
    function F(t, e, n, r, i, s) {
        if (!f.isBuffer(t))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > i || e < s)
            throw new RangeError('"value" argument is out of bounds');
        if (n + r > t.length)
            throw new RangeError("Index out of range")
    }
    function j(t, e, n, r, i) {
        G(e, r, i, t, n, 7);
        let s = Number(e & BigInt(4294967295));
        t[n++] = s,
        s >>= 8,
        t[n++] = s,
        s >>= 8,
        t[n++] = s,
        s >>= 8,
        t[n++] = s;
        let o = Number(e >> BigInt(32) & BigInt(4294967295));
        return t[n++] = o,
        o >>= 8,
        t[n++] = o,
        o >>= 8,
        t[n++] = o,
        o >>= 8,
        t[n++] = o,
        n
    }
    function U(t, e, n, r, i) {
        G(e, r, i, t, n, 7);
        let s = Number(e & BigInt(4294967295));
        t[n + 7] = s,
        s >>= 8,
        t[n + 6] = s,
        s >>= 8,
        t[n + 5] = s,
        s >>= 8,
        t[n + 4] = s;
        let o = Number(e >> BigInt(32) & BigInt(4294967295));
        return t[n + 3] = o,
        o >>= 8,
        t[n + 2] = o,
        o >>= 8,
        t[n + 1] = o,
        o >>= 8,
        t[n] = o,
        n + 8
    }
    function z(t, e, n, r, i, s) {
        if (n + r > t.length)
            throw new RangeError("Index out of range");
        if (n < 0)
            throw new RangeError("Index out of range")
    }
    function V(t, e, n, r, i) {
        return e = +e,
        n >>>= 0,
        i || z(t, 0, n, 4),
        c.write(t, e, n, r, 23, 4),
        n + 4
    }
    function W(t, e, n, r, i) {
        return e = +e,
        n >>>= 0,
        i || z(t, 0, n, 8),
        c.write(t, e, n, r, 52, 8),
        n + 8
    }
    f.prototype.slice = function(t, e) {
        const n = this.length;
        (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
        (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n),
        e < t && (e = t);
        const r = this.subarray(t, e);
        return Object.setPrototypeOf(r, f.prototype),
        r
    }
    ,
    f.prototype.readUintLE = f.prototype.readUIntLE = function(t, e, n) {
        t >>>= 0,
        e >>>= 0,
        n || L(t, e, this.length);
        let r = this[t]
          , i = 1
          , s = 0;
        for (; ++s < e && (i *= 256); )
            r += this[t + s] * i;
        return r
    }
    ,
    f.prototype.readUintBE = f.prototype.readUIntBE = function(t, e, n) {
        t >>>= 0,
        e >>>= 0,
        n || L(t, e, this.length);
        let r = this[t + --e]
          , i = 1;
        for (; e > 0 && (i *= 256); )
            r += this[t + --e] * i;
        return r
    }
    ,
    f.prototype.readUint8 = f.prototype.readUInt8 = function(t, e) {
        return t >>>= 0,
        e || L(t, 1, this.length),
        this[t]
    }
    ,
    f.prototype.readUint16LE = f.prototype.readUInt16LE = function(t, e) {
        return t >>>= 0,
        e || L(t, 2, this.length),
        this[t] | this[t + 1] << 8
    }
    ,
    f.prototype.readUint16BE = f.prototype.readUInt16BE = function(t, e) {
        return t >>>= 0,
        e || L(t, 2, this.length),
        this[t] << 8 | this[t + 1]
    }
    ,
    f.prototype.readUint32LE = f.prototype.readUInt32LE = function(t, e) {
        return t >>>= 0,
        e || L(t, 4, this.length),
        (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
    }
    ,
    f.prototype.readUint32BE = f.prototype.readUInt32BE = function(t, e) {
        return t >>>= 0,
        e || L(t, 4, this.length),
        16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
    }
    ,
    f.prototype.readBigUInt64LE = rt((function(t) {
        X(t >>>= 0, "offset");
        const e = this[t]
          , n = this[t + 7];
        void 0 !== e && void 0 !== n || q(t, this.length - 8);
        const r = e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24
          , i = this[++t] + 256 * this[++t] + 65536 * this[++t] + n * 2 ** 24;
        return BigInt(r) + (BigInt(i) << BigInt(32))
    }
    )),
    f.prototype.readBigUInt64BE = rt((function(t) {
        X(t >>>= 0, "offset");
        const e = this[t]
          , n = this[t + 7];
        void 0 !== e && void 0 !== n || q(t, this.length - 8);
        const r = e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t]
          , i = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n;
        return (BigInt(r) << BigInt(32)) + BigInt(i)
    }
    )),
    f.prototype.readIntLE = function(t, e, n) {
        t >>>= 0,
        e >>>= 0,
        n || L(t, e, this.length);
        let r = this[t]
          , i = 1
          , s = 0;
        for (; ++s < e && (i *= 256); )
            r += this[t + s] * i;
        return i *= 128,
        r >= i && (r -= Math.pow(2, 8 * e)),
        r
    }
    ,
    f.prototype.readIntBE = function(t, e, n) {
        t >>>= 0,
        e >>>= 0,
        n || L(t, e, this.length);
        let r = e
          , i = 1
          , s = this[t + --r];
        for (; r > 0 && (i *= 256); )
            s += this[t + --r] * i;
        return i *= 128,
        s >= i && (s -= Math.pow(2, 8 * e)),
        s
    }
    ,
    f.prototype.readInt8 = function(t, e) {
        return t >>>= 0,
        e || L(t, 1, this.length),
        128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
    }
    ,
    f.prototype.readInt16LE = function(t, e) {
        t >>>= 0,
        e || L(t, 2, this.length);
        const n = this[t] | this[t + 1] << 8;
        return 32768 & n ? 4294901760 | n : n
    }
    ,
    f.prototype.readInt16BE = function(t, e) {
        t >>>= 0,
        e || L(t, 2, this.length);
        const n = this[t + 1] | this[t] << 8;
        return 32768 & n ? 4294901760 | n : n
    }
    ,
    f.prototype.readInt32LE = function(t, e) {
        return t >>>= 0,
        e || L(t, 4, this.length),
        this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
    }
    ,
    f.prototype.readInt32BE = function(t, e) {
        return t >>>= 0,
        e || L(t, 4, this.length),
        this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
    }
    ,
    f.prototype.readBigInt64LE = rt((function(t) {
        X(t >>>= 0, "offset");
        const e = this[t]
          , n = this[t + 7];
        void 0 !== e && void 0 !== n || q(t, this.length - 8);
        const r = this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (n << 24);
        return (BigInt(r) << BigInt(32)) + BigInt(e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24)
    }
    )),
    f.prototype.readBigInt64BE = rt((function(t) {
        X(t >>>= 0, "offset");
        const e = this[t]
          , n = this[t + 7];
        void 0 !== e && void 0 !== n || q(t, this.length - 8);
        const r = (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
        return (BigInt(r) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n)
    }
    )),
    f.prototype.readFloatLE = function(t, e) {
        return t >>>= 0,
        e || L(t, 4, this.length),
        c.read(this, t, !0, 23, 4)
    }
    ,
    f.prototype.readFloatBE = function(t, e) {
        return t >>>= 0,
        e || L(t, 4, this.length),
        c.read(this, t, !1, 23, 4)
    }
    ,
    f.prototype.readDoubleLE = function(t, e) {
        return t >>>= 0,
        e || L(t, 8, this.length),
        c.read(this, t, !0, 52, 8)
    }
    ,
    f.prototype.readDoubleBE = function(t, e) {
        return t >>>= 0,
        e || L(t, 8, this.length),
        c.read(this, t, !1, 52, 8)
    }
    ,
    f.prototype.writeUintLE = f.prototype.writeUIntLE = function(t, e, n, r) {
        if (t = +t,
        e >>>= 0,
        n >>>= 0,
        !r) {
            F(this, t, e, n, Math.pow(2, 8 * n) - 1, 0)
        }
        let i = 1
          , s = 0;
        for (this[e] = 255 & t; ++s < n && (i *= 256); )
            this[e + s] = t / i & 255;
        return e + n
    }
    ,
    f.prototype.writeUintBE = f.prototype.writeUIntBE = function(t, e, n, r) {
        if (t = +t,
        e >>>= 0,
        n >>>= 0,
        !r) {
            F(this, t, e, n, Math.pow(2, 8 * n) - 1, 0)
        }
        let i = n - 1
          , s = 1;
        for (this[e + i] = 255 & t; --i >= 0 && (s *= 256); )
            this[e + i] = t / s & 255;
        return e + n
    }
    ,
    f.prototype.writeUint8 = f.prototype.writeUInt8 = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 1, 255, 0),
        this[e] = 255 & t,
        e + 1
    }
    ,
    f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 2, 65535, 0),
        this[e] = 255 & t,
        this[e + 1] = t >>> 8,
        e + 2
    }
    ,
    f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 2, 65535, 0),
        this[e] = t >>> 8,
        this[e + 1] = 255 & t,
        e + 2
    }
    ,
    f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 4, 4294967295, 0),
        this[e + 3] = t >>> 24,
        this[e + 2] = t >>> 16,
        this[e + 1] = t >>> 8,
        this[e] = 255 & t,
        e + 4
    }
    ,
    f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 4, 4294967295, 0),
        this[e] = t >>> 24,
        this[e + 1] = t >>> 16,
        this[e + 2] = t >>> 8,
        this[e + 3] = 255 & t,
        e + 4
    }
    ,
    f.prototype.writeBigUInt64LE = rt((function(t, e=0) {
        return j(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"))
    }
    )),
    f.prototype.writeBigUInt64BE = rt((function(t, e=0) {
        return U(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"))
    }
    )),
    f.prototype.writeIntLE = function(t, e, n, r) {
        if (t = +t,
        e >>>= 0,
        !r) {
            const r = Math.pow(2, 8 * n - 1);
            F(this, t, e, n, r - 1, -r)
        }
        let i = 0
          , s = 1
          , o = 0;
        for (this[e] = 255 & t; ++i < n && (s *= 256); )
            t < 0 && 0 === o && 0 !== this[e + i - 1] && (o = 1),
            this[e + i] = (t / s >> 0) - o & 255;
        return e + n
    }
    ,
    f.prototype.writeIntBE = function(t, e, n, r) {
        if (t = +t,
        e >>>= 0,
        !r) {
            const r = Math.pow(2, 8 * n - 1);
            F(this, t, e, n, r - 1, -r)
        }
        let i = n - 1
          , s = 1
          , o = 0;
        for (this[e + i] = 255 & t; --i >= 0 && (s *= 256); )
            t < 0 && 0 === o && 0 !== this[e + i + 1] && (o = 1),
            this[e + i] = (t / s >> 0) - o & 255;
        return e + n
    }
    ,
    f.prototype.writeInt8 = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 1, 127, -128),
        t < 0 && (t = 255 + t + 1),
        this[e] = 255 & t,
        e + 1
    }
    ,
    f.prototype.writeInt16LE = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 2, 32767, -32768),
        this[e] = 255 & t,
        this[e + 1] = t >>> 8,
        e + 2
    }
    ,
    f.prototype.writeInt16BE = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 2, 32767, -32768),
        this[e] = t >>> 8,
        this[e + 1] = 255 & t,
        e + 2
    }
    ,
    f.prototype.writeInt32LE = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 4, 2147483647, -2147483648),
        this[e] = 255 & t,
        this[e + 1] = t >>> 8,
        this[e + 2] = t >>> 16,
        this[e + 3] = t >>> 24,
        e + 4
    }
    ,
    f.prototype.writeInt32BE = function(t, e, n) {
        return t = +t,
        e >>>= 0,
        n || F(this, t, e, 4, 2147483647, -2147483648),
        t < 0 && (t = 4294967295 + t + 1),
        this[e] = t >>> 24,
        this[e + 1] = t >>> 16,
        this[e + 2] = t >>> 8,
        this[e + 3] = 255 & t,
        e + 4
    }
    ,
    f.prototype.writeBigInt64LE = rt((function(t, e=0) {
        return j(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }
    )),
    f.prototype.writeBigInt64BE = rt((function(t, e=0) {
        return U(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }
    )),
    f.prototype.writeFloatLE = function(t, e, n) {
        return V(this, t, e, !0, n)
    }
    ,
    f.prototype.writeFloatBE = function(t, e, n) {
        return V(this, t, e, !1, n)
    }
    ,
    f.prototype.writeDoubleLE = function(t, e, n) {
        return W(this, t, e, !0, n)
    }
    ,
    f.prototype.writeDoubleBE = function(t, e, n) {
        return W(this, t, e, !1, n)
    }
    ,
    f.prototype.copy = function(t, e, n, r) {
        if (!f.isBuffer(t))
            throw new TypeError("argument should be a Buffer");
        if (n || (n = 0),
        r || 0 === r || (r = this.length),
        e >= t.length && (e = t.length),
        e || (e = 0),
        r > 0 && r < n && (r = n),
        r === n)
            return 0;
        if (0 === t.length || 0 === this.length)
            return 0;
        if (e < 0)
            throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length)
            throw new RangeError("Index out of range");
        if (r < 0)
            throw new RangeError("sourceEnd out of bounds");
        r > this.length && (r = this.length),
        t.length - e < r - n && (r = t.length - e + n);
        const i = r - n;
        return this === t && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e, n, r) : Uint8Array.prototype.set.call(t, this.subarray(n, r), e),
        i
    }
    ,
    f.prototype.fill = function(t, e, n, r) {
        if ("string" == typeof t) {
            if ("string" == typeof e ? (r = e,
            e = 0,
            n = this.length) : "string" == typeof n && (r = n,
            n = this.length),
            void 0 !== r && "string" != typeof r)
                throw new TypeError("encoding must be a string");
            if ("string" == typeof r && !f.isEncoding(r))
                throw new TypeError("Unknown encoding: " + r);
            if (1 === t.length) {
                const e = t.charCodeAt(0);
                ("utf8" === r && e < 128 || "latin1" === r) && (t = e)
            }
        } else
            "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t));
        if (e < 0 || this.length < e || this.length < n)
            throw new RangeError("Out of range index");
        if (n <= e)
            return this;
        let i;
        if (e >>>= 0,
        n = void 0 === n ? this.length : n >>> 0,
        t || (t = 0),
        "number" == typeof t)
            for (i = e; i < n; ++i)
                this[i] = t;
        else {
            const s = f.isBuffer(t) ? t : f.from(t, r)
              , o = s.length;
            if (0 === o)
                throw new TypeError('The value "' + t + '" is invalid for argument "value"');
            for (i = 0; i < n - e; ++i)
                this[i + e] = s[i % o]
        }
        return this
    }
    ;
    const Y = {};
    function H(t, e, n) {
        Y[t] = class extends n {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: e.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${t}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return t
            }
            set code(t) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: t,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${t}]: ${this.message}`
            }
        }
    }
    function $(t) {
        let e = ""
          , n = t.length;
        const r = "-" === t[0] ? 1 : 0;
        for (; n >= r + 4; n -= 3)
            e = `_${t.slice(n - 3, n)}${e}`;
        return `${t.slice(0, n)}${e}`
    }
    function G(t, e, n, r, i, s) {
        if (t > n || t < e) {
            const r = "bigint" == typeof e ? "n" : "";
            let i;
            throw i = s > 3 ? 0 === e || e === BigInt(0) ? `>= 0${r} and < 2${r} ** ${8 * (s + 1)}${r}` : `>= -(2${r} ** ${8 * (s + 1) - 1}${r}) and < 2 ** ${8 * (s + 1) - 1}${r}` : `>= ${e}${r} and <= ${n}${r}`,
            new Y.ERR_OUT_OF_RANGE("value",i,t)
        }
        !function(t, e, n) {
            X(e, "offset"),
            void 0 !== t[e] && void 0 !== t[e + n] || q(e, t.length - (n + 1))
        }(r, i, s)
    }
    function X(t, e) {
        if ("number" != typeof t)
            throw new Y.ERR_INVALID_ARG_TYPE(e,"number",t)
    }
    function q(t, e, n) {
        if (Math.floor(t) !== t)
            throw X(t, n),
            new Y.ERR_OUT_OF_RANGE(n || "offset","an integer",t);
        if (e < 0)
            throw new Y.ERR_BUFFER_OUT_OF_BOUNDS;
        throw new Y.ERR_OUT_OF_RANGE(n || "offset",`>= ${n ? 1 : 0} and <= ${e}`,t)
    }
    H("ERR_BUFFER_OUT_OF_BOUNDS", (function(t) {
        return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }
    ), RangeError),
    H("ERR_INVALID_ARG_TYPE", (function(t, e) {
        return `The "${t}" argument must be of type number. Received type ${typeof e}`
    }
    ), TypeError),
    H("ERR_OUT_OF_RANGE", (function(t, e, n) {
        let r = `The value of "${t}" is out of range.`
          , i = n;
        return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = $(String(n)) : "bigint" == typeof n && (i = String(n),
        (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = $(i)),
        i += "n"),
        r += ` It must be ${e}. Received ${i}`,
        r
    }
    ), RangeError);
    const K = /[^+/0-9A-Za-z-_]/g;
    function Q(t, e) {
        let n;
        e = e || 1 / 0;
        const r = t.length;
        let i = null;
        const s = [];
        for (let o = 0; o < r; ++o) {
            if (n = t.charCodeAt(o),
            n > 55295 && n < 57344) {
                if (!i) {
                    if (n > 56319) {
                        (e -= 3) > -1 && s.push(239, 191, 189);
                        continue
                    }
                    if (o + 1 === r) {
                        (e -= 3) > -1 && s.push(239, 191, 189);
                        continue
                    }
                    i = n;
                    continue
                }
                if (n < 56320) {
                    (e -= 3) > -1 && s.push(239, 191, 189),
                    i = n;
                    continue
                }
                n = 65536 + (i - 55296 << 10 | n - 56320)
            } else
                i && (e -= 3) > -1 && s.push(239, 191, 189);
            if (i = null,
            n < 128) {
                if ((e -= 1) < 0)
                    break;
                s.push(n)
            } else if (n < 2048) {
                if ((e -= 2) < 0)
                    break;
                s.push(n >> 6 | 192, 63 & n | 128)
            } else if (n < 65536) {
                if ((e -= 3) < 0)
                    break;
                s.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
            } else {
                if (!(n < 1114112))
                    throw new Error("Invalid code point");
                if ((e -= 4) < 0)
                    break;
                s.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
            }
        }
        return s
    }
    function Z(t) {
        return l.toByteArray(function(t) {
            if ((t = (t = t.split("=")[0]).trim().replace(K, "")).length < 2)
                return "";
            for (; t.length % 4 != 0; )
                t += "=";
            return t
        }(t))
    }
    function J(t, e, n, r) {
        let i;
        for (i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)
            e[i + n] = t[i];
        return i
    }
    function tt(t, e) {
        return t instanceof e || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === e.name
    }
    function et(t) {
        return t != t
    }
    const nt = function() {
        const t = "0123456789abcdef"
          , e = new Array(256);
        for (let n = 0; n < 16; ++n) {
            const r = 16 * n;
            for (let i = 0; i < 16; ++i)
                e[r + i] = t[n] + t[i]
        }
        return e
    }();
    function rt(t) {
        return "undefined" == typeof BigInt ? it : t
    }
    function it() {
        throw new Error("BigInt not supported")
    }
}
)),
o.register("kuxul", (function(e, n) {
    var r, i;
    t(e.exports, "toByteArray", (()=>r), (t=>r = t)),
    t(e.exports, "fromByteArray", (()=>i), (t=>i = t)),
    r = function(t) {
        var e, n, r = h(t), i = r[0], s = r[1], l = new a(function(t, e, n) {
            return 3 * (e + n) / 4 - n
        }(0, i, s)), c = 0, u = s > 0 ? i - 4 : i;
        for (n = 0; n < u; n += 4)
            e = o[t.charCodeAt(n)] << 18 | o[t.charCodeAt(n + 1)] << 12 | o[t.charCodeAt(n + 2)] << 6 | o[t.charCodeAt(n + 3)],
            l[c++] = e >> 16 & 255,
            l[c++] = e >> 8 & 255,
            l[c++] = 255 & e;
        2 === s && (e = o[t.charCodeAt(n)] << 2 | o[t.charCodeAt(n + 1)] >> 4,
        l[c++] = 255 & e);
        1 === s && (e = o[t.charCodeAt(n)] << 10 | o[t.charCodeAt(n + 1)] << 4 | o[t.charCodeAt(n + 2)] >> 2,
        l[c++] = e >> 8 & 255,
        l[c++] = 255 & e);
        return l
    }
    ,
    i = function(t) {
        for (var e, n = t.length, r = n % 3, i = [], o = 16383, a = 0, l = n - r; a < l; a += o)
            i.push(d(t, a, a + o > l ? l : a + o));
        1 === r ? (e = t[n - 1],
        i.push(s[e >> 2] + s[e << 4 & 63] + "==")) : 2 === r && (e = (t[n - 2] << 8) + t[n - 1],
        i.push(s[e >> 10] + s[e >> 4 & 63] + s[e << 2 & 63] + "="));
        return i.join("")
    }
    ;
    for (var s = [], o = [], a = "undefined" != typeof Uint8Array ? Uint8Array : Array, l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = 0, u = l.length; c < u; ++c)
        s[c] = l[c],
        o[l.charCodeAt(c)] = c;
    function h(t) {
        var e = t.length;
        if (e % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
        var n = t.indexOf("=");
        return -1 === n && (n = e),
        [n, n === e ? 0 : 4 - n % 4]
    }
    function d(t, e, n) {
        for (var r, i, o = [], a = e; a < n; a += 3)
            r = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]),
            o.push(s[(i = r) >> 18 & 63] + s[i >> 12 & 63] + s[i >> 6 & 63] + s[63 & i]);
        return o.join("")
    }
    o["-".charCodeAt(0)] = 62,
    o["_".charCodeAt(0)] = 63
}
)),
o.register("9NvM5", (function(e, n) {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var r, i;
    t(e.exports, "read", (()=>r), (t=>r = t)),
    t(e.exports, "write", (()=>i), (t=>i = t)),
    r = function(t, e, n, r, i) {
        var s, o, a = 8 * i - r - 1, l = (1 << a) - 1, c = l >> 1, u = -7, h = n ? i - 1 : 0, d = n ? -1 : 1, f = t[e + h];
        for (h += d,
        s = f & (1 << -u) - 1,
        f >>= -u,
        u += a; u > 0; s = 256 * s + t[e + h],
        h += d,
        u -= 8)
            ;
        for (o = s & (1 << -u) - 1,
        s >>= -u,
        u += r; u > 0; o = 256 * o + t[e + h],
        h += d,
        u -= 8)
            ;
        if (0 === s)
            s = 1 - c;
        else {
            if (s === l)
                return o ? NaN : 1 / 0 * (f ? -1 : 1);
            o += Math.pow(2, r),
            s -= c
        }
        return (f ? -1 : 1) * o * Math.pow(2, s - r)
    }
    ,
    i = function(t, e, n, r, i, s) {
        var o, a, l, c = 8 * s - i - 1, u = (1 << c) - 1, h = u >> 1, d = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : s - 1, p = r ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e),
        isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
        o = u) : (o = Math.floor(Math.log(e) / Math.LN2),
        e * (l = Math.pow(2, -o)) < 1 && (o--,
        l *= 2),
        (e += o + h >= 1 ? d / l : d * Math.pow(2, 1 - h)) * l >= 2 && (o++,
        l /= 2),
        o + h >= u ? (a = 0,
        o = u) : o + h >= 1 ? (a = (e * l - 1) * Math.pow(2, i),
        o += h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i),
        o = 0)); i >= 8; t[n + f] = 255 & a,
        f += p,
        a /= 256,
        i -= 8)
            ;
        for (o = o << i | a,
        c += i; c > 0; t[n + f] = 255 & o,
        f += p,
        o /= 256,
        c -= 8)
            ;
        t[n + f - p] |= 128 * m
    }
}
)),
o.register("gNDby", (function(n, r) {
    t(n.exports, "Struct", (()=>I)),
    t(n.exports, "SOLANA_SCHEMA", (()=>C)),
    t(n.exports, "Enum", (()=>M)),
    t(n.exports, "MAX_SEED_LENGTH", (()=>O)),
    t(n.exports, "PUBLIC_KEY_LENGTH", (()=>N)),
    t(n.exports, "PublicKey", (()=>D)),
    t(n.exports, "Account", (()=>B)),
    t(n.exports, "BPF_LOADER_DEPRECATED_PROGRAM_ID", (()=>L)),
    t(n.exports, "PACKET_DATA_SIZE", (()=>F)),
    t(n.exports, "VERSION_PREFIX_MASK", (()=>j)),
    t(n.exports, "SIGNATURE_LENGTH_IN_BYTES", (()=>U)),
    t(n.exports, "TransactionExpiredBlockheightExceededError", (()=>z)),
    t(n.exports, "TransactionExpiredTimeoutError", (()=>V)),
    t(n.exports, "TransactionExpiredNonceInvalidError", (()=>W)),
    t(n.exports, "MessageAccountKeys", (()=>Y)),
    t(n.exports, "Message", (()=>J)),
    t(n.exports, "MessageV0", (()=>tt)),
    t(n.exports, "VersionedMessage", (()=>et)),
    t(n.exports, "TransactionStatus", (()=>nt)),
    t(n.exports, "TransactionInstruction", (()=>st)),
    t(n.exports, "Transaction", (()=>ot)),
    t(n.exports, "TransactionMessage", (()=>at)),
    t(n.exports, "VersionedTransaction", (()=>lt)),
    t(n.exports, "SYSVAR_CLOCK_PUBKEY", (()=>ct)),
    t(n.exports, "SYSVAR_EPOCH_SCHEDULE_PUBKEY", (()=>ut)),
    t(n.exports, "SYSVAR_INSTRUCTIONS_PUBKEY", (()=>ht)),
    t(n.exports, "SYSVAR_RECENT_BLOCKHASHES_PUBKEY", (()=>dt)),
    t(n.exports, "SYSVAR_RENT_PUBKEY", (()=>ft)),
    t(n.exports, "SYSVAR_REWARDS_PUBKEY", (()=>pt)),
    t(n.exports, "SYSVAR_SLOT_HASHES_PUBKEY", (()=>mt)),
    t(n.exports, "SYSVAR_SLOT_HISTORY_PUBKEY", (()=>gt)),
    t(n.exports, "SYSVAR_STAKE_HISTORY_PUBKEY", (()=>yt)),
    t(n.exports, "sendAndConfirmTransaction", (()=>bt)),
    t(n.exports, "FeeCalculatorLayout", (()=>Et)),
    t(n.exports, "NONCE_ACCOUNT_LENGTH", (()=>At)),
    t(n.exports, "NonceAccount", (()=>St)),
    t(n.exports, "SystemInstruction", (()=>It)),
    t(n.exports, "SYSTEM_INSTRUCTION_LAYOUTS", (()=>Mt)),
    t(n.exports, "SystemProgram", (()=>Ct)),
    t(n.exports, "Loader", (()=>Ot)),
    t(n.exports, "BPF_LOADER_PROGRAM_ID", (()=>Nt)),
    t(n.exports, "BpfLoader", (()=>Rt)),
    t(n.exports, "EpochSchedule", (()=>Ut)),
    t(n.exports, "SendTransactionError", (()=>zt)),
    t(n.exports, "SolanaJSONRPCErrorCode", (()=>Vt)),
    t(n.exports, "SolanaJSONRPCError", (()=>Wt)),
    t(n.exports, "AddressLookupTableAccount", (()=>$t)),
    t(n.exports, "BLOCKHASH_CACHE_TIMEOUT_MS", (()=>Zt)),
    t(n.exports, "Connection", (()=>Fn)),
    t(n.exports, "Keypair", (()=>jn)),
    t(n.exports, "LOOKUP_TABLE_INSTRUCTION_LAYOUTS", (()=>Un)),
    t(n.exports, "AddressLookupTableInstruction", (()=>zn)),
    t(n.exports, "AddressLookupTableProgram", (()=>Vn)),
    t(n.exports, "ComputeBudgetInstruction", (()=>Wn)),
    t(n.exports, "COMPUTE_BUDGET_INSTRUCTION_LAYOUTS", (()=>Yn)),
    t(n.exports, "ComputeBudgetProgram", (()=>Hn)),
    t(n.exports, "Ed25519Program", (()=>Gn)),
    t(n.exports, "Secp256k1Program", (()=>Kn)),
    t(n.exports, "STAKE_CONFIG_ID", (()=>Qn)),
    t(n.exports, "Authorized", (()=>Zn)),
    t(n.exports, "Lockup", (()=>Jn)),
    t(n.exports, "StakeInstruction", (()=>tr)),
    t(n.exports, "STAKE_INSTRUCTION_LAYOUTS", (()=>er)),
    t(n.exports, "StakeProgram", (()=>rr)),
    t(n.exports, "StakeAuthorizationLayout", (()=>nr)),
    t(n.exports, "VoteInit", (()=>ir)),
    t(n.exports, "VoteInstruction", (()=>sr)),
    t(n.exports, "VoteProgram", (()=>lr)),
    t(n.exports, "VoteAuthorizationLayout", (()=>ar)),
    t(n.exports, "VALIDATOR_INFO_KEY", (()=>cr)),
    t(n.exports, "ValidatorInfo", (()=>hr)),
    t(n.exports, "VOTE_PROGRAM_ID", (()=>dr)),
    t(n.exports, "VoteAccount", (()=>pr)),
    t(n.exports, "clusterApiUrl", (()=>vr)),
    t(n.exports, "sendAndConfirmRawTransaction", (()=>wr)),
    t(n.exports, "LAMPORTS_PER_SOL", (()=>xr));
    var i = o("6ZWSX")
      , s = o("3dtER")
      , a = o("9NqJu")
      , l = o("dEXSZ")
      , c = o("4UTkl")
      , u = o("6XnWx")
      , h = o("75BJw")
      , d = o("Q02IV")
      , f = (d = o("Q02IV"),
    o("gyRuj"))
      , p = o("fYtTx")
      , m = o("eB9mD")
      , g = o("9aP4M")
      , y = o("ckEgg")
      , b = o("J0sDk")
      , v = o("70Xw9")
      , w = o("7Rh2L");
    a.utils.sha512Sync = (...t)=>(0,
    s.sha512)(a.utils.concatBytes(...t));
    const x = a.utils.randomPrivateKey
      , E = ()=>{
        const t = a.utils.randomPrivateKey()
          , e = _(t)
          , n = new Uint8Array(64);
        return n.set(t),
        n.set(e, 32),
        {
            publicKey: e,
            secretKey: n
        }
    }
      , _ = a.sync.getPublicKey;
    function A(t) {
        try {
            return a.Point.fromHex(t, !0),
            !0
        } catch {
            return !1
        }
    }
    const S = (t,e)=>a.sync.sign(t, e.slice(0, 32))
      , T = a.sync.verify
      , k = t=>i.Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? i.Buffer.from(t.buffer, t.byteOffset, t.byteLength) : i.Buffer.from(t);
    class I {
        constructor(t) {
            Object.assign(this, t)
        }
        encode() {
            return i.Buffer.from((0,
            h.serialize)(C, this))
        }
        static decode(t) {
            return (0,
            h.deserialize)(C, this, t)
        }
        static decodeUnchecked(t) {
            return (0,
            h.deserializeUnchecked)(C, this, t)
        }
    }
    class M extends I {
        constructor(t) {
            if (super(t),
            this.enum = "",
            1 !== Object.keys(t).length)
                throw new Error("Enum can only take single value");
            Object.keys(t).map((t=>{
                this.enum = t
            }
            ))
        }
    }
    const C = new Map;
    let P;
    const O = 32
      , N = 32;
    let R = 1;
    P = Symbol.toStringTag;
    class D extends I {
        constructor(t) {
            if (super({}),
            this._bn = void 0,
            function(t) {
                return void 0 !== t._bn
            }(t))
                this._bn = t._bn;
            else {
                if ("string" == typeof t) {
                    const n = e(c).decode(t);
                    if (n.length != N)
                        throw new Error("Invalid public key input");
                    this._bn = new (e(l))(n)
                } else
                    this._bn = new (e(l))(t);
                if (this._bn.byteLength() > N)
                    throw new Error("Invalid public key input")
            }
        }
        static unique() {
            const t = new D(R);
            return R += 1,
            new D(t.toBuffer())
        }
        equals(t) {
            return this._bn.eq(t._bn)
        }
        toBase58() {
            return e(c).encode(this.toBytes())
        }
        toJSON() {
            return this.toBase58()
        }
        toBytes() {
            const t = this.toBuffer();
            return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)
        }
        toBuffer() {
            const t = this._bn.toArrayLike(i.Buffer);
            if (t.length === N)
                return t;
            const e = i.Buffer.alloc(32);
            return t.copy(e, 32 - t.length),
            e
        }
        get[P]() {
            return `PublicKey(${this.toString()})`
        }
        toString() {
            return this.toBase58()
        }
        static async createWithSeed(t, e, n) {
            const r = i.Buffer.concat([t.toBuffer(), i.Buffer.from(e), n.toBuffer()])
              , s = (0,
            u.sha256)(r);
            return new D(s)
        }
        static createProgramAddressSync(t, e) {
            let n = i.Buffer.alloc(0);
            t.forEach((function(t) {
                if (t.length > O)
                    throw new TypeError("Max seed length exceeded");
                n = i.Buffer.concat([n, k(t)])
            }
            )),
            n = i.Buffer.concat([n, e.toBuffer(), i.Buffer.from("ProgramDerivedAddress")]);
            const r = (0,
            u.sha256)(n);
            if (A(r))
                throw new Error("Invalid seeds, address must fall off the curve");
            return new D(r)
        }
        static async createProgramAddress(t, e) {
            return this.createProgramAddressSync(t, e)
        }
        static findProgramAddressSync(t, e) {
            let n, r = 255;
            for (; 0 != r; ) {
                try {
                    const s = t.concat(i.Buffer.from([r]));
                    n = this.createProgramAddressSync(s, e)
                } catch (t) {
                    if (t instanceof TypeError)
                        throw t;
                    r--;
                    continue
                }
                return [n, r]
            }
            throw new Error("Unable to find a viable program address nonce")
        }
        static async findProgramAddress(t, e) {
            return this.findProgramAddressSync(t, e)
        }
        static isOnCurve(t) {
            return A(new D(t).toBytes())
        }
    }
    D.default = new D("11111111111111111111111111111111"),
    C.set(D, {
        kind: "struct",
        fields: [["_bn", "u256"]]
    });
    class B {
        constructor(t) {
            if (this._publicKey = void 0,
            this._secretKey = void 0,
            t) {
                const e = k(t);
                if (64 !== t.length)
                    throw new Error("bad secret key size");
                this._publicKey = e.slice(32, 64),
                this._secretKey = e.slice(0, 32)
            } else
                this._secretKey = k(x()),
                this._publicKey = k(_(this._secretKey))
        }
        get publicKey() {
            return new D(this._publicKey)
        }
        get secretKey() {
            return i.Buffer.concat([this._secretKey, this._publicKey], 64)
        }
    }
    const L = new D("BPFLoader1111111111111111111111111111111111")
      , F = 1232
      , j = 127
      , U = 64;
    class z extends Error {
        constructor(t) {
            super(`Signature ${t} has expired: block height exceeded.`),
            this.signature = void 0,
            this.signature = t
        }
    }
    Object.defineProperty(z.prototype, "name", {
        value: "TransactionExpiredBlockheightExceededError"
    });
    class V extends Error {
        constructor(t, e) {
            super(`Transaction was not confirmed in ${e.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`),
            this.signature = void 0,
            this.signature = t
        }
    }
    Object.defineProperty(V.prototype, "name", {
        value: "TransactionExpiredTimeoutError"
    });
    class W extends Error {
        constructor(t) {
            super(`Signature ${t} has expired: the nonce is no longer valid.`),
            this.signature = void 0,
            this.signature = t
        }
    }
    Object.defineProperty(W.prototype, "name", {
        value: "TransactionExpiredNonceInvalidError"
    });
    class Y {
        constructor(t, e) {
            this.staticAccountKeys = void 0,
            this.accountKeysFromLookups = void 0,
            this.staticAccountKeys = t,
            this.accountKeysFromLookups = e
        }
        keySegments() {
            const t = [this.staticAccountKeys];
            return this.accountKeysFromLookups && (t.push(this.accountKeysFromLookups.writable),
            t.push(this.accountKeysFromLookups.readonly)),
            t
        }
        get(t) {
            for (const e of this.keySegments()) {
                if (t < e.length)
                    return e[t];
                t -= e.length
            }
        }
        get length() {
            return this.keySegments().flat().length
        }
        compileInstructions(t) {
            if (this.length > 256)
                throw new Error("Account index overflow encountered during compilation");
            const e = new Map;
            this.keySegments().flat().forEach(((t,n)=>{
                e.set(t.toBase58(), n)
            }
            ));
            const n = t=>{
                const n = e.get(t.toBase58());
                if (void 0 === n)
                    throw new Error("Encountered an unknown instruction account key during compilation");
                return n
            }
            ;
            return t.map((t=>({
                programIdIndex: n(t.programId),
                accountKeyIndexes: t.keys.map((t=>n(t.pubkey))),
                data: t.data
            })))
        }
    }
    const H = (t="publicKey")=>d.blob(32, t)
      , $ = (t="signature")=>d.blob(64, t)
      , G = (t="string")=>{
        const e = d.struct([d.u32("length"), d.u32("lengthPadding"), d.blob(d.offset(d.u32(), -8), "chars")], t)
          , n = e.decode.bind(e)
          , r = e.encode.bind(e)
          , s = e;
        return s.decode = (t,e)=>n(t, e).chars.toString(),
        s.encode = (t,e,n)=>{
            const s = {
                chars: i.Buffer.from(t, "utf8")
            };
            return r(s, e, n)
        }
        ,
        s.alloc = t=>d.u32().span + d.u32().span + i.Buffer.from(t, "utf8").length,
        s
    }
    ;
    function X(t, e) {
        const n = t=>{
            if (t.span >= 0)
                return t.span;
            if ("function" == typeof t.alloc)
                return t.alloc(e[t.property]);
            if ("count"in t && "elementLayout"in t) {
                const r = e[t.property];
                if (Array.isArray(r))
                    return r.length * n(t.elementLayout)
            } else if ("fields"in t)
                return X({
                    layout: t
                }, e[t.property]);
            return 0
        }
        ;
        let r = 0;
        return t.layout.fields.forEach((t=>{
            r += n(t)
        }
        )),
        r
    }
    function q(t) {
        let e = 0
          , n = 0;
        for (; ; ) {
            let r = t.shift();
            if (e |= (127 & r) << 7 * n,
            n += 1,
            0 == (128 & r))
                break
        }
        return e
    }
    function K(t, e) {
        let n = e;
        for (; ; ) {
            let e = 127 & n;
            if (n >>= 7,
            0 == n) {
                t.push(e);
                break
            }
            e |= 128,
            t.push(e)
        }
    }
    function Q(t, e) {
        if (!t)
            throw new Error(e || "Assertion failed")
    }
    class Z {
        constructor(t, e) {
            this.payer = void 0,
            this.keyMetaMap = void 0,
            this.payer = t,
            this.keyMetaMap = e
        }
        static compile(t, e) {
            const n = new Map
              , r = t=>{
                const e = t.toBase58();
                let r = n.get(e);
                return void 0 === r && (r = {
                    isSigner: !1,
                    isWritable: !1,
                    isInvoked: !1
                },
                n.set(e, r)),
                r
            }
              , i = r(e);
            i.isSigner = !0,
            i.isWritable = !0;
            for (const e of t) {
                r(e.programId).isInvoked = !0;
                for (const t of e.keys) {
                    const e = r(t.pubkey);
                    e.isSigner || (e.isSigner = t.isSigner),
                    e.isWritable || (e.isWritable = t.isWritable)
                }
            }
            return new Z(e,n)
        }
        getMessageComponents() {
            const t = [...this.keyMetaMap.entries()];
            Q(t.length <= 256, "Max static account keys length exceeded");
            const e = t.filter((([,t])=>t.isSigner && t.isWritable))
              , n = t.filter((([,t])=>t.isSigner && !t.isWritable))
              , r = t.filter((([,t])=>!t.isSigner && t.isWritable))
              , i = t.filter((([,t])=>!t.isSigner && !t.isWritable))
              , s = {
                numRequiredSignatures: e.length + n.length,
                numReadonlySignedAccounts: n.length,
                numReadonlyUnsignedAccounts: i.length
            };
            {
                Q(e.length > 0, "Expected at least one writable signer key");
                const [t] = e[0];
                Q(t === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
            }
            return [s, [...e.map((([t])=>new D(t))), ...n.map((([t])=>new D(t))), ...r.map((([t])=>new D(t))), ...i.map((([t])=>new D(t)))]]
        }
        extractTableLookup(t) {
            const [e,n] = this.drainKeysFoundInLookupTable(t.state.addresses, (t=>!t.isSigner && !t.isInvoked && t.isWritable))
              , [r,i] = this.drainKeysFoundInLookupTable(t.state.addresses, (t=>!t.isSigner && !t.isInvoked && !t.isWritable));
            if (0 !== e.length || 0 !== r.length)
                return [{
                    accountKey: t.key,
                    writableIndexes: e,
                    readonlyIndexes: r
                }, {
                    writable: n,
                    readonly: i
                }]
        }
        drainKeysFoundInLookupTable(t, e) {
            const n = new Array
              , r = new Array;
            for (const [i,s] of this.keyMetaMap.entries())
                if (e(s)) {
                    const e = new D(i)
                      , s = t.findIndex((t=>t.equals(e)));
                    s >= 0 && (Q(s < 256, "Max lookup table index exceeded"),
                    n.push(s),
                    r.push(e),
                    this.keyMetaMap.delete(i))
                }
            return [n, r]
        }
    }
    class J {
        constructor(t) {
            this.header = void 0,
            this.accountKeys = void 0,
            this.recentBlockhash = void 0,
            this.instructions = void 0,
            this.indexToProgramIds = new Map,
            this.header = t.header,
            this.accountKeys = t.accountKeys.map((t=>new D(t))),
            this.recentBlockhash = t.recentBlockhash,
            this.instructions = t.instructions,
            this.instructions.forEach((t=>this.indexToProgramIds.set(t.programIdIndex, this.accountKeys[t.programIdIndex])))
        }
        get version() {
            return "legacy"
        }
        get staticAccountKeys() {
            return this.accountKeys
        }
        get compiledInstructions() {
            return this.instructions.map((t=>({
                programIdIndex: t.programIdIndex,
                accountKeyIndexes: t.accounts,
                data: e(c).decode(t.data)
            })))
        }
        get addressTableLookups() {
            return []
        }
        getAccountKeys() {
            return new Y(this.staticAccountKeys)
        }
        static compile(t) {
            const n = Z.compile(t.instructions, t.payerKey)
              , [r,i] = n.getMessageComponents()
              , s = new Y(i).compileInstructions(t.instructions).map((t=>({
                programIdIndex: t.programIdIndex,
                accounts: t.accountKeyIndexes,
                data: e(c).encode(t.data)
            })));
            return new J({
                header: r,
                accountKeys: i,
                recentBlockhash: t.recentBlockhash,
                instructions: s
            })
        }
        isAccountSigner(t) {
            return t < this.header.numRequiredSignatures
        }
        isAccountWritable(t) {
            const e = this.header.numRequiredSignatures;
            if (t >= this.header.numRequiredSignatures) {
                return t - e < this.accountKeys.length - e - this.header.numReadonlyUnsignedAccounts
            }
            return t < e - this.header.numReadonlySignedAccounts
        }
        isProgramId(t) {
            return this.indexToProgramIds.has(t)
        }
        programIds() {
            return [...this.indexToProgramIds.values()]
        }
        nonProgramIds() {
            return this.accountKeys.filter(((t,e)=>!this.isProgramId(e)))
        }
        serialize() {
            const t = this.accountKeys.length;
            let n = [];
            K(n, t);
            const r = this.instructions.map((t=>{
                const {accounts: n, programIdIndex: r} = t
                  , s = Array.from(e(c).decode(t.data));
                let o = [];
                K(o, n.length);
                let a = [];
                return K(a, s.length),
                {
                    programIdIndex: r,
                    keyIndicesCount: i.Buffer.from(o),
                    keyIndices: n,
                    dataLength: i.Buffer.from(a),
                    data: s
                }
            }
            ));
            let s = [];
            K(s, r.length);
            let o = i.Buffer.alloc(F);
            i.Buffer.from(s).copy(o);
            let a = s.length;
            r.forEach((t=>{
                const e = d.struct([d.u8("programIdIndex"), d.blob(t.keyIndicesCount.length, "keyIndicesCount"), d.seq(d.u8("keyIndex"), t.keyIndices.length, "keyIndices"), d.blob(t.dataLength.length, "dataLength"), d.seq(d.u8("userdatum"), t.data.length, "data")]).encode(t, o, a);
                a += e
            }
            )),
            o = o.slice(0, a);
            const l = d.struct([d.blob(1, "numRequiredSignatures"), d.blob(1, "numReadonlySignedAccounts"), d.blob(1, "numReadonlyUnsignedAccounts"), d.blob(n.length, "keyCount"), d.seq(H("key"), t, "keys"), H("recentBlockhash")])
              , u = {
                numRequiredSignatures: i.Buffer.from([this.header.numRequiredSignatures]),
                numReadonlySignedAccounts: i.Buffer.from([this.header.numReadonlySignedAccounts]),
                numReadonlyUnsignedAccounts: i.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
                keyCount: i.Buffer.from(n),
                keys: this.accountKeys.map((t=>k(t.toBytes()))),
                recentBlockhash: e(c).decode(this.recentBlockhash)
            };
            let h = i.Buffer.alloc(2048);
            const f = l.encode(u, h);
            return o.copy(h, f),
            h.slice(0, f + o.length)
        }
        static from(t) {
            let n = [...t];
            const r = n.shift();
            if (r !== (r & j))
                throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
            const s = n.shift()
              , o = n.shift()
              , a = q(n);
            let l = [];
            for (let t = 0; t < a; t++) {
                const t = n.slice(0, N);
                n = n.slice(N),
                l.push(new D(i.Buffer.from(t)))
            }
            const u = n.slice(0, N);
            n = n.slice(N);
            const h = q(n);
            let d = [];
            for (let t = 0; t < h; t++) {
                const t = n.shift()
                  , r = q(n)
                  , s = n.slice(0, r);
                n = n.slice(r);
                const o = q(n)
                  , a = n.slice(0, o)
                  , l = e(c).encode(i.Buffer.from(a));
                n = n.slice(o),
                d.push({
                    programIdIndex: t,
                    accounts: s,
                    data: l
                })
            }
            const f = {
                header: {
                    numRequiredSignatures: r,
                    numReadonlySignedAccounts: s,
                    numReadonlyUnsignedAccounts: o
                },
                recentBlockhash: e(c).encode(i.Buffer.from(u)),
                accountKeys: l,
                instructions: d
            };
            return new J(f)
        }
    }
    class tt {
        constructor(t) {
            this.header = void 0,
            this.staticAccountKeys = void 0,
            this.recentBlockhash = void 0,
            this.compiledInstructions = void 0,
            this.addressTableLookups = void 0,
            this.header = t.header,
            this.staticAccountKeys = t.staticAccountKeys,
            this.recentBlockhash = t.recentBlockhash,
            this.compiledInstructions = t.compiledInstructions,
            this.addressTableLookups = t.addressTableLookups
        }
        get version() {
            return 0
        }
        get numAccountKeysFromLookups() {
            let t = 0;
            for (const e of this.addressTableLookups)
                t += e.readonlyIndexes.length + e.writableIndexes.length;
            return t
        }
        getAccountKeys(t) {
            let e;
            if (t && "accountKeysFromLookups"in t && t.accountKeysFromLookups) {
                if (this.numAccountKeysFromLookups != t.accountKeysFromLookups.writable.length + t.accountKeysFromLookups.readonly.length)
                    throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
                e = t.accountKeysFromLookups
            } else if (t && "addressLookupTableAccounts"in t && t.addressLookupTableAccounts)
                e = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
            else if (this.addressTableLookups.length > 0)
                throw new Error("Failed to get account keys because address table lookups were not resolved");
            return new Y(this.staticAccountKeys,e)
        }
        isAccountSigner(t) {
            return t < this.header.numRequiredSignatures
        }
        isAccountWritable(t) {
            const e = this.header.numRequiredSignatures
              , n = this.staticAccountKeys.length;
            if (t >= n) {
                return t - n < this.addressTableLookups.reduce(((t,e)=>t + e.writableIndexes.length), 0)
            }
            if (t >= this.header.numRequiredSignatures) {
                return t - e < n - e - this.header.numReadonlyUnsignedAccounts
            }
            return t < e - this.header.numReadonlySignedAccounts
        }
        resolveAddressTableLookups(t) {
            const e = {
                writable: [],
                readonly: []
            };
            for (const n of this.addressTableLookups) {
                const r = t.find((t=>t.key.equals(n.accountKey)));
                if (!r)
                    throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);
                for (const t of n.writableIndexes) {
                    if (!(t < r.state.addresses.length))
                        throw new Error(`Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`);
                    e.writable.push(r.state.addresses[t])
                }
                for (const t of n.readonlyIndexes) {
                    if (!(t < r.state.addresses.length))
                        throw new Error(`Failed to find address for index ${t} in address lookup table ${n.accountKey.toBase58()}`);
                    e.readonly.push(r.state.addresses[t])
                }
            }
            return e
        }
        static compile(t) {
            const e = Z.compile(t.instructions, t.payerKey)
              , n = new Array
              , r = {
                writable: new Array,
                readonly: new Array
            }
              , i = t.addressLookupTableAccounts || [];
            for (const t of i) {
                const i = e.extractTableLookup(t);
                if (void 0 !== i) {
                    const [t,{writable: e, readonly: s}] = i;
                    n.push(t),
                    r.writable.push(...e),
                    r.readonly.push(...s)
                }
            }
            const [s,o] = e.getMessageComponents()
              , a = new Y(o,r).compileInstructions(t.instructions);
            return new tt({
                header: s,
                staticAccountKeys: o,
                recentBlockhash: t.recentBlockhash,
                compiledInstructions: a,
                addressTableLookups: n
            })
        }
        serialize() {
            const t = Array();
            K(t, this.staticAccountKeys.length);
            const n = this.serializeInstructions()
              , r = Array();
            K(r, this.compiledInstructions.length);
            const i = this.serializeAddressTableLookups()
              , s = Array();
            K(s, this.addressTableLookups.length);
            const o = d.struct([d.u8("prefix"), d.struct([d.u8("numRequiredSignatures"), d.u8("numReadonlySignedAccounts"), d.u8("numReadonlyUnsignedAccounts")], "header"), d.blob(t.length, "staticAccountKeysLength"), d.seq(H(), this.staticAccountKeys.length, "staticAccountKeys"), H("recentBlockhash"), d.blob(r.length, "instructionsLength"), d.blob(n.length, "serializedInstructions"), d.blob(s.length, "addressTableLookupsLength"), d.blob(i.length, "serializedAddressTableLookups")])
              , a = new Uint8Array(F)
              , l = o.encode({
                prefix: 128,
                header: this.header,
                staticAccountKeysLength: new Uint8Array(t),
                staticAccountKeys: this.staticAccountKeys.map((t=>t.toBytes())),
                recentBlockhash: e(c).decode(this.recentBlockhash),
                instructionsLength: new Uint8Array(r),
                serializedInstructions: n,
                addressTableLookupsLength: new Uint8Array(s),
                serializedAddressTableLookups: i
            }, a);
            return a.slice(0, l)
        }
        serializeInstructions() {
            let t = 0;
            const e = new Uint8Array(F);
            for (const n of this.compiledInstructions) {
                const r = Array();
                K(r, n.accountKeyIndexes.length);
                const i = Array();
                K(i, n.data.length);
                t += d.struct([d.u8("programIdIndex"), d.blob(r.length, "encodedAccountKeyIndexesLength"), d.seq(d.u8(), n.accountKeyIndexes.length, "accountKeyIndexes"), d.blob(i.length, "encodedDataLength"), d.blob(n.data.length, "data")]).encode({
                    programIdIndex: n.programIdIndex,
                    encodedAccountKeyIndexesLength: new Uint8Array(r),
                    accountKeyIndexes: n.accountKeyIndexes,
                    encodedDataLength: new Uint8Array(i),
                    data: n.data
                }, e, t)
            }
            return e.slice(0, t)
        }
        serializeAddressTableLookups() {
            let t = 0;
            const e = new Uint8Array(F);
            for (const n of this.addressTableLookups) {
                const r = Array();
                K(r, n.writableIndexes.length);
                const i = Array();
                K(i, n.readonlyIndexes.length);
                t += d.struct([H("accountKey"), d.blob(r.length, "encodedWritableIndexesLength"), d.seq(d.u8(), n.writableIndexes.length, "writableIndexes"), d.blob(i.length, "encodedReadonlyIndexesLength"), d.seq(d.u8(), n.readonlyIndexes.length, "readonlyIndexes")]).encode({
                    accountKey: n.accountKey.toBytes(),
                    encodedWritableIndexesLength: new Uint8Array(r),
                    writableIndexes: n.writableIndexes,
                    encodedReadonlyIndexesLength: new Uint8Array(i),
                    readonlyIndexes: n.readonlyIndexes
                }, e, t)
            }
            return e.slice(0, t)
        }
        static deserialize(t) {
            let n = [...t];
            const r = n.shift()
              , i = r & j;
            Q(r !== i, "Expected versioned message but received legacy message");
            Q(0 === i, `Expected versioned message with version 0 but found version ${i}`);
            const s = {
                numRequiredSignatures: n.shift(),
                numReadonlySignedAccounts: n.shift(),
                numReadonlyUnsignedAccounts: n.shift()
            }
              , o = []
              , a = q(n);
            for (let t = 0; t < a; t++)
                o.push(new D(n.splice(0, N)));
            const l = e(c).encode(n.splice(0, N))
              , u = q(n)
              , h = [];
            for (let t = 0; t < u; t++) {
                const t = n.shift()
                  , e = q(n)
                  , r = n.splice(0, e)
                  , i = q(n)
                  , s = new Uint8Array(n.splice(0, i));
                h.push({
                    programIdIndex: t,
                    accountKeyIndexes: r,
                    data: s
                })
            }
            const d = q(n)
              , f = [];
            for (let t = 0; t < d; t++) {
                const t = new D(n.splice(0, N))
                  , e = q(n)
                  , r = n.splice(0, e)
                  , i = q(n)
                  , s = n.splice(0, i);
                f.push({
                    accountKey: t,
                    writableIndexes: r,
                    readonlyIndexes: s
                })
            }
            return new tt({
                header: s,
                staticAccountKeys: o,
                recentBlockhash: l,
                compiledInstructions: h,
                addressTableLookups: f
            })
        }
    }
    const et = {
        deserializeMessageVersion(t) {
            const e = t[0]
              , n = e & j;
            return n === e ? "legacy" : n
        },
        deserialize: t=>{
            const e = et.deserializeMessageVersion(t);
            if ("legacy" === e)
                return J.from(t);
            if (0 === e)
                return tt.deserialize(t);
            throw new Error(`Transaction message version ${e} deserialization is not supported`)
        }
    };
    let nt;
    var rt;
    (rt = nt || (nt = {}))[rt.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED",
    rt[rt.PROCESSED = 1] = "PROCESSED",
    rt[rt.TIMED_OUT = 2] = "TIMED_OUT",
    rt[rt.NONCE_INVALID = 3] = "NONCE_INVALID";
    const it = i.Buffer.alloc(U).fill(0);
    class st {
        constructor(t) {
            this.keys = void 0,
            this.programId = void 0,
            this.data = i.Buffer.alloc(0),
            this.programId = t.programId,
            this.keys = t.keys,
            t.data && (this.data = t.data)
        }
        toJSON() {
            return {
                keys: this.keys.map((({pubkey: t, isSigner: e, isWritable: n})=>({
                    pubkey: t.toJSON(),
                    isSigner: e,
                    isWritable: n
                }))),
                programId: this.programId.toJSON(),
                data: [...this.data]
            }
        }
    }
    class ot {
        get signature() {
            return this.signatures.length > 0 ? this.signatures[0].signature : null
        }
        constructor(t) {
            if (this.signatures = [],
            this.feePayer = void 0,
            this.instructions = [],
            this.recentBlockhash = void 0,
            this.lastValidBlockHeight = void 0,
            this.nonceInfo = void 0,
            this.minNonceContextSlot = void 0,
            this._message = void 0,
            this._json = void 0,
            t)
                if (t.feePayer && (this.feePayer = t.feePayer),
                t.signatures && (this.signatures = t.signatures),
                Object.prototype.hasOwnProperty.call(t, "nonceInfo")) {
                    const {minContextSlot: e, nonceInfo: n} = t;
                    this.minNonceContextSlot = e,
                    this.nonceInfo = n
                } else if (Object.prototype.hasOwnProperty.call(t, "lastValidBlockHeight")) {
                    const {blockhash: e, lastValidBlockHeight: n} = t;
                    this.recentBlockhash = e,
                    this.lastValidBlockHeight = n
                } else {
                    const {recentBlockhash: e, nonceInfo: n} = t;
                    n && (this.nonceInfo = n),
                    this.recentBlockhash = e
                }
        }
        toJSON() {
            return {
                recentBlockhash: this.recentBlockhash || null,
                feePayer: this.feePayer ? this.feePayer.toJSON() : null,
                nonceInfo: this.nonceInfo ? {
                    nonce: this.nonceInfo.nonce,
                    nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
                } : null,
                instructions: this.instructions.map((t=>t.toJSON())),
                signers: this.signatures.map((({publicKey: t})=>t.toJSON()))
            }
        }
        add(...t) {
            if (0 === t.length)
                throw new Error("No instructions");
            return t.forEach((t=>{
                "instructions"in t ? this.instructions = this.instructions.concat(t.instructions) : "data"in t && "programId"in t && "keys"in t ? this.instructions.push(t) : this.instructions.push(new st(t))
            }
            )),
            this
        }
        compileMessage() {
            if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
                return this._message;
            let t, n, r;
            if (this.nonceInfo ? (t = this.nonceInfo.nonce,
            n = this.instructions[0] != this.nonceInfo.nonceInstruction ? [this.nonceInfo.nonceInstruction, ...this.instructions] : this.instructions) : (t = this.recentBlockhash,
            n = this.instructions),
            !t)
                throw new Error("Transaction recentBlockhash required");
            if (n.length < 1 && console.warn("No instructions provided"),
            this.feePayer)
                r = this.feePayer;
            else {
                if (!(this.signatures.length > 0 && this.signatures[0].publicKey))
                    throw new Error("Transaction fee payer required");
                r = this.signatures[0].publicKey
            }
            for (let t = 0; t < n.length; t++)
                if (void 0 === n[t].programId)
                    throw new Error(`Transaction instruction index ${t} has undefined program id`);
            const i = []
              , s = [];
            n.forEach((t=>{
                t.keys.forEach((t=>{
                    s.push({
                        ...t
                    })
                }
                ));
                const e = t.programId.toString();
                i.includes(e) || i.push(e)
            }
            )),
            i.forEach((t=>{
                s.push({
                    pubkey: new D(t),
                    isSigner: !1,
                    isWritable: !1
                })
            }
            ));
            const o = [];
            s.forEach((t=>{
                const e = t.pubkey.toString()
                  , n = o.findIndex((t=>t.pubkey.toString() === e));
                n > -1 ? (o[n].isWritable = o[n].isWritable || t.isWritable,
                o[n].isSigner = o[n].isSigner || t.isSigner) : o.push(t)
            }
            )),
            o.sort((function(t, e) {
                return t.isSigner !== e.isSigner ? t.isSigner ? -1 : 1 : t.isWritable !== e.isWritable ? t.isWritable ? -1 : 1 : t.pubkey.toBase58().localeCompare(e.pubkey.toBase58())
            }
            ));
            const a = o.findIndex((t=>t.pubkey.equals(r)));
            if (a > -1) {
                const [t] = o.splice(a, 1);
                t.isSigner = !0,
                t.isWritable = !0,
                o.unshift(t)
            } else
                o.unshift({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !0
                });
            for (const t of this.signatures) {
                const e = o.findIndex((e=>e.pubkey.equals(t.publicKey)));
                if (!(e > -1))
                    throw new Error(`unknown signer: ${t.publicKey.toString()}`);
                o[e].isSigner || (o[e].isSigner = !0,
                console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))
            }
            let l = 0
              , u = 0
              , h = 0;
            const d = []
              , f = [];
            o.forEach((({pubkey: t, isSigner: e, isWritable: n})=>{
                e ? (d.push(t.toString()),
                l += 1,
                n || (u += 1)) : (f.push(t.toString()),
                n || (h += 1))
            }
            ));
            const p = d.concat(f)
              , m = n.map((t=>{
                const {data: n, programId: r} = t;
                return {
                    programIdIndex: p.indexOf(r.toString()),
                    accounts: t.keys.map((t=>p.indexOf(t.pubkey.toString()))),
                    data: e(c).encode(n)
                }
            }
            ));
            return m.forEach((t=>{
                Q(t.programIdIndex >= 0),
                t.accounts.forEach((t=>Q(t >= 0)))
            }
            )),
            new J({
                header: {
                    numRequiredSignatures: l,
                    numReadonlySignedAccounts: u,
                    numReadonlyUnsignedAccounts: h
                },
                accountKeys: p,
                recentBlockhash: t,
                instructions: m
            })
        }
        _compile() {
            const t = this.compileMessage()
              , e = t.accountKeys.slice(0, t.header.numRequiredSignatures);
            if (this.signatures.length === e.length) {
                if (this.signatures.every(((t,n)=>e[n].equals(t.publicKey))))
                    return t
            }
            return this.signatures = e.map((t=>({
                signature: null,
                publicKey: t
            }))),
            t
        }
        serializeMessage() {
            return this._compile().serialize()
        }
        async getEstimatedFee(t) {
            return (await t.getFeeForMessage(this.compileMessage())).value
        }
        setSigners(...t) {
            if (0 === t.length)
                throw new Error("No signers");
            const e = new Set;
            this.signatures = t.filter((t=>{
                const n = t.toString();
                return !e.has(n) && (e.add(n),
                !0)
            }
            )).map((t=>({
                signature: null,
                publicKey: t
            })))
        }
        sign(...t) {
            if (0 === t.length)
                throw new Error("No signers");
            const e = new Set
              , n = [];
            for (const r of t) {
                const t = r.publicKey.toString();
                e.has(t) || (e.add(t),
                n.push(r))
            }
            this.signatures = n.map((t=>({
                signature: null,
                publicKey: t.publicKey
            })));
            const r = this._compile();
            this._partialSign(r, ...n)
        }
        partialSign(...t) {
            if (0 === t.length)
                throw new Error("No signers");
            const e = new Set
              , n = [];
            for (const r of t) {
                const t = r.publicKey.toString();
                e.has(t) || (e.add(t),
                n.push(r))
            }
            const r = this._compile();
            this._partialSign(r, ...n)
        }
        _partialSign(t, ...e) {
            const n = t.serialize();
            e.forEach((t=>{
                const e = S(n, t.secretKey);
                this._addSignature(t.publicKey, k(e))
            }
            ))
        }
        addSignature(t, e) {
            this._compile(),
            this._addSignature(t, e)
        }
        _addSignature(t, e) {
            Q(64 === e.length);
            const n = this.signatures.findIndex((e=>t.equals(e.publicKey)));
            if (n < 0)
                throw new Error(`unknown signer: ${t.toString()}`);
            this.signatures[n].signature = i.Buffer.from(e)
        }
        verifySignatures(t) {
            return this._verifySignatures(this.serializeMessage(), void 0 === t || t)
        }
        _verifySignatures(t, e) {
            for (const {signature: n, publicKey: r} of this.signatures)
                if (null === n) {
                    if (e)
                        return !1
                } else if (!T(n, t, r.toBytes()))
                    return !1;
            return !0
        }
        serialize(t) {
            const {requireAllSignatures: e, verifySignatures: n} = Object.assign({
                requireAllSignatures: !0,
                verifySignatures: !0
            }, t)
              , r = this.serializeMessage();
            if (n && !this._verifySignatures(r, e))
                throw new Error("Signature verification failed");
            return this._serialize(r)
        }
        _serialize(t) {
            const {signatures: e} = this
              , n = [];
            K(n, e.length);
            const r = n.length + 64 * e.length + t.length
              , s = i.Buffer.alloc(r);
            return Q(e.length < 256),
            i.Buffer.from(n).copy(s, 0),
            e.forEach((({signature: t},e)=>{
                null !== t && (Q(64 === t.length, "signature has invalid length"),
                i.Buffer.from(t).copy(s, n.length + 64 * e))
            }
            )),
            t.copy(s, n.length + 64 * e.length),
            Q(s.length <= F, `Transaction too large: ${s.length} > ${F}`),
            s
        }
        get keys() {
            return Q(1 === this.instructions.length),
            this.instructions[0].keys.map((t=>t.pubkey))
        }
        get programId() {
            return Q(1 === this.instructions.length),
            this.instructions[0].programId
        }
        get data() {
            return Q(1 === this.instructions.length),
            this.instructions[0].data
        }
        static from(t) {
            let n = [...t];
            const r = q(n);
            let s = [];
            for (let t = 0; t < r; t++) {
                const t = n.slice(0, U);
                n = n.slice(U),
                s.push(e(c).encode(i.Buffer.from(t)))
            }
            return ot.populate(J.from(n), s)
        }
        static populate(t, n=[]) {
            const r = new ot;
            return r.recentBlockhash = t.recentBlockhash,
            t.header.numRequiredSignatures > 0 && (r.feePayer = t.accountKeys[0]),
            n.forEach(((n,i)=>{
                const s = {
                    signature: n == e(c).encode(it) ? null : e(c).decode(n),
                    publicKey: t.accountKeys[i]
                };
                r.signatures.push(s)
            }
            )),
            t.instructions.forEach((n=>{
                const i = n.accounts.map((e=>{
                    const n = t.accountKeys[e];
                    return {
                        pubkey: n,
                        isSigner: r.signatures.some((t=>t.publicKey.toString() === n.toString())) || t.isAccountSigner(e),
                        isWritable: t.isAccountWritable(e)
                    }
                }
                ));
                r.instructions.push(new st({
                    keys: i,
                    programId: t.accountKeys[n.programIdIndex],
                    data: e(c).decode(n.data)
                }))
            }
            )),
            r._message = t,
            r._json = r.toJSON(),
            r
        }
    }
    class at {
        constructor(t) {
            this.payerKey = void 0,
            this.instructions = void 0,
            this.recentBlockhash = void 0,
            this.payerKey = t.payerKey,
            this.instructions = t.instructions,
            this.recentBlockhash = t.recentBlockhash
        }
        static decompile(t, e) {
            const {header: n, compiledInstructions: r, recentBlockhash: i} = t
              , {numRequiredSignatures: s, numReadonlySignedAccounts: o, numReadonlyUnsignedAccounts: a} = n
              , l = s - o;
            Q(l > 0, "Message header is invalid");
            const c = t.staticAccountKeys.length - s - a;
            Q(c >= 0, "Message header is invalid");
            const u = t.getAccountKeys(e)
              , h = u.get(0);
            if (void 0 === h)
                throw new Error("Failed to decompile message because no account keys were found");
            const d = [];
            for (const t of r) {
                const e = [];
                for (const r of t.accountKeyIndexes) {
                    const t = u.get(r);
                    if (void 0 === t)
                        throw new Error(`Failed to find key for account key index ${r}`);
                    let i;
                    i = r < s ? r < l : r < u.staticAccountKeys.length ? r - s < c : r - u.staticAccountKeys.length < u.accountKeysFromLookups.writable.length,
                    e.push({
                        pubkey: t,
                        isSigner: r < n.numRequiredSignatures,
                        isWritable: i
                    })
                }
                const r = u.get(t.programIdIndex);
                if (void 0 === r)
                    throw new Error(`Failed to find program id for program id index ${t.programIdIndex}`);
                d.push(new st({
                    programId: r,
                    data: k(t.data),
                    keys: e
                }))
            }
            return new at({
                payerKey: h,
                instructions: d,
                recentBlockhash: i
            })
        }
        compileToLegacyMessage() {
            return J.compile({
                payerKey: this.payerKey,
                recentBlockhash: this.recentBlockhash,
                instructions: this.instructions
            })
        }
        compileToV0Message(t) {
            return tt.compile({
                payerKey: this.payerKey,
                recentBlockhash: this.recentBlockhash,
                instructions: this.instructions,
                addressLookupTableAccounts: t
            })
        }
    }
    class lt {
        get version() {
            return this.message.version
        }
        constructor(t, e) {
            if (this.signatures = void 0,
            this.message = void 0,
            void 0 !== e)
                Q(e.length === t.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"),
                this.signatures = e;
            else {
                const e = [];
                for (let n = 0; n < t.header.numRequiredSignatures; n++)
                    e.push(new Uint8Array(U));
                this.signatures = e
            }
            this.message = t
        }
        serialize() {
            const t = this.message.serialize()
              , e = Array();
            K(e, this.signatures.length);
            const n = d.struct([d.blob(e.length, "encodedSignaturesLength"), d.seq($(), this.signatures.length, "signatures"), d.blob(t.length, "serializedMessage")])
              , r = new Uint8Array(2048)
              , i = n.encode({
                encodedSignaturesLength: new Uint8Array(e),
                signatures: this.signatures,
                serializedMessage: t
            }, r);
            return r.slice(0, i)
        }
        static deserialize(t) {
            let e = [...t];
            const n = []
              , r = q(e);
            for (let t = 0; t < r; t++)
                n.push(new Uint8Array(e.splice(0, U)));
            const i = et.deserialize(new Uint8Array(e));
            return new lt(i,n)
        }
        sign(t) {
            const e = this.message.serialize()
              , n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
            for (const r of t) {
                const t = n.findIndex((t=>t.equals(r.publicKey)));
                Q(t >= 0, `Cannot sign with non signer key ${r.publicKey.toBase58()}`),
                this.signatures[t] = S(e, r.secretKey)
            }
        }
        addSignature(t, e) {
            Q(64 === e.byteLength, "Signature must be 64 bytes long");
            const n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex((e=>e.equals(t)));
            Q(n >= 0, `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`),
            this.signatures[n] = e
        }
    }
    const ct = new D("SysvarC1ock11111111111111111111111111111111")
      , ut = new D("SysvarEpochSchedu1e111111111111111111111111")
      , ht = new D("Sysvar1nstructions1111111111111111111111111")
      , dt = new D("SysvarRecentB1ockHashes11111111111111111111")
      , ft = new D("SysvarRent111111111111111111111111111111111")
      , pt = new D("SysvarRewards111111111111111111111111111111")
      , mt = new D("SysvarS1otHashes111111111111111111111111111")
      , gt = new D("SysvarS1otHistory11111111111111111111111111")
      , yt = new D("SysvarStakeHistory1111111111111111111111111");
    async function bt(t, e, n, r) {
        const i = r && {
            skipPreflight: r.skipPreflight,
            preflightCommitment: r.preflightCommitment || r.commitment,
            maxRetries: r.maxRetries,
            minContextSlot: r.minContextSlot
        }
          , s = await t.sendTransaction(e, n, i);
        let o;
        if (null != e.recentBlockhash && null != e.lastValidBlockHeight)
            o = (await t.confirmTransaction({
                abortSignal: r?.abortSignal,
                signature: s,
                blockhash: e.recentBlockhash,
                lastValidBlockHeight: e.lastValidBlockHeight
            }, r && r.commitment)).value;
        else if (null != e.minNonceContextSlot && null != e.nonceInfo) {
            const {nonceInstruction: n} = e.nonceInfo
              , i = n.keys[0].pubkey;
            o = (await t.confirmTransaction({
                abortSignal: r?.abortSignal,
                minContextSlot: e.minNonceContextSlot,
                nonceAccountPubkey: i,
                nonceValue: e.nonceInfo.nonce,
                signature: s
            }, r && r.commitment)).value
        } else
            null != r?.abortSignal && console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),
            o = (await t.confirmTransaction(s, r && r.commitment)).value;
        if (o.err)
            throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);
        return s
    }
    function vt(t) {
        return new Promise((e=>setTimeout(e, t)))
    }
    function wt(t, e) {
        const n = t.layout.span >= 0 ? t.layout.span : X(t, e)
          , r = i.Buffer.alloc(n)
          , s = Object.assign({
            instruction: t.index
        }, e);
        return t.layout.encode(s, r),
        r
    }
    function xt(t, e) {
        let n;
        try {
            n = t.layout.decode(e)
        } catch (t) {
            throw new Error("invalid instruction; " + t)
        }
        if (n.instruction !== t.index)
            throw new Error(`invalid instruction; instruction index mismatch ${n.instruction} != ${t.index}`);
        return n
    }
    const Et = d.nu64("lamportsPerSignature")
      , _t = d.struct([d.u32("version"), d.u32("state"), H("authorizedPubkey"), H("nonce"), d.struct([Et], "feeCalculator")])
      , At = _t.span;
    class St {
        constructor(t) {
            this.authorizedPubkey = void 0,
            this.nonce = void 0,
            this.feeCalculator = void 0,
            this.authorizedPubkey = t.authorizedPubkey,
            this.nonce = t.nonce,
            this.feeCalculator = t.feeCalculator
        }
        static fromAccountData(t) {
            const e = _t.decode(k(t), 0);
            return new St({
                authorizedPubkey: new D(e.authorizedPubkey),
                nonce: new D(e.nonce).toString(),
                feeCalculator: e.feeCalculator
            })
        }
    }
    const Tt = (kt = 8,
    t=>{
        const e = (0,
        d.blob)(kt, t)
          , {encode: n, decode: r} = (t=>({
            decode: t.decode.bind(t),
            encode: t.encode.bind(t)
        }))(e)
          , s = e;
        return s.decode = (t,e)=>{
            const n = r(t, e);
            return (0,
            f.toBigIntLE)(i.Buffer.from(n))
        }
        ,
        s.encode = (t,e,r)=>{
            const i = (0,
            f.toBufferLE)(t, kt);
            return n(i, e, r)
        }
        ,
        s
    }
    );
    var kt;
    class It {
        constructor() {}
        static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = d.u32("instruction").decode(t.data);
            let n;
            for (const [t,r] of Object.entries(Mt))
                if (r.index == e) {
                    n = t;
                    break
                }
            if (!n)
                throw new Error("Instruction type incorrect; not a SystemInstruction");
            return n
        }
        static decodeCreateAccount(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 2);
            const {lamports: e, space: n, programId: r} = xt(Mt.Create, t.data);
            return {
                fromPubkey: t.keys[0].pubkey,
                newAccountPubkey: t.keys[1].pubkey,
                lamports: e,
                space: n,
                programId: new D(r)
            }
        }
        static decodeTransfer(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 2);
            const {lamports: e} = xt(Mt.Transfer, t.data);
            return {
                fromPubkey: t.keys[0].pubkey,
                toPubkey: t.keys[1].pubkey,
                lamports: e
            }
        }
        static decodeTransferWithSeed(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3);
            const {lamports: e, seed: n, programId: r} = xt(Mt.TransferWithSeed, t.data);
            return {
                fromPubkey: t.keys[0].pubkey,
                basePubkey: t.keys[1].pubkey,
                toPubkey: t.keys[2].pubkey,
                lamports: e,
                seed: n,
                programId: new D(r)
            }
        }
        static decodeAllocate(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 1);
            const {space: e} = xt(Mt.Allocate, t.data);
            return {
                accountPubkey: t.keys[0].pubkey,
                space: e
            }
        }
        static decodeAllocateWithSeed(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 1);
            const {base: e, seed: n, space: r, programId: i} = xt(Mt.AllocateWithSeed, t.data);
            return {
                accountPubkey: t.keys[0].pubkey,
                basePubkey: new D(e),
                seed: n,
                space: r,
                programId: new D(i)
            }
        }
        static decodeAssign(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 1);
            const {programId: e} = xt(Mt.Assign, t.data);
            return {
                accountPubkey: t.keys[0].pubkey,
                programId: new D(e)
            }
        }
        static decodeAssignWithSeed(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 1);
            const {base: e, seed: n, programId: r} = xt(Mt.AssignWithSeed, t.data);
            return {
                accountPubkey: t.keys[0].pubkey,
                basePubkey: new D(e),
                seed: n,
                programId: new D(r)
            }
        }
        static decodeCreateWithSeed(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 2);
            const {base: e, seed: n, lamports: r, space: i, programId: s} = xt(Mt.CreateWithSeed, t.data);
            return {
                fromPubkey: t.keys[0].pubkey,
                newAccountPubkey: t.keys[1].pubkey,
                basePubkey: new D(e),
                seed: n,
                lamports: r,
                space: i,
                programId: new D(s)
            }
        }
        static decodeNonceInitialize(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3);
            const {authorized: e} = xt(Mt.InitializeNonceAccount, t.data);
            return {
                noncePubkey: t.keys[0].pubkey,
                authorizedPubkey: new D(e)
            }
        }
        static decodeNonceAdvance(t) {
            return this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3),
            xt(Mt.AdvanceNonceAccount, t.data),
            {
                noncePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey
            }
        }
        static decodeNonceWithdraw(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 5);
            const {lamports: e} = xt(Mt.WithdrawNonceAccount, t.data);
            return {
                noncePubkey: t.keys[0].pubkey,
                toPubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[4].pubkey,
                lamports: e
            }
        }
        static decodeNonceAuthorize(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 2);
            const {authorized: e} = xt(Mt.AuthorizeNonceAccount, t.data);
            return {
                noncePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[1].pubkey,
                newAuthorizedPubkey: new D(e)
            }
        }
        static checkProgramId(t) {
            if (!t.equals(Ct.programId))
                throw new Error("invalid instruction; programId is not SystemProgram")
        }
        static checkKeyLength(t, e) {
            if (t.length < e)
                throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)
        }
    }
    const Mt = Object.freeze({
        Create: {
            index: 0,
            layout: d.struct([d.u32("instruction"), d.ns64("lamports"), d.ns64("space"), H("programId")])
        },
        Assign: {
            index: 1,
            layout: d.struct([d.u32("instruction"), H("programId")])
        },
        Transfer: {
            index: 2,
            layout: d.struct([d.u32("instruction"), Tt("lamports")])
        },
        CreateWithSeed: {
            index: 3,
            layout: d.struct([d.u32("instruction"), H("base"), G("seed"), d.ns64("lamports"), d.ns64("space"), H("programId")])
        },
        AdvanceNonceAccount: {
            index: 4,
            layout: d.struct([d.u32("instruction")])
        },
        WithdrawNonceAccount: {
            index: 5,
            layout: d.struct([d.u32("instruction"), d.ns64("lamports")])
        },
        InitializeNonceAccount: {
            index: 6,
            layout: d.struct([d.u32("instruction"), H("authorized")])
        },
        AuthorizeNonceAccount: {
            index: 7,
            layout: d.struct([d.u32("instruction"), H("authorized")])
        },
        Allocate: {
            index: 8,
            layout: d.struct([d.u32("instruction"), d.ns64("space")])
        },
        AllocateWithSeed: {
            index: 9,
            layout: d.struct([d.u32("instruction"), H("base"), G("seed"), d.ns64("space"), H("programId")])
        },
        AssignWithSeed: {
            index: 10,
            layout: d.struct([d.u32("instruction"), H("base"), G("seed"), H("programId")])
        },
        TransferWithSeed: {
            index: 11,
            layout: d.struct([d.u32("instruction"), Tt("lamports"), G("seed"), H("programId")])
        },
        UpgradeNonceAccount: {
            index: 12,
            layout: d.struct([d.u32("instruction")])
        }
    });
    class Ct {
        constructor() {}
        static createAccount(t) {
            const e = wt(Mt.Create, {
                lamports: t.lamports,
                space: t.space,
                programId: k(t.programId.toBuffer())
            });
            return new st({
                keys: [{
                    pubkey: t.fromPubkey,
                    isSigner: !0,
                    isWritable: !0
                }, {
                    pubkey: t.newAccountPubkey,
                    isSigner: !0,
                    isWritable: !0
                }],
                programId: this.programId,
                data: e
            })
        }
        static transfer(t) {
            let e, n;
            if ("basePubkey"in t) {
                e = wt(Mt.TransferWithSeed, {
                    lamports: BigInt(t.lamports),
                    seed: t.seed,
                    programId: k(t.programId.toBuffer())
                }),
                n = [{
                    pubkey: t.fromPubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: t.basePubkey,
                    isSigner: !0,
                    isWritable: !1
                }, {
                    pubkey: t.toPubkey,
                    isSigner: !1,
                    isWritable: !0
                }]
            } else {
                e = wt(Mt.Transfer, {
                    lamports: BigInt(t.lamports)
                }),
                n = [{
                    pubkey: t.fromPubkey,
                    isSigner: !0,
                    isWritable: !0
                }, {
                    pubkey: t.toPubkey,
                    isSigner: !1,
                    isWritable: !0
                }]
            }
            return new st({
                keys: n,
                programId: this.programId,
                data: e
            })
        }
        static assign(t) {
            let e, n;
            if ("basePubkey"in t) {
                e = wt(Mt.AssignWithSeed, {
                    base: k(t.basePubkey.toBuffer()),
                    seed: t.seed,
                    programId: k(t.programId.toBuffer())
                }),
                n = [{
                    pubkey: t.accountPubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: t.basePubkey,
                    isSigner: !0,
                    isWritable: !1
                }]
            } else {
                e = wt(Mt.Assign, {
                    programId: k(t.programId.toBuffer())
                }),
                n = [{
                    pubkey: t.accountPubkey,
                    isSigner: !0,
                    isWritable: !0
                }]
            }
            return new st({
                keys: n,
                programId: this.programId,
                data: e
            })
        }
        static createAccountWithSeed(t) {
            const e = wt(Mt.CreateWithSeed, {
                base: k(t.basePubkey.toBuffer()),
                seed: t.seed,
                lamports: t.lamports,
                space: t.space,
                programId: k(t.programId.toBuffer())
            });
            let n = [{
                pubkey: t.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: t.newAccountPubkey,
                isSigner: !1,
                isWritable: !0
            }];
            return t.basePubkey != t.fromPubkey && n.push({
                pubkey: t.basePubkey,
                isSigner: !0,
                isWritable: !1
            }),
            new st({
                keys: n,
                programId: this.programId,
                data: e
            })
        }
        static createNonceAccount(t) {
            const e = new ot;
            "basePubkey"in t && "seed"in t ? e.add(Ct.createAccountWithSeed({
                fromPubkey: t.fromPubkey,
                newAccountPubkey: t.noncePubkey,
                basePubkey: t.basePubkey,
                seed: t.seed,
                lamports: t.lamports,
                space: At,
                programId: this.programId
            })) : e.add(Ct.createAccount({
                fromPubkey: t.fromPubkey,
                newAccountPubkey: t.noncePubkey,
                lamports: t.lamports,
                space: At,
                programId: this.programId
            }));
            const n = {
                noncePubkey: t.noncePubkey,
                authorizedPubkey: t.authorizedPubkey
            };
            return e.add(this.nonceInitialize(n)),
            e
        }
        static nonceInitialize(t) {
            const e = wt(Mt.InitializeNonceAccount, {
                authorized: k(t.authorizedPubkey.toBuffer())
            })
              , n = {
                keys: [{
                    pubkey: t.noncePubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: dt,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: ft,
                    isSigner: !1,
                    isWritable: !1
                }],
                programId: this.programId,
                data: e
            };
            return new st(n)
        }
        static nonceAdvance(t) {
            const e = wt(Mt.AdvanceNonceAccount)
              , n = {
                keys: [{
                    pubkey: t.noncePubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: dt,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: t.authorizedPubkey,
                    isSigner: !0,
                    isWritable: !1
                }],
                programId: this.programId,
                data: e
            };
            return new st(n)
        }
        static nonceWithdraw(t) {
            const e = wt(Mt.WithdrawNonceAccount, {
                lamports: t.lamports
            });
            return new st({
                keys: [{
                    pubkey: t.noncePubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: t.toPubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: dt,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: ft,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: t.authorizedPubkey,
                    isSigner: !0,
                    isWritable: !1
                }],
                programId: this.programId,
                data: e
            })
        }
        static nonceAuthorize(t) {
            const e = wt(Mt.AuthorizeNonceAccount, {
                authorized: k(t.newAuthorizedPubkey.toBuffer())
            });
            return new st({
                keys: [{
                    pubkey: t.noncePubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: t.authorizedPubkey,
                    isSigner: !0,
                    isWritable: !1
                }],
                programId: this.programId,
                data: e
            })
        }
        static allocate(t) {
            let e, n;
            if ("basePubkey"in t) {
                e = wt(Mt.AllocateWithSeed, {
                    base: k(t.basePubkey.toBuffer()),
                    seed: t.seed,
                    space: t.space,
                    programId: k(t.programId.toBuffer())
                }),
                n = [{
                    pubkey: t.accountPubkey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: t.basePubkey,
                    isSigner: !0,
                    isWritable: !1
                }]
            } else {
                e = wt(Mt.Allocate, {
                    space: t.space
                }),
                n = [{
                    pubkey: t.accountPubkey,
                    isSigner: !0,
                    isWritable: !0
                }]
            }
            return new st({
                keys: n,
                programId: this.programId,
                data: e
            })
        }
    }
    Ct.programId = new D("11111111111111111111111111111111");
    const Pt = F - 300;
    class Ot {
        constructor() {}
        static getMinNumSignatures(t) {
            return 2 * (Math.ceil(t / Ot.chunkSize) + 1 + 1)
        }
        static async load(t, e, n, r, s) {
            {
                const i = await t.getMinimumBalanceForRentExemption(s.length)
                  , o = await t.getAccountInfo(n.publicKey, "confirmed");
                let a = null;
                if (null !== o) {
                    if (o.executable)
                        return console.error("Program load failed, account is already executable"),
                        !1;
                    o.data.length !== s.length && (a = a || new ot,
                    a.add(Ct.allocate({
                        accountPubkey: n.publicKey,
                        space: s.length
                    }))),
                    o.owner.equals(r) || (a = a || new ot,
                    a.add(Ct.assign({
                        accountPubkey: n.publicKey,
                        programId: r
                    }))),
                    o.lamports < i && (a = a || new ot,
                    a.add(Ct.transfer({
                        fromPubkey: e.publicKey,
                        toPubkey: n.publicKey,
                        lamports: i - o.lamports
                    })))
                } else
                    a = (new ot).add(Ct.createAccount({
                        fromPubkey: e.publicKey,
                        newAccountPubkey: n.publicKey,
                        lamports: i > 0 ? i : 1,
                        space: s.length,
                        programId: r
                    }));
                null !== a && await bt(t, a, [e, n], {
                    commitment: "confirmed"
                })
            }
            const o = d.struct([d.u32("instruction"), d.u32("offset"), d.u32("bytesLength"), d.u32("bytesLengthPadding"), d.seq(d.u8("byte"), d.offset(d.u32(), -8), "bytes")])
              , a = Ot.chunkSize;
            let l = 0
              , c = s
              , u = [];
            for (; c.length > 0; ) {
                const s = c.slice(0, a)
                  , h = i.Buffer.alloc(a + 16);
                o.encode({
                    instruction: 0,
                    offset: l,
                    bytes: s,
                    bytesLength: 0,
                    bytesLengthPadding: 0
                }, h);
                const d = (new ot).add({
                    keys: [{
                        pubkey: n.publicKey,
                        isSigner: !0,
                        isWritable: !0
                    }],
                    programId: r,
                    data: h
                });
                if (u.push(bt(t, d, [e, n], {
                    commitment: "confirmed"
                })),
                t._rpcEndpoint.includes("solana.com")) {
                    const t = 4;
                    await vt(1e3 / t)
                }
                l += a,
                c = c.slice(a)
            }
            await Promise.all(u);
            {
                const s = d.struct([d.u32("instruction")])
                  , o = i.Buffer.alloc(s.span);
                s.encode({
                    instruction: 1
                }, o);
                const a = (new ot).add({
                    keys: [{
                        pubkey: n.publicKey,
                        isSigner: !0,
                        isWritable: !0
                    }, {
                        pubkey: ft,
                        isSigner: !1,
                        isWritable: !1
                    }],
                    programId: r,
                    data: o
                });
                await bt(t, a, [e, n], {
                    commitment: "confirmed"
                })
            }
            return !0
        }
    }
    Ot.chunkSize = Pt;
    const Nt = new D("BPFLoader2111111111111111111111111111111111");
    class Rt {
        static getMinNumSignatures(t) {
            return Ot.getMinNumSignatures(t)
        }
        static load(t, e, n, r, i) {
            return Ot.load(t, e, n, i, r)
        }
    }
    var Dt = Object.prototype.toString
      , Bt = Object.keys || function(t) {
        var e = [];
        for (var n in t)
            e.push(n);
        return e
    }
    ;
    function Lt(t, e) {
        var n, r, i, s, o, a, l;
        if (!0 === t)
            return "true";
        if (!1 === t)
            return "false";
        switch (typeof t) {
        case "object":
            if (null === t)
                return null;
            if (t.toJSON && "function" == typeof t.toJSON)
                return Lt(t.toJSON(), e);
            if ("[object Array]" === (l = Dt.call(t))) {
                for (i = "[",
                r = t.length - 1,
                n = 0; n < r; n++)
                    i += Lt(t[n], !0) + ",";
                return r > -1 && (i += Lt(t[n], !0)),
                i + "]"
            }
            if ("[object Object]" === l) {
                for (r = (s = Bt(t).sort()).length,
                i = "",
                n = 0; n < r; )
                    void 0 !== (a = Lt(t[o = s[n]], !1)) && (i && (i += ","),
                    i += JSON.stringify(o) + ":" + a),
                    n++;
                return "{" + i + "}"
            }
            return JSON.stringify(t);
        case "function":
        case "undefined":
            return e ? null : void 0;
        case "string":
            return JSON.stringify(t);
        default:
            return isFinite(t) ? t : null
        }
    }
    var Ft = function(t) {
        var e = Lt(t, !1);
        if (void 0 !== e)
            return "" + e
    };
    function jt(t) {
        let e = 0;
        for (; t > 1; )
            t /= 2,
            e++;
        return e
    }
    class Ut {
        constructor(t, e, n, r, i) {
            this.slotsPerEpoch = void 0,
            this.leaderScheduleSlotOffset = void 0,
            this.warmup = void 0,
            this.firstNormalEpoch = void 0,
            this.firstNormalSlot = void 0,
            this.slotsPerEpoch = t,
            this.leaderScheduleSlotOffset = e,
            this.warmup = n,
            this.firstNormalEpoch = r,
            this.firstNormalSlot = i
        }
        getEpoch(t) {
            return this.getEpochAndSlotIndex(t)[0]
        }
        getEpochAndSlotIndex(t) {
            if (t < this.firstNormalSlot) {
                const n = jt(0 === (e = t + 32 + 1) ? 1 : (e--,
                e |= e >> 1,
                e |= e >> 2,
                e |= e >> 4,
                e |= e >> 8,
                e |= e >> 16,
                1 + (e |= e >> 32))) - jt(32) - 1;
                return [n, t - (this.getSlotsInEpoch(n) - 32)]
            }
            {
                const e = t - this.firstNormalSlot
                  , n = Math.floor(e / this.slotsPerEpoch);
                return [this.firstNormalEpoch + n, e % this.slotsPerEpoch]
            }
            var e
        }
        getFirstSlotInEpoch(t) {
            return t <= this.firstNormalEpoch ? 32 * (Math.pow(2, t) - 1) : (t - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
        }
        getLastSlotInEpoch(t) {
            return this.getFirstSlotInEpoch(t) + this.getSlotsInEpoch(t) - 1
        }
        getSlotsInEpoch(t) {
            return t < this.firstNormalEpoch ? Math.pow(2, t + jt(32)) : this.slotsPerEpoch
        }
    }
    class zt extends Error {
        constructor(t, e) {
            super(t),
            this.logs = void 0,
            this.logs = e
        }
    }
    const Vt = {
        JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
        JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
        JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
        JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
        JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
        JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
        JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
        JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
        JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
        JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
        JSON_RPC_SCAN_ERROR: -32012,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
        JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
        JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
        JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
    };
    class Wt extends Error {
        constructor({code: t, message: e, data: n}, r) {
            super(null != r ? `${r}: ${e}` : e),
            this.code = void 0,
            this.data = void 0,
            this.code = t,
            this.data = n,
            this.name = "SolanaJSONRPCError"
        }
    }
    var Yt = globalThis.fetch;
    class Ht extends (e(g)) {
        constructor(t, n, r) {
            super((t=>{
                const r = e(y)(t, {
                    autoconnect: !0,
                    max_reconnects: 5,
                    reconnect: !0,
                    reconnect_interval: 1e3,
                    ...n
                });
                return this.underlyingSocket = "socket"in r ? r.socket : r,
                r
            }
            ), t, n, r),
            this.underlyingSocket = void 0
        }
        call(...t) {
            const e = this.underlyingSocket?.readyState;
            return 1 === e ? super.call(...t) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + t[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + e + ")"))
        }
        notify(...t) {
            const e = this.underlyingSocket?.readyState;
            return 1 === e ? super.notify(...t) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + t[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + e + ")"))
        }
    }
    class $t {
        constructor(t) {
            this.key = void 0,
            this.state = void 0,
            this.key = t.key,
            this.state = t.state
        }
        isActive() {
            const t = BigInt("0xffffffffffffffff");
            return this.state.deactivationSlot === t
        }
        static deserialize(t) {
            const e = function(t, e) {
                let n;
                try {
                    n = t.layout.decode(e)
                } catch (t) {
                    throw new Error("invalid instruction; " + t)
                }
                if (n.typeIndex !== t.index)
                    throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${t.index}`);
                return n
            }(Gt, t)
              , n = t.length - 56;
            Q(n >= 0, "lookup table is invalid"),
            Q(n % 32 == 0, "lookup table is invalid");
            const r = n / 32
              , {addresses: i} = d.struct([d.seq(H(), r, "addresses")]).decode(t.slice(56));
            return {
                deactivationSlot: e.deactivationSlot,
                lastExtendedSlot: e.lastExtendedSlot,
                lastExtendedSlotStartIndex: e.lastExtendedStartIndex,
                authority: 0 !== e.authority.length ? new D(e.authority[0]) : void 0,
                addresses: i.map((t=>new D(t)))
            }
        }
    }
    const Gt = {
        index: 1,
        layout: d.struct([d.u32("typeIndex"), Tt("deactivationSlot"), d.nu64("lastExtendedSlot"), d.u8("lastExtendedStartIndex"), d.u8(), d.seq(H(), d.offset(d.u8(), -1), "authority")])
    }
      , Xt = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
    const qt = (0,
    p.coerce)((0,
    p.instance)(D), (0,
    p.string)(), (t=>new D(t)))
      , Kt = (0,
    p.tuple)([(0,
    p.string)(), (0,
    p.literal)("base64")])
      , Qt = (0,
    p.coerce)((0,
    p.instance)(i.Buffer), Kt, (t=>i.Buffer.from(t[0], "base64")))
      , Zt = 3e4;
    function Jt(t) {
        let e, n;
        if ("string" == typeof t)
            e = t;
        else if (t) {
            const {commitment: r, ...i} = t;
            e = r,
            n = i
        }
        return {
            commitment: e,
            config: n
        }
    }
    function te(t) {
        return (0,
        p.union)([(0,
        p.type)({
            jsonrpc: (0,
            p.literal)("2.0"),
            id: (0,
            p.string)(),
            result: t
        }), (0,
        p.type)({
            jsonrpc: (0,
            p.literal)("2.0"),
            id: (0,
            p.string)(),
            error: (0,
            p.type)({
                code: (0,
                p.unknown)(),
                message: (0,
                p.string)(),
                data: (0,
                p.optional)((0,
                p.any)())
            })
        })])
    }
    const ee = te((0,
    p.unknown)());
    function ne(t) {
        return (0,
        p.coerce)(te(t), ee, (e=>"error"in e ? e : {
            ...e,
            result: (0,
            p.create)(e.result, t)
        }))
    }
    function re(t) {
        return ne((0,
        p.type)({
            context: (0,
            p.type)({
                slot: (0,
                p.number)()
            }),
            value: t
        }))
    }
    function ie(t) {
        return (0,
        p.type)({
            context: (0,
            p.type)({
                slot: (0,
                p.number)()
            }),
            value: t
        })
    }
    function se(t, n) {
        return 0 === t ? new tt({
            header: n.header,
            staticAccountKeys: n.accountKeys.map((t=>new D(t))),
            recentBlockhash: n.recentBlockhash,
            compiledInstructions: n.instructions.map((t=>({
                programIdIndex: t.programIdIndex,
                accountKeyIndexes: t.accounts,
                data: e(c).decode(t.data)
            }))),
            addressTableLookups: n.addressTableLookups
        }) : new J(n)
    }
    const oe = (0,
    p.type)({
        foundation: (0,
        p.number)(),
        foundationTerm: (0,
        p.number)(),
        initial: (0,
        p.number)(),
        taper: (0,
        p.number)(),
        terminal: (0,
        p.number)()
    })
      , ae = ne((0,
    p.array)((0,
    p.nullable)((0,
    p.type)({
        epoch: (0,
        p.number)(),
        effectiveSlot: (0,
        p.number)(),
        amount: (0,
        p.number)(),
        postBalance: (0,
        p.number)(),
        commission: (0,
        p.optional)((0,
        p.nullable)((0,
        p.number)()))
    }))))
      , le = (0,
    p.type)({
        total: (0,
        p.number)(),
        validator: (0,
        p.number)(),
        foundation: (0,
        p.number)(),
        epoch: (0,
        p.number)()
    })
      , ce = (0,
    p.type)({
        epoch: (0,
        p.number)(),
        slotIndex: (0,
        p.number)(),
        slotsInEpoch: (0,
        p.number)(),
        absoluteSlot: (0,
        p.number)(),
        blockHeight: (0,
        p.optional)((0,
        p.number)()),
        transactionCount: (0,
        p.optional)((0,
        p.number)())
    })
      , ue = (0,
    p.type)({
        slotsPerEpoch: (0,
        p.number)(),
        leaderScheduleSlotOffset: (0,
        p.number)(),
        warmup: (0,
        p.boolean)(),
        firstNormalEpoch: (0,
        p.number)(),
        firstNormalSlot: (0,
        p.number)()
    })
      , he = (0,
    p.record)((0,
    p.string)(), (0,
    p.array)((0,
    p.number)()))
      , de = (0,
    p.nullable)((0,
    p.union)([(0,
    p.type)({}), (0,
    p.string)()]))
      , fe = (0,
    p.type)({
        err: de
    })
      , pe = (0,
    p.literal)("receivedSignature")
      , me = (0,
    p.type)({
        "solana-core": (0,
        p.string)(),
        "feature-set": (0,
        p.optional)((0,
        p.number)())
    })
      , ge = re((0,
    p.type)({
        err: (0,
        p.nullable)((0,
        p.union)([(0,
        p.type)({}), (0,
        p.string)()])),
        logs: (0,
        p.nullable)((0,
        p.array)((0,
        p.string)())),
        accounts: (0,
        p.optional)((0,
        p.nullable)((0,
        p.array)((0,
        p.nullable)((0,
        p.type)({
            executable: (0,
            p.boolean)(),
            owner: (0,
            p.string)(),
            lamports: (0,
            p.number)(),
            data: (0,
            p.array)((0,
            p.string)()),
            rentEpoch: (0,
            p.optional)((0,
            p.number)())
        }))))),
        unitsConsumed: (0,
        p.optional)((0,
        p.number)()),
        returnData: (0,
        p.optional)((0,
        p.nullable)((0,
        p.type)({
            programId: (0,
            p.string)(),
            data: (0,
            p.tuple)([(0,
            p.string)(), (0,
            p.literal)("base64")])
        })))
    }))
      , ye = re((0,
    p.type)({
        byIdentity: (0,
        p.record)((0,
        p.string)(), (0,
        p.array)((0,
        p.number)())),
        range: (0,
        p.type)({
            firstSlot: (0,
            p.number)(),
            lastSlot: (0,
            p.number)()
        })
    }));
    const be = ne(oe)
      , ve = ne(le)
      , we = ne(ce)
      , xe = ne(ue)
      , Ee = ne(he)
      , _e = ne((0,
    p.number)())
      , Ae = re((0,
    p.type)({
        total: (0,
        p.number)(),
        circulating: (0,
        p.number)(),
        nonCirculating: (0,
        p.number)(),
        nonCirculatingAccounts: (0,
        p.array)(qt)
    }))
      , Se = (0,
    p.type)({
        amount: (0,
        p.string)(),
        uiAmount: (0,
        p.nullable)((0,
        p.number)()),
        decimals: (0,
        p.number)(),
        uiAmountString: (0,
        p.optional)((0,
        p.string)())
    })
      , Te = re((0,
    p.array)((0,
    p.type)({
        address: qt,
        amount: (0,
        p.string)(),
        uiAmount: (0,
        p.nullable)((0,
        p.number)()),
        decimals: (0,
        p.number)(),
        uiAmountString: (0,
        p.optional)((0,
        p.string)())
    })))
      , ke = re((0,
    p.array)((0,
    p.type)({
        pubkey: qt,
        account: (0,
        p.type)({
            executable: (0,
            p.boolean)(),
            owner: qt,
            lamports: (0,
            p.number)(),
            data: Qt,
            rentEpoch: (0,
            p.number)()
        })
    })))
      , Ie = (0,
    p.type)({
        program: (0,
        p.string)(),
        parsed: (0,
        p.unknown)(),
        space: (0,
        p.number)()
    })
      , Me = re((0,
    p.array)((0,
    p.type)({
        pubkey: qt,
        account: (0,
        p.type)({
            executable: (0,
            p.boolean)(),
            owner: qt,
            lamports: (0,
            p.number)(),
            data: Ie,
            rentEpoch: (0,
            p.number)()
        })
    })))
      , Ce = re((0,
    p.array)((0,
    p.type)({
        lamports: (0,
        p.number)(),
        address: qt
    })))
      , Pe = (0,
    p.type)({
        executable: (0,
        p.boolean)(),
        owner: qt,
        lamports: (0,
        p.number)(),
        data: Qt,
        rentEpoch: (0,
        p.number)()
    })
      , Oe = (0,
    p.type)({
        pubkey: qt,
        account: Pe
    })
      , Ne = (0,
    p.coerce)((0,
    p.union)([(0,
    p.instance)(i.Buffer), Ie]), (0,
    p.union)([Kt, Ie]), (t=>Array.isArray(t) ? (0,
    p.create)(t, Qt) : t))
      , Re = (0,
    p.type)({
        executable: (0,
        p.boolean)(),
        owner: qt,
        lamports: (0,
        p.number)(),
        data: Ne,
        rentEpoch: (0,
        p.number)()
    })
      , De = (0,
    p.type)({
        pubkey: qt,
        account: Re
    })
      , Be = (0,
    p.type)({
        state: (0,
        p.union)([(0,
        p.literal)("active"), (0,
        p.literal)("inactive"), (0,
        p.literal)("activating"), (0,
        p.literal)("deactivating")]),
        active: (0,
        p.number)(),
        inactive: (0,
        p.number)()
    })
      , Le = ne((0,
    p.array)((0,
    p.type)({
        signature: (0,
        p.string)(),
        slot: (0,
        p.number)(),
        err: de,
        memo: (0,
        p.nullable)((0,
        p.string)()),
        blockTime: (0,
        p.optional)((0,
        p.nullable)((0,
        p.number)()))
    })))
      , Fe = ne((0,
    p.array)((0,
    p.type)({
        signature: (0,
        p.string)(),
        slot: (0,
        p.number)(),
        err: de,
        memo: (0,
        p.nullable)((0,
        p.string)()),
        blockTime: (0,
        p.optional)((0,
        p.nullable)((0,
        p.number)()))
    })))
      , je = (0,
    p.type)({
        subscription: (0,
        p.number)(),
        result: ie(Pe)
    })
      , Ue = (0,
    p.type)({
        pubkey: qt,
        account: Pe
    })
      , ze = (0,
    p.type)({
        subscription: (0,
        p.number)(),
        result: ie(Ue)
    })
      , Ve = (0,
    p.type)({
        parent: (0,
        p.number)(),
        slot: (0,
        p.number)(),
        root: (0,
        p.number)()
    })
      , We = (0,
    p.type)({
        subscription: (0,
        p.number)(),
        result: Ve
    })
      , Ye = (0,
    p.union)([(0,
    p.type)({
        type: (0,
        p.union)([(0,
        p.literal)("firstShredReceived"), (0,
        p.literal)("completed"), (0,
        p.literal)("optimisticConfirmation"), (0,
        p.literal)("root")]),
        slot: (0,
        p.number)(),
        timestamp: (0,
        p.number)()
    }), (0,
    p.type)({
        type: (0,
        p.literal)("createdBank"),
        parent: (0,
        p.number)(),
        slot: (0,
        p.number)(),
        timestamp: (0,
        p.number)()
    }), (0,
    p.type)({
        type: (0,
        p.literal)("frozen"),
        slot: (0,
        p.number)(),
        timestamp: (0,
        p.number)(),
        stats: (0,
        p.type)({
            numTransactionEntries: (0,
            p.number)(),
            numSuccessfulTransactions: (0,
            p.number)(),
            numFailedTransactions: (0,
            p.number)(),
            maxTransactionsPerEntry: (0,
            p.number)()
        })
    }), (0,
    p.type)({
        type: (0,
        p.literal)("dead"),
        slot: (0,
        p.number)(),
        timestamp: (0,
        p.number)(),
        err: (0,
        p.string)()
    })])
      , He = (0,
    p.type)({
        subscription: (0,
        p.number)(),
        result: Ye
    })
      , $e = (0,
    p.type)({
        subscription: (0,
        p.number)(),
        result: ie((0,
        p.union)([fe, pe]))
    })
      , Ge = (0,
    p.type)({
        subscription: (0,
        p.number)(),
        result: (0,
        p.number)()
    })
      , Xe = (0,
    p.type)({
        pubkey: (0,
        p.string)(),
        gossip: (0,
        p.nullable)((0,
        p.string)()),
        tpu: (0,
        p.nullable)((0,
        p.string)()),
        rpc: (0,
        p.nullable)((0,
        p.string)()),
        version: (0,
        p.nullable)((0,
        p.string)())
    })
      , qe = (0,
    p.type)({
        votePubkey: (0,
        p.string)(),
        nodePubkey: (0,
        p.string)(),
        activatedStake: (0,
        p.number)(),
        epochVoteAccount: (0,
        p.boolean)(),
        epochCredits: (0,
        p.array)((0,
        p.tuple)([(0,
        p.number)(), (0,
        p.number)(), (0,
        p.number)()])),
        commission: (0,
        p.number)(),
        lastVote: (0,
        p.number)(),
        rootSlot: (0,
        p.nullable)((0,
        p.number)())
    })
      , Ke = ne((0,
    p.type)({
        current: (0,
        p.array)(qe),
        delinquent: (0,
        p.array)(qe)
    }))
      , Qe = (0,
    p.union)([(0,
    p.literal)("processed"), (0,
    p.literal)("confirmed"), (0,
    p.literal)("finalized")])
      , Ze = (0,
    p.type)({
        slot: (0,
        p.number)(),
        confirmations: (0,
        p.nullable)((0,
        p.number)()),
        err: de,
        confirmationStatus: (0,
        p.optional)(Qe)
    })
      , Je = re((0,
    p.array)((0,
    p.nullable)(Ze)))
      , tn = ne((0,
    p.number)())
      , en = (0,
    p.type)({
        accountKey: qt,
        writableIndexes: (0,
        p.array)((0,
        p.number)()),
        readonlyIndexes: (0,
        p.array)((0,
        p.number)())
    })
      , nn = (0,
    p.type)({
        signatures: (0,
        p.array)((0,
        p.string)()),
        message: (0,
        p.type)({
            accountKeys: (0,
            p.array)((0,
            p.string)()),
            header: (0,
            p.type)({
                numRequiredSignatures: (0,
                p.number)(),
                numReadonlySignedAccounts: (0,
                p.number)(),
                numReadonlyUnsignedAccounts: (0,
                p.number)()
            }),
            instructions: (0,
            p.array)((0,
            p.type)({
                accounts: (0,
                p.array)((0,
                p.number)()),
                data: (0,
                p.string)(),
                programIdIndex: (0,
                p.number)()
            })),
            recentBlockhash: (0,
            p.string)(),
            addressTableLookups: (0,
            p.optional)((0,
            p.array)(en))
        })
    })
      , rn = (0,
    p.type)({
        pubkey: qt,
        signer: (0,
        p.boolean)(),
        writable: (0,
        p.boolean)(),
        source: (0,
        p.optional)((0,
        p.union)([(0,
        p.literal)("transaction"), (0,
        p.literal)("lookupTable")]))
    })
      , sn = (0,
    p.type)({
        accountKeys: (0,
        p.array)(rn),
        signatures: (0,
        p.array)((0,
        p.string)())
    })
      , on = (0,
    p.type)({
        parsed: (0,
        p.unknown)(),
        program: (0,
        p.string)(),
        programId: qt
    })
      , an = (0,
    p.type)({
        accounts: (0,
        p.array)(qt),
        data: (0,
        p.string)(),
        programId: qt
    })
      , ln = (0,
    p.union)([an, on])
      , cn = (0,
    p.union)([(0,
    p.type)({
        parsed: (0,
        p.unknown)(),
        program: (0,
        p.string)(),
        programId: (0,
        p.string)()
    }), (0,
    p.type)({
        accounts: (0,
        p.array)((0,
        p.string)()),
        data: (0,
        p.string)(),
        programId: (0,
        p.string)()
    })])
      , un = (0,
    p.coerce)(ln, cn, (t=>"accounts"in t ? (0,
    p.create)(t, an) : (0,
    p.create)(t, on)))
      , hn = (0,
    p.type)({
        signatures: (0,
        p.array)((0,
        p.string)()),
        message: (0,
        p.type)({
            accountKeys: (0,
            p.array)(rn),
            instructions: (0,
            p.array)(un),
            recentBlockhash: (0,
            p.string)(),
            addressTableLookups: (0,
            p.optional)((0,
            p.nullable)((0,
            p.array)(en)))
        })
    })
      , dn = (0,
    p.type)({
        accountIndex: (0,
        p.number)(),
        mint: (0,
        p.string)(),
        owner: (0,
        p.optional)((0,
        p.string)()),
        uiTokenAmount: Se
    })
      , fn = (0,
    p.type)({
        writable: (0,
        p.array)(qt),
        readonly: (0,
        p.array)(qt)
    })
      , pn = (0,
    p.type)({
        err: de,
        fee: (0,
        p.number)(),
        innerInstructions: (0,
        p.optional)((0,
        p.nullable)((0,
        p.array)((0,
        p.type)({
            index: (0,
            p.number)(),
            instructions: (0,
            p.array)((0,
            p.type)({
                accounts: (0,
                p.array)((0,
                p.number)()),
                data: (0,
                p.string)(),
                programIdIndex: (0,
                p.number)()
            }))
        })))),
        preBalances: (0,
        p.array)((0,
        p.number)()),
        postBalances: (0,
        p.array)((0,
        p.number)()),
        logMessages: (0,
        p.optional)((0,
        p.nullable)((0,
        p.array)((0,
        p.string)()))),
        preTokenBalances: (0,
        p.optional)((0,
        p.nullable)((0,
        p.array)(dn))),
        postTokenBalances: (0,
        p.optional)((0,
        p.nullable)((0,
        p.array)(dn))),
        loadedAddresses: (0,
        p.optional)(fn),
        computeUnitsConsumed: (0,
        p.optional)((0,
        p.number)())
    })
      , mn = (0,
    p.type)({
        err: de,
        fee: (0,
        p.number)(),
        innerInstructions: (0,
        p.optional)((0,
        p.nullable)((0,
        p.array)((0,
        p.type)({
            index: (0,
            p.number)(),
            instructions: (0,
            p.array)(un)
        })))),
        preBalances: (0,
        p.array)((0,
        p.number)()),
        postBalances: (0,
        p.array)((0,
        p.number)()),
        logMessages: (0,
        p.optional)((0,
        p.nullable)((0,
        p.array)((0,
        p.string)()))),
        preTokenBalances: (0,
        p.optional)((0,
        p.nullable)((0,
        p.array)(dn))),
        postTokenBalances: (0,
        p.optional)((0,
        p.nullable)((0,
        p.array)(dn))),
        loadedAddresses: (0,
        p.optional)(fn),
        computeUnitsConsumed: (0,
        p.optional)((0,
        p.number)())
    })
      , gn = (0,
    p.union)([(0,
    p.literal)(0), (0,
    p.literal)("legacy")])
      , yn = (0,
    p.type)({
        pubkey: (0,
        p.string)(),
        lamports: (0,
        p.number)(),
        postBalance: (0,
        p.nullable)((0,
        p.number)()),
        rewardType: (0,
        p.nullable)((0,
        p.string)()),
        commission: (0,
        p.optional)((0,
        p.nullable)((0,
        p.number)()))
    })
      , bn = ne((0,
    p.nullable)((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        previousBlockhash: (0,
        p.string)(),
        parentSlot: (0,
        p.number)(),
        transactions: (0,
        p.array)((0,
        p.type)({
            transaction: nn,
            meta: (0,
            p.nullable)(pn),
            version: (0,
            p.optional)(gn)
        })),
        rewards: (0,
        p.optional)((0,
        p.array)(yn)),
        blockTime: (0,
        p.nullable)((0,
        p.number)()),
        blockHeight: (0,
        p.nullable)((0,
        p.number)())
    })))
      , vn = ne((0,
    p.nullable)((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        previousBlockhash: (0,
        p.string)(),
        parentSlot: (0,
        p.number)(),
        rewards: (0,
        p.optional)((0,
        p.array)(yn)),
        blockTime: (0,
        p.nullable)((0,
        p.number)()),
        blockHeight: (0,
        p.nullable)((0,
        p.number)())
    })))
      , wn = ne((0,
    p.nullable)((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        previousBlockhash: (0,
        p.string)(),
        parentSlot: (0,
        p.number)(),
        transactions: (0,
        p.array)((0,
        p.type)({
            transaction: sn,
            meta: (0,
            p.nullable)(pn),
            version: (0,
            p.optional)(gn)
        })),
        rewards: (0,
        p.optional)((0,
        p.array)(yn)),
        blockTime: (0,
        p.nullable)((0,
        p.number)()),
        blockHeight: (0,
        p.nullable)((0,
        p.number)())
    })))
      , xn = ne((0,
    p.nullable)((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        previousBlockhash: (0,
        p.string)(),
        parentSlot: (0,
        p.number)(),
        transactions: (0,
        p.array)((0,
        p.type)({
            transaction: hn,
            meta: (0,
            p.nullable)(mn),
            version: (0,
            p.optional)(gn)
        })),
        rewards: (0,
        p.optional)((0,
        p.array)(yn)),
        blockTime: (0,
        p.nullable)((0,
        p.number)()),
        blockHeight: (0,
        p.nullable)((0,
        p.number)())
    })))
      , En = ne((0,
    p.nullable)((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        previousBlockhash: (0,
        p.string)(),
        parentSlot: (0,
        p.number)(),
        transactions: (0,
        p.array)((0,
        p.type)({
            transaction: sn,
            meta: (0,
            p.nullable)(mn),
            version: (0,
            p.optional)(gn)
        })),
        rewards: (0,
        p.optional)((0,
        p.array)(yn)),
        blockTime: (0,
        p.nullable)((0,
        p.number)()),
        blockHeight: (0,
        p.nullable)((0,
        p.number)())
    })))
      , _n = ne((0,
    p.nullable)((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        previousBlockhash: (0,
        p.string)(),
        parentSlot: (0,
        p.number)(),
        rewards: (0,
        p.optional)((0,
        p.array)(yn)),
        blockTime: (0,
        p.nullable)((0,
        p.number)()),
        blockHeight: (0,
        p.nullable)((0,
        p.number)())
    })))
      , An = ne((0,
    p.nullable)((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        previousBlockhash: (0,
        p.string)(),
        parentSlot: (0,
        p.number)(),
        transactions: (0,
        p.array)((0,
        p.type)({
            transaction: nn,
            meta: (0,
            p.nullable)(pn)
        })),
        rewards: (0,
        p.optional)((0,
        p.array)(yn)),
        blockTime: (0,
        p.nullable)((0,
        p.number)())
    })))
      , Sn = ne((0,
    p.nullable)((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        previousBlockhash: (0,
        p.string)(),
        parentSlot: (0,
        p.number)(),
        signatures: (0,
        p.array)((0,
        p.string)()),
        blockTime: (0,
        p.nullable)((0,
        p.number)())
    })))
      , Tn = ne((0,
    p.nullable)((0,
    p.type)({
        slot: (0,
        p.number)(),
        meta: pn,
        blockTime: (0,
        p.optional)((0,
        p.nullable)((0,
        p.number)())),
        transaction: nn,
        version: (0,
        p.optional)(gn)
    })))
      , kn = ne((0,
    p.nullable)((0,
    p.type)({
        slot: (0,
        p.number)(),
        transaction: hn,
        meta: (0,
        p.nullable)(mn),
        blockTime: (0,
        p.optional)((0,
        p.nullable)((0,
        p.number)())),
        version: (0,
        p.optional)(gn)
    })))
      , In = re((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        feeCalculator: (0,
        p.type)({
            lamportsPerSignature: (0,
            p.number)()
        })
    }))
      , Mn = re((0,
    p.type)({
        blockhash: (0,
        p.string)(),
        lastValidBlockHeight: (0,
        p.number)()
    }))
      , Cn = (0,
    p.type)({
        slot: (0,
        p.number)(),
        numTransactions: (0,
        p.number)(),
        numSlots: (0,
        p.number)(),
        samplePeriodSecs: (0,
        p.number)()
    })
      , Pn = ne((0,
    p.array)(Cn))
      , On = re((0,
    p.nullable)((0,
    p.type)({
        feeCalculator: (0,
        p.type)({
            lamportsPerSignature: (0,
            p.number)()
        })
    })))
      , Nn = ne((0,
    p.string)())
      , Rn = ne((0,
    p.string)())
      , Dn = (0,
    p.type)({
        err: de,
        logs: (0,
        p.array)((0,
        p.string)()),
        signature: (0,
        p.string)()
    })
      , Bn = (0,
    p.type)({
        result: ie(Dn),
        subscription: (0,
        p.number)()
    })
      , Ln = {
        "solana-client": "js/0.0.0-development"
    };
    class Fn {
        constructor(t, n) {
            let r, i, s, o, a, l;
            var c;
            this._commitment = void 0,
            this._confirmTransactionInitialTimeout = void 0,
            this._rpcEndpoint = void 0,
            this._rpcWsEndpoint = void 0,
            this._rpcClient = void 0,
            this._rpcRequest = void 0,
            this._rpcBatchRequest = void 0,
            this._rpcWebSocket = void 0,
            this._rpcWebSocketConnected = !1,
            this._rpcWebSocketHeartbeat = null,
            this._rpcWebSocketIdleTimeout = null,
            this._rpcWebSocketGeneration = 0,
            this._disableBlockhashCaching = !1,
            this._pollingBlockhash = !1,
            this._blockhashInfo = {
                latestBlockhash: null,
                lastFetch: 0,
                transactionSignatures: [],
                simulatedSignatures: []
            },
            this._nextClientSubscriptionId = 0,
            this._subscriptionDisposeFunctionsByClientSubscriptionId = {},
            this._subscriptionHashByClientSubscriptionId = {},
            this._subscriptionStateChangeCallbacksByHash = {},
            this._subscriptionCallbacksByServerSubscriptionId = {},
            this._subscriptionsByHash = {},
            this._subscriptionsAutoDisposedByRpc = new Set,
            this.getBlockHeight = (()=>{
                const t = {};
                return async e=>{
                    const {commitment: n, config: r} = Jt(e)
                      , i = this._buildArgs([], n, void 0, r)
                      , s = Ft(i);
                    return t[s] = t[s] ?? (async()=>{
                        try {
                            const t = await this._rpcRequest("getBlockHeight", i)
                              , e = (0,
                            p.create)(t, ne((0,
                            p.number)()));
                            if ("error"in e)
                                throw new Wt(e.error,"failed to get block height information");
                            return e.result
                        } finally {
                            delete t[s]
                        }
                    }
                    )(),
                    await t[s]
                }
            }
            )(),
            n && "string" == typeof n ? this._commitment = n : n && (this._commitment = n.commitment,
            this._confirmTransactionInitialTimeout = n.confirmTransactionInitialTimeout,
            r = n.wsEndpoint,
            i = n.httpHeaders,
            s = n.fetch,
            o = n.fetchMiddleware,
            a = n.disableRetryOnRateLimit,
            l = n.httpAgent),
            this._rpcEndpoint = function(t) {
                if (!1 === /^https?:/.test(t))
                    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
                return t
            }(t),
            this._rpcWsEndpoint = r || function(t) {
                const e = t.match(Xt);
                if (null == e)
                    throw TypeError(`Failed to validate endpoint URL \`${t}\``);
                const [n,r,i,s] = e
                  , o = t.startsWith("https:") ? "wss:" : "ws:"
                  , a = null == i ? null : parseInt(i.slice(1), 10);
                return `${o}//${r}${null == a ? "" : `:${a + 1}`}${s}`
            }(t),
            this._rpcClient = function(t, n, r, i, s, o) {
                const a = r || Yt;
                let l;
                return null != o && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."),
                i && (l = async(t,e)=>{
                    const n = await new Promise(((n,r)=>{
                        try {
                            i(t, e, ((t,e)=>n([t, e])))
                        } catch (t) {
                            r(t)
                        }
                    }
                    ));
                    return await a(...n)
                }
                ),
                new (e(m))((async(e,r)=>{
                    const i = {
                        method: "POST",
                        body: e,
                        agent: void 0,
                        headers: Object.assign({
                            "Content-Type": "application/json"
                        }, n || {}, Ln)
                    };
                    try {
                        let e, n = 5, o = 500;
                        for (; e = l ? await l(t, i) : await a(t, i),
                        429 === e.status && !0 !== s && (n -= 1,
                        0 !== n); )
                            console.log(`Server responded with ${e.status} ${e.statusText}.  Retrying after ${o}ms delay...`),
                            await vt(o),
                            o *= 2;
                        const c = await e.text();
                        e.ok ? r(null, c) : r(new Error(`${e.status} ${e.statusText}: ${c}`))
                    } catch (t) {
                        t instanceof Error && r(t)
                    }
                }
                ),{})
            }(t, i, s, o, a, l),
            this._rpcRequest = (c = this._rpcClient,
            (t,e)=>new Promise(((n,r)=>{
                c.request(t, e, ((t,e)=>{
                    t ? r(t) : n(e)
                }
                ))
            }
            ))),
            this._rpcBatchRequest = function(t) {
                return e=>new Promise(((n,r)=>{
                    0 === e.length && n([]);
                    const i = e.map((e=>t.request(e.methodName, e.args)));
                    t.request(i, ((t,e)=>{
                        t ? r(t) : n(e)
                    }
                    ))
                }
                ))
            }(this._rpcClient),
            this._rpcWebSocket = new Ht(this._rpcWsEndpoint,{
                autoconnect: !1,
                max_reconnects: 1 / 0
            }),
            this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
            this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
            this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
            this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)),
            this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)),
            this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)),
            this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)),
            this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)),
            this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)),
            this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
        }
        get commitment() {
            return this._commitment
        }
        get rpcEndpoint() {
            return this._rpcEndpoint
        }
        async getBalanceAndContext(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = this._buildArgs([t.toBase58()], n, void 0, r)
              , s = await this._rpcRequest("getBalance", i)
              , o = (0,
            p.create)(s, re((0,
            p.number)()));
            if ("error"in o)
                throw new Wt(o.error,`failed to get balance for ${t.toBase58()}`);
            return o.result
        }
        async getBalance(t, e) {
            return await this.getBalanceAndContext(t, e).then((t=>t.value)).catch((e=>{
                throw new Error("failed to get balance of account " + t.toBase58() + ": " + e)
            }
            ))
        }
        async getBlockTime(t) {
            const e = await this._rpcRequest("getBlockTime", [t])
              , n = (0,
            p.create)(e, ne((0,
            p.nullable)((0,
            p.number)())));
            if ("error"in n)
                throw new Wt(n.error,`failed to get block time for slot ${t}`);
            return n.result
        }
        async getMinimumLedgerSlot() {
            const t = await this._rpcRequest("minimumLedgerSlot", [])
              , e = (0,
            p.create)(t, ne((0,
            p.number)()));
            if ("error"in e)
                throw new Wt(e.error,"failed to get minimum ledger slot");
            return e.result
        }
        async getFirstAvailableBlock() {
            const t = await this._rpcRequest("getFirstAvailableBlock", [])
              , e = (0,
            p.create)(t, _e);
            if ("error"in e)
                throw new Wt(e.error,"failed to get first available block");
            return e.result
        }
        async getSupply(t) {
            let e = {};
            e = "string" == typeof t ? {
                commitment: t
            } : t ? {
                ...t,
                commitment: t && t.commitment || this.commitment
            } : {
                commitment: this.commitment
            };
            const n = await this._rpcRequest("getSupply", [e])
              , r = (0,
            p.create)(n, Ae);
            if ("error"in r)
                throw new Wt(r.error,"failed to get supply");
            return r.result
        }
        async getTokenSupply(t, e) {
            const n = this._buildArgs([t.toBase58()], e)
              , r = await this._rpcRequest("getTokenSupply", n)
              , i = (0,
            p.create)(r, re(Se));
            if ("error"in i)
                throw new Wt(i.error,"failed to get token supply");
            return i.result
        }
        async getTokenAccountBalance(t, e) {
            const n = this._buildArgs([t.toBase58()], e)
              , r = await this._rpcRequest("getTokenAccountBalance", n)
              , i = (0,
            p.create)(r, re(Se));
            if ("error"in i)
                throw new Wt(i.error,"failed to get token account balance");
            return i.result
        }
        async getTokenAccountsByOwner(t, e, n) {
            const {commitment: r, config: i} = Jt(n);
            let s = [t.toBase58()];
            "mint"in e ? s.push({
                mint: e.mint.toBase58()
            }) : s.push({
                programId: e.programId.toBase58()
            });
            const o = this._buildArgs(s, r, "base64", i)
              , a = await this._rpcRequest("getTokenAccountsByOwner", o)
              , l = (0,
            p.create)(a, ke);
            if ("error"in l)
                throw new Wt(l.error,`failed to get token accounts owned by account ${t.toBase58()}`);
            return l.result
        }
        async getParsedTokenAccountsByOwner(t, e, n) {
            let r = [t.toBase58()];
            "mint"in e ? r.push({
                mint: e.mint.toBase58()
            }) : r.push({
                programId: e.programId.toBase58()
            });
            const i = this._buildArgs(r, n, "jsonParsed")
              , s = await this._rpcRequest("getTokenAccountsByOwner", i)
              , o = (0,
            p.create)(s, Me);
            if ("error"in o)
                throw new Wt(o.error,`failed to get token accounts owned by account ${t.toBase58()}`);
            return o.result
        }
        async getLargestAccounts(t) {
            const e = {
                ...t,
                commitment: t && t.commitment || this.commitment
            }
              , n = e.filter || e.commitment ? [e] : []
              , r = await this._rpcRequest("getLargestAccounts", n)
              , i = (0,
            p.create)(r, Ce);
            if ("error"in i)
                throw new Wt(i.error,"failed to get largest accounts");
            return i.result
        }
        async getTokenLargestAccounts(t, e) {
            const n = this._buildArgs([t.toBase58()], e)
              , r = await this._rpcRequest("getTokenLargestAccounts", n)
              , i = (0,
            p.create)(r, Te);
            if ("error"in i)
                throw new Wt(i.error,"failed to get token largest accounts");
            return i.result
        }
        async getAccountInfoAndContext(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = this._buildArgs([t.toBase58()], n, "base64", r)
              , s = await this._rpcRequest("getAccountInfo", i)
              , o = (0,
            p.create)(s, re((0,
            p.nullable)(Pe)));
            if ("error"in o)
                throw new Wt(o.error,`failed to get info about account ${t.toBase58()}`);
            return o.result
        }
        async getParsedAccountInfo(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = this._buildArgs([t.toBase58()], n, "jsonParsed", r)
              , s = await this._rpcRequest("getAccountInfo", i)
              , o = (0,
            p.create)(s, re((0,
            p.nullable)(Re)));
            if ("error"in o)
                throw new Wt(o.error,`failed to get info about account ${t.toBase58()}`);
            return o.result
        }
        async getAccountInfo(t, e) {
            try {
                return (await this.getAccountInfoAndContext(t, e)).value
            } catch (e) {
                throw new Error("failed to get info about account " + t.toBase58() + ": " + e)
            }
        }
        async getMultipleParsedAccounts(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = t.map((t=>t.toBase58()))
              , s = this._buildArgs([i], n, "jsonParsed", r)
              , o = await this._rpcRequest("getMultipleAccounts", s)
              , a = (0,
            p.create)(o, re((0,
            p.array)((0,
            p.nullable)(Re))));
            if ("error"in a)
                throw new Wt(a.error,`failed to get info for accounts ${i}`);
            return a.result
        }
        async getMultipleAccountsInfoAndContext(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = t.map((t=>t.toBase58()))
              , s = this._buildArgs([i], n, "base64", r)
              , o = await this._rpcRequest("getMultipleAccounts", s)
              , a = (0,
            p.create)(o, re((0,
            p.array)((0,
            p.nullable)(Pe))));
            if ("error"in a)
                throw new Wt(a.error,`failed to get info for accounts ${i}`);
            return a.result
        }
        async getMultipleAccountsInfo(t, e) {
            return (await this.getMultipleAccountsInfoAndContext(t, e)).value
        }
        async getStakeActivation(t, e, n) {
            const {commitment: r, config: i} = Jt(e)
              , s = this._buildArgs([t.toBase58()], r, void 0, {
                ...i,
                epoch: null != n ? n : i?.epoch
            })
              , o = await this._rpcRequest("getStakeActivation", s)
              , a = (0,
            p.create)(o, ne(Be));
            if ("error"in a)
                throw new Wt(a.error,`failed to get Stake Activation ${t.toBase58()}`);
            return a.result
        }
        async getProgramAccounts(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , {encoding: i, ...s} = r || {}
              , o = this._buildArgs([t.toBase58()], n, i || "base64", s)
              , a = await this._rpcRequest("getProgramAccounts", o)
              , l = (0,
            p.create)(a, ne((0,
            p.array)(Oe)));
            if ("error"in l)
                throw new Wt(l.error,`failed to get accounts owned by program ${t.toBase58()}`);
            return l.result
        }
        async getParsedProgramAccounts(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = this._buildArgs([t.toBase58()], n, "jsonParsed", r)
              , s = await this._rpcRequest("getProgramAccounts", i)
              , o = (0,
            p.create)(s, ne((0,
            p.array)(De)));
            if ("error"in o)
                throw new Wt(o.error,`failed to get accounts owned by program ${t.toBase58()}`);
            return o.result
        }
        async confirmTransaction(t, n) {
            let r, i;
            if ("string" == typeof t)
                r = t;
            else {
                const e = t;
                if (e.abortSignal?.aborted)
                    return Promise.reject(e.abortSignal.reason);
                r = e.signature
            }
            try {
                i = e(c).decode(r)
            } catch (t) {
                throw new Error("signature must be base58 encoded: " + r)
            }
            return Q(64 === i.length, "signature has invalid length"),
            "string" == typeof t ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
                commitment: n || this.commitment,
                signature: r
            }) : "lastValidBlockHeight"in t ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
                commitment: n || this.commitment,
                strategy: t
            }) : await this.confirmTransactionUsingDurableNonceStrategy({
                commitment: n || this.commitment,
                strategy: t
            })
        }
        getCancellationPromise(t) {
            return new Promise(((e,n)=>{
                null != t && (t.aborted ? n(t.reason) : t.addEventListener("abort", (()=>{
                    n(t.reason)
                }
                )))
            }
            ))
        }
        getTransactionConfirmationPromise({commitment: t, signature: e}) {
            let n, r, i = !1;
            return {
                abortConfirmation: ()=>{
                    r && (r(),
                    r = void 0),
                    null != n && (this.removeSignatureListener(n),
                    n = void 0)
                }
                ,
                confirmationPromise: new Promise(((s,o)=>{
                    try {
                        n = this.onSignature(e, ((t,e)=>{
                            n = void 0;
                            const r = {
                                context: e,
                                value: t
                            };
                            s({
                                __type: nt.PROCESSED,
                                response: r
                            })
                        }
                        ), t);
                        const a = new Promise((t=>{
                            null == n ? t() : r = this._onSubscriptionStateChange(n, (e=>{
                                "subscribed" === e && t()
                            }
                            ))
                        }
                        ));
                        (async()=>{
                            if (await a,
                            i)
                                return;
                            const n = await this.getSignatureStatus(e);
                            if (i)
                                return;
                            if (null == n)
                                return;
                            const {context: r, value: l} = n;
                            if (null != l)
                                if (l?.err)
                                    o(l.err);
                                else {
                                    switch (t) {
                                    case "confirmed":
                                    case "single":
                                    case "singleGossip":
                                        if ("processed" === l.confirmationStatus)
                                            return;
                                        break;
                                    case "finalized":
                                    case "max":
                                    case "root":
                                        if ("processed" === l.confirmationStatus || "confirmed" === l.confirmationStatus)
                                            return
                                    }
                                    i = !0,
                                    s({
                                        __type: nt.PROCESSED,
                                        response: {
                                            context: r,
                                            value: l
                                        }
                                    })
                                }
                        }
                        )()
                    } catch (t) {
                        o(t)
                    }
                }
                ))
            }
        }
        async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment: t, strategy: {abortSignal: e, lastValidBlockHeight: n, signature: r}}) {
            let i = !1;
            const s = new Promise((e=>{
                const r = async()=>{
                    try {
                        return await this.getBlockHeight(t)
                    } catch (t) {
                        return -1
                    }
                }
                ;
                (async()=>{
                    let t = await r();
                    if (!i) {
                        for (; t <= n; ) {
                            if (await vt(1e3),
                            i)
                                return;
                            if (t = await r(),
                            i)
                                return
                        }
                        e({
                            __type: nt.BLOCKHEIGHT_EXCEEDED
                        })
                    }
                }
                )()
            }
            ))
              , {abortConfirmation: o, confirmationPromise: a} = this.getTransactionConfirmationPromise({
                commitment: t,
                signature: r
            })
              , l = this.getCancellationPromise(e);
            let c;
            try {
                const t = await Promise.race([l, a, s]);
                if (t.__type !== nt.PROCESSED)
                    throw new z(r);
                c = t.response
            } finally {
                i = !0,
                o()
            }
            return c
        }
        async confirmTransactionUsingDurableNonceStrategy({commitment: t, strategy: {abortSignal: e, minContextSlot: n, nonceAccountPubkey: r, nonceValue: i, signature: s}}) {
            let o = !1;
            const a = new Promise((e=>{
                let s = i
                  , a = null;
                const l = async()=>{
                    try {
                        const {context: e, value: i} = await this.getNonceAndContext(r, {
                            commitment: t,
                            minContextSlot: n
                        });
                        return a = e.slot,
                        i?.nonce
                    } catch (t) {
                        return s
                    }
                }
                ;
                (async()=>{
                    if (s = await l(),
                    !o)
                        for (; ; ) {
                            if (i !== s)
                                return void e({
                                    __type: nt.NONCE_INVALID,
                                    slotInWhichNonceDidAdvance: a
                                });
                            if (await vt(2e3),
                            o)
                                return;
                            if (s = await l(),
                            o)
                                return
                        }
                }
                )()
            }
            ))
              , {abortConfirmation: l, confirmationPromise: c} = this.getTransactionConfirmationPromise({
                commitment: t,
                signature: s
            })
              , u = this.getCancellationPromise(e);
            let h;
            try {
                const e = await Promise.race([u, c, a]);
                if (e.__type === nt.PROCESSED)
                    h = e.response;
                else {
                    let r;
                    for (; ; ) {
                        const t = await this.getSignatureStatus(s);
                        if (null == t)
                            break;
                        if (!(t.context.slot < (e.slotInWhichNonceDidAdvance ?? n))) {
                            r = t;
                            break
                        }
                        await vt(400)
                    }
                    if (!r?.value)
                        throw new W(s);
                    {
                        const e = t || "finalized"
                          , {confirmationStatus: n} = r.value;
                        switch (e) {
                        case "processed":
                        case "recent":
                            if ("processed" !== n && "confirmed" !== n && "finalized" !== n)
                                throw new W(s);
                            break;
                        case "confirmed":
                        case "single":
                        case "singleGossip":
                            if ("confirmed" !== n && "finalized" !== n)
                                throw new W(s);
                            break;
                        case "finalized":
                        case "max":
                        case "root":
                            if ("finalized" !== n)
                                throw new W(s)
                        }
                        h = {
                            context: r.context,
                            value: {
                                err: r.value.err
                            }
                        }
                    }
                }
            } finally {
                o = !0,
                l()
            }
            return h
        }
        async confirmTransactionUsingLegacyTimeoutStrategy({commitment: t, signature: e}) {
            let n;
            const r = new Promise((e=>{
                let r = this._confirmTransactionInitialTimeout || 6e4;
                switch (t) {
                case "processed":
                case "recent":
                case "single":
                case "confirmed":
                case "singleGossip":
                    r = this._confirmTransactionInitialTimeout || 3e4
                }
                n = setTimeout((()=>e({
                    __type: nt.TIMED_OUT,
                    timeoutMs: r
                })), r)
            }
            ))
              , {abortConfirmation: i, confirmationPromise: s} = this.getTransactionConfirmationPromise({
                commitment: t,
                signature: e
            });
            let o;
            try {
                const t = await Promise.race([s, r]);
                if (t.__type !== nt.PROCESSED)
                    throw new V(e,t.timeoutMs / 1e3);
                o = t.response
            } finally {
                clearTimeout(n),
                i()
            }
            return o
        }
        async getClusterNodes() {
            const t = await this._rpcRequest("getClusterNodes", [])
              , e = (0,
            p.create)(t, ne((0,
            p.array)(Xe)));
            if ("error"in e)
                throw new Wt(e.error,"failed to get cluster nodes");
            return e.result
        }
        async getVoteAccounts(t) {
            const e = this._buildArgs([], t)
              , n = await this._rpcRequest("getVoteAccounts", e)
              , r = (0,
            p.create)(n, Ke);
            if ("error"in r)
                throw new Wt(r.error,"failed to get vote accounts");
            return r.result
        }
        async getSlot(t) {
            const {commitment: e, config: n} = Jt(t)
              , r = this._buildArgs([], e, void 0, n)
              , i = await this._rpcRequest("getSlot", r)
              , s = (0,
            p.create)(i, ne((0,
            p.number)()));
            if ("error"in s)
                throw new Wt(s.error,"failed to get slot");
            return s.result
        }
        async getSlotLeader(t) {
            const {commitment: e, config: n} = Jt(t)
              , r = this._buildArgs([], e, void 0, n)
              , i = await this._rpcRequest("getSlotLeader", r)
              , s = (0,
            p.create)(i, ne((0,
            p.string)()));
            if ("error"in s)
                throw new Wt(s.error,"failed to get slot leader");
            return s.result
        }
        async getSlotLeaders(t, e) {
            const n = [t, e]
              , r = await this._rpcRequest("getSlotLeaders", n)
              , i = (0,
            p.create)(r, ne((0,
            p.array)(qt)));
            if ("error"in i)
                throw new Wt(i.error,"failed to get slot leaders");
            return i.result
        }
        async getSignatureStatus(t, e) {
            const {context: n, value: r} = await this.getSignatureStatuses([t], e);
            Q(1 === r.length);
            return {
                context: n,
                value: r[0]
            }
        }
        async getSignatureStatuses(t, e) {
            const n = [t];
            e && n.push(e);
            const r = await this._rpcRequest("getSignatureStatuses", n)
              , i = (0,
            p.create)(r, Je);
            if ("error"in i)
                throw new Wt(i.error,"failed to get signature status");
            return i.result
        }
        async getTransactionCount(t) {
            const {commitment: e, config: n} = Jt(t)
              , r = this._buildArgs([], e, void 0, n)
              , i = await this._rpcRequest("getTransactionCount", r)
              , s = (0,
            p.create)(i, ne((0,
            p.number)()));
            if ("error"in s)
                throw new Wt(s.error,"failed to get transaction count");
            return s.result
        }
        async getTotalSupply(t) {
            return (await this.getSupply({
                commitment: t,
                excludeNonCirculatingAccountsList: !0
            })).value.total
        }
        async getInflationGovernor(t) {
            const e = this._buildArgs([], t)
              , n = await this._rpcRequest("getInflationGovernor", e)
              , r = (0,
            p.create)(n, be);
            if ("error"in r)
                throw new Wt(r.error,"failed to get inflation");
            return r.result
        }
        async getInflationReward(t, e, n) {
            const {commitment: r, config: i} = Jt(n)
              , s = this._buildArgs([t.map((t=>t.toBase58()))], r, void 0, {
                ...i,
                epoch: null != e ? e : i?.epoch
            })
              , o = await this._rpcRequest("getInflationReward", s)
              , a = (0,
            p.create)(o, ae);
            if ("error"in a)
                throw new Wt(a.error,"failed to get inflation reward");
            return a.result
        }
        async getInflationRate() {
            const t = await this._rpcRequest("getInflationRate", [])
              , e = (0,
            p.create)(t, ve);
            if ("error"in e)
                throw new Wt(e.error,"failed to get inflation rate");
            return e.result
        }
        async getEpochInfo(t) {
            const {commitment: e, config: n} = Jt(t)
              , r = this._buildArgs([], e, void 0, n)
              , i = await this._rpcRequest("getEpochInfo", r)
              , s = (0,
            p.create)(i, we);
            if ("error"in s)
                throw new Wt(s.error,"failed to get epoch info");
            return s.result
        }
        async getEpochSchedule() {
            const t = await this._rpcRequest("getEpochSchedule", [])
              , e = (0,
            p.create)(t, xe);
            if ("error"in e)
                throw new Wt(e.error,"failed to get epoch schedule");
            const n = e.result;
            return new Ut(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)
        }
        async getLeaderSchedule() {
            const t = await this._rpcRequest("getLeaderSchedule", [])
              , e = (0,
            p.create)(t, Ee);
            if ("error"in e)
                throw new Wt(e.error,"failed to get leader schedule");
            return e.result
        }
        async getMinimumBalanceForRentExemption(t, e) {
            const n = this._buildArgs([t], e)
              , r = await this._rpcRequest("getMinimumBalanceForRentExemption", n)
              , i = (0,
            p.create)(r, tn);
            return "error"in i ? (console.warn("Unable to fetch minimum balance for rent exemption"),
            0) : i.result
        }
        async getRecentBlockhashAndContext(t) {
            const e = this._buildArgs([], t)
              , n = await this._rpcRequest("getRecentBlockhash", e)
              , r = (0,
            p.create)(n, In);
            if ("error"in r)
                throw new Wt(r.error,"failed to get recent blockhash");
            return r.result
        }
        async getRecentPerformanceSamples(t) {
            const e = await this._rpcRequest("getRecentPerformanceSamples", t ? [t] : [])
              , n = (0,
            p.create)(e, Pn);
            if ("error"in n)
                throw new Wt(n.error,"failed to get recent performance samples");
            return n.result
        }
        async getFeeCalculatorForBlockhash(t, e) {
            const n = this._buildArgs([t], e)
              , r = await this._rpcRequest("getFeeCalculatorForBlockhash", n)
              , i = (0,
            p.create)(r, On);
            if ("error"in i)
                throw new Wt(i.error,"failed to get fee calculator");
            const {context: s, value: o} = i.result;
            return {
                context: s,
                value: null !== o ? o.feeCalculator : null
            }
        }
        async getFeeForMessage(t, e) {
            const n = k(t.serialize()).toString("base64")
              , r = this._buildArgs([n], e)
              , i = await this._rpcRequest("getFeeForMessage", r)
              , s = (0,
            p.create)(i, re((0,
            p.nullable)((0,
            p.number)())));
            if ("error"in s)
                throw new Wt(s.error,"failed to get fee for message");
            if (null === s.result)
                throw new Error("invalid blockhash");
            return s.result
        }
        async getRecentBlockhash(t) {
            try {
                return (await this.getRecentBlockhashAndContext(t)).value
            } catch (t) {
                throw new Error("failed to get recent blockhash: " + t)
            }
        }
        async getLatestBlockhash(t) {
            try {
                return (await this.getLatestBlockhashAndContext(t)).value
            } catch (t) {
                throw new Error("failed to get recent blockhash: " + t)
            }
        }
        async getLatestBlockhashAndContext(t) {
            const {commitment: e, config: n} = Jt(t)
              , r = this._buildArgs([], e, void 0, n)
              , i = await this._rpcRequest("getLatestBlockhash", r)
              , s = (0,
            p.create)(i, Mn);
            if ("error"in s)
                throw new Wt(s.error,"failed to get latest blockhash");
            return s.result
        }
        async getVersion() {
            const t = await this._rpcRequest("getVersion", [])
              , e = (0,
            p.create)(t, ne(me));
            if ("error"in e)
                throw new Wt(e.error,"failed to get version");
            return e.result
        }
        async getGenesisHash() {
            const t = await this._rpcRequest("getGenesisHash", [])
              , e = (0,
            p.create)(t, ne((0,
            p.string)()));
            if ("error"in e)
                throw new Wt(e.error,"failed to get genesis hash");
            return e.result
        }
        async getBlock(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = this._buildArgsAtLeastConfirmed([t], n, void 0, r)
              , s = await this._rpcRequest("getBlock", i);
            try {
                switch (r?.transactionDetails) {
                case "accounts":
                    {
                        const t = (0,
                        p.create)(s, wn);
                        if ("error"in t)
                            throw t.error;
                        return t.result
                    }
                case "none":
                    {
                        const t = (0,
                        p.create)(s, vn);
                        if ("error"in t)
                            throw t.error;
                        return t.result
                    }
                default:
                    {
                        const t = (0,
                        p.create)(s, bn);
                        if ("error"in t)
                            throw t.error;
                        const {result: e} = t;
                        return e ? {
                            ...e,
                            transactions: e.transactions.map((({transaction: t, meta: e, version: n})=>({
                                meta: e,
                                transaction: {
                                    ...t,
                                    message: se(n, t.message)
                                },
                                version: n
                            })))
                        } : null
                    }
                }
            } catch (t) {
                throw new Wt(t,"failed to get confirmed block")
            }
        }
        async getParsedBlock(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r)
              , s = await this._rpcRequest("getBlock", i);
            try {
                switch (r?.transactionDetails) {
                case "accounts":
                    {
                        const t = (0,
                        p.create)(s, En);
                        if ("error"in t)
                            throw t.error;
                        return t.result
                    }
                case "none":
                    {
                        const t = (0,
                        p.create)(s, _n);
                        if ("error"in t)
                            throw t.error;
                        return t.result
                    }
                default:
                    {
                        const t = (0,
                        p.create)(s, xn);
                        if ("error"in t)
                            throw t.error;
                        return t.result
                    }
                }
            } catch (t) {
                throw new Wt(t,"failed to get block")
            }
        }
        async getBlockProduction(t) {
            let e, n;
            if ("string" == typeof t)
                n = t;
            else if (t) {
                const {commitment: r, ...i} = t;
                n = r,
                e = i
            }
            const r = this._buildArgs([], n, "base64", e)
              , i = await this._rpcRequest("getBlockProduction", r)
              , s = (0,
            p.create)(i, ye);
            if ("error"in s)
                throw new Wt(s.error,"failed to get block production information");
            return s.result
        }
        async getTransaction(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = this._buildArgsAtLeastConfirmed([t], n, void 0, r)
              , s = await this._rpcRequest("getTransaction", i)
              , o = (0,
            p.create)(s, Tn);
            if ("error"in o)
                throw new Wt(o.error,"failed to get transaction");
            const a = o.result;
            return a ? {
                ...a,
                transaction: {
                    ...a.transaction,
                    message: se(a.version, a.transaction.message)
                }
            } : a
        }
        async getParsedTransaction(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r)
              , s = await this._rpcRequest("getTransaction", i)
              , o = (0,
            p.create)(s, kn);
            if ("error"in o)
                throw new Wt(o.error,"failed to get transaction");
            return o.result
        }
        async getParsedTransactions(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = t.map((t=>({
                methodName: "getTransaction",
                args: this._buildArgsAtLeastConfirmed([t], n, "jsonParsed", r)
            })));
            return (await this._rpcBatchRequest(i)).map((t=>{
                const e = (0,
                p.create)(t, kn);
                if ("error"in e)
                    throw new Wt(e.error,"failed to get transactions");
                return e.result
            }
            ))
        }
        async getTransactions(t, e) {
            const {commitment: n, config: r} = Jt(e)
              , i = t.map((t=>({
                methodName: "getTransaction",
                args: this._buildArgsAtLeastConfirmed([t], n, void 0, r)
            })));
            return (await this._rpcBatchRequest(i)).map((t=>{
                const e = (0,
                p.create)(t, Tn);
                if ("error"in e)
                    throw new Wt(e.error,"failed to get transactions");
                const n = e.result;
                return n ? {
                    ...n,
                    transaction: {
                        ...n.transaction,
                        message: se(n.version, n.transaction.message)
                    }
                } : n
            }
            ))
        }
        async getConfirmedBlock(t, e) {
            const n = this._buildArgsAtLeastConfirmed([t], e)
              , r = await this._rpcRequest("getConfirmedBlock", n)
              , i = (0,
            p.create)(r, An);
            if ("error"in i)
                throw new Wt(i.error,"failed to get confirmed block");
            const s = i.result;
            if (!s)
                throw new Error("Confirmed block " + t + " not found");
            const o = {
                ...s,
                transactions: s.transactions.map((({transaction: t, meta: e})=>{
                    const n = new J(t.message);
                    return {
                        meta: e,
                        transaction: {
                            ...t,
                            message: n
                        }
                    }
                }
                ))
            };
            return {
                ...o,
                transactions: o.transactions.map((({transaction: t, meta: e})=>({
                    meta: e,
                    transaction: ot.populate(t.message, t.signatures)
                })))
            }
        }
        async getBlocks(t, e, n) {
            const r = this._buildArgsAtLeastConfirmed(void 0 !== e ? [t, e] : [t], n)
              , i = await this._rpcRequest("getBlocks", r)
              , s = (0,
            p.create)(i, ne((0,
            p.array)((0,
            p.number)())));
            if ("error"in s)
                throw new Wt(s.error,"failed to get blocks");
            return s.result
        }
        async getBlockSignatures(t, e) {
            const n = this._buildArgsAtLeastConfirmed([t], e, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            })
              , r = await this._rpcRequest("getBlock", n)
              , i = (0,
            p.create)(r, Sn);
            if ("error"in i)
                throw new Wt(i.error,"failed to get block");
            const s = i.result;
            if (!s)
                throw new Error("Block " + t + " not found");
            return s
        }
        async getConfirmedBlockSignatures(t, e) {
            const n = this._buildArgsAtLeastConfirmed([t], e, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            })
              , r = await this._rpcRequest("getConfirmedBlock", n)
              , i = (0,
            p.create)(r, Sn);
            if ("error"in i)
                throw new Wt(i.error,"failed to get confirmed block");
            const s = i.result;
            if (!s)
                throw new Error("Confirmed block " + t + " not found");
            return s
        }
        async getConfirmedTransaction(t, e) {
            const n = this._buildArgsAtLeastConfirmed([t], e)
              , r = await this._rpcRequest("getConfirmedTransaction", n)
              , i = (0,
            p.create)(r, Tn);
            if ("error"in i)
                throw new Wt(i.error,"failed to get transaction");
            const s = i.result;
            if (!s)
                return s;
            const o = new J(s.transaction.message)
              , a = s.transaction.signatures;
            return {
                ...s,
                transaction: ot.populate(o, a)
            }
        }
        async getParsedConfirmedTransaction(t, e) {
            const n = this._buildArgsAtLeastConfirmed([t], e, "jsonParsed")
              , r = await this._rpcRequest("getConfirmedTransaction", n)
              , i = (0,
            p.create)(r, kn);
            if ("error"in i)
                throw new Wt(i.error,"failed to get confirmed transaction");
            return i.result
        }
        async getParsedConfirmedTransactions(t, e) {
            const n = t.map((t=>({
                methodName: "getConfirmedTransaction",
                args: this._buildArgsAtLeastConfirmed([t], e, "jsonParsed")
            })));
            return (await this._rpcBatchRequest(n)).map((t=>{
                const e = (0,
                p.create)(t, kn);
                if ("error"in e)
                    throw new Wt(e.error,"failed to get confirmed transactions");
                return e.result
            }
            ))
        }
        async getConfirmedSignaturesForAddress(t, e, n) {
            let r = {}
              , i = await this.getFirstAvailableBlock();
            for (; !("until"in r) && !(--e <= 0 || e < i); )
                try {
                    const t = await this.getConfirmedBlockSignatures(e, "finalized");
                    t.signatures.length > 0 && (r.until = t.signatures[t.signatures.length - 1].toString())
                } catch (t) {
                    if (t instanceof Error && t.message.includes("skipped"))
                        continue;
                    throw t
                }
            let s = await this.getSlot("finalized");
            for (; !("before"in r || ++n > s); )
                try {
                    const t = await this.getConfirmedBlockSignatures(n);
                    t.signatures.length > 0 && (r.before = t.signatures[t.signatures.length - 1].toString())
                } catch (t) {
                    if (t instanceof Error && t.message.includes("skipped"))
                        continue;
                    throw t
                }
            return (await this.getConfirmedSignaturesForAddress2(t, r)).map((t=>t.signature))
        }
        async getConfirmedSignaturesForAddress2(t, e, n) {
            const r = this._buildArgsAtLeastConfirmed([t.toBase58()], n, void 0, e)
              , i = await this._rpcRequest("getConfirmedSignaturesForAddress2", r)
              , s = (0,
            p.create)(i, Le);
            if ("error"in s)
                throw new Wt(s.error,"failed to get confirmed signatures for address");
            return s.result
        }
        async getSignaturesForAddress(t, e, n) {
            const r = this._buildArgsAtLeastConfirmed([t.toBase58()], n, void 0, e)
              , i = await this._rpcRequest("getSignaturesForAddress", r)
              , s = (0,
            p.create)(i, Fe);
            if ("error"in s)
                throw new Wt(s.error,"failed to get signatures for address");
            return s.result
        }
        async getAddressLookupTable(t, e) {
            const {context: n, value: r} = await this.getAccountInfoAndContext(t, e);
            let i = null;
            return null !== r && (i = new $t({
                key: t,
                state: $t.deserialize(r.data)
            })),
            {
                context: n,
                value: i
            }
        }
        async getNonceAndContext(t, e) {
            const {context: n, value: r} = await this.getAccountInfoAndContext(t, e);
            let i = null;
            return null !== r && (i = St.fromAccountData(r.data)),
            {
                context: n,
                value: i
            }
        }
        async getNonce(t, e) {
            return await this.getNonceAndContext(t, e).then((t=>t.value)).catch((e=>{
                throw new Error("failed to get nonce for account " + t.toBase58() + ": " + e)
            }
            ))
        }
        async requestAirdrop(t, e) {
            const n = await this._rpcRequest("requestAirdrop", [t.toBase58(), e])
              , r = (0,
            p.create)(n, Nn);
            if ("error"in r)
                throw new Wt(r.error,`airdrop to ${t.toBase58()} failed`);
            return r.result
        }
        async _blockhashWithExpiryBlockHeight(t) {
            if (!t) {
                for (; this._pollingBlockhash; )
                    await vt(100);
                const t = Date.now() - this._blockhashInfo.lastFetch >= Zt;
                if (null !== this._blockhashInfo.latestBlockhash && !t)
                    return this._blockhashInfo.latestBlockhash
            }
            return await this._pollNewBlockhash()
        }
        async _pollNewBlockhash() {
            this._pollingBlockhash = !0;
            try {
                const t = Date.now()
                  , e = this._blockhashInfo.latestBlockhash
                  , n = e ? e.blockhash : null;
                for (let t = 0; t < 50; t++) {
                    const t = await this.getLatestBlockhash("finalized");
                    if (n !== t.blockhash)
                        return this._blockhashInfo = {
                            latestBlockhash: t,
                            lastFetch: Date.now(),
                            transactionSignatures: [],
                            simulatedSignatures: []
                        },
                        t;
                    await vt(200)
                }
                throw new Error(`Unable to obtain a new blockhash after ${Date.now() - t}ms`)
            } finally {
                this._pollingBlockhash = !1
            }
        }
        async getStakeMinimumDelegation(t) {
            const {commitment: e, config: n} = Jt(t)
              , r = this._buildArgs([], e, "base64", n)
              , i = await this._rpcRequest("getStakeMinimumDelegation", r)
              , s = (0,
            p.create)(i, re((0,
            p.number)()));
            if ("error"in s)
                throw new Wt(s.error,"failed to get stake minimum delegation");
            return s.result
        }
        async simulateTransaction(t, e, n) {
            if ("message"in t) {
                const r = t.serialize()
                  , s = i.Buffer.from(r).toString("base64");
                if (Array.isArray(e) || void 0 !== n)
                    throw new Error("Invalid arguments");
                const o = e || {};
                o.encoding = "base64",
                "commitment"in o || (o.commitment = this.commitment);
                const a = [s, o]
                  , l = await this._rpcRequest("simulateTransaction", a)
                  , c = (0,
                p.create)(l, ge);
                if ("error"in c)
                    throw new Error("failed to simulate transaction: " + c.error.message);
                return c.result
            }
            let r;
            if (t instanceof ot) {
                let e = t;
                r = new ot,
                r.feePayer = e.feePayer,
                r.instructions = t.instructions,
                r.nonceInfo = e.nonceInfo,
                r.signatures = e.signatures
            } else
                r = ot.populate(t),
                r._message = r._json = void 0;
            if (void 0 !== e && !Array.isArray(e))
                throw new Error("Invalid arguments");
            const s = e;
            if (r.nonceInfo && s)
                r.sign(...s);
            else {
                let t = this._disableBlockhashCaching;
                for (; ; ) {
                    const e = await this._blockhashWithExpiryBlockHeight(t);
                    if (r.lastValidBlockHeight = e.lastValidBlockHeight,
                    r.recentBlockhash = e.blockhash,
                    !s)
                        break;
                    if (r.sign(...s),
                    !r.signature)
                        throw new Error("!signature");
                    const n = r.signature.toString("base64");
                    if (!this._blockhashInfo.simulatedSignatures.includes(n) && !this._blockhashInfo.transactionSignatures.includes(n)) {
                        this._blockhashInfo.simulatedSignatures.push(n);
                        break
                    }
                    t = !0
                }
            }
            const o = r._compile()
              , a = o.serialize()
              , l = r._serialize(a).toString("base64")
              , c = {
                encoding: "base64",
                commitment: this.commitment
            };
            if (n) {
                const t = (Array.isArray(n) ? n : o.nonProgramIds()).map((t=>t.toBase58()));
                c.accounts = {
                    encoding: "base64",
                    addresses: t
                }
            }
            s && (c.sigVerify = !0);
            const u = [l, c]
              , h = await this._rpcRequest("simulateTransaction", u)
              , d = (0,
            p.create)(h, ge);
            if ("error"in d) {
                let t;
                if ("data"in d.error && (t = d.error.data.logs,
                t && Array.isArray(t))) {
                    const e = "\n    "
                      , n = e + t.join(e);
                    console.error(d.error.message, n)
                }
                throw new zt("failed to simulate transaction: " + d.error.message,t)
            }
            return d.result
        }
        async sendTransaction(t, e, n) {
            if ("version"in t) {
                if (e && Array.isArray(e))
                    throw new Error("Invalid arguments");
                const n = t.serialize();
                return await this.sendRawTransaction(n, e)
            }
            if (void 0 === e || !Array.isArray(e))
                throw new Error("Invalid arguments");
            const r = e;
            if (t.nonceInfo)
                t.sign(...r);
            else {
                let e = this._disableBlockhashCaching;
                for (; ; ) {
                    const n = await this._blockhashWithExpiryBlockHeight(e);
                    if (t.lastValidBlockHeight = n.lastValidBlockHeight,
                    t.recentBlockhash = n.blockhash,
                    t.sign(...r),
                    !t.signature)
                        throw new Error("!signature");
                    const i = t.signature.toString("base64");
                    if (!this._blockhashInfo.transactionSignatures.includes(i)) {
                        this._blockhashInfo.transactionSignatures.push(i);
                        break
                    }
                    e = !0
                }
            }
            const i = t.serialize();
            return await this.sendRawTransaction(i, n)
        }
        async sendRawTransaction(t, e) {
            const n = k(t).toString("base64");
            return await this.sendEncodedTransaction(n, e)
        }
        async sendEncodedTransaction(t, e) {
            const n = {
                encoding: "base64"
            }
              , r = e && e.skipPreflight
              , i = e && e.preflightCommitment || this.commitment;
            e && null != e.maxRetries && (n.maxRetries = e.maxRetries),
            e && null != e.minContextSlot && (n.minContextSlot = e.minContextSlot),
            r && (n.skipPreflight = r),
            i && (n.preflightCommitment = i);
            const s = [t, n]
              , o = await this._rpcRequest("sendTransaction", s)
              , a = (0,
            p.create)(o, Rn);
            if ("error"in a) {
                let t;
                throw "data"in a.error && (t = a.error.data.logs),
                new zt("failed to send transaction: " + a.error.message,t)
            }
            return a.result
        }
        _wsOnOpen() {
            this._rpcWebSocketConnected = !0,
            this._rpcWebSocketHeartbeat = setInterval((()=>{
                (async()=>{
                    try {
                        await this._rpcWebSocket.notify("ping")
                    } catch {}
                }
                )()
            }
            ), 5e3),
            this._updateSubscriptions()
        }
        _wsOnError(t) {
            this._rpcWebSocketConnected = !1,
            console.error("ws error:", t.message)
        }
        _wsOnClose(t) {
            this._rpcWebSocketConnected = !1,
            this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER,
            this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout),
            this._rpcWebSocketIdleTimeout = null),
            this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat),
            this._rpcWebSocketHeartbeat = null),
            1e3 !== t ? (this._subscriptionCallbacksByServerSubscriptionId = {},
            Object.entries(this._subscriptionsByHash).forEach((([t,e])=>{
                this._setSubscription(t, {
                    ...e,
                    state: "pending"
                })
            }
            ))) : this._updateSubscriptions()
        }
        _setSubscription(t, e) {
            const n = this._subscriptionsByHash[t]?.state;
            if (this._subscriptionsByHash[t] = e,
            n !== e.state) {
                const n = this._subscriptionStateChangeCallbacksByHash[t];
                n && n.forEach((t=>{
                    try {
                        t(e.state)
                    } catch {}
                }
                ))
            }
        }
        _onSubscriptionStateChange(t, e) {
            var n;
            const r = this._subscriptionHashByClientSubscriptionId[t];
            if (null == r)
                return ()=>{}
                ;
            const i = (n = this._subscriptionStateChangeCallbacksByHash)[r] || (n[r] = new Set);
            return i.add(e),
            ()=>{
                i.delete(e),
                0 === i.size && delete this._subscriptionStateChangeCallbacksByHash[r]
            }
        }
        async _updateSubscriptions() {
            if (0 === Object.keys(this._subscriptionsByHash).length)
                return void (this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1,
                this._rpcWebSocketIdleTimeout = setTimeout((()=>{
                    this._rpcWebSocketIdleTimeout = null;
                    try {
                        this._rpcWebSocket.close()
                    } catch (t) {
                        t instanceof Error && console.log(`Error when closing socket connection: ${t.message}`)
                    }
                }
                ), 500)));
            if (null !== this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout),
            this._rpcWebSocketIdleTimeout = null,
            this._rpcWebSocketConnected = !0),
            !this._rpcWebSocketConnected)
                return void this._rpcWebSocket.connect();
            const t = this._rpcWebSocketGeneration
              , e = ()=>t === this._rpcWebSocketGeneration;
            await Promise.all(Object.keys(this._subscriptionsByHash).map((async t=>{
                const n = this._subscriptionsByHash[t];
                if (void 0 !== n)
                    switch (n.state) {
                    case "pending":
                    case "unsubscribed":
                        if (0 === n.callbacks.size)
                            return delete this._subscriptionsByHash[t],
                            "unsubscribed" === n.state && delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId],
                            void await this._updateSubscriptions();
                        await (async()=>{
                            const {args: r, method: i} = n;
                            try {
                                this._setSubscription(t, {
                                    ...n,
                                    state: "subscribing"
                                });
                                const e = await this._rpcWebSocket.call(i, r);
                                this._setSubscription(t, {
                                    ...n,
                                    serverSubscriptionId: e,
                                    state: "subscribed"
                                }),
                                this._subscriptionCallbacksByServerSubscriptionId[e] = n.callbacks,
                                await this._updateSubscriptions()
                            } catch (s) {
                                if (s instanceof Error && console.error(`${i} error for argument`, r, s.message),
                                !e())
                                    return;
                                this._setSubscription(t, {
                                    ...n,
                                    state: "pending"
                                }),
                                await this._updateSubscriptions()
                            }
                        }
                        )();
                        break;
                    case "subscribed":
                        0 === n.callbacks.size && await (async()=>{
                            const {serverSubscriptionId: r, unsubscribeMethod: i} = n;
                            if (this._subscriptionsAutoDisposedByRpc.has(r))
                                this._subscriptionsAutoDisposedByRpc.delete(r);
                            else {
                                this._setSubscription(t, {
                                    ...n,
                                    state: "unsubscribing"
                                }),
                                this._setSubscription(t, {
                                    ...n,
                                    state: "unsubscribing"
                                });
                                try {
                                    await this._rpcWebSocket.call(i, [r])
                                } catch (r) {
                                    if (r instanceof Error && console.error(`${i} error:`, r.message),
                                    !e())
                                        return;
                                    return this._setSubscription(t, {
                                        ...n,
                                        state: "subscribed"
                                    }),
                                    void await this._updateSubscriptions()
                                }
                            }
                            this._setSubscription(t, {
                                ...n,
                                state: "unsubscribed"
                            }),
                            await this._updateSubscriptions()
                        }
                        )()
                    }
            }
            )))
        }
        _handleServerNotification(t, e) {
            const n = this._subscriptionCallbacksByServerSubscriptionId[t];
            void 0 !== n && n.forEach((t=>{
                try {
                    t(...e)
                } catch (t) {
                    console.error(t)
                }
            }
            ))
        }
        _wsOnAccountNotification(t) {
            const {result: e, subscription: n} = (0,
            p.create)(t, je);
            this._handleServerNotification(n, [e.value, e.context])
        }
        _makeSubscription(t, e) {
            const n = this._nextClientSubscriptionId++
              , r = Ft([t.method, e])
              , i = this._subscriptionsByHash[r];
            return void 0 === i ? this._subscriptionsByHash[r] = {
                ...t,
                args: e,
                callbacks: new Set([t.callback]),
                state: "pending"
            } : i.callbacks.add(t.callback),
            this._subscriptionHashByClientSubscriptionId[n] = r,
            this._subscriptionDisposeFunctionsByClientSubscriptionId[n] = async()=>{
                delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],
                delete this._subscriptionHashByClientSubscriptionId[n];
                const e = this._subscriptionsByHash[r];
                Q(void 0 !== e, `Could not find a \`Subscription\` when tearing down client subscription #${n}`),
                e.callbacks.delete(t.callback),
                await this._updateSubscriptions()
            }
            ,
            this._updateSubscriptions(),
            n
        }
        onAccountChange(t, e, n) {
            const r = this._buildArgs([t.toBase58()], n || this._commitment || "finalized", "base64");
            return this._makeSubscription({
                callback: e,
                method: "accountSubscribe",
                unsubscribeMethod: "accountUnsubscribe"
            }, r)
        }
        async removeAccountChangeListener(t) {
            await this._unsubscribeClientSubscription(t, "account change")
        }
        _wsOnProgramAccountNotification(t) {
            const {result: e, subscription: n} = (0,
            p.create)(t, ze);
            this._handleServerNotification(n, [{
                accountId: e.value.pubkey,
                accountInfo: e.value.account
            }, e.context])
        }
        onProgramAccountChange(t, e, n, r) {
            const i = this._buildArgs([t.toBase58()], n || this._commitment || "finalized", "base64", r ? {
                filters: r
            } : void 0);
            return this._makeSubscription({
                callback: e,
                method: "programSubscribe",
                unsubscribeMethod: "programUnsubscribe"
            }, i)
        }
        async removeProgramAccountChangeListener(t) {
            await this._unsubscribeClientSubscription(t, "program account change")
        }
        onLogs(t, e, n) {
            const r = this._buildArgs(["object" == typeof t ? {
                mentions: [t.toString()]
            } : t], n || this._commitment || "finalized");
            return this._makeSubscription({
                callback: e,
                method: "logsSubscribe",
                unsubscribeMethod: "logsUnsubscribe"
            }, r)
        }
        async removeOnLogsListener(t) {
            await this._unsubscribeClientSubscription(t, "logs")
        }
        _wsOnLogsNotification(t) {
            const {result: e, subscription: n} = (0,
            p.create)(t, Bn);
            this._handleServerNotification(n, [e.value, e.context])
        }
        _wsOnSlotNotification(t) {
            const {result: e, subscription: n} = (0,
            p.create)(t, We);
            this._handleServerNotification(n, [e])
        }
        onSlotChange(t) {
            return this._makeSubscription({
                callback: t,
                method: "slotSubscribe",
                unsubscribeMethod: "slotUnsubscribe"
            }, [])
        }
        async removeSlotChangeListener(t) {
            await this._unsubscribeClientSubscription(t, "slot change")
        }
        _wsOnSlotUpdatesNotification(t) {
            const {result: e, subscription: n} = (0,
            p.create)(t, He);
            this._handleServerNotification(n, [e])
        }
        onSlotUpdate(t) {
            return this._makeSubscription({
                callback: t,
                method: "slotsUpdatesSubscribe",
                unsubscribeMethod: "slotsUpdatesUnsubscribe"
            }, [])
        }
        async removeSlotUpdateListener(t) {
            await this._unsubscribeClientSubscription(t, "slot update")
        }
        async _unsubscribeClientSubscription(t, e) {
            const n = this._subscriptionDisposeFunctionsByClientSubscriptionId[t];
            n ? await n() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${e}' events could not be found.`)
        }
        _buildArgs(t, e, n, r) {
            const i = e || this._commitment;
            if (i || n || r) {
                let e = {};
                n && (e.encoding = n),
                i && (e.commitment = i),
                r && (e = Object.assign(e, r)),
                t.push(e)
            }
            return t
        }
        _buildArgsAtLeastConfirmed(t, e, n, r) {
            const i = e || this._commitment;
            if (i && !["confirmed", "finalized"].includes(i))
                throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
            return this._buildArgs(t, e, n, r)
        }
        _wsOnSignatureNotification(t) {
            const {result: e, subscription: n} = (0,
            p.create)(t, $e);
            "receivedSignature" !== e.value && this._subscriptionsAutoDisposedByRpc.add(n),
            this._handleServerNotification(n, "receivedSignature" === e.value ? [{
                type: "received"
            }, e.context] : [{
                type: "status",
                result: e.value
            }, e.context])
        }
        onSignature(t, e, n) {
            const r = this._buildArgs([t], n || this._commitment || "finalized")
              , i = this._makeSubscription({
                callback: (t,n)=>{
                    if ("status" === t.type) {
                        e(t.result, n);
                        try {
                            this.removeSignatureListener(i)
                        } catch (t) {}
                    }
                }
                ,
                method: "signatureSubscribe",
                unsubscribeMethod: "signatureUnsubscribe"
            }, r);
            return i
        }
        onSignatureWithOptions(t, e, n) {
            const {commitment: r, ...i} = {
                ...n,
                commitment: n && n.commitment || this._commitment || "finalized"
            }
              , s = this._buildArgs([t], r, void 0, i)
              , o = this._makeSubscription({
                callback: (t,n)=>{
                    e(t, n);
                    try {
                        this.removeSignatureListener(o)
                    } catch (t) {}
                }
                ,
                method: "signatureSubscribe",
                unsubscribeMethod: "signatureUnsubscribe"
            }, s);
            return o
        }
        async removeSignatureListener(t) {
            await this._unsubscribeClientSubscription(t, "signature result")
        }
        _wsOnRootNotification(t) {
            const {result: e, subscription: n} = (0,
            p.create)(t, Ge);
            this._handleServerNotification(n, [e])
        }
        onRootChange(t) {
            return this._makeSubscription({
                callback: t,
                method: "rootSubscribe",
                unsubscribeMethod: "rootUnsubscribe"
            }, [])
        }
        async removeRootChangeListener(t) {
            await this._unsubscribeClientSubscription(t, "root change")
        }
    }
    class jn {
        constructor(t) {
            this._keypair = void 0,
            this._keypair = t ?? E()
        }
        static generate() {
            return new jn(E())
        }
        static fromSecretKey(t, e) {
            if (64 !== t.byteLength)
                throw new Error("bad secret key size");
            const n = t.slice(32, 64);
            if (!e || !e.skipValidation) {
                const e = t.slice(0, 32)
                  , r = _(e);
                for (let t = 0; t < 32; t++)
                    if (n[t] !== r[t])
                        throw new Error("provided secretKey is invalid")
            }
            return new jn({
                publicKey: n,
                secretKey: t
            })
        }
        static fromSeed(t) {
            const e = _(t)
              , n = new Uint8Array(64);
            return n.set(t),
            n.set(e, 32),
            new jn({
                publicKey: e,
                secretKey: n
            })
        }
        get publicKey() {
            return new D(this._keypair.publicKey)
        }
        get secretKey() {
            return new Uint8Array(this._keypair.secretKey)
        }
    }
    const Un = Object.freeze({
        CreateLookupTable: {
            index: 0,
            layout: d.struct([d.u32("instruction"), Tt("recentSlot"), d.u8("bumpSeed")])
        },
        FreezeLookupTable: {
            index: 1,
            layout: d.struct([d.u32("instruction")])
        },
        ExtendLookupTable: {
            index: 2,
            layout: d.struct([d.u32("instruction"), Tt(), d.seq(H(), d.offset(d.u32(), -8), "addresses")])
        },
        DeactivateLookupTable: {
            index: 3,
            layout: d.struct([d.u32("instruction")])
        },
        CloseLookupTable: {
            index: 4,
            layout: d.struct([d.u32("instruction")])
        }
    });
    class zn {
        constructor() {}
        static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = d.u32("instruction").decode(t.data);
            let n;
            for (const [t,r] of Object.entries(Un))
                if (r.index == e) {
                    n = t;
                    break
                }
            if (!n)
                throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
            return n
        }
        static decodeCreateLookupTable(t) {
            this.checkProgramId(t.programId),
            this.checkKeysLength(t.keys, 4);
            const {recentSlot: e} = xt(Un.CreateLookupTable, t.data);
            return {
                authority: t.keys[1].pubkey,
                payer: t.keys[2].pubkey,
                recentSlot: Number(e)
            }
        }
        static decodeExtendLookupTable(t) {
            if (this.checkProgramId(t.programId),
            t.keys.length < 2)
                throw new Error(`invalid instruction; found ${t.keys.length} keys, expected at least 2`);
            const {addresses: e} = xt(Un.ExtendLookupTable, t.data);
            return {
                lookupTable: t.keys[0].pubkey,
                authority: t.keys[1].pubkey,
                payer: t.keys.length > 2 ? t.keys[2].pubkey : void 0,
                addresses: e.map((t=>new D(t)))
            }
        }
        static decodeCloseLookupTable(t) {
            return this.checkProgramId(t.programId),
            this.checkKeysLength(t.keys, 3),
            {
                lookupTable: t.keys[0].pubkey,
                authority: t.keys[1].pubkey,
                recipient: t.keys[2].pubkey
            }
        }
        static decodeFreezeLookupTable(t) {
            return this.checkProgramId(t.programId),
            this.checkKeysLength(t.keys, 2),
            {
                lookupTable: t.keys[0].pubkey,
                authority: t.keys[1].pubkey
            }
        }
        static decodeDeactivateLookupTable(t) {
            return this.checkProgramId(t.programId),
            this.checkKeysLength(t.keys, 2),
            {
                lookupTable: t.keys[0].pubkey,
                authority: t.keys[1].pubkey
            }
        }
        static checkProgramId(t) {
            if (!t.equals(Vn.programId))
                throw new Error("invalid instruction; programId is not AddressLookupTable Program")
        }
        static checkKeysLength(t, e) {
            if (t.length < e)
                throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)
        }
    }
    class Vn {
        constructor() {}
        static createLookupTable(t) {
            const [e,n] = D.findProgramAddressSync([t.authority.toBuffer(), (0,
            f.toBufferLE)(BigInt(t.recentSlot), 8)], this.programId)
              , r = wt(Un.CreateLookupTable, {
                recentSlot: BigInt(t.recentSlot),
                bumpSeed: n
            })
              , i = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: t.authority,
                isSigner: !0,
                isWritable: !1
            }, {
                pubkey: t.payer,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: Ct.programId,
                isSigner: !1,
                isWritable: !1
            }];
            return [new st({
                programId: this.programId,
                keys: i,
                data: r
            }), e]
        }
        static freezeLookupTable(t) {
            const e = wt(Un.FreezeLookupTable)
              , n = [{
                pubkey: t.lookupTable,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: t.authority,
                isSigner: !0,
                isWritable: !1
            }];
            return new st({
                programId: this.programId,
                keys: n,
                data: e
            })
        }
        static extendLookupTable(t) {
            const e = wt(Un.ExtendLookupTable, {
                addresses: t.addresses.map((t=>t.toBytes()))
            })
              , n = [{
                pubkey: t.lookupTable,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: t.authority,
                isSigner: !0,
                isWritable: !1
            }];
            return t.payer && n.push({
                pubkey: t.payer,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: Ct.programId,
                isSigner: !1,
                isWritable: !1
            }),
            new st({
                programId: this.programId,
                keys: n,
                data: e
            })
        }
        static deactivateLookupTable(t) {
            const e = wt(Un.DeactivateLookupTable)
              , n = [{
                pubkey: t.lookupTable,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: t.authority,
                isSigner: !0,
                isWritable: !1
            }];
            return new st({
                programId: this.programId,
                keys: n,
                data: e
            })
        }
        static closeLookupTable(t) {
            const e = wt(Un.CloseLookupTable)
              , n = [{
                pubkey: t.lookupTable,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: t.authority,
                isSigner: !0,
                isWritable: !1
            }, {
                pubkey: t.recipient,
                isSigner: !1,
                isWritable: !0
            }];
            return new st({
                programId: this.programId,
                keys: n,
                data: e
            })
        }
    }
    Vn.programId = new D("AddressLookupTab1e1111111111111111111111111");
    class Wn {
        constructor() {}
        static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = d.u8("instruction").decode(t.data);
            let n;
            for (const [t,r] of Object.entries(Yn))
                if (r.index == e) {
                    n = t;
                    break
                }
            if (!n)
                throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
            return n
        }
        static decodeRequestUnits(t) {
            this.checkProgramId(t.programId);
            const {units: e, additionalFee: n} = xt(Yn.RequestUnits, t.data);
            return {
                units: e,
                additionalFee: n
            }
        }
        static decodeRequestHeapFrame(t) {
            this.checkProgramId(t.programId);
            const {bytes: e} = xt(Yn.RequestHeapFrame, t.data);
            return {
                bytes: e
            }
        }
        static decodeSetComputeUnitLimit(t) {
            this.checkProgramId(t.programId);
            const {units: e} = xt(Yn.SetComputeUnitLimit, t.data);
            return {
                units: e
            }
        }
        static decodeSetComputeUnitPrice(t) {
            this.checkProgramId(t.programId);
            const {microLamports: e} = xt(Yn.SetComputeUnitPrice, t.data);
            return {
                microLamports: e
            }
        }
        static checkProgramId(t) {
            if (!t.equals(Hn.programId))
                throw new Error("invalid instruction; programId is not ComputeBudgetProgram")
        }
    }
    const Yn = Object.freeze({
        RequestUnits: {
            index: 0,
            layout: d.struct([d.u8("instruction"), d.u32("units"), d.u32("additionalFee")])
        },
        RequestHeapFrame: {
            index: 1,
            layout: d.struct([d.u8("instruction"), d.u32("bytes")])
        },
        SetComputeUnitLimit: {
            index: 2,
            layout: d.struct([d.u8("instruction"), d.u32("units")])
        },
        SetComputeUnitPrice: {
            index: 3,
            layout: d.struct([d.u8("instruction"), Tt("microLamports")])
        }
    });
    class Hn {
        constructor() {}
        static requestUnits(t) {
            const e = wt(Yn.RequestUnits, t);
            return new st({
                keys: [],
                programId: this.programId,
                data: e
            })
        }
        static requestHeapFrame(t) {
            const e = wt(Yn.RequestHeapFrame, t);
            return new st({
                keys: [],
                programId: this.programId,
                data: e
            })
        }
        static setComputeUnitLimit(t) {
            const e = wt(Yn.SetComputeUnitLimit, t);
            return new st({
                keys: [],
                programId: this.programId,
                data: e
            })
        }
        static setComputeUnitPrice(t) {
            const e = wt(Yn.SetComputeUnitPrice, {
                microLamports: BigInt(t.microLamports)
            });
            return new st({
                keys: [],
                programId: this.programId,
                data: e
            })
        }
    }
    Hn.programId = new D("ComputeBudget111111111111111111111111111111");
    const $n = d.struct([d.u8("numSignatures"), d.u8("padding"), d.u16("signatureOffset"), d.u16("signatureInstructionIndex"), d.u16("publicKeyOffset"), d.u16("publicKeyInstructionIndex"), d.u16("messageDataOffset"), d.u16("messageDataSize"), d.u16("messageInstructionIndex")]);
    class Gn {
        constructor() {}
        static createInstructionWithPublicKey(t) {
            const {publicKey: e, message: n, signature: r, instructionIndex: s} = t;
            Q(32 === e.length, `Public Key must be 32 bytes but received ${e.length} bytes`),
            Q(64 === r.length, `Signature must be 64 bytes but received ${r.length} bytes`);
            const o = $n.span
              , a = o + e.length
              , l = a + r.length
              , c = i.Buffer.alloc(l + n.length)
              , u = null == s ? 65535 : s;
            return $n.encode({
                numSignatures: 1,
                padding: 0,
                signatureOffset: a,
                signatureInstructionIndex: u,
                publicKeyOffset: o,
                publicKeyInstructionIndex: u,
                messageDataOffset: l,
                messageDataSize: n.length,
                messageInstructionIndex: u
            }, c),
            c.fill(e, o),
            c.fill(r, a),
            c.fill(n, l),
            new st({
                keys: [],
                programId: Gn.programId,
                data: c
            })
        }
        static createInstructionWithPrivateKey(t) {
            const {privateKey: e, message: n, instructionIndex: r} = t;
            Q(64 === e.length, `Private key must be 64 bytes but received ${e.length} bytes`);
            try {
                const t = jn.fromSecretKey(e)
                  , i = t.publicKey.toBytes()
                  , s = S(n, t.secretKey);
                return this.createInstructionWithPublicKey({
                    publicKey: i,
                    message: n,
                    signature: s,
                    instructionIndex: r
                })
            } catch (t) {
                throw new Error(`Error creating instruction; ${t}`)
            }
        }
    }
    Gn.programId = new D("Ed25519SigVerify111111111111111111111111111"),
    w.utils.hmacSha256Sync = (t,...e)=>{
        const n = v.hmac.create(u.sha256, t);
        return e.forEach((t=>n.update(t))),
        n.digest()
    }
    ;
    w.utils.isValidPrivateKey;
    const Xn = w.getPublicKey
      , qn = d.struct([d.u8("numSignatures"), d.u16("signatureOffset"), d.u8("signatureInstructionIndex"), d.u16("ethAddressOffset"), d.u8("ethAddressInstructionIndex"), d.u16("messageDataOffset"), d.u16("messageDataSize"), d.u8("messageInstructionIndex"), d.blob(20, "ethAddress"), d.blob(64, "signature"), d.u8("recoveryId")]);
    class Kn {
        constructor() {}
        static publicKeyToEthAddress(t) {
            Q(64 === t.length, `Public key must be 64 bytes but received ${t.length} bytes`);
            try {
                return i.Buffer.from((0,
                b.keccak_256)(k(t))).slice(-20)
            } catch (t) {
                throw new Error(`Error constructing Ethereum address: ${t}`)
            }
        }
        static createInstructionWithPublicKey(t) {
            const {publicKey: e, message: n, signature: r, recoveryId: i, instructionIndex: s} = t;
            return Kn.createInstructionWithEthAddress({
                ethAddress: Kn.publicKeyToEthAddress(e),
                message: n,
                signature: r,
                recoveryId: i,
                instructionIndex: s
            })
        }
        static createInstructionWithEthAddress(t) {
            const {ethAddress: e, message: n, signature: r, recoveryId: s, instructionIndex: o=0} = t;
            let a;
            a = "string" == typeof e ? e.startsWith("0x") ? i.Buffer.from(e.substr(2), "hex") : i.Buffer.from(e, "hex") : e,
            Q(20 === a.length, `Address must be 20 bytes but received ${a.length} bytes`);
            const l = 12 + a.length
              , c = l + r.length + 1
              , u = i.Buffer.alloc(qn.span + n.length);
            return qn.encode({
                numSignatures: 1,
                signatureOffset: l,
                signatureInstructionIndex: o,
                ethAddressOffset: 12,
                ethAddressInstructionIndex: o,
                messageDataOffset: c,
                messageDataSize: n.length,
                messageInstructionIndex: o,
                signature: k(r),
                ethAddress: k(a),
                recoveryId: s
            }, u),
            u.fill(k(n), qn.span),
            new st({
                keys: [],
                programId: Kn.programId,
                data: u
            })
        }
        static createInstructionWithPrivateKey(t) {
            const {privateKey: e, message: n, instructionIndex: r} = t;
            Q(32 === e.length, `Private key must be 32 bytes but received ${e.length} bytes`);
            try {
                const t = k(e)
                  , a = Xn(t, !1).slice(1)
                  , l = i.Buffer.from((0,
                b.keccak_256)(k(n)))
                  , [c,u] = (s = l,
                o = t,
                w.signSync(s, o, {
                    der: !1,
                    recovered: !0
                }));
                return this.createInstructionWithPublicKey({
                    publicKey: a,
                    message: n,
                    signature: c,
                    recoveryId: u,
                    instructionIndex: r
                })
            } catch (t) {
                throw new Error(`Error creating instruction; ${t}`)
            }
            var s, o
        }
    }
    Kn.programId = new D("KeccakSecp256k11111111111111111111111111111");
    const Qn = new D("StakeConfig11111111111111111111111111111111");
    class Zn {
        constructor(t, e) {
            this.staker = void 0,
            this.withdrawer = void 0,
            this.staker = t,
            this.withdrawer = e
        }
    }
    class Jn {
        constructor(t, e, n) {
            this.unixTimestamp = void 0,
            this.epoch = void 0,
            this.custodian = void 0,
            this.unixTimestamp = t,
            this.epoch = e,
            this.custodian = n
        }
    }
    Jn.default = new Jn(0,0,D.default);
    class tr {
        constructor() {}
        static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = d.u32("instruction").decode(t.data);
            let n;
            for (const [t,r] of Object.entries(er))
                if (r.index == e) {
                    n = t;
                    break
                }
            if (!n)
                throw new Error("Instruction type incorrect; not a StakeInstruction");
            return n
        }
        static decodeInitialize(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 2);
            const {authorized: e, lockup: n} = xt(er.Initialize, t.data);
            return {
                stakePubkey: t.keys[0].pubkey,
                authorized: new Zn(new D(e.staker),new D(e.withdrawer)),
                lockup: new Jn(n.unixTimestamp,n.epoch,new D(n.custodian))
            }
        }
        static decodeDelegate(t) {
            return this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 6),
            xt(er.Delegate, t.data),
            {
                stakePubkey: t.keys[0].pubkey,
                votePubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[5].pubkey
            }
        }
        static decodeAuthorize(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3);
            const {newAuthorized: e, stakeAuthorizationType: n} = xt(er.Authorize, t.data)
              , r = {
                stakePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
                newAuthorizedPubkey: new D(e),
                stakeAuthorizationType: {
                    index: n
                }
            };
            return t.keys.length > 3 && (r.custodianPubkey = t.keys[3].pubkey),
            r
        }
        static decodeAuthorizeWithSeed(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 2);
            const {newAuthorized: e, stakeAuthorizationType: n, authoritySeed: r, authorityOwner: i} = xt(er.AuthorizeWithSeed, t.data)
              , s = {
                stakePubkey: t.keys[0].pubkey,
                authorityBase: t.keys[1].pubkey,
                authoritySeed: r,
                authorityOwner: new D(i),
                newAuthorizedPubkey: new D(e),
                stakeAuthorizationType: {
                    index: n
                }
            };
            return t.keys.length > 3 && (s.custodianPubkey = t.keys[3].pubkey),
            s
        }
        static decodeSplit(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3);
            const {lamports: e} = xt(er.Split, t.data);
            return {
                stakePubkey: t.keys[0].pubkey,
                splitStakePubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
                lamports: e
            }
        }
        static decodeMerge(t) {
            return this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3),
            xt(er.Merge, t.data),
            {
                stakePubkey: t.keys[0].pubkey,
                sourceStakePubKey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[4].pubkey
            }
        }
        static decodeWithdraw(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 5);
            const {lamports: e} = xt(er.Withdraw, t.data)
              , n = {
                stakePubkey: t.keys[0].pubkey,
                toPubkey: t.keys[1].pubkey,
                authorizedPubkey: t.keys[4].pubkey,
                lamports: e
            };
            return t.keys.length > 5 && (n.custodianPubkey = t.keys[5].pubkey),
            n
        }
        static decodeDeactivate(t) {
            return this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3),
            xt(er.Deactivate, t.data),
            {
                stakePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey
            }
        }
        static checkProgramId(t) {
            if (!t.equals(rr.programId))
                throw new Error("invalid instruction; programId is not StakeProgram")
        }
        static checkKeyLength(t, e) {
            if (t.length < e)
                throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)
        }
    }
    const er = Object.freeze({
        Initialize: {
            index: 0,
            layout: d.struct([d.u32("instruction"), ((t="authorized")=>d.struct([H("staker"), H("withdrawer")], t))(), ((t="lockup")=>d.struct([d.ns64("unixTimestamp"), d.ns64("epoch"), H("custodian")], t))()])
        },
        Authorize: {
            index: 1,
            layout: d.struct([d.u32("instruction"), H("newAuthorized"), d.u32("stakeAuthorizationType")])
        },
        Delegate: {
            index: 2,
            layout: d.struct([d.u32("instruction")])
        },
        Split: {
            index: 3,
            layout: d.struct([d.u32("instruction"), d.ns64("lamports")])
        },
        Withdraw: {
            index: 4,
            layout: d.struct([d.u32("instruction"), d.ns64("lamports")])
        },
        Deactivate: {
            index: 5,
            layout: d.struct([d.u32("instruction")])
        },
        Merge: {
            index: 7,
            layout: d.struct([d.u32("instruction")])
        },
        AuthorizeWithSeed: {
            index: 8,
            layout: d.struct([d.u32("instruction"), H("newAuthorized"), d.u32("stakeAuthorizationType"), G("authoritySeed"), H("authorityOwner")])
        }
    })
      , nr = Object.freeze({
        Staker: {
            index: 0
        },
        Withdrawer: {
            index: 1
        }
    });
    class rr {
        constructor() {}
        static initialize(t) {
            const {stakePubkey: e, authorized: n, lockup: r} = t
              , i = r || Jn.default
              , s = wt(er.Initialize, {
                authorized: {
                    staker: k(n.staker.toBuffer()),
                    withdrawer: k(n.withdrawer.toBuffer())
                },
                lockup: {
                    unixTimestamp: i.unixTimestamp,
                    epoch: i.epoch,
                    custodian: k(i.custodian.toBuffer())
                }
            })
              , o = {
                keys: [{
                    pubkey: e,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: ft,
                    isSigner: !1,
                    isWritable: !1
                }],
                programId: this.programId,
                data: s
            };
            return new st(o)
        }
        static createAccountWithSeed(t) {
            const e = new ot;
            e.add(Ct.createAccountWithSeed({
                fromPubkey: t.fromPubkey,
                newAccountPubkey: t.stakePubkey,
                basePubkey: t.basePubkey,
                seed: t.seed,
                lamports: t.lamports,
                space: this.space,
                programId: this.programId
            }));
            const {stakePubkey: n, authorized: r, lockup: i} = t;
            return e.add(this.initialize({
                stakePubkey: n,
                authorized: r,
                lockup: i
            }))
        }
        static createAccount(t) {
            const e = new ot;
            e.add(Ct.createAccount({
                fromPubkey: t.fromPubkey,
                newAccountPubkey: t.stakePubkey,
                lamports: t.lamports,
                space: this.space,
                programId: this.programId
            }));
            const {stakePubkey: n, authorized: r, lockup: i} = t;
            return e.add(this.initialize({
                stakePubkey: n,
                authorized: r,
                lockup: i
            }))
        }
        static delegate(t) {
            const {stakePubkey: e, authorizedPubkey: n, votePubkey: r} = t
              , i = wt(er.Delegate);
            return (new ot).add({
                keys: [{
                    pubkey: e,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: ct,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: yt,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: Qn,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }],
                programId: this.programId,
                data: i
            })
        }
        static authorize(t) {
            const {stakePubkey: e, authorizedPubkey: n, newAuthorizedPubkey: r, stakeAuthorizationType: i, custodianPubkey: s} = t
              , o = wt(er.Authorize, {
                newAuthorized: k(r.toBuffer()),
                stakeAuthorizationType: i.index
            })
              , a = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: ct,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !0,
                isWritable: !1
            }];
            return s && a.push({
                pubkey: s,
                isSigner: !1,
                isWritable: !1
            }),
            (new ot).add({
                keys: a,
                programId: this.programId,
                data: o
            })
        }
        static authorizeWithSeed(t) {
            const {stakePubkey: e, authorityBase: n, authoritySeed: r, authorityOwner: i, newAuthorizedPubkey: s, stakeAuthorizationType: o, custodianPubkey: a} = t
              , l = wt(er.AuthorizeWithSeed, {
                newAuthorized: k(s.toBuffer()),
                stakeAuthorizationType: o.index,
                authoritySeed: r,
                authorityOwner: k(i.toBuffer())
            })
              , c = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !0,
                isWritable: !1
            }, {
                pubkey: ct,
                isSigner: !1,
                isWritable: !1
            }];
            return a && c.push({
                pubkey: a,
                isSigner: !1,
                isWritable: !1
            }),
            (new ot).add({
                keys: c,
                programId: this.programId,
                data: l
            })
        }
        static splitInstruction(t) {
            const {stakePubkey: e, authorizedPubkey: n, splitStakePubkey: r, lamports: i} = t
              , s = wt(er.Split, {
                lamports: i
            });
            return new st({
                keys: [{
                    pubkey: e,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }],
                programId: this.programId,
                data: s
            })
        }
        static split(t) {
            const e = new ot;
            return e.add(Ct.createAccount({
                fromPubkey: t.authorizedPubkey,
                newAccountPubkey: t.splitStakePubkey,
                lamports: 0,
                space: this.space,
                programId: this.programId
            })),
            e.add(this.splitInstruction(t))
        }
        static splitWithSeed(t) {
            const {stakePubkey: e, authorizedPubkey: n, splitStakePubkey: r, basePubkey: i, seed: s, lamports: o} = t
              , a = new ot;
            return a.add(Ct.allocate({
                accountPubkey: r,
                basePubkey: i,
                seed: s,
                space: this.space,
                programId: this.programId
            })),
            a.add(this.splitInstruction({
                stakePubkey: e,
                authorizedPubkey: n,
                splitStakePubkey: r,
                lamports: o
            }))
        }
        static merge(t) {
            const {stakePubkey: e, sourceStakePubKey: n, authorizedPubkey: r} = t
              , i = wt(er.Merge);
            return (new ot).add({
                keys: [{
                    pubkey: e,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: ct,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: yt,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }],
                programId: this.programId,
                data: i
            })
        }
        static withdraw(t) {
            const {stakePubkey: e, authorizedPubkey: n, toPubkey: r, lamports: i, custodianPubkey: s} = t
              , o = wt(er.Withdraw, {
                lamports: i
            })
              , a = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: r,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: ct,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: yt,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: n,
                isSigner: !0,
                isWritable: !1
            }];
            return s && a.push({
                pubkey: s,
                isSigner: !1,
                isWritable: !1
            }),
            (new ot).add({
                keys: a,
                programId: this.programId,
                data: o
            })
        }
        static deactivate(t) {
            const {stakePubkey: e, authorizedPubkey: n} = t
              , r = wt(er.Deactivate);
            return (new ot).add({
                keys: [{
                    pubkey: e,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: ct,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }],
                programId: this.programId,
                data: r
            })
        }
    }
    rr.programId = new D("Stake11111111111111111111111111111111111111"),
    rr.space = 200;
    class ir {
        constructor(t, e, n, r) {
            this.nodePubkey = void 0,
            this.authorizedVoter = void 0,
            this.authorizedWithdrawer = void 0,
            this.commission = void 0,
            this.nodePubkey = t,
            this.authorizedVoter = e,
            this.authorizedWithdrawer = n,
            this.commission = r
        }
    }
    class sr {
        constructor() {}
        static decodeInstructionType(t) {
            this.checkProgramId(t.programId);
            const e = d.u32("instruction").decode(t.data);
            let n;
            for (const [t,r] of Object.entries(or))
                if (r.index == e) {
                    n = t;
                    break
                }
            if (!n)
                throw new Error("Instruction type incorrect; not a VoteInstruction");
            return n
        }
        static decodeInitializeAccount(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 4);
            const {voteInit: e} = xt(or.InitializeAccount, t.data);
            return {
                votePubkey: t.keys[0].pubkey,
                nodePubkey: t.keys[3].pubkey,
                voteInit: new ir(new D(e.nodePubkey),new D(e.authorizedVoter),new D(e.authorizedWithdrawer),e.commission)
            }
        }
        static decodeAuthorize(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3);
            const {newAuthorized: e, voteAuthorizationType: n} = xt(or.Authorize, t.data);
            return {
                votePubkey: t.keys[0].pubkey,
                authorizedPubkey: t.keys[2].pubkey,
                newAuthorizedPubkey: new D(e),
                voteAuthorizationType: {
                    index: n
                }
            }
        }
        static decodeAuthorizeWithSeed(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3);
            const {voteAuthorizeWithSeedArgs: {currentAuthorityDerivedKeyOwnerPubkey: e, currentAuthorityDerivedKeySeed: n, newAuthorized: r, voteAuthorizationType: i}} = xt(or.AuthorizeWithSeed, t.data);
            return {
                currentAuthorityDerivedKeyBasePubkey: t.keys[2].pubkey,
                currentAuthorityDerivedKeyOwnerPubkey: new D(e),
                currentAuthorityDerivedKeySeed: n,
                newAuthorizedPubkey: new D(r),
                voteAuthorizationType: {
                    index: i
                },
                votePubkey: t.keys[0].pubkey
            }
        }
        static decodeWithdraw(t) {
            this.checkProgramId(t.programId),
            this.checkKeyLength(t.keys, 3);
            const {lamports: e} = xt(or.Withdraw, t.data);
            return {
                votePubkey: t.keys[0].pubkey,
                authorizedWithdrawerPubkey: t.keys[2].pubkey,
                lamports: e,
                toPubkey: t.keys[1].pubkey
            }
        }
        static checkProgramId(t) {
            if (!t.equals(lr.programId))
                throw new Error("invalid instruction; programId is not VoteProgram")
        }
        static checkKeyLength(t, e) {
            if (t.length < e)
                throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)
        }
    }
    const or = Object.freeze({
        InitializeAccount: {
            index: 0,
            layout: d.struct([d.u32("instruction"), ((t="voteInit")=>d.struct([H("nodePubkey"), H("authorizedVoter"), H("authorizedWithdrawer"), d.u8("commission")], t))()])
        },
        Authorize: {
            index: 1,
            layout: d.struct([d.u32("instruction"), H("newAuthorized"), d.u32("voteAuthorizationType")])
        },
        Withdraw: {
            index: 3,
            layout: d.struct([d.u32("instruction"), d.ns64("lamports")])
        },
        AuthorizeWithSeed: {
            index: 10,
            layout: d.struct([d.u32("instruction"), ((t="voteAuthorizeWithSeedArgs")=>d.struct([d.u32("voteAuthorizationType"), H("currentAuthorityDerivedKeyOwnerPubkey"), G("currentAuthorityDerivedKeySeed"), H("newAuthorized")], t))()])
        }
    })
      , ar = Object.freeze({
        Voter: {
            index: 0
        },
        Withdrawer: {
            index: 1
        }
    });
    class lr {
        constructor() {}
        static initializeAccount(t) {
            const {votePubkey: e, nodePubkey: n, voteInit: r} = t
              , i = wt(or.InitializeAccount, {
                voteInit: {
                    nodePubkey: k(r.nodePubkey.toBuffer()),
                    authorizedVoter: k(r.authorizedVoter.toBuffer()),
                    authorizedWithdrawer: k(r.authorizedWithdrawer.toBuffer()),
                    commission: r.commission
                }
            })
              , s = {
                keys: [{
                    pubkey: e,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: ft,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: ct,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }],
                programId: this.programId,
                data: i
            };
            return new st(s)
        }
        static createAccount(t) {
            const e = new ot;
            return e.add(Ct.createAccount({
                fromPubkey: t.fromPubkey,
                newAccountPubkey: t.votePubkey,
                lamports: t.lamports,
                space: this.space,
                programId: this.programId
            })),
            e.add(this.initializeAccount({
                votePubkey: t.votePubkey,
                nodePubkey: t.voteInit.nodePubkey,
                voteInit: t.voteInit
            }))
        }
        static authorize(t) {
            const {votePubkey: e, authorizedPubkey: n, newAuthorizedPubkey: r, voteAuthorizationType: i} = t
              , s = wt(or.Authorize, {
                newAuthorized: k(r.toBuffer()),
                voteAuthorizationType: i.index
            })
              , o = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: ct,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: n,
                isSigner: !0,
                isWritable: !1
            }];
            return (new ot).add({
                keys: o,
                programId: this.programId,
                data: s
            })
        }
        static authorizeWithSeed(t) {
            const {currentAuthorityDerivedKeyBasePubkey: e, currentAuthorityDerivedKeyOwnerPubkey: n, currentAuthorityDerivedKeySeed: r, newAuthorizedPubkey: i, voteAuthorizationType: s, votePubkey: o} = t
              , a = wt(or.AuthorizeWithSeed, {
                voteAuthorizeWithSeedArgs: {
                    currentAuthorityDerivedKeyOwnerPubkey: k(n.toBuffer()),
                    currentAuthorityDerivedKeySeed: r,
                    newAuthorized: k(i.toBuffer()),
                    voteAuthorizationType: s.index
                }
            })
              , l = [{
                pubkey: o,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: ct,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: e,
                isSigner: !0,
                isWritable: !1
            }];
            return (new ot).add({
                keys: l,
                programId: this.programId,
                data: a
            })
        }
        static withdraw(t) {
            const {votePubkey: e, authorizedWithdrawerPubkey: n, lamports: r, toPubkey: i} = t
              , s = wt(or.Withdraw, {
                lamports: r
            })
              , o = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: i,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !0,
                isWritable: !1
            }];
            return (new ot).add({
                keys: o,
                programId: this.programId,
                data: s
            })
        }
        static safeWithdraw(t, e, n) {
            if (t.lamports > e - n)
                throw new Error("Withdraw will leave vote account with insuffcient funds.");
            return lr.withdraw(t)
        }
    }
    lr.programId = new D("Vote111111111111111111111111111111111111111"),
    lr.space = 3731;
    const cr = new D("Va1idator1nfo111111111111111111111111111111")
      , ur = (0,
    p.type)({
        name: (0,
        p.string)(),
        website: (0,
        p.optional)((0,
        p.string)()),
        details: (0,
        p.optional)((0,
        p.string)()),
        keybaseUsername: (0,
        p.optional)((0,
        p.string)())
    });
    class hr {
        constructor(t, e) {
            this.key = void 0,
            this.info = void 0,
            this.key = t,
            this.info = e
        }
        static fromConfigData(t) {
            let e = [...t];
            if (2 !== q(e))
                return null;
            const n = [];
            for (let t = 0; t < 2; t++) {
                const t = new D(e.slice(0, N));
                e = e.slice(N);
                const r = 1 === e.slice(0, 1)[0];
                e = e.slice(1),
                n.push({
                    publicKey: t,
                    isSigner: r
                })
            }
            if (n[0].publicKey.equals(cr) && n[1].isSigner) {
                const t = G().decode(i.Buffer.from(e))
                  , r = JSON.parse(t);
                return (0,
                p.assert)(r, ur),
                new hr(n[1].publicKey,r)
            }
            return null
        }
    }
    const dr = new D("Vote111111111111111111111111111111111111111")
      , fr = d.struct([H("nodePubkey"), H("authorizedWithdrawer"), d.u8("commission"), d.nu64(), d.seq(d.struct([d.nu64("slot"), d.u32("confirmationCount")]), d.offset(d.u32(), -8), "votes"), d.u8("rootSlotValid"), d.nu64("rootSlot"), d.nu64(), d.seq(d.struct([d.nu64("epoch"), H("authorizedVoter")]), d.offset(d.u32(), -8), "authorizedVoters"), d.struct([d.seq(d.struct([H("authorizedPubkey"), d.nu64("epochOfLastAuthorizedSwitch"), d.nu64("targetEpoch")]), 32, "buf"), d.nu64("idx"), d.u8("isEmpty")], "priorVoters"), d.nu64(), d.seq(d.struct([d.nu64("epoch"), d.nu64("credits"), d.nu64("prevCredits")]), d.offset(d.u32(), -8), "epochCredits"), d.struct([d.nu64("slot"), d.nu64("timestamp")], "lastTimestamp")]);
    class pr {
        constructor(t) {
            this.nodePubkey = void 0,
            this.authorizedWithdrawer = void 0,
            this.commission = void 0,
            this.rootSlot = void 0,
            this.votes = void 0,
            this.authorizedVoters = void 0,
            this.priorVoters = void 0,
            this.epochCredits = void 0,
            this.lastTimestamp = void 0,
            this.nodePubkey = t.nodePubkey,
            this.authorizedWithdrawer = t.authorizedWithdrawer,
            this.commission = t.commission,
            this.rootSlot = t.rootSlot,
            this.votes = t.votes,
            this.authorizedVoters = t.authorizedVoters,
            this.priorVoters = t.priorVoters,
            this.epochCredits = t.epochCredits,
            this.lastTimestamp = t.lastTimestamp
        }
        static fromAccountData(t) {
            const e = fr.decode(k(t), 4);
            let n = e.rootSlot;
            return e.rootSlotValid || (n = null),
            new pr({
                nodePubkey: new D(e.nodePubkey),
                authorizedWithdrawer: new D(e.authorizedWithdrawer),
                commission: e.commission,
                votes: e.votes,
                rootSlot: n,
                authorizedVoters: e.authorizedVoters.map(mr),
                priorVoters: yr(e.priorVoters),
                epochCredits: e.epochCredits,
                lastTimestamp: e.lastTimestamp
            })
        }
    }
    function mr({authorizedVoter: t, epoch: e}) {
        return {
            epoch: e,
            authorizedVoter: new D(t)
        }
    }
    function gr({authorizedPubkey: t, epochOfLastAuthorizedSwitch: e, targetEpoch: n}) {
        return {
            authorizedPubkey: new D(t),
            epochOfLastAuthorizedSwitch: e,
            targetEpoch: n
        }
    }
    function yr({buf: t, idx: e, isEmpty: n}) {
        return n ? [] : [...t.slice(e + 1).map(gr), ...t.slice(0, e).map(gr)]
    }
    const br = {
        http: {
            devnet: "http://api.devnet.solana.com",
            testnet: "http://api.testnet.solana.com",
            "mainnet-beta": "http://api.mainnet-beta.solana.com/"
        },
        https: {
            devnet: "https://api.devnet.solana.com",
            testnet: "https://api.testnet.solana.com",
            "mainnet-beta": "https://api.mainnet-beta.solana.com/"
        }
    };
    function vr(t, e) {
        const n = !1 === e ? "http" : "https";
        if (!t)
            return br[n].devnet;
        const r = br[n][t];
        if (!r)
            throw new Error(`Unknown ${n} cluster: ${t}`);
        return r
    }
    async function wr(t, e, n, r) {
        let i, s;
        n && Object.prototype.hasOwnProperty.call(n, "lastValidBlockHeight") || n && Object.prototype.hasOwnProperty.call(n, "nonceValue") ? (i = n,
        s = r) : s = n;
        const o = s && {
            skipPreflight: s.skipPreflight,
            preflightCommitment: s.preflightCommitment || s.commitment,
            minContextSlot: s.minContextSlot
        }
          , a = await t.sendRawTransaction(e, o)
          , l = s && s.commitment
          , c = i ? t.confirmTransaction(i, l) : t.confirmTransaction(a, l)
          , u = (await c).value;
        if (u.err)
            throw new Error(`Raw transaction ${a} failed (${JSON.stringify(u)})`);
        return a
    }
    const xr = 1e9
}
)),
o.register("3dtER", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.sha384 = t.exports.sha512_256 = t.exports.sha512_224 = t.exports.sha512 = t.exports.SHA512 = void 0;
    var n = o("g9W9K")
      , r = o("eDgKs")
      , i = o("3Bcdj");
    const [s,a] = r.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t=>BigInt(t))))
      , l = new Uint32Array(80)
      , c = new Uint32Array(80);
    class u extends n.SHA2 {
        constructor() {
            super(128, 64, 16, !1),
            this.Ah = 1779033703,
            this.Al = -205731576,
            this.Bh = -1150833019,
            this.Bl = -2067093701,
            this.Ch = 1013904242,
            this.Cl = -23791573,
            this.Dh = -1521486534,
            this.Dl = 1595750129,
            this.Eh = 1359893119,
            this.El = -1377402159,
            this.Fh = -1694144372,
            this.Fl = 725511199,
            this.Gh = 528734635,
            this.Gl = -79577749,
            this.Hh = 1541459225,
            this.Hl = 327033209
        }
        get() {
            const {Ah: t, Al: e, Bh: n, Bl: r, Ch: i, Cl: s, Dh: o, Dl: a, Eh: l, El: c, Fh: u, Fl: h, Gh: d, Gl: f, Hh: p, Hl: m} = this;
            return [t, e, n, r, i, s, o, a, l, c, u, h, d, f, p, m]
        }
        set(t, e, n, r, i, s, o, a, l, c, u, h, d, f, p, m) {
            this.Ah = 0 | t,
            this.Al = 0 | e,
            this.Bh = 0 | n,
            this.Bl = 0 | r,
            this.Ch = 0 | i,
            this.Cl = 0 | s,
            this.Dh = 0 | o,
            this.Dl = 0 | a,
            this.Eh = 0 | l,
            this.El = 0 | c,
            this.Fh = 0 | u,
            this.Fl = 0 | h,
            this.Gh = 0 | d,
            this.Gl = 0 | f,
            this.Hh = 0 | p,
            this.Hl = 0 | m
        }
        process(t, e) {
            for (let n = 0; n < 16; n++,
            e += 4)
                l[n] = t.getUint32(e),
                c[n] = t.getUint32(e += 4);
            for (let t = 16; t < 80; t++) {
                const e = 0 | l[t - 15]
                  , n = 0 | c[t - 15]
                  , i = r.default.rotrSH(e, n, 1) ^ r.default.rotrSH(e, n, 8) ^ r.default.shrSH(e, n, 7)
                  , s = r.default.rotrSL(e, n, 1) ^ r.default.rotrSL(e, n, 8) ^ r.default.shrSL(e, n, 7)
                  , o = 0 | l[t - 2]
                  , a = 0 | c[t - 2]
                  , u = r.default.rotrSH(o, a, 19) ^ r.default.rotrBH(o, a, 61) ^ r.default.shrSH(o, a, 6)
                  , h = r.default.rotrSL(o, a, 19) ^ r.default.rotrBL(o, a, 61) ^ r.default.shrSL(o, a, 6)
                  , d = r.default.add4L(s, h, c[t - 7], c[t - 16])
                  , f = r.default.add4H(d, i, u, l[t - 7], l[t - 16]);
                l[t] = 0 | f,
                c[t] = 0 | d
            }
            let {Ah: n, Al: i, Bh: o, Bl: u, Ch: h, Cl: d, Dh: f, Dl: p, Eh: m, El: g, Fh: y, Fl: b, Gh: v, Gl: w, Hh: x, Hl: E} = this;
            for (let t = 0; t < 80; t++) {
                const e = r.default.rotrSH(m, g, 14) ^ r.default.rotrSH(m, g, 18) ^ r.default.rotrBH(m, g, 41)
                  , _ = r.default.rotrSL(m, g, 14) ^ r.default.rotrSL(m, g, 18) ^ r.default.rotrBL(m, g, 41)
                  , A = m & y ^ ~m & v
                  , S = g & b ^ ~g & w
                  , T = r.default.add5L(E, _, S, a[t], c[t])
                  , k = r.default.add5H(T, x, e, A, s[t], l[t])
                  , I = 0 | T
                  , M = r.default.rotrSH(n, i, 28) ^ r.default.rotrBH(n, i, 34) ^ r.default.rotrBH(n, i, 39)
                  , C = r.default.rotrSL(n, i, 28) ^ r.default.rotrBL(n, i, 34) ^ r.default.rotrBL(n, i, 39)
                  , P = n & o ^ n & h ^ o & h
                  , O = i & u ^ i & d ^ u & d;
                x = 0 | v,
                E = 0 | w,
                v = 0 | y,
                w = 0 | b,
                y = 0 | m,
                b = 0 | g,
                ({h: m, l: g} = r.default.add(0 | f, 0 | p, 0 | k, 0 | I)),
                f = 0 | h,
                p = 0 | d,
                h = 0 | o,
                d = 0 | u,
                o = 0 | n,
                u = 0 | i;
                const N = r.default.add3L(I, C, O);
                n = r.default.add3H(N, k, M, P),
                i = 0 | N
            }
            ({h: n, l: i} = r.default.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | i)),
            ({h: o, l: u} = r.default.add(0 | this.Bh, 0 | this.Bl, 0 | o, 0 | u)),
            ({h: h, l: d} = r.default.add(0 | this.Ch, 0 | this.Cl, 0 | h, 0 | d)),
            ({h: f, l: p} = r.default.add(0 | this.Dh, 0 | this.Dl, 0 | f, 0 | p)),
            ({h: m, l: g} = r.default.add(0 | this.Eh, 0 | this.El, 0 | m, 0 | g)),
            ({h: y, l: b} = r.default.add(0 | this.Fh, 0 | this.Fl, 0 | y, 0 | b)),
            ({h: v, l: w} = r.default.add(0 | this.Gh, 0 | this.Gl, 0 | v, 0 | w)),
            ({h: x, l: E} = r.default.add(0 | this.Hh, 0 | this.Hl, 0 | x, 0 | E)),
            this.set(n, i, o, u, h, d, f, p, m, g, y, b, v, w, x, E)
        }
        roundClean() {
            l.fill(0),
            c.fill(0)
        }
        destroy() {
            this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        }
    }
    t.exports.SHA512 = u;
    class h extends u {
        constructor() {
            super(),
            this.Ah = -1942145080,
            this.Al = 424955298,
            this.Bh = 1944164710,
            this.Bl = -1982016298,
            this.Ch = 502970286,
            this.Cl = 855612546,
            this.Dh = 1738396948,
            this.Dl = 1479516111,
            this.Eh = 258812777,
            this.El = 2077511080,
            this.Fh = 2011393907,
            this.Fl = 79989058,
            this.Gh = 1067287976,
            this.Gl = 1780299464,
            this.Hh = 286451373,
            this.Hl = -1848208735,
            this.outputLen = 28
        }
    }
    class d extends u {
        constructor() {
            super(),
            this.Ah = 573645204,
            this.Al = -64227540,
            this.Bh = -1621794909,
            this.Bl = -934517566,
            this.Ch = 596883563,
            this.Cl = 1867755857,
            this.Dh = -1774684391,
            this.Dl = 1497426621,
            this.Eh = -1775747358,
            this.El = -1467023389,
            this.Fh = -1101128155,
            this.Fl = 1401305490,
            this.Gh = 721525244,
            this.Gl = 746961066,
            this.Hh = 246885852,
            this.Hl = -2117784414,
            this.outputLen = 32
        }
    }
    class f extends u {
        constructor() {
            super(),
            this.Ah = -876896931,
            this.Al = -1056596264,
            this.Bh = 1654270250,
            this.Bl = 914150663,
            this.Ch = -1856437926,
            this.Cl = 812702999,
            this.Dh = 355462360,
            this.Dl = -150054599,
            this.Eh = 1731405415,
            this.El = -4191439,
            this.Fh = -1900787065,
            this.Fl = 1750603025,
            this.Gh = -619958771,
            this.Gl = 1694076839,
            this.Hh = 1203062813,
            this.Hl = -1090891868,
            this.outputLen = 48
        }
    }
    t.exports.sha512 = (0,
    i.wrapConstructor)((()=>new u)),
    t.exports.sha512_224 = (0,
    i.wrapConstructor)((()=>new h)),
    t.exports.sha512_256 = (0,
    i.wrapConstructor)((()=>new d)),
    t.exports.sha384 = (0,
    i.wrapConstructor)((()=>new f))
}
)),
o.register("g9W9K", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.SHA2 = void 0;
    var n = o("dNiq9")
      , r = o("3Bcdj");
    class i extends r.Hash {
        constructor(t, e, n, i) {
            super(),
            this.blockLen = t,
            this.outputLen = e,
            this.padOffset = n,
            this.isLE = i,
            this.finished = !1,
            this.length = 0,
            this.pos = 0,
            this.destroyed = !1,
            this.buffer = new Uint8Array(t),
            this.view = (0,
            r.createView)(this.buffer)
        }
        update(t) {
            n.default.exists(this);
            const {view: e, buffer: i, blockLen: s} = this
              , o = (t = (0,
            r.toBytes)(t)).length;
            for (let n = 0; n < o; ) {
                const a = Math.min(s - this.pos, o - n);
                if (a !== s)
                    i.set(t.subarray(n, n + a), this.pos),
                    this.pos += a,
                    n += a,
                    this.pos === s && (this.process(e, 0),
                    this.pos = 0);
                else {
                    const e = (0,
                    r.createView)(t);
                    for (; s <= o - n; n += s)
                        this.process(e, n)
                }
            }
            return this.length += t.length,
            this.roundClean(),
            this
        }
        digestInto(t) {
            n.default.exists(this),
            n.default.output(t, this),
            this.finished = !0;
            const {buffer: e, view: i, blockLen: s, isLE: o} = this;
            let {pos: a} = this;
            e[a++] = 128,
            this.buffer.subarray(a).fill(0),
            this.padOffset > s - a && (this.process(i, 0),
            a = 0);
            for (let t = a; t < s; t++)
                e[t] = 0;
            !function(t, e, n, r) {
                if ("function" == typeof t.setBigUint64)
                    return t.setBigUint64(e, n, r);
                const i = BigInt(32)
                  , s = BigInt(4294967295)
                  , o = Number(n >> i & s)
                  , a = Number(n & s)
                  , l = r ? 4 : 0
                  , c = r ? 0 : 4;
                t.setUint32(e + l, o, r),
                t.setUint32(e + c, a, r)
            }(i, s - 8, BigInt(8 * this.length), o),
            this.process(i, 0);
            const l = (0,
            r.createView)(t)
              , c = this.outputLen;
            if (c % 4)
                throw new Error("_sha2: outputLen should be aligned to 32bit");
            const u = c / 4
              , h = this.get();
            if (u > h.length)
                throw new Error("_sha2: outputLen bigger than state");
            for (let t = 0; t < u; t++)
                l.setUint32(4 * t, h[t], o)
        }
        digest() {
            const {buffer: t, outputLen: e} = this;
            this.digestInto(t);
            const n = t.slice(0, e);
            return this.destroy(),
            n
        }
        _cloneInto(t) {
            t || (t = new this.constructor),
            t.set(...this.get());
            const {blockLen: e, buffer: n, length: r, finished: i, destroyed: s, pos: o} = this;
            return t.length = r,
            t.pos = o,
            t.finished = i,
            t.destroyed = s,
            r % e && t.buffer.set(n),
            t
        }
    }
    t.exports.SHA2 = i
}
)),
o.register("dNiq9", (function(t, e) {
    function n(t) {
        if (!Number.isSafeInteger(t) || t < 0)
            throw new Error(`Wrong positive integer: ${t}`)
    }
    function r(t) {
        if ("boolean" != typeof t)
            throw new Error(`Expected boolean, not ${t}`)
    }
    function i(t, ...e) {
        if (!(t instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (e.length > 0 && !e.includes(t.length))
            throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`)
    }
    function s(t) {
        if ("function" != typeof t || "function" != typeof t.create)
            throw new Error("Hash should be wrapped by utils.wrapConstructor");
        n(t.outputLen),
        n(t.blockLen)
    }
    function o(t, e=!0) {
        if (t.destroyed)
            throw new Error("Hash instance has been destroyed");
        if (e && t.finished)
            throw new Error("Hash#digest() has already been called")
    }
    function a(t, e) {
        i(t);
        const n = e.outputLen;
        if (t.length < n)
            throw new Error(`digestInto() expects output buffer of length at least ${n}`)
    }
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.output = t.exports.exists = t.exports.hash = t.exports.bytes = t.exports.bool = t.exports.number = void 0,
    t.exports.number = n,
    t.exports.bool = r,
    t.exports.bytes = i,
    t.exports.hash = s,
    t.exports.exists = o,
    t.exports.output = a;
    const l = {
        number: n,
        bool: r,
        bytes: i,
        hash: s,
        exists: o,
        output: a
    };
    t.exports.default = l
}
)),
o.register("3Bcdj", (function(t, e) {
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.randomBytes = t.exports.wrapConstructorWithOpts = t.exports.wrapConstructor = t.exports.checkOpts = t.exports.Hash = t.exports.concatBytes = t.exports.toBytes = t.exports.utf8ToBytes = t.exports.asyncLoop = t.exports.nextTick = t.exports.hexToBytes = t.exports.bytesToHex = t.exports.isLE = t.exports.rotr = t.exports.createView = t.exports.u32 = t.exports.u8 = void 0;
    var n = o("2LMAo");
    t.exports.u8 = t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength);
    t.exports.u32 = t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength / 4));
    t.exports.createView = t=>new DataView(t.buffer,t.byteOffset,t.byteLength);
    if (t.exports.rotr = (t,e)=>t << 32 - e | t >>> e,
    t.exports.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0],
    !t.exports.isLE)
        throw new Error("Non little-endian hardware is not supported");
    const r = Array.from({
        length: 256
    }, ((t,e)=>e.toString(16).padStart(2, "0")));
    t.exports.bytesToHex = function(t) {
        if (!(t instanceof Uint8Array))
            throw new Error("Uint8Array expected");
        let e = "";
        for (let n = 0; n < t.length; n++)
            e += r[t[n]];
        return e
    }
    ,
    t.exports.hexToBytes = function(t) {
        if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
        if (t.length % 2)
            throw new Error("hexToBytes: received invalid unpadded hex");
        const e = new Uint8Array(t.length / 2);
        for (let n = 0; n < e.length; n++) {
            const r = 2 * n
              , i = t.slice(r, r + 2)
              , s = Number.parseInt(i, 16);
            if (Number.isNaN(s) || s < 0)
                throw new Error("Invalid byte sequence");
            e[n] = s
        }
        return e
    }
    ;
    function i(t) {
        if ("string" != typeof t)
            throw new TypeError("utf8ToBytes expected string, got " + typeof t);
        return (new TextEncoder).encode(t)
    }
    function s(t) {
        if ("string" == typeof t && (t = i(t)),
        !(t instanceof Uint8Array))
            throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);
        return t
    }
    t.exports.nextTick = async()=>{}
    ,
    t.exports.asyncLoop = async function(e, n, r) {
        let i = Date.now();
        for (let s = 0; s < e; s++) {
            r(s);
            const e = Date.now() - i;
            e >= 0 && e < n || (await (0,
            t.exports.nextTick)(),
            i += e)
        }
    }
    ,
    t.exports.utf8ToBytes = i,
    t.exports.toBytes = s,
    t.exports.concatBytes = function(...t) {
        if (!t.every((t=>t instanceof Uint8Array)))
            throw new Error("Uint8Array list expected");
        if (1 === t.length)
            return t[0];
        const e = t.reduce(((t,e)=>t + e.length), 0)
          , n = new Uint8Array(e);
        for (let e = 0, r = 0; e < t.length; e++) {
            const i = t[e];
            n.set(i, r),
            r += i.length
        }
        return n
    }
    ;
    t.exports.Hash = class {
        clone() {
            return this._cloneInto()
        }
    }
    ;
    const a = t=>"[object Object]" === Object.prototype.toString.call(t) && t.constructor === Object;
    t.exports.checkOpts = function(t, e) {
        if (void 0 !== e && ("object" != typeof e || !a(e)))
            throw new TypeError("Options should be object or undefined");
        return Object.assign(t, e)
    }
    ,
    t.exports.wrapConstructor = function(t) {
        const e = e=>t().update(s(e)).digest()
          , n = t();
        return e.outputLen = n.outputLen,
        e.blockLen = n.blockLen,
        e.create = ()=>t(),
        e
    }
    ,
    t.exports.wrapConstructorWithOpts = function(t) {
        const e = (e,n)=>t(n).update(s(e)).digest()
          , n = t({});
        return e.outputLen = n.outputLen,
        e.blockLen = n.blockLen,
        e.create = e=>t(e),
        e
    }
    ,
    t.exports.randomBytes = function(t=32) {
        if (n.crypto.web)
            return n.crypto.web.getRandomValues(new Uint8Array(t));
        if (n.crypto.node)
            return new Uint8Array(n.crypto.node.randomBytes(t).buffer);
        throw new Error("The environment doesn't have randomBytes function")
    }
}
)),
o.register("2LMAo", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.crypto = void 0,
    t.exports.crypto = {
        node: void 0,
        web: "object" == typeof self && "crypto"in self ? self.crypto : void 0
    }
}
)),
o.register("eDgKs", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.add = t.exports.toBig = t.exports.split = t.exports.fromBig = void 0;
    const n = BigInt(2 ** 32 - 1)
      , r = BigInt(32);
    function i(t, e=!1) {
        return e ? {
            h: Number(t & n),
            l: Number(t >> r & n)
        } : {
            h: 0 | Number(t >> r & n),
            l: 0 | Number(t & n)
        }
    }
    function s(t, e=!1) {
        let n = new Uint32Array(t.length)
          , r = new Uint32Array(t.length);
        for (let s = 0; s < t.length; s++) {
            const {h: o, l: a} = i(t[s], e);
            [n[s],r[s]] = [o, a]
        }
        return [n, r]
    }
    t.exports.fromBig = i,
    t.exports.split = s;
    t.exports.toBig = (t,e)=>BigInt(t >>> 0) << r | BigInt(e >>> 0);
    function o(t, e, n, r) {
        const i = (e >>> 0) + (r >>> 0);
        return {
            h: t + n + (i / 2 ** 32 | 0) | 0,
            l: 0 | i
        }
    }
    t.exports.add = o;
    const a = {
        fromBig: i,
        split: s,
        toBig: t.exports.toBig,
        shrSH: (t,e,n)=>t >>> n,
        shrSL: (t,e,n)=>t << 32 - n | e >>> n,
        rotrSH: (t,e,n)=>t >>> n | e << 32 - n,
        rotrSL: (t,e,n)=>t << 32 - n | e >>> n,
        rotrBH: (t,e,n)=>t << 64 - n | e >>> n - 32,
        rotrBL: (t,e,n)=>t >>> n - 32 | e << 64 - n,
        rotr32H: (t,e)=>e,
        rotr32L: (t,e)=>t,
        rotlSH: (t,e,n)=>t << n | e >>> 32 - n,
        rotlSL: (t,e,n)=>e << n | t >>> 32 - n,
        rotlBH: (t,e,n)=>e << n - 32 | t >>> 64 - n,
        rotlBL: (t,e,n)=>t << n - 32 | e >>> 64 - n,
        add: o,
        add3L: (t,e,n)=>(t >>> 0) + (e >>> 0) + (n >>> 0),
        add3H: (t,e,n,r)=>e + n + r + (t / 2 ** 32 | 0) | 0,
        add4L: (t,e,n,r)=>(t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
        add4H: (t,e,n,r,i)=>e + n + r + i + (t / 2 ** 32 | 0) | 0,
        add5H: (t,e,n,r,i,s)=>e + n + r + i + s + (t / 2 ** 32 | 0) | 0,
        add5L: (t,e,n,r,i)=>(t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0)
    };
    t.exports.default = a
}
)),
o.register("9NqJu", (function(e, n) {
    t(e.exports, "Point", (()=>A)),
    t(e.exports, "utils", (()=>nt)),
    t(e.exports, "sync", (()=>tt));
    /*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
    var r = o("kjyEk");
    const i = BigInt(0)
      , s = BigInt(1)
      , a = BigInt(2)
      , l = BigInt(8)
      , c = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989")
      , u = Object.freeze({
        a: BigInt(-1),
        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
        P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
        l: c,
        n: c,
        h: BigInt(8),
        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
    })
      , h = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000")
      , d = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752")
      , f = (BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742"),
    BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"))
      , p = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578")
      , m = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838")
      , g = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    class y {
        constructor(t, e, n, r) {
            this.x = t,
            this.y = e,
            this.z = n,
            this.t = r
        }
        static fromAffine(t) {
            if (!(t instanceof A))
                throw new TypeError("ExtendedPoint#fromAffine: expected Point");
            return t.equals(A.ZERO) ? y.ZERO : new y(t.x,t.y,s,B(t.x * t.y))
        }
        static toAffineBatch(t) {
            const e = function(t, e=u.P) {
                const n = new Array(t.length)
                  , r = L(t.reduce(((t,r,s)=>r === i ? t : (n[s] = t,
                B(t * r, e))), s), e);
                return t.reduceRight(((t,r,s)=>r === i ? t : (n[s] = B(t * n[s], e),
                B(t * r, e))), r),
                n
            }(t.map((t=>t.z)));
            return t.map(((t,n)=>t.toAffine(e[n])))
        }
        static normalizeZ(t) {
            return this.toAffineBatch(t).map(this.fromAffine)
        }
        equals(t) {
            v(t);
            const {x: e, y: n, z: r} = this
              , {x: i, y: s, z: o} = t
              , a = B(e * o)
              , l = B(i * r)
              , c = B(n * o)
              , u = B(s * r);
            return a === l && c === u
        }
        negate() {
            return new y(B(-this.x),this.y,this.z,B(-this.t))
        }
        double() {
            const {x: t, y: e, z: n} = this
              , {a: r} = u
              , i = B(t * t)
              , s = B(e * e)
              , o = B(a * B(n * n))
              , l = B(r * i)
              , c = t + e
              , h = B(B(c * c) - i - s)
              , d = l + s
              , f = d - o
              , p = l - s
              , m = B(h * f)
              , g = B(d * p)
              , b = B(h * p)
              , v = B(f * d);
            return new y(m,g,v,b)
        }
        add(t) {
            v(t);
            const {x: e, y: n, z: r, t: s} = this
              , {x: o, y: l, z: c, t: u} = t
              , h = B((n - e) * (l + o))
              , d = B((n + e) * (l - o))
              , f = B(d - h);
            if (f === i)
                return this.double();
            const p = B(r * a * u)
              , m = B(s * a * c)
              , g = m + p
              , b = d + h
              , w = m - p
              , x = B(g * f)
              , E = B(b * w)
              , _ = B(g * w)
              , A = B(f * b);
            return new y(x,E,A,_)
        }
        subtract(t) {
            return this.add(t.negate())
        }
        precomputeWindow(t) {
            const e = 1 + 256 / t
              , n = [];
            let r = this
              , i = r;
            for (let s = 0; s < e; s++) {
                i = r,
                n.push(i);
                for (let e = 1; e < 2 ** (t - 1); e++)
                    i = i.add(r),
                    n.push(i);
                r = i.double()
            }
            return n
        }
        wNAF(t, e) {
            !e && this.equals(y.BASE) && (e = A.BASE);
            const n = e && e._WINDOW_SIZE || 1;
            if (256 % n)
                throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
            let r = e && _.get(e);
            r || (r = this.precomputeWindow(n),
            e && 1 !== n && (r = y.normalizeZ(r),
            _.set(e, r)));
            let i = y.ZERO
              , o = y.BASE;
            const a = 1 + 256 / n
              , l = 2 ** (n - 1)
              , c = BigInt(2 ** n - 1)
              , u = 2 ** n
              , h = BigInt(n);
            for (let e = 0; e < a; e++) {
                const n = e * l;
                let a = Number(t & c);
                t >>= h,
                a > l && (a -= u,
                t += s);
                const d = n
                  , f = n + Math.abs(a) - 1
                  , p = e % 2 != 0
                  , m = a < 0;
                0 === a ? o = o.add(b(p, r[d])) : i = i.add(b(m, r[f]))
            }
            return y.normalizeZ([i, o])[0]
        }
        multiply(t, e) {
            return this.wNAF(Y(t, u.l), e)
        }
        multiplyUnsafe(t) {
            let e = Y(t, u.l, !1);
            const n = y.BASE
              , r = y.ZERO;
            if (e === i)
                return r;
            if (this.equals(r) || e === s)
                return this;
            if (this.equals(n))
                return this.wNAF(e);
            let o = r
              , a = this;
            for (; e > i; )
                e & s && (o = o.add(a)),
                a = a.double(),
                e >>= s;
            return o
        }
        isSmallOrder() {
            return this.multiplyUnsafe(u.h).equals(y.ZERO)
        }
        isTorsionFree() {
            let t = this.multiplyUnsafe(u.l / a).double();
            return u.l % a && (t = t.add(this)),
            t.equals(y.ZERO)
        }
        toAffine(t) {
            const {x: e, y: n, z: r} = this
              , i = this.equals(y.ZERO);
            null == t && (t = i ? l : L(r));
            const o = B(e * t)
              , a = B(n * t)
              , c = B(r * t);
            if (i)
                return A.ZERO;
            if (c !== s)
                throw new Error("invZ was invalid");
            return new A(o,a)
        }
        fromRistrettoBytes() {
            x()
        }
        toRistrettoBytes() {
            x()
        }
        fromRistrettoHash() {
            x()
        }
    }
    function b(t, e) {
        const n = e.negate();
        return t ? n : e
    }
    function v(t) {
        if (!(t instanceof y))
            throw new TypeError("ExtendedPoint expected")
    }
    function w(t) {
        if (!(t instanceof E))
            throw new TypeError("RistrettoPoint expected")
    }
    function x() {
        throw new Error("Legacy method: switch to RistrettoPoint")
    }
    y.BASE = new y(u.Gx,u.Gy,s,B(u.Gx * u.Gy)),
    y.ZERO = new y(i,s,s,i);
    class E {
        constructor(t) {
            this.ep = t
        }
        static calcElligatorRistrettoMap(t) {
            const {d: e} = u
              , n = B(d * t * t)
              , r = B((n + s) * m);
            let i = BigInt(-1);
            const o = B((i - e * n) * B(n + e));
            let {isValid: a, value: l} = U(r, o)
              , c = B(l * t);
            O(c) || (c = B(-c)),
            a || (l = c),
            a || (i = n);
            const h = B(i * (n - s) * g - o)
              , p = l * l
              , b = B((l + l) * o)
              , v = B(h * f)
              , w = B(s - p)
              , x = B(s + p);
            return new y(B(b * x),B(w * v),B(v * x),B(b * w))
        }
        static hashToCurve(t) {
            const e = D((t = W(t, 64)).slice(0, 32))
              , n = this.calcElligatorRistrettoMap(e)
              , r = D(t.slice(32, 64))
              , i = this.calcElligatorRistrettoMap(r);
            return new E(n.add(i))
        }
        static fromHex(t) {
            t = W(t, 32);
            const {a: e, d: n} = u
              , r = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint"
              , o = D(t);
            if (!function(t, e) {
                if (t.length !== e.length)
                    return !1;
                for (let n = 0; n < t.length; n++)
                    if (t[n] !== e[n])
                        return !1;
                return !0
            }(P(o), t) || O(o))
                throw new Error(r);
            const a = B(o * o)
              , l = B(s + e * a)
              , c = B(s - e * a)
              , h = B(l * l)
              , d = B(c * c)
              , f = B(e * n * h - d)
              , {isValid: p, value: m} = z(B(f * d))
              , g = B(m * c)
              , b = B(m * g * f);
            let v = B((o + o) * g);
            O(v) && (v = B(-v));
            const w = B(l * b)
              , x = B(v * w);
            if (!p || O(x) || w === i)
                throw new Error(r);
            return new E(new y(v,w,s,x))
        }
        toRawBytes() {
            let {x: t, y: e, z: n, t: r} = this.ep;
            const i = B(B(n + e) * B(n - e))
              , s = B(t * e)
              , o = B(s * s)
              , {value: a} = z(B(i * o))
              , l = B(a * i)
              , c = B(a * s)
              , u = B(l * c * r);
            let h;
            if (O(r * u)) {
                let n = B(e * d)
                  , r = B(t * d);
                t = n,
                e = r,
                h = B(l * p)
            } else
                h = c;
            O(t * u) && (e = B(-e));
            let f = B((n - e) * h);
            return O(f) && (f = B(-f)),
            P(f)
        }
        toHex() {
            return I(this.toRawBytes())
        }
        toString() {
            return this.toHex()
        }
        equals(t) {
            w(t);
            const e = this.ep
              , n = t.ep
              , r = B(e.x * n.y) === B(e.y * n.x)
              , i = B(e.y * n.y) === B(e.x * n.x);
            return r || i
        }
        add(t) {
            return w(t),
            new E(this.ep.add(t.ep))
        }
        subtract(t) {
            return w(t),
            new E(this.ep.subtract(t.ep))
        }
        multiply(t) {
            return new E(this.ep.multiply(t))
        }
        multiplyUnsafe(t) {
            return new E(this.ep.multiplyUnsafe(t))
        }
    }
    E.BASE = new E(y.BASE),
    E.ZERO = new E(y.ZERO);
    const _ = new WeakMap;
    class A {
        constructor(t, e) {
            this.x = t,
            this.y = e
        }
        _setWindowSize(t) {
            this._WINDOW_SIZE = t,
            _.delete(this)
        }
        static fromHex(t, e=!0) {
            const {d: n, P: r} = u
              , i = (t = W(t, 32)).slice();
            i[31] = -129 & t[31];
            const o = N(i);
            if (e && o >= r)
                throw new Error("Expected 0 < hex < P");
            if (!e && o >= h)
                throw new Error("Expected 0 < hex < 2**256");
            const a = B(o * o)
              , l = B(a - s)
              , c = B(n * a + s);
            let {isValid: d, value: f} = U(l, c);
            if (!d)
                throw new Error("Point.fromHex: invalid y coordinate");
            const p = (f & s) === s;
            return 0 != (128 & t[31]) !== p && (f = B(-f)),
            new A(f,o)
        }
        static async fromPrivateKey(t) {
            return (await K(t)).point
        }
        toRawBytes() {
            const t = P(this.y);
            return t[31] |= this.x & s ? 128 : 0,
            t
        }
        toHex() {
            return I(this.toRawBytes())
        }
        toX25519() {
            const {y: t} = this;
            return P(B((s + t) * L(s - t)))
        }
        isTorsionFree() {
            return y.fromAffine(this).isTorsionFree()
        }
        equals(t) {
            return this.x === t.x && this.y === t.y
        }
        negate() {
            return new A(B(-this.x),this.y)
        }
        add(t) {
            return y.fromAffine(this).add(y.fromAffine(t)).toAffine()
        }
        subtract(t) {
            return this.add(t.negate())
        }
        multiply(t) {
            return y.fromAffine(this).multiply(t, this).toAffine()
        }
    }
    A.BASE = new A(u.Gx,u.Gy),
    A.ZERO = new A(i,s);
    class S {
        constructor(t, e) {
            this.r = t,
            this.s = e,
            this.assertValidity()
        }
        static fromHex(t) {
            const e = W(t, 64)
              , n = A.fromHex(e.slice(0, 32), !1)
              , r = N(e.slice(32, 64));
            return new S(n,r)
        }
        assertValidity() {
            const {r: t, s: e} = this;
            if (!(t instanceof A))
                throw new Error("Expected Point instance");
            return Y(e, u.l, !1),
            this
        }
        toRawBytes() {
            const t = new Uint8Array(64);
            return t.set(this.r.toRawBytes()),
            t.set(P(this.s), 32),
            t
        }
        toHex() {
            return I(this.toRawBytes())
        }
    }
    function T(...t) {
        if (!t.every((t=>t instanceof Uint8Array)))
            throw new Error("Expected Uint8Array list");
        if (1 === t.length)
            return t[0];
        const e = t.reduce(((t,e)=>t + e.length), 0)
          , n = new Uint8Array(e);
        for (let e = 0, r = 0; e < t.length; e++) {
            const i = t[e];
            n.set(i, r),
            r += i.length
        }
        return n
    }
    const k = Array.from({
        length: 256
    }, ((t,e)=>e.toString(16).padStart(2, "0")));
    function I(t) {
        if (!(t instanceof Uint8Array))
            throw new Error("Uint8Array expected");
        let e = "";
        for (let n = 0; n < t.length; n++)
            e += k[t[n]];
        return e
    }
    function M(t) {
        if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
        if (t.length % 2)
            throw new Error("hexToBytes: received invalid unpadded hex");
        const e = new Uint8Array(t.length / 2);
        for (let n = 0; n < e.length; n++) {
            const r = 2 * n
              , i = t.slice(r, r + 2)
              , s = Number.parseInt(i, 16);
            if (Number.isNaN(s) || s < 0)
                throw new Error("Invalid byte sequence");
            e[n] = s
        }
        return e
    }
    function C(t) {
        return M(t.toString(16).padStart(64, "0"))
    }
    function P(t) {
        return C(t).reverse()
    }
    function O(t) {
        return (B(t) & s) === s
    }
    function N(t) {
        if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
        return BigInt("0x" + I(Uint8Array.from(t).reverse()))
    }
    const R = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    function D(t) {
        return B(N(t) & R)
    }
    function B(t, e=u.P) {
        const n = t % e;
        return n >= i ? n : e + n
    }
    function L(t, e=u.P) {
        if (t === i || e <= i)
            throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
        let n = B(t, e)
          , r = e
          , o = i
          , a = s
          , l = s
          , c = i;
        for (; n !== i; ) {
            const t = r / n
              , e = r % n
              , i = o - l * t
              , s = a - c * t;
            r = n,
            n = e,
            o = l,
            a = c,
            l = i,
            c = s
        }
        if (r !== s)
            throw new Error("invert: does not exist");
        return B(o, e)
    }
    function F(t, e) {
        const {P: n} = u;
        let r = t;
        for (; e-- > i; )
            r *= r,
            r %= n;
        return r
    }
    function j(t) {
        const {P: e} = u
          , n = BigInt(5)
          , r = BigInt(10)
          , i = BigInt(20)
          , o = BigInt(40)
          , l = BigInt(80)
          , c = t * t % e * t % e
          , h = F(c, a) * c % e
          , d = F(h, s) * t % e
          , f = F(d, n) * d % e
          , p = F(f, r) * f % e
          , m = F(p, i) * p % e
          , g = F(m, o) * m % e
          , y = F(g, l) * g % e
          , b = F(y, l) * g % e
          , v = F(b, r) * f % e;
        return {
            pow_p_5_8: F(v, a) * t % e,
            b2: c
        }
    }
    function U(t, e) {
        const n = B(e * e * e)
          , r = B(n * n * e);
        let i = B(t * n * j(t * r).pow_p_5_8);
        const s = B(e * i * i)
          , o = i
          , a = B(i * d)
          , l = s === t
          , c = s === B(-t)
          , u = s === B(-t * d);
        return l && (i = o),
        (c || u) && (i = a),
        O(i) && (i = B(-i)),
        {
            isValid: l || c,
            value: i
        }
    }
    function z(t) {
        return U(s, t)
    }
    function V(t) {
        return B(N(t), u.l)
    }
    function W(t, e) {
        const n = t instanceof Uint8Array ? Uint8Array.from(t) : M(t);
        if ("number" == typeof e && n.length !== e)
            throw new Error(`Expected ${e} bytes`);
        return n
    }
    function Y(t, e, n=!0) {
        if (!e)
            throw new TypeError("Specify max value");
        if ("number" == typeof t && Number.isSafeInteger(t) && (t = BigInt(t)),
        "bigint" == typeof t && t < e)
            if (n) {
                if (i < t)
                    return t
            } else if (i <= t)
                return t;
        throw new TypeError("Expected valid scalar: 0 < scalar < max")
    }
    function H(t) {
        return t[0] &= 248,
        t[31] &= 127,
        t[31] |= 64,
        t
    }
    function $(t) {
        if (32 !== (t = "bigint" == typeof t || "number" == typeof t ? C(Y(t, h)) : W(t)).length)
            throw new Error("Expected 32 bytes");
        return t
    }
    function G(t) {
        const e = H(t.slice(0, 32))
          , n = t.slice(32, 64)
          , r = V(e)
          , i = A.BASE.multiply(r)
          , s = i.toRawBytes();
        return {
            head: e,
            prefix: n,
            scalar: r,
            point: i,
            pointBytes: s
        }
    }
    let X;
    function q(...t) {
        if ("function" != typeof X)
            throw new Error("utils.sha512Sync must be set to use sync methods");
        return X(...t)
    }
    async function K(t) {
        return G(await nt.sha512($(t)))
    }
    function Q(t) {
        return G(q($(t)))
    }
    function Z(t, e, n) {
        e = W(e),
        n instanceof A || (n = A.fromHex(n, !1));
        const {r: r, s: i} = t instanceof S ? t.assertValidity() : S.fromHex(t);
        return {
            r: r,
            s: i,
            SB: y.BASE.multiplyUnsafe(i),
            pub: n,
            msg: e
        }
    }
    function J(t, e, n, r) {
        const i = V(r)
          , s = y.fromAffine(t).multiplyUnsafe(i);
        return y.fromAffine(e).add(s).subtract(n).multiplyUnsafe(u.h).equals(y.ZERO)
    }
    const tt = {
        getExtendedPublicKey: Q,
        getPublicKey: function(t) {
            return Q(t).pointBytes
        },
        sign: function(t, e) {
            t = W(t);
            const {prefix: n, scalar: r, pointBytes: i} = Q(e)
              , s = V(q(n, t))
              , o = A.BASE.multiply(s)
              , a = B(s + V(q(o.toRawBytes(), i, t)) * r, u.l);
            return new S(o,a).toRawBytes()
        },
        verify: function(t, e, n) {
            const {r: r, SB: i, msg: s, pub: o} = Z(t, e, n)
              , a = q(r.toRawBytes(), o.toRawBytes(), s);
            return J(o, r, i, a)
        }
    };
    A.BASE._setWindowSize(8);
    const et = {
        node: r,
        web: "object" == typeof self && "crypto"in self ? self.crypto : void 0
    }
      , nt = {
        bytesToHex: I,
        hexToBytes: M,
        concatBytes: T,
        getExtendedPublicKey: K,
        mod: B,
        invert: L,
        TORSION_SUBGROUP: ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],
        hashToPrivateScalar: t=>{
            if ((t = W(t)).length < 40 || t.length > 1024)
                throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
            return B(N(t), u.l - s) + s
        }
        ,
        randomBytes: (t=32)=>{
            if (et.web)
                return et.web.getRandomValues(new Uint8Array(t));
            if (et.node) {
                const {randomBytes: e} = et.node;
                return new Uint8Array(e(t).buffer)
            }
            throw new Error("The environment doesn't have randomBytes function")
        }
        ,
        randomPrivateKey: ()=>nt.randomBytes(32),
        sha512: async(...t)=>{
            const e = T(...t);
            if (et.web) {
                const t = await et.web.subtle.digest("SHA-512", e.buffer);
                return new Uint8Array(t)
            }
            if (et.node)
                return Uint8Array.from(et.node.createHash("sha512").update(e).digest());
            throw new Error("The environment doesn't have sha512 function")
        }
        ,
        precompute(t=8, e=A.BASE) {
            const n = e.equals(A.BASE) ? e : new A(e.x,e.y);
            return n._setWindowSize(t),
            n.multiply(a),
            n
        },
        sha512Sync: void 0
    };
    Object.defineProperties(nt, {
        sha512Sync: {
            configurable: !1,
            get: ()=>X,
            set(t) {
                X || (X = t)
            }
        }
    })
}
)),
o.register("kjyEk", (function(t, e) {}
)),
o.register("dEXSZ", (function(t, e) {
    !function(t, e) {
        function n(t, e) {
            if (!t)
                throw new Error(e || "Assertion failed")
        }
        function r(t, e) {
            t.super_ = e;
            var n = function() {};
            n.prototype = e.prototype,
            t.prototype = new n,
            t.prototype.constructor = t
        }
        function i(t, e, n) {
            if (i.isBN(t))
                return t;
            this.negative = 0,
            this.words = null,
            this.length = 0,
            this.red = null,
            null !== t && ("le" !== e && "be" !== e || (n = e,
            e = 10),
            this._init(t || 0, e || 10, n || "be"))
        }
        var s;
        "object" == typeof t ? t.exports = i : e.BN = i,
        i.BN = i,
        i.wordSize = 26;
        try {
            s = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : o("kjyEk").Buffer
        } catch (t) {}
        function a(t, e) {
            var r = t.charCodeAt(e);
            return r >= 48 && r <= 57 ? r - 48 : r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : void n(!1, "Invalid character in " + t)
        }
        function l(t, e, n) {
            var r = a(t, n);
            return n - 1 >= e && (r |= a(t, n - 1) << 4),
            r
        }
        function c(t, e, r, i) {
            for (var s = 0, o = 0, a = Math.min(t.length, r), l = e; l < a; l++) {
                var c = t.charCodeAt(l) - 48;
                s *= i,
                o = c >= 49 ? c - 49 + 10 : c >= 17 ? c - 17 + 10 : c,
                n(c >= 0 && o < i, "Invalid character"),
                s += o
            }
            return s
        }
        function u(t, e) {
            t.words = e.words,
            t.length = e.length,
            t.negative = e.negative,
            t.red = e.red
        }
        if (i.isBN = function(t) {
            return t instanceof i || null !== t && "object" == typeof t && t.constructor.wordSize === i.wordSize && Array.isArray(t.words)
        }
        ,
        i.max = function(t, e) {
            return t.cmp(e) > 0 ? t : e
        }
        ,
        i.min = function(t, e) {
            return t.cmp(e) < 0 ? t : e
        }
        ,
        i.prototype._init = function(t, e, r) {
            if ("number" == typeof t)
                return this._initNumber(t, e, r);
            if ("object" == typeof t)
                return this._initArray(t, e, r);
            "hex" === e && (e = 16),
            n(e === (0 | e) && e >= 2 && e <= 36);
            var i = 0;
            "-" === (t = t.toString().replace(/\s+/g, ""))[0] && (i++,
            this.negative = 1),
            i < t.length && (16 === e ? this._parseHex(t, i, r) : (this._parseBase(t, e, i),
            "le" === r && this._initArray(this.toArray(), e, r)))
        }
        ,
        i.prototype._initNumber = function(t, e, r) {
            t < 0 && (this.negative = 1,
            t = -t),
            t < 67108864 ? (this.words = [67108863 & t],
            this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863],
            this.length = 2) : (n(t < 9007199254740992),
            this.words = [67108863 & t, t / 67108864 & 67108863, 1],
            this.length = 3),
            "le" === r && this._initArray(this.toArray(), e, r)
        }
        ,
        i.prototype._initArray = function(t, e, r) {
            if (n("number" == typeof t.length),
            t.length <= 0)
                return this.words = [0],
                this.length = 1,
                this;
            this.length = Math.ceil(t.length / 3),
            this.words = new Array(this.length);
            for (var i = 0; i < this.length; i++)
                this.words[i] = 0;
            var s, o, a = 0;
            if ("be" === r)
                for (i = t.length - 1,
                s = 0; i >= 0; i -= 3)
                    o = t[i] | t[i - 1] << 8 | t[i - 2] << 16,
                    this.words[s] |= o << a & 67108863,
                    this.words[s + 1] = o >>> 26 - a & 67108863,
                    (a += 24) >= 26 && (a -= 26,
                    s++);
            else if ("le" === r)
                for (i = 0,
                s = 0; i < t.length; i += 3)
                    o = t[i] | t[i + 1] << 8 | t[i + 2] << 16,
                    this.words[s] |= o << a & 67108863,
                    this.words[s + 1] = o >>> 26 - a & 67108863,
                    (a += 24) >= 26 && (a -= 26,
                    s++);
            return this._strip()
        }
        ,
        i.prototype._parseHex = function(t, e, n) {
            this.length = Math.ceil((t.length - e) / 6),
            this.words = new Array(this.length);
            for (var r = 0; r < this.length; r++)
                this.words[r] = 0;
            var i, s = 0, o = 0;
            if ("be" === n)
                for (r = t.length - 1; r >= e; r -= 2)
                    i = l(t, e, r) << s,
                    this.words[o] |= 67108863 & i,
                    s >= 18 ? (s -= 18,
                    o += 1,
                    this.words[o] |= i >>> 26) : s += 8;
            else
                for (r = (t.length - e) % 2 == 0 ? e + 1 : e; r < t.length; r += 2)
                    i = l(t, e, r) << s,
                    this.words[o] |= 67108863 & i,
                    s >= 18 ? (s -= 18,
                    o += 1,
                    this.words[o] |= i >>> 26) : s += 8;
            this._strip()
        }
        ,
        i.prototype._parseBase = function(t, e, n) {
            this.words = [0],
            this.length = 1;
            for (var r = 0, i = 1; i <= 67108863; i *= e)
                r++;
            r--,
            i = i / e | 0;
            for (var s = t.length - n, o = s % r, a = Math.min(s, s - o) + n, l = 0, u = n; u < a; u += r)
                l = c(t, u, u + r, e),
                this.imuln(i),
                this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
            if (0 !== o) {
                var h = 1;
                for (l = c(t, u, t.length, e),
                u = 0; u < o; u++)
                    h *= e;
                this.imuln(h),
                this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l)
            }
            this._strip()
        }
        ,
        i.prototype.copy = function(t) {
            t.words = new Array(this.length);
            for (var e = 0; e < this.length; e++)
                t.words[e] = this.words[e];
            t.length = this.length,
            t.negative = this.negative,
            t.red = this.red
        }
        ,
        i.prototype._move = function(t) {
            u(t, this)
        }
        ,
        i.prototype.clone = function() {
            var t = new i(null);
            return this.copy(t),
            t
        }
        ,
        i.prototype._expand = function(t) {
            for (; this.length < t; )
                this.words[this.length++] = 0;
            return this
        }
        ,
        i.prototype._strip = function() {
            for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
            return this._normSign()
        }
        ,
        i.prototype._normSign = function() {
            return 1 === this.length && 0 === this.words[0] && (this.negative = 0),
            this
        }
        ,
        "undefined" != typeof Symbol && "function" == typeof Symbol.for)
            try {
                i.prototype[Symbol.for("nodejs.util.inspect.custom")] = h
            } catch (t) {
                i.prototype.inspect = h
            }
        else
            i.prototype.inspect = h;
        function h() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var d = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
          , f = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
          , p = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        i.prototype.toString = function(t, e) {
            var r;
            if (e = 0 | e || 1,
            16 === (t = t || 10) || "hex" === t) {
                r = "";
                for (var i = 0, s = 0, o = 0; o < this.length; o++) {
                    var a = this.words[o]
                      , l = (16777215 & (a << i | s)).toString(16);
                    s = a >>> 24 - i & 16777215,
                    (i += 2) >= 26 && (i -= 26,
                    o--),
                    r = 0 !== s || o !== this.length - 1 ? d[6 - l.length] + l + r : l + r
                }
                for (0 !== s && (r = s.toString(16) + r); r.length % e != 0; )
                    r = "0" + r;
                return 0 !== this.negative && (r = "-" + r),
                r
            }
            if (t === (0 | t) && t >= 2 && t <= 36) {
                var c = f[t]
                  , u = p[t];
                r = "";
                var h = this.clone();
                for (h.negative = 0; !h.isZero(); ) {
                    var m = h.modrn(u).toString(t);
                    r = (h = h.idivn(u)).isZero() ? m + r : d[c - m.length] + m + r
                }
                for (this.isZero() && (r = "0" + r); r.length % e != 0; )
                    r = "0" + r;
                return 0 !== this.negative && (r = "-" + r),
                r
            }
            n(!1, "Base should be between 2 and 36")
        }
        ,
        i.prototype.toNumber = function() {
            var t = this.words[0];
            return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"),
            0 !== this.negative ? -t : t
        }
        ,
        i.prototype.toJSON = function() {
            return this.toString(16, 2)
        }
        ,
        s && (i.prototype.toBuffer = function(t, e) {
            return this.toArrayLike(s, t, e)
        }
        ),
        i.prototype.toArray = function(t, e) {
            return this.toArrayLike(Array, t, e)
        }
        ;
        function m(t, e, n) {
            n.negative = e.negative ^ t.negative;
            var r = t.length + e.length | 0;
            n.length = r,
            r = r - 1 | 0;
            var i = 0 | t.words[0]
              , s = 0 | e.words[0]
              , o = i * s
              , a = 67108863 & o
              , l = o / 67108864 | 0;
            n.words[0] = a;
            for (var c = 1; c < r; c++) {
                for (var u = l >>> 26, h = 67108863 & l, d = Math.min(c, e.length - 1), f = Math.max(0, c - t.length + 1); f <= d; f++) {
                    var p = c - f | 0;
                    u += (o = (i = 0 | t.words[p]) * (s = 0 | e.words[f]) + h) / 67108864 | 0,
                    h = 67108863 & o
                }
                n.words[c] = 0 | h,
                l = 0 | u
            }
            return 0 !== l ? n.words[c] = 0 | l : n.length--,
            n._strip()
        }
        i.prototype.toArrayLike = function(t, e, r) {
            this._strip();
            var i = this.byteLength()
              , s = r || Math.max(1, i);
            n(i <= s, "byte array longer than desired length"),
            n(s > 0, "Requested array length <= 0");
            var o = function(t, e) {
                return t.allocUnsafe ? t.allocUnsafe(e) : new t(e)
            }(t, s);
            return this["_toArrayLike" + ("le" === e ? "LE" : "BE")](o, i),
            o
        }
        ,
        i.prototype._toArrayLikeLE = function(t, e) {
            for (var n = 0, r = 0, i = 0, s = 0; i < this.length; i++) {
                var o = this.words[i] << s | r;
                t[n++] = 255 & o,
                n < t.length && (t[n++] = o >> 8 & 255),
                n < t.length && (t[n++] = o >> 16 & 255),
                6 === s ? (n < t.length && (t[n++] = o >> 24 & 255),
                r = 0,
                s = 0) : (r = o >>> 24,
                s += 2)
            }
            if (n < t.length)
                for (t[n++] = r; n < t.length; )
                    t[n++] = 0
        }
        ,
        i.prototype._toArrayLikeBE = function(t, e) {
            for (var n = t.length - 1, r = 0, i = 0, s = 0; i < this.length; i++) {
                var o = this.words[i] << s | r;
                t[n--] = 255 & o,
                n >= 0 && (t[n--] = o >> 8 & 255),
                n >= 0 && (t[n--] = o >> 16 & 255),
                6 === s ? (n >= 0 && (t[n--] = o >> 24 & 255),
                r = 0,
                s = 0) : (r = o >>> 24,
                s += 2)
            }
            if (n >= 0)
                for (t[n--] = r; n >= 0; )
                    t[n--] = 0
        }
        ,
        Math.clz32 ? i.prototype._countBits = function(t) {
            return 32 - Math.clz32(t)
        }
        : i.prototype._countBits = function(t) {
            var e = t
              , n = 0;
            return e >= 4096 && (n += 13,
            e >>>= 13),
            e >= 64 && (n += 7,
            e >>>= 7),
            e >= 8 && (n += 4,
            e >>>= 4),
            e >= 2 && (n += 2,
            e >>>= 2),
            n + e
        }
        ,
        i.prototype._zeroBits = function(t) {
            if (0 === t)
                return 26;
            var e = t
              , n = 0;
            return 0 == (8191 & e) && (n += 13,
            e >>>= 13),
            0 == (127 & e) && (n += 7,
            e >>>= 7),
            0 == (15 & e) && (n += 4,
            e >>>= 4),
            0 == (3 & e) && (n += 2,
            e >>>= 2),
            0 == (1 & e) && n++,
            n
        }
        ,
        i.prototype.bitLength = function() {
            var t = this.words[this.length - 1]
              , e = this._countBits(t);
            return 26 * (this.length - 1) + e
        }
        ,
        i.prototype.zeroBits = function() {
            if (this.isZero())
                return 0;
            for (var t = 0, e = 0; e < this.length; e++) {
                var n = this._zeroBits(this.words[e]);
                if (t += n,
                26 !== n)
                    break
            }
            return t
        }
        ,
        i.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }
        ,
        i.prototype.toTwos = function(t) {
            return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone()
        }
        ,
        i.prototype.fromTwos = function(t) {
            return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone()
        }
        ,
        i.prototype.isNeg = function() {
            return 0 !== this.negative
        }
        ,
        i.prototype.neg = function() {
            return this.clone().ineg()
        }
        ,
        i.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        i.prototype.iuor = function(t) {
            for (; this.length < t.length; )
                this.words[this.length++] = 0;
            for (var e = 0; e < t.length; e++)
                this.words[e] = this.words[e] | t.words[e];
            return this._strip()
        }
        ,
        i.prototype.ior = function(t) {
            return n(0 == (this.negative | t.negative)),
            this.iuor(t)
        }
        ,
        i.prototype.or = function(t) {
            return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this)
        }
        ,
        i.prototype.uor = function(t) {
            return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this)
        }
        ,
        i.prototype.iuand = function(t) {
            var e;
            e = this.length > t.length ? t : this;
            for (var n = 0; n < e.length; n++)
                this.words[n] = this.words[n] & t.words[n];
            return this.length = e.length,
            this._strip()
        }
        ,
        i.prototype.iand = function(t) {
            return n(0 == (this.negative | t.negative)),
            this.iuand(t)
        }
        ,
        i.prototype.and = function(t) {
            return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this)
        }
        ,
        i.prototype.uand = function(t) {
            return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this)
        }
        ,
        i.prototype.iuxor = function(t) {
            var e, n;
            this.length > t.length ? (e = this,
            n = t) : (e = t,
            n = this);
            for (var r = 0; r < n.length; r++)
                this.words[r] = e.words[r] ^ n.words[r];
            if (this !== e)
                for (; r < e.length; r++)
                    this.words[r] = e.words[r];
            return this.length = e.length,
            this._strip()
        }
        ,
        i.prototype.ixor = function(t) {
            return n(0 == (this.negative | t.negative)),
            this.iuxor(t)
        }
        ,
        i.prototype.xor = function(t) {
            return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this)
        }
        ,
        i.prototype.uxor = function(t) {
            return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this)
        }
        ,
        i.prototype.inotn = function(t) {
            n("number" == typeof t && t >= 0);
            var e = 0 | Math.ceil(t / 26)
              , r = t % 26;
            this._expand(e),
            r > 0 && e--;
            for (var i = 0; i < e; i++)
                this.words[i] = 67108863 & ~this.words[i];
            return r > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - r),
            this._strip()
        }
        ,
        i.prototype.notn = function(t) {
            return this.clone().inotn(t)
        }
        ,
        i.prototype.setn = function(t, e) {
            n("number" == typeof t && t >= 0);
            var r = t / 26 | 0
              , i = t % 26;
            return this._expand(r + 1),
            this.words[r] = e ? this.words[r] | 1 << i : this.words[r] & ~(1 << i),
            this._strip()
        }
        ,
        i.prototype.iadd = function(t) {
            var e, n, r;
            if (0 !== this.negative && 0 === t.negative)
                return this.negative = 0,
                e = this.isub(t),
                this.negative ^= 1,
                this._normSign();
            if (0 === this.negative && 0 !== t.negative)
                return t.negative = 0,
                e = this.isub(t),
                t.negative = 1,
                e._normSign();
            this.length > t.length ? (n = this,
            r = t) : (n = t,
            r = this);
            for (var i = 0, s = 0; s < r.length; s++)
                e = (0 | n.words[s]) + (0 | r.words[s]) + i,
                this.words[s] = 67108863 & e,
                i = e >>> 26;
            for (; 0 !== i && s < n.length; s++)
                e = (0 | n.words[s]) + i,
                this.words[s] = 67108863 & e,
                i = e >>> 26;
            if (this.length = n.length,
            0 !== i)
                this.words[this.length] = i,
                this.length++;
            else if (n !== this)
                for (; s < n.length; s++)
                    this.words[s] = n.words[s];
            return this
        }
        ,
        i.prototype.add = function(t) {
            var e;
            return 0 !== t.negative && 0 === this.negative ? (t.negative = 0,
            e = this.sub(t),
            t.negative ^= 1,
            e) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0,
            e = t.sub(this),
            this.negative = 1,
            e) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this)
        }
        ,
        i.prototype.isub = function(t) {
            if (0 !== t.negative) {
                t.negative = 0;
                var e = this.iadd(t);
                return t.negative = 1,
                e._normSign()
            }
            if (0 !== this.negative)
                return this.negative = 0,
                this.iadd(t),
                this.negative = 1,
                this._normSign();
            var n, r, i = this.cmp(t);
            if (0 === i)
                return this.negative = 0,
                this.length = 1,
                this.words[0] = 0,
                this;
            i > 0 ? (n = this,
            r = t) : (n = t,
            r = this);
            for (var s = 0, o = 0; o < r.length; o++)
                s = (e = (0 | n.words[o]) - (0 | r.words[o]) + s) >> 26,
                this.words[o] = 67108863 & e;
            for (; 0 !== s && o < n.length; o++)
                s = (e = (0 | n.words[o]) + s) >> 26,
                this.words[o] = 67108863 & e;
            if (0 === s && o < n.length && n !== this)
                for (; o < n.length; o++)
                    this.words[o] = n.words[o];
            return this.length = Math.max(this.length, o),
            n !== this && (this.negative = 1),
            this._strip()
        }
        ,
        i.prototype.sub = function(t) {
            return this.clone().isub(t)
        }
        ;
        var g = function(t, e, n) {
            var r, i, s, o = t.words, a = e.words, l = n.words, c = 0, u = 0 | o[0], h = 8191 & u, d = u >>> 13, f = 0 | o[1], p = 8191 & f, m = f >>> 13, g = 0 | o[2], y = 8191 & g, b = g >>> 13, v = 0 | o[3], w = 8191 & v, x = v >>> 13, E = 0 | o[4], _ = 8191 & E, A = E >>> 13, S = 0 | o[5], T = 8191 & S, k = S >>> 13, I = 0 | o[6], M = 8191 & I, C = I >>> 13, P = 0 | o[7], O = 8191 & P, N = P >>> 13, R = 0 | o[8], D = 8191 & R, B = R >>> 13, L = 0 | o[9], F = 8191 & L, j = L >>> 13, U = 0 | a[0], z = 8191 & U, V = U >>> 13, W = 0 | a[1], Y = 8191 & W, H = W >>> 13, $ = 0 | a[2], G = 8191 & $, X = $ >>> 13, q = 0 | a[3], K = 8191 & q, Q = q >>> 13, Z = 0 | a[4], J = 8191 & Z, tt = Z >>> 13, et = 0 | a[5], nt = 8191 & et, rt = et >>> 13, it = 0 | a[6], st = 8191 & it, ot = it >>> 13, at = 0 | a[7], lt = 8191 & at, ct = at >>> 13, ut = 0 | a[8], ht = 8191 & ut, dt = ut >>> 13, ft = 0 | a[9], pt = 8191 & ft, mt = ft >>> 13;
            n.negative = t.negative ^ e.negative,
            n.length = 19;
            var gt = (c + (r = Math.imul(h, z)) | 0) + ((8191 & (i = (i = Math.imul(h, V)) + Math.imul(d, z) | 0)) << 13) | 0;
            c = ((s = Math.imul(d, V)) + (i >>> 13) | 0) + (gt >>> 26) | 0,
            gt &= 67108863,
            r = Math.imul(p, z),
            i = (i = Math.imul(p, V)) + Math.imul(m, z) | 0,
            s = Math.imul(m, V);
            var yt = (c + (r = r + Math.imul(h, Y) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, H) | 0) + Math.imul(d, Y) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(d, H) | 0) + (i >>> 13) | 0) + (yt >>> 26) | 0,
            yt &= 67108863,
            r = Math.imul(y, z),
            i = (i = Math.imul(y, V)) + Math.imul(b, z) | 0,
            s = Math.imul(b, V),
            r = r + Math.imul(p, Y) | 0,
            i = (i = i + Math.imul(p, H) | 0) + Math.imul(m, Y) | 0,
            s = s + Math.imul(m, H) | 0;
            var bt = (c + (r = r + Math.imul(h, G) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, X) | 0) + Math.imul(d, G) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(d, X) | 0) + (i >>> 13) | 0) + (bt >>> 26) | 0,
            bt &= 67108863,
            r = Math.imul(w, z),
            i = (i = Math.imul(w, V)) + Math.imul(x, z) | 0,
            s = Math.imul(x, V),
            r = r + Math.imul(y, Y) | 0,
            i = (i = i + Math.imul(y, H) | 0) + Math.imul(b, Y) | 0,
            s = s + Math.imul(b, H) | 0,
            r = r + Math.imul(p, G) | 0,
            i = (i = i + Math.imul(p, X) | 0) + Math.imul(m, G) | 0,
            s = s + Math.imul(m, X) | 0;
            var vt = (c + (r = r + Math.imul(h, K) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, Q) | 0) + Math.imul(d, K) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(d, Q) | 0) + (i >>> 13) | 0) + (vt >>> 26) | 0,
            vt &= 67108863,
            r = Math.imul(_, z),
            i = (i = Math.imul(_, V)) + Math.imul(A, z) | 0,
            s = Math.imul(A, V),
            r = r + Math.imul(w, Y) | 0,
            i = (i = i + Math.imul(w, H) | 0) + Math.imul(x, Y) | 0,
            s = s + Math.imul(x, H) | 0,
            r = r + Math.imul(y, G) | 0,
            i = (i = i + Math.imul(y, X) | 0) + Math.imul(b, G) | 0,
            s = s + Math.imul(b, X) | 0,
            r = r + Math.imul(p, K) | 0,
            i = (i = i + Math.imul(p, Q) | 0) + Math.imul(m, K) | 0,
            s = s + Math.imul(m, Q) | 0;
            var wt = (c + (r = r + Math.imul(h, J) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, tt) | 0) + Math.imul(d, J) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(d, tt) | 0) + (i >>> 13) | 0) + (wt >>> 26) | 0,
            wt &= 67108863,
            r = Math.imul(T, z),
            i = (i = Math.imul(T, V)) + Math.imul(k, z) | 0,
            s = Math.imul(k, V),
            r = r + Math.imul(_, Y) | 0,
            i = (i = i + Math.imul(_, H) | 0) + Math.imul(A, Y) | 0,
            s = s + Math.imul(A, H) | 0,
            r = r + Math.imul(w, G) | 0,
            i = (i = i + Math.imul(w, X) | 0) + Math.imul(x, G) | 0,
            s = s + Math.imul(x, X) | 0,
            r = r + Math.imul(y, K) | 0,
            i = (i = i + Math.imul(y, Q) | 0) + Math.imul(b, K) | 0,
            s = s + Math.imul(b, Q) | 0,
            r = r + Math.imul(p, J) | 0,
            i = (i = i + Math.imul(p, tt) | 0) + Math.imul(m, J) | 0,
            s = s + Math.imul(m, tt) | 0;
            var xt = (c + (r = r + Math.imul(h, nt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, rt) | 0) + Math.imul(d, nt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(d, rt) | 0) + (i >>> 13) | 0) + (xt >>> 26) | 0,
            xt &= 67108863,
            r = Math.imul(M, z),
            i = (i = Math.imul(M, V)) + Math.imul(C, z) | 0,
            s = Math.imul(C, V),
            r = r + Math.imul(T, Y) | 0,
            i = (i = i + Math.imul(T, H) | 0) + Math.imul(k, Y) | 0,
            s = s + Math.imul(k, H) | 0,
            r = r + Math.imul(_, G) | 0,
            i = (i = i + Math.imul(_, X) | 0) + Math.imul(A, G) | 0,
            s = s + Math.imul(A, X) | 0,
            r = r + Math.imul(w, K) | 0,
            i = (i = i + Math.imul(w, Q) | 0) + Math.imul(x, K) | 0,
            s = s + Math.imul(x, Q) | 0,
            r = r + Math.imul(y, J) | 0,
            i = (i = i + Math.imul(y, tt) | 0) + Math.imul(b, J) | 0,
            s = s + Math.imul(b, tt) | 0,
            r = r + Math.imul(p, nt) | 0,
            i = (i = i + Math.imul(p, rt) | 0) + Math.imul(m, nt) | 0,
            s = s + Math.imul(m, rt) | 0;
            var Et = (c + (r = r + Math.imul(h, st) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, ot) | 0) + Math.imul(d, st) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(d, ot) | 0) + (i >>> 13) | 0) + (Et >>> 26) | 0,
            Et &= 67108863,
            r = Math.imul(O, z),
            i = (i = Math.imul(O, V)) + Math.imul(N, z) | 0,
            s = Math.imul(N, V),
            r = r + Math.imul(M, Y) | 0,
            i = (i = i + Math.imul(M, H) | 0) + Math.imul(C, Y) | 0,
            s = s + Math.imul(C, H) | 0,
            r = r + Math.imul(T, G) | 0,
            i = (i = i + Math.imul(T, X) | 0) + Math.imul(k, G) | 0,
            s = s + Math.imul(k, X) | 0,
            r = r + Math.imul(_, K) | 0,
            i = (i = i + Math.imul(_, Q) | 0) + Math.imul(A, K) | 0,
            s = s + Math.imul(A, Q) | 0,
            r = r + Math.imul(w, J) | 0,
            i = (i = i + Math.imul(w, tt) | 0) + Math.imul(x, J) | 0,
            s = s + Math.imul(x, tt) | 0,
            r = r + Math.imul(y, nt) | 0,
            i = (i = i + Math.imul(y, rt) | 0) + Math.imul(b, nt) | 0,
            s = s + Math.imul(b, rt) | 0,
            r = r + Math.imul(p, st) | 0,
            i = (i = i + Math.imul(p, ot) | 0) + Math.imul(m, st) | 0,
            s = s + Math.imul(m, ot) | 0;
            var _t = (c + (r = r + Math.imul(h, lt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, ct) | 0) + Math.imul(d, lt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(d, ct) | 0) + (i >>> 13) | 0) + (_t >>> 26) | 0,
            _t &= 67108863,
            r = Math.imul(D, z),
            i = (i = Math.imul(D, V)) + Math.imul(B, z) | 0,
            s = Math.imul(B, V),
            r = r + Math.imul(O, Y) | 0,
            i = (i = i + Math.imul(O, H) | 0) + Math.imul(N, Y) | 0,
            s = s + Math.imul(N, H) | 0,
            r = r + Math.imul(M, G) | 0,
            i = (i = i + Math.imul(M, X) | 0) + Math.imul(C, G) | 0,
            s = s + Math.imul(C, X) | 0,
            r = r + Math.imul(T, K) | 0,
            i = (i = i + Math.imul(T, Q) | 0) + Math.imul(k, K) | 0,
            s = s + Math.imul(k, Q) | 0,
            r = r + Math.imul(_, J) | 0,
            i = (i = i + Math.imul(_, tt) | 0) + Math.imul(A, J) | 0,
            s = s + Math.imul(A, tt) | 0,
            r = r + Math.imul(w, nt) | 0,
            i = (i = i + Math.imul(w, rt) | 0) + Math.imul(x, nt) | 0,
            s = s + Math.imul(x, rt) | 0,
            r = r + Math.imul(y, st) | 0,
            i = (i = i + Math.imul(y, ot) | 0) + Math.imul(b, st) | 0,
            s = s + Math.imul(b, ot) | 0,
            r = r + Math.imul(p, lt) | 0,
            i = (i = i + Math.imul(p, ct) | 0) + Math.imul(m, lt) | 0,
            s = s + Math.imul(m, ct) | 0;
            var At = (c + (r = r + Math.imul(h, ht) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, dt) | 0) + Math.imul(d, ht) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(d, dt) | 0) + (i >>> 13) | 0) + (At >>> 26) | 0,
            At &= 67108863,
            r = Math.imul(F, z),
            i = (i = Math.imul(F, V)) + Math.imul(j, z) | 0,
            s = Math.imul(j, V),
            r = r + Math.imul(D, Y) | 0,
            i = (i = i + Math.imul(D, H) | 0) + Math.imul(B, Y) | 0,
            s = s + Math.imul(B, H) | 0,
            r = r + Math.imul(O, G) | 0,
            i = (i = i + Math.imul(O, X) | 0) + Math.imul(N, G) | 0,
            s = s + Math.imul(N, X) | 0,
            r = r + Math.imul(M, K) | 0,
            i = (i = i + Math.imul(M, Q) | 0) + Math.imul(C, K) | 0,
            s = s + Math.imul(C, Q) | 0,
            r = r + Math.imul(T, J) | 0,
            i = (i = i + Math.imul(T, tt) | 0) + Math.imul(k, J) | 0,
            s = s + Math.imul(k, tt) | 0,
            r = r + Math.imul(_, nt) | 0,
            i = (i = i + Math.imul(_, rt) | 0) + Math.imul(A, nt) | 0,
            s = s + Math.imul(A, rt) | 0,
            r = r + Math.imul(w, st) | 0,
            i = (i = i + Math.imul(w, ot) | 0) + Math.imul(x, st) | 0,
            s = s + Math.imul(x, ot) | 0,
            r = r + Math.imul(y, lt) | 0,
            i = (i = i + Math.imul(y, ct) | 0) + Math.imul(b, lt) | 0,
            s = s + Math.imul(b, ct) | 0,
            r = r + Math.imul(p, ht) | 0,
            i = (i = i + Math.imul(p, dt) | 0) + Math.imul(m, ht) | 0,
            s = s + Math.imul(m, dt) | 0;
            var St = (c + (r = r + Math.imul(h, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, mt) | 0) + Math.imul(d, pt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(d, mt) | 0) + (i >>> 13) | 0) + (St >>> 26) | 0,
            St &= 67108863,
            r = Math.imul(F, Y),
            i = (i = Math.imul(F, H)) + Math.imul(j, Y) | 0,
            s = Math.imul(j, H),
            r = r + Math.imul(D, G) | 0,
            i = (i = i + Math.imul(D, X) | 0) + Math.imul(B, G) | 0,
            s = s + Math.imul(B, X) | 0,
            r = r + Math.imul(O, K) | 0,
            i = (i = i + Math.imul(O, Q) | 0) + Math.imul(N, K) | 0,
            s = s + Math.imul(N, Q) | 0,
            r = r + Math.imul(M, J) | 0,
            i = (i = i + Math.imul(M, tt) | 0) + Math.imul(C, J) | 0,
            s = s + Math.imul(C, tt) | 0,
            r = r + Math.imul(T, nt) | 0,
            i = (i = i + Math.imul(T, rt) | 0) + Math.imul(k, nt) | 0,
            s = s + Math.imul(k, rt) | 0,
            r = r + Math.imul(_, st) | 0,
            i = (i = i + Math.imul(_, ot) | 0) + Math.imul(A, st) | 0,
            s = s + Math.imul(A, ot) | 0,
            r = r + Math.imul(w, lt) | 0,
            i = (i = i + Math.imul(w, ct) | 0) + Math.imul(x, lt) | 0,
            s = s + Math.imul(x, ct) | 0,
            r = r + Math.imul(y, ht) | 0,
            i = (i = i + Math.imul(y, dt) | 0) + Math.imul(b, ht) | 0,
            s = s + Math.imul(b, dt) | 0;
            var Tt = (c + (r = r + Math.imul(p, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(p, mt) | 0) + Math.imul(m, pt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(m, mt) | 0) + (i >>> 13) | 0) + (Tt >>> 26) | 0,
            Tt &= 67108863,
            r = Math.imul(F, G),
            i = (i = Math.imul(F, X)) + Math.imul(j, G) | 0,
            s = Math.imul(j, X),
            r = r + Math.imul(D, K) | 0,
            i = (i = i + Math.imul(D, Q) | 0) + Math.imul(B, K) | 0,
            s = s + Math.imul(B, Q) | 0,
            r = r + Math.imul(O, J) | 0,
            i = (i = i + Math.imul(O, tt) | 0) + Math.imul(N, J) | 0,
            s = s + Math.imul(N, tt) | 0,
            r = r + Math.imul(M, nt) | 0,
            i = (i = i + Math.imul(M, rt) | 0) + Math.imul(C, nt) | 0,
            s = s + Math.imul(C, rt) | 0,
            r = r + Math.imul(T, st) | 0,
            i = (i = i + Math.imul(T, ot) | 0) + Math.imul(k, st) | 0,
            s = s + Math.imul(k, ot) | 0,
            r = r + Math.imul(_, lt) | 0,
            i = (i = i + Math.imul(_, ct) | 0) + Math.imul(A, lt) | 0,
            s = s + Math.imul(A, ct) | 0,
            r = r + Math.imul(w, ht) | 0,
            i = (i = i + Math.imul(w, dt) | 0) + Math.imul(x, ht) | 0,
            s = s + Math.imul(x, dt) | 0;
            var kt = (c + (r = r + Math.imul(y, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(y, mt) | 0) + Math.imul(b, pt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(b, mt) | 0) + (i >>> 13) | 0) + (kt >>> 26) | 0,
            kt &= 67108863,
            r = Math.imul(F, K),
            i = (i = Math.imul(F, Q)) + Math.imul(j, K) | 0,
            s = Math.imul(j, Q),
            r = r + Math.imul(D, J) | 0,
            i = (i = i + Math.imul(D, tt) | 0) + Math.imul(B, J) | 0,
            s = s + Math.imul(B, tt) | 0,
            r = r + Math.imul(O, nt) | 0,
            i = (i = i + Math.imul(O, rt) | 0) + Math.imul(N, nt) | 0,
            s = s + Math.imul(N, rt) | 0,
            r = r + Math.imul(M, st) | 0,
            i = (i = i + Math.imul(M, ot) | 0) + Math.imul(C, st) | 0,
            s = s + Math.imul(C, ot) | 0,
            r = r + Math.imul(T, lt) | 0,
            i = (i = i + Math.imul(T, ct) | 0) + Math.imul(k, lt) | 0,
            s = s + Math.imul(k, ct) | 0,
            r = r + Math.imul(_, ht) | 0,
            i = (i = i + Math.imul(_, dt) | 0) + Math.imul(A, ht) | 0,
            s = s + Math.imul(A, dt) | 0;
            var It = (c + (r = r + Math.imul(w, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(w, mt) | 0) + Math.imul(x, pt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(x, mt) | 0) + (i >>> 13) | 0) + (It >>> 26) | 0,
            It &= 67108863,
            r = Math.imul(F, J),
            i = (i = Math.imul(F, tt)) + Math.imul(j, J) | 0,
            s = Math.imul(j, tt),
            r = r + Math.imul(D, nt) | 0,
            i = (i = i + Math.imul(D, rt) | 0) + Math.imul(B, nt) | 0,
            s = s + Math.imul(B, rt) | 0,
            r = r + Math.imul(O, st) | 0,
            i = (i = i + Math.imul(O, ot) | 0) + Math.imul(N, st) | 0,
            s = s + Math.imul(N, ot) | 0,
            r = r + Math.imul(M, lt) | 0,
            i = (i = i + Math.imul(M, ct) | 0) + Math.imul(C, lt) | 0,
            s = s + Math.imul(C, ct) | 0,
            r = r + Math.imul(T, ht) | 0,
            i = (i = i + Math.imul(T, dt) | 0) + Math.imul(k, ht) | 0,
            s = s + Math.imul(k, dt) | 0;
            var Mt = (c + (r = r + Math.imul(_, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(_, mt) | 0) + Math.imul(A, pt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(A, mt) | 0) + (i >>> 13) | 0) + (Mt >>> 26) | 0,
            Mt &= 67108863,
            r = Math.imul(F, nt),
            i = (i = Math.imul(F, rt)) + Math.imul(j, nt) | 0,
            s = Math.imul(j, rt),
            r = r + Math.imul(D, st) | 0,
            i = (i = i + Math.imul(D, ot) | 0) + Math.imul(B, st) | 0,
            s = s + Math.imul(B, ot) | 0,
            r = r + Math.imul(O, lt) | 0,
            i = (i = i + Math.imul(O, ct) | 0) + Math.imul(N, lt) | 0,
            s = s + Math.imul(N, ct) | 0,
            r = r + Math.imul(M, ht) | 0,
            i = (i = i + Math.imul(M, dt) | 0) + Math.imul(C, ht) | 0,
            s = s + Math.imul(C, dt) | 0;
            var Ct = (c + (r = r + Math.imul(T, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(T, mt) | 0) + Math.imul(k, pt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(k, mt) | 0) + (i >>> 13) | 0) + (Ct >>> 26) | 0,
            Ct &= 67108863,
            r = Math.imul(F, st),
            i = (i = Math.imul(F, ot)) + Math.imul(j, st) | 0,
            s = Math.imul(j, ot),
            r = r + Math.imul(D, lt) | 0,
            i = (i = i + Math.imul(D, ct) | 0) + Math.imul(B, lt) | 0,
            s = s + Math.imul(B, ct) | 0,
            r = r + Math.imul(O, ht) | 0,
            i = (i = i + Math.imul(O, dt) | 0) + Math.imul(N, ht) | 0,
            s = s + Math.imul(N, dt) | 0;
            var Pt = (c + (r = r + Math.imul(M, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(M, mt) | 0) + Math.imul(C, pt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(C, mt) | 0) + (i >>> 13) | 0) + (Pt >>> 26) | 0,
            Pt &= 67108863,
            r = Math.imul(F, lt),
            i = (i = Math.imul(F, ct)) + Math.imul(j, lt) | 0,
            s = Math.imul(j, ct),
            r = r + Math.imul(D, ht) | 0,
            i = (i = i + Math.imul(D, dt) | 0) + Math.imul(B, ht) | 0,
            s = s + Math.imul(B, dt) | 0;
            var Ot = (c + (r = r + Math.imul(O, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(O, mt) | 0) + Math.imul(N, pt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(N, mt) | 0) + (i >>> 13) | 0) + (Ot >>> 26) | 0,
            Ot &= 67108863,
            r = Math.imul(F, ht),
            i = (i = Math.imul(F, dt)) + Math.imul(j, ht) | 0,
            s = Math.imul(j, dt);
            var Nt = (c + (r = r + Math.imul(D, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(D, mt) | 0) + Math.imul(B, pt) | 0)) << 13) | 0;
            c = ((s = s + Math.imul(B, mt) | 0) + (i >>> 13) | 0) + (Nt >>> 26) | 0,
            Nt &= 67108863;
            var Rt = (c + (r = Math.imul(F, pt)) | 0) + ((8191 & (i = (i = Math.imul(F, mt)) + Math.imul(j, pt) | 0)) << 13) | 0;
            return c = ((s = Math.imul(j, mt)) + (i >>> 13) | 0) + (Rt >>> 26) | 0,
            Rt &= 67108863,
            l[0] = gt,
            l[1] = yt,
            l[2] = bt,
            l[3] = vt,
            l[4] = wt,
            l[5] = xt,
            l[6] = Et,
            l[7] = _t,
            l[8] = At,
            l[9] = St,
            l[10] = Tt,
            l[11] = kt,
            l[12] = It,
            l[13] = Mt,
            l[14] = Ct,
            l[15] = Pt,
            l[16] = Ot,
            l[17] = Nt,
            l[18] = Rt,
            0 !== c && (l[19] = c,
            n.length++),
            n
        };
        function y(t, e, n) {
            n.negative = e.negative ^ t.negative,
            n.length = t.length + e.length;
            for (var r = 0, i = 0, s = 0; s < n.length - 1; s++) {
                var o = i;
                i = 0;
                for (var a = 67108863 & r, l = Math.min(s, e.length - 1), c = Math.max(0, s - t.length + 1); c <= l; c++) {
                    var u = s - c
                      , h = (0 | t.words[u]) * (0 | e.words[c])
                      , d = 67108863 & h;
                    a = 67108863 & (d = d + a | 0),
                    i += (o = (o = o + (h / 67108864 | 0) | 0) + (d >>> 26) | 0) >>> 26,
                    o &= 67108863
                }
                n.words[s] = a,
                r = o,
                o = i
            }
            return 0 !== r ? n.words[s] = r : n.length--,
            n._strip()
        }
        function b(t, e, n) {
            return y(t, e, n)
        }
        function v(t, e) {
            this.x = t,
            this.y = e
        }
        Math.imul || (g = m),
        i.prototype.mulTo = function(t, e) {
            var n = this.length + t.length;
            return 10 === this.length && 10 === t.length ? g(this, t, e) : n < 63 ? m(this, t, e) : n < 1024 ? y(this, t, e) : b(this, t, e)
        }
        ,
        v.prototype.makeRBT = function(t) {
            for (var e = new Array(t), n = i.prototype._countBits(t) - 1, r = 0; r < t; r++)
                e[r] = this.revBin(r, n, t);
            return e
        }
        ,
        v.prototype.revBin = function(t, e, n) {
            if (0 === t || t === n - 1)
                return t;
            for (var r = 0, i = 0; i < e; i++)
                r |= (1 & t) << e - i - 1,
                t >>= 1;
            return r
        }
        ,
        v.prototype.permute = function(t, e, n, r, i, s) {
            for (var o = 0; o < s; o++)
                r[o] = e[t[o]],
                i[o] = n[t[o]]
        }
        ,
        v.prototype.transform = function(t, e, n, r, i, s) {
            this.permute(s, t, e, n, r, i);
            for (var o = 1; o < i; o <<= 1)
                for (var a = o << 1, l = Math.cos(2 * Math.PI / a), c = Math.sin(2 * Math.PI / a), u = 0; u < i; u += a)
                    for (var h = l, d = c, f = 0; f < o; f++) {
                        var p = n[u + f]
                          , m = r[u + f]
                          , g = n[u + f + o]
                          , y = r[u + f + o]
                          , b = h * g - d * y;
                        y = h * y + d * g,
                        g = b,
                        n[u + f] = p + g,
                        r[u + f] = m + y,
                        n[u + f + o] = p - g,
                        r[u + f + o] = m - y,
                        f !== a && (b = l * h - c * d,
                        d = l * d + c * h,
                        h = b)
                    }
        }
        ,
        v.prototype.guessLen13b = function(t, e) {
            var n = 1 | Math.max(e, t)
              , r = 1 & n
              , i = 0;
            for (n = n / 2 | 0; n; n >>>= 1)
                i++;
            return 1 << i + 1 + r
        }
        ,
        v.prototype.conjugate = function(t, e, n) {
            if (!(n <= 1))
                for (var r = 0; r < n / 2; r++) {
                    var i = t[r];
                    t[r] = t[n - r - 1],
                    t[n - r - 1] = i,
                    i = e[r],
                    e[r] = -e[n - r - 1],
                    e[n - r - 1] = -i
                }
        }
        ,
        v.prototype.normalize13b = function(t, e) {
            for (var n = 0, r = 0; r < e / 2; r++) {
                var i = 8192 * Math.round(t[2 * r + 1] / e) + Math.round(t[2 * r] / e) + n;
                t[r] = 67108863 & i,
                n = i < 67108864 ? 0 : i / 67108864 | 0
            }
            return t
        }
        ,
        v.prototype.convert13b = function(t, e, r, i) {
            for (var s = 0, o = 0; o < e; o++)
                s += 0 | t[o],
                r[2 * o] = 8191 & s,
                s >>>= 13,
                r[2 * o + 1] = 8191 & s,
                s >>>= 13;
            for (o = 2 * e; o < i; ++o)
                r[o] = 0;
            n(0 === s),
            n(0 == (-8192 & s))
        }
        ,
        v.prototype.stub = function(t) {
            for (var e = new Array(t), n = 0; n < t; n++)
                e[n] = 0;
            return e
        }
        ,
        v.prototype.mulp = function(t, e, n) {
            var r = 2 * this.guessLen13b(t.length, e.length)
              , i = this.makeRBT(r)
              , s = this.stub(r)
              , o = new Array(r)
              , a = new Array(r)
              , l = new Array(r)
              , c = new Array(r)
              , u = new Array(r)
              , h = new Array(r)
              , d = n.words;
            d.length = r,
            this.convert13b(t.words, t.length, o, r),
            this.convert13b(e.words, e.length, c, r),
            this.transform(o, s, a, l, r, i),
            this.transform(c, s, u, h, r, i);
            for (var f = 0; f < r; f++) {
                var p = a[f] * u[f] - l[f] * h[f];
                l[f] = a[f] * h[f] + l[f] * u[f],
                a[f] = p
            }
            return this.conjugate(a, l, r),
            this.transform(a, l, d, s, r, i),
            this.conjugate(d, s, r),
            this.normalize13b(d, r),
            n.negative = t.negative ^ e.negative,
            n.length = t.length + e.length,
            n._strip()
        }
        ,
        i.prototype.mul = function(t) {
            var e = new i(null);
            return e.words = new Array(this.length + t.length),
            this.mulTo(t, e)
        }
        ,
        i.prototype.mulf = function(t) {
            var e = new i(null);
            return e.words = new Array(this.length + t.length),
            b(this, t, e)
        }
        ,
        i.prototype.imul = function(t) {
            return this.clone().mulTo(t, this)
        }
        ,
        i.prototype.imuln = function(t) {
            var e = t < 0;
            e && (t = -t),
            n("number" == typeof t),
            n(t < 67108864);
            for (var r = 0, i = 0; i < this.length; i++) {
                var s = (0 | this.words[i]) * t
                  , o = (67108863 & s) + (67108863 & r);
                r >>= 26,
                r += s / 67108864 | 0,
                r += o >>> 26,
                this.words[i] = 67108863 & o
            }
            return 0 !== r && (this.words[i] = r,
            this.length++),
            e ? this.ineg() : this
        }
        ,
        i.prototype.muln = function(t) {
            return this.clone().imuln(t)
        }
        ,
        i.prototype.sqr = function() {
            return this.mul(this)
        }
        ,
        i.prototype.isqr = function() {
            return this.imul(this.clone())
        }
        ,
        i.prototype.pow = function(t) {
            var e = function(t) {
                for (var e = new Array(t.bitLength()), n = 0; n < e.length; n++) {
                    var r = n / 26 | 0
                      , i = n % 26;
                    e[n] = t.words[r] >>> i & 1
                }
                return e
            }(t);
            if (0 === e.length)
                return new i(1);
            for (var n = this, r = 0; r < e.length && 0 === e[r]; r++,
            n = n.sqr())
                ;
            if (++r < e.length)
                for (var s = n.sqr(); r < e.length; r++,
                s = s.sqr())
                    0 !== e[r] && (n = n.mul(s));
            return n
        }
        ,
        i.prototype.iushln = function(t) {
            n("number" == typeof t && t >= 0);
            var e, r = t % 26, i = (t - r) / 26, s = 67108863 >>> 26 - r << 26 - r;
            if (0 !== r) {
                var o = 0;
                for (e = 0; e < this.length; e++) {
                    var a = this.words[e] & s
                      , l = (0 | this.words[e]) - a << r;
                    this.words[e] = l | o,
                    o = a >>> 26 - r
                }
                o && (this.words[e] = o,
                this.length++)
            }
            if (0 !== i) {
                for (e = this.length - 1; e >= 0; e--)
                    this.words[e + i] = this.words[e];
                for (e = 0; e < i; e++)
                    this.words[e] = 0;
                this.length += i
            }
            return this._strip()
        }
        ,
        i.prototype.ishln = function(t) {
            return n(0 === this.negative),
            this.iushln(t)
        }
        ,
        i.prototype.iushrn = function(t, e, r) {
            var i;
            n("number" == typeof t && t >= 0),
            i = e ? (e - e % 26) / 26 : 0;
            var s = t % 26
              , o = Math.min((t - s) / 26, this.length)
              , a = 67108863 ^ 67108863 >>> s << s
              , l = r;
            if (i -= o,
            i = Math.max(0, i),
            l) {
                for (var c = 0; c < o; c++)
                    l.words[c] = this.words[c];
                l.length = o
            }
            if (0 === o)
                ;
            else if (this.length > o)
                for (this.length -= o,
                c = 0; c < this.length; c++)
                    this.words[c] = this.words[c + o];
            else
                this.words[0] = 0,
                this.length = 1;
            var u = 0;
            for (c = this.length - 1; c >= 0 && (0 !== u || c >= i); c--) {
                var h = 0 | this.words[c];
                this.words[c] = u << 26 - s | h >>> s,
                u = h & a
            }
            return l && 0 !== u && (l.words[l.length++] = u),
            0 === this.length && (this.words[0] = 0,
            this.length = 1),
            this._strip()
        }
        ,
        i.prototype.ishrn = function(t, e, r) {
            return n(0 === this.negative),
            this.iushrn(t, e, r)
        }
        ,
        i.prototype.shln = function(t) {
            return this.clone().ishln(t)
        }
        ,
        i.prototype.ushln = function(t) {
            return this.clone().iushln(t)
        }
        ,
        i.prototype.shrn = function(t) {
            return this.clone().ishrn(t)
        }
        ,
        i.prototype.ushrn = function(t) {
            return this.clone().iushrn(t)
        }
        ,
        i.prototype.testn = function(t) {
            n("number" == typeof t && t >= 0);
            var e = t % 26
              , r = (t - e) / 26
              , i = 1 << e;
            return !(this.length <= r) && !!(this.words[r] & i)
        }
        ,
        i.prototype.imaskn = function(t) {
            n("number" == typeof t && t >= 0);
            var e = t % 26
              , r = (t - e) / 26;
            if (n(0 === this.negative, "imaskn works only with positive numbers"),
            this.length <= r)
                return this;
            if (0 !== e && r++,
            this.length = Math.min(r, this.length),
            0 !== e) {
                var i = 67108863 ^ 67108863 >>> e << e;
                this.words[this.length - 1] &= i
            }
            return this._strip()
        }
        ,
        i.prototype.maskn = function(t) {
            return this.clone().imaskn(t)
        }
        ,
        i.prototype.iaddn = function(t) {
            return n("number" == typeof t),
            n(t < 67108864),
            t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= t ? (this.words[0] = t - (0 | this.words[0]),
            this.negative = 0,
            this) : (this.negative = 0,
            this.isubn(t),
            this.negative = 1,
            this) : this._iaddn(t)
        }
        ,
        i.prototype._iaddn = function(t) {
            this.words[0] += t;
            for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)
                this.words[e] -= 67108864,
                e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++;
            return this.length = Math.max(this.length, e + 1),
            this
        }
        ,
        i.prototype.isubn = function(t) {
            if (n("number" == typeof t),
            n(t < 67108864),
            t < 0)
                return this.iaddn(-t);
            if (0 !== this.negative)
                return this.negative = 0,
                this.iaddn(t),
                this.negative = 1,
                this;
            if (this.words[0] -= t,
            1 === this.length && this.words[0] < 0)
                this.words[0] = -this.words[0],
                this.negative = 1;
            else
                for (var e = 0; e < this.length && this.words[e] < 0; e++)
                    this.words[e] += 67108864,
                    this.words[e + 1] -= 1;
            return this._strip()
        }
        ,
        i.prototype.addn = function(t) {
            return this.clone().iaddn(t)
        }
        ,
        i.prototype.subn = function(t) {
            return this.clone().isubn(t)
        }
        ,
        i.prototype.iabs = function() {
            return this.negative = 0,
            this
        }
        ,
        i.prototype.abs = function() {
            return this.clone().iabs()
        }
        ,
        i.prototype._ishlnsubmul = function(t, e, r) {
            var i, s, o = t.length + r;
            this._expand(o);
            var a = 0;
            for (i = 0; i < t.length; i++) {
                s = (0 | this.words[i + r]) + a;
                var l = (0 | t.words[i]) * e;
                a = ((s -= 67108863 & l) >> 26) - (l / 67108864 | 0),
                this.words[i + r] = 67108863 & s
            }
            for (; i < this.length - r; i++)
                a = (s = (0 | this.words[i + r]) + a) >> 26,
                this.words[i + r] = 67108863 & s;
            if (0 === a)
                return this._strip();
            for (n(-1 === a),
            a = 0,
            i = 0; i < this.length; i++)
                a = (s = -(0 | this.words[i]) + a) >> 26,
                this.words[i] = 67108863 & s;
            return this.negative = 1,
            this._strip()
        }
        ,
        i.prototype._wordDiv = function(t, e) {
            var n = (this.length,
            t.length)
              , r = this.clone()
              , s = t
              , o = 0 | s.words[s.length - 1];
            0 !== (n = 26 - this._countBits(o)) && (s = s.ushln(n),
            r.iushln(n),
            o = 0 | s.words[s.length - 1]);
            var a, l = r.length - s.length;
            if ("mod" !== e) {
                (a = new i(null)).length = l + 1,
                a.words = new Array(a.length);
                for (var c = 0; c < a.length; c++)
                    a.words[c] = 0
            }
            var u = r.clone()._ishlnsubmul(s, 1, l);
            0 === u.negative && (r = u,
            a && (a.words[l] = 1));
            for (var h = l - 1; h >= 0; h--) {
                var d = 67108864 * (0 | r.words[s.length + h]) + (0 | r.words[s.length + h - 1]);
                for (d = Math.min(d / o | 0, 67108863),
                r._ishlnsubmul(s, d, h); 0 !== r.negative; )
                    d--,
                    r.negative = 0,
                    r._ishlnsubmul(s, 1, h),
                    r.isZero() || (r.negative ^= 1);
                a && (a.words[h] = d)
            }
            return a && a._strip(),
            r._strip(),
            "div" !== e && 0 !== n && r.iushrn(n),
            {
                div: a || null,
                mod: r
            }
        }
        ,
        i.prototype.divmod = function(t, e, r) {
            return n(!t.isZero()),
            this.isZero() ? {
                div: new i(0),
                mod: new i(0)
            } : 0 !== this.negative && 0 === t.negative ? (a = this.neg().divmod(t, e),
            "mod" !== e && (s = a.div.neg()),
            "div" !== e && (o = a.mod.neg(),
            r && 0 !== o.negative && o.iadd(t)),
            {
                div: s,
                mod: o
            }) : 0 === this.negative && 0 !== t.negative ? (a = this.divmod(t.neg(), e),
            "mod" !== e && (s = a.div.neg()),
            {
                div: s,
                mod: a.mod
            }) : 0 != (this.negative & t.negative) ? (a = this.neg().divmod(t.neg(), e),
            "div" !== e && (o = a.mod.neg(),
            r && 0 !== o.negative && o.isub(t)),
            {
                div: a.div,
                mod: o
            }) : t.length > this.length || this.cmp(t) < 0 ? {
                div: new i(0),
                mod: this
            } : 1 === t.length ? "div" === e ? {
                div: this.divn(t.words[0]),
                mod: null
            } : "mod" === e ? {
                div: null,
                mod: new i(this.modrn(t.words[0]))
            } : {
                div: this.divn(t.words[0]),
                mod: new i(this.modrn(t.words[0]))
            } : this._wordDiv(t, e);
            var s, o, a
        }
        ,
        i.prototype.div = function(t) {
            return this.divmod(t, "div", !1).div
        }
        ,
        i.prototype.mod = function(t) {
            return this.divmod(t, "mod", !1).mod
        }
        ,
        i.prototype.umod = function(t) {
            return this.divmod(t, "mod", !0).mod
        }
        ,
        i.prototype.divRound = function(t) {
            var e = this.divmod(t);
            if (e.mod.isZero())
                return e.div;
            var n = 0 !== e.div.negative ? e.mod.isub(t) : e.mod
              , r = t.ushrn(1)
              , i = t.andln(1)
              , s = n.cmp(r);
            return s < 0 || 1 === i && 0 === s ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1)
        }
        ,
        i.prototype.modrn = function(t) {
            var e = t < 0;
            e && (t = -t),
            n(t <= 67108863);
            for (var r = 67108864 % t, i = 0, s = this.length - 1; s >= 0; s--)
                i = (r * i + (0 | this.words[s])) % t;
            return e ? -i : i
        }
        ,
        i.prototype.modn = function(t) {
            return this.modrn(t)
        }
        ,
        i.prototype.idivn = function(t) {
            var e = t < 0;
            e && (t = -t),
            n(t <= 67108863);
            for (var r = 0, i = this.length - 1; i >= 0; i--) {
                var s = (0 | this.words[i]) + 67108864 * r;
                this.words[i] = s / t | 0,
                r = s % t
            }
            return this._strip(),
            e ? this.ineg() : this
        }
        ,
        i.prototype.divn = function(t) {
            return this.clone().idivn(t)
        }
        ,
        i.prototype.egcd = function(t) {
            n(0 === t.negative),
            n(!t.isZero());
            var e = this
              , r = t.clone();
            e = 0 !== e.negative ? e.umod(t) : e.clone();
            for (var s = new i(1), o = new i(0), a = new i(0), l = new i(1), c = 0; e.isEven() && r.isEven(); )
                e.iushrn(1),
                r.iushrn(1),
                ++c;
            for (var u = r.clone(), h = e.clone(); !e.isZero(); ) {
                for (var d = 0, f = 1; 0 == (e.words[0] & f) && d < 26; ++d,
                f <<= 1)
                    ;
                if (d > 0)
                    for (e.iushrn(d); d-- > 0; )
                        (s.isOdd() || o.isOdd()) && (s.iadd(u),
                        o.isub(h)),
                        s.iushrn(1),
                        o.iushrn(1);
                for (var p = 0, m = 1; 0 == (r.words[0] & m) && p < 26; ++p,
                m <<= 1)
                    ;
                if (p > 0)
                    for (r.iushrn(p); p-- > 0; )
                        (a.isOdd() || l.isOdd()) && (a.iadd(u),
                        l.isub(h)),
                        a.iushrn(1),
                        l.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r),
                s.isub(a),
                o.isub(l)) : (r.isub(e),
                a.isub(s),
                l.isub(o))
            }
            return {
                a: a,
                b: l,
                gcd: r.iushln(c)
            }
        }
        ,
        i.prototype._invmp = function(t) {
            n(0 === t.negative),
            n(!t.isZero());
            var e = this
              , r = t.clone();
            e = 0 !== e.negative ? e.umod(t) : e.clone();
            for (var s, o = new i(1), a = new i(0), l = r.clone(); e.cmpn(1) > 0 && r.cmpn(1) > 0; ) {
                for (var c = 0, u = 1; 0 == (e.words[0] & u) && c < 26; ++c,
                u <<= 1)
                    ;
                if (c > 0)
                    for (e.iushrn(c); c-- > 0; )
                        o.isOdd() && o.iadd(l),
                        o.iushrn(1);
                for (var h = 0, d = 1; 0 == (r.words[0] & d) && h < 26; ++h,
                d <<= 1)
                    ;
                if (h > 0)
                    for (r.iushrn(h); h-- > 0; )
                        a.isOdd() && a.iadd(l),
                        a.iushrn(1);
                e.cmp(r) >= 0 ? (e.isub(r),
                o.isub(a)) : (r.isub(e),
                a.isub(o))
            }
            return (s = 0 === e.cmpn(1) ? o : a).cmpn(0) < 0 && s.iadd(t),
            s
        }
        ,
        i.prototype.gcd = function(t) {
            if (this.isZero())
                return t.abs();
            if (t.isZero())
                return this.abs();
            var e = this.clone()
              , n = t.clone();
            e.negative = 0,
            n.negative = 0;
            for (var r = 0; e.isEven() && n.isEven(); r++)
                e.iushrn(1),
                n.iushrn(1);
            for (; ; ) {
                for (; e.isEven(); )
                    e.iushrn(1);
                for (; n.isEven(); )
                    n.iushrn(1);
                var i = e.cmp(n);
                if (i < 0) {
                    var s = e;
                    e = n,
                    n = s
                } else if (0 === i || 0 === n.cmpn(1))
                    break;
                e.isub(n)
            }
            return n.iushln(r)
        }
        ,
        i.prototype.invm = function(t) {
            return this.egcd(t).a.umod(t)
        }
        ,
        i.prototype.isEven = function() {
            return 0 == (1 & this.words[0])
        }
        ,
        i.prototype.isOdd = function() {
            return 1 == (1 & this.words[0])
        }
        ,
        i.prototype.andln = function(t) {
            return this.words[0] & t
        }
        ,
        i.prototype.bincn = function(t) {
            n("number" == typeof t);
            var e = t % 26
              , r = (t - e) / 26
              , i = 1 << e;
            if (this.length <= r)
                return this._expand(r + 1),
                this.words[r] |= i,
                this;
            for (var s = i, o = r; 0 !== s && o < this.length; o++) {
                var a = 0 | this.words[o];
                s = (a += s) >>> 26,
                a &= 67108863,
                this.words[o] = a
            }
            return 0 !== s && (this.words[o] = s,
            this.length++),
            this
        }
        ,
        i.prototype.isZero = function() {
            return 1 === this.length && 0 === this.words[0]
        }
        ,
        i.prototype.cmpn = function(t) {
            var e, r = t < 0;
            if (0 !== this.negative && !r)
                return -1;
            if (0 === this.negative && r)
                return 1;
            if (this._strip(),
            this.length > 1)
                e = 1;
            else {
                r && (t = -t),
                n(t <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                e = i === t ? 0 : i < t ? -1 : 1
            }
            return 0 !== this.negative ? 0 | -e : e
        }
        ,
        i.prototype.cmp = function(t) {
            if (0 !== this.negative && 0 === t.negative)
                return -1;
            if (0 === this.negative && 0 !== t.negative)
                return 1;
            var e = this.ucmp(t);
            return 0 !== this.negative ? 0 | -e : e
        }
        ,
        i.prototype.ucmp = function(t) {
            if (this.length > t.length)
                return 1;
            if (this.length < t.length)
                return -1;
            for (var e = 0, n = this.length - 1; n >= 0; n--) {
                var r = 0 | this.words[n]
                  , i = 0 | t.words[n];
                if (r !== i) {
                    r < i ? e = -1 : r > i && (e = 1);
                    break
                }
            }
            return e
        }
        ,
        i.prototype.gtn = function(t) {
            return 1 === this.cmpn(t)
        }
        ,
        i.prototype.gt = function(t) {
            return 1 === this.cmp(t)
        }
        ,
        i.prototype.gten = function(t) {
            return this.cmpn(t) >= 0
        }
        ,
        i.prototype.gte = function(t) {
            return this.cmp(t) >= 0
        }
        ,
        i.prototype.ltn = function(t) {
            return -1 === this.cmpn(t)
        }
        ,
        i.prototype.lt = function(t) {
            return -1 === this.cmp(t)
        }
        ,
        i.prototype.lten = function(t) {
            return this.cmpn(t) <= 0
        }
        ,
        i.prototype.lte = function(t) {
            return this.cmp(t) <= 0
        }
        ,
        i.prototype.eqn = function(t) {
            return 0 === this.cmpn(t)
        }
        ,
        i.prototype.eq = function(t) {
            return 0 === this.cmp(t)
        }
        ,
        i.red = function(t) {
            return new T(t)
        }
        ,
        i.prototype.toRed = function(t) {
            return n(!this.red, "Already a number in reduction context"),
            n(0 === this.negative, "red works only with positives"),
            t.convertTo(this)._forceRed(t)
        }
        ,
        i.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        i.prototype._forceRed = function(t) {
            return this.red = t,
            this
        }
        ,
        i.prototype.forceRed = function(t) {
            return n(!this.red, "Already a number in reduction context"),
            this._forceRed(t)
        }
        ,
        i.prototype.redAdd = function(t) {
            return n(this.red, "redAdd works only with red numbers"),
            this.red.add(this, t)
        }
        ,
        i.prototype.redIAdd = function(t) {
            return n(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, t)
        }
        ,
        i.prototype.redSub = function(t) {
            return n(this.red, "redSub works only with red numbers"),
            this.red.sub(this, t)
        }
        ,
        i.prototype.redISub = function(t) {
            return n(this.red, "redISub works only with red numbers"),
            this.red.isub(this, t)
        }
        ,
        i.prototype.redShl = function(t) {
            return n(this.red, "redShl works only with red numbers"),
            this.red.shl(this, t)
        }
        ,
        i.prototype.redMul = function(t) {
            return n(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, t),
            this.red.mul(this, t)
        }
        ,
        i.prototype.redIMul = function(t) {
            return n(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, t),
            this.red.imul(this, t)
        }
        ,
        i.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        i.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        i.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        i.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        i.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        i.prototype.redPow = function(t) {
            return n(this.red && !t.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, t)
        }
        ;
        var w = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function x(t, e) {
            this.name = t,
            this.p = new i(e,16),
            this.n = this.p.bitLength(),
            this.k = new i(1).iushln(this.n).isub(this.p),
            this.tmp = this._tmp()
        }
        function E() {
            x.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        function _() {
            x.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        function A() {
            x.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        function S() {
            x.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        function T(t) {
            if ("string" == typeof t) {
                var e = i._prime(t);
                this.m = e.p,
                this.prime = e
            } else
                n(t.gtn(1), "modulus must be greater than 1"),
                this.m = t,
                this.prime = null
        }
        function k(t) {
            T.call(this, t),
            this.shift = this.m.bitLength(),
            this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26),
            this.r = new i(1).iushln(this.shift),
            this.r2 = this.imod(this.r.sqr()),
            this.rinv = this.r._invmp(this.m),
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
            this.minv = this.minv.umod(this.r),
            this.minv = this.r.sub(this.minv)
        }
        x.prototype._tmp = function() {
            var t = new i(null);
            return t.words = new Array(Math.ceil(this.n / 13)),
            t
        }
        ,
        x.prototype.ireduce = function(t) {
            var e, n = t;
            do {
                this.split(n, this.tmp),
                e = (n = (n = this.imulK(n)).iadd(this.tmp)).bitLength()
            } while (e > this.n);
            var r = e < this.n ? -1 : n.ucmp(this.p);
            return 0 === r ? (n.words[0] = 0,
            n.length = 1) : r > 0 ? n.isub(this.p) : void 0 !== n.strip ? n.strip() : n._strip(),
            n
        }
        ,
        x.prototype.split = function(t, e) {
            t.iushrn(this.n, 0, e)
        }
        ,
        x.prototype.imulK = function(t) {
            return t.imul(this.k)
        }
        ,
        r(E, x),
        E.prototype.split = function(t, e) {
            for (var n = 4194303, r = Math.min(t.length, 9), i = 0; i < r; i++)
                e.words[i] = t.words[i];
            if (e.length = r,
            t.length <= 9)
                return t.words[0] = 0,
                void (t.length = 1);
            var s = t.words[9];
            for (e.words[e.length++] = s & n,
            i = 10; i < t.length; i++) {
                var o = 0 | t.words[i];
                t.words[i - 10] = (o & n) << 4 | s >>> 22,
                s = o
            }
            s >>>= 22,
            t.words[i - 10] = s,
            0 === s && t.length > 10 ? t.length -= 10 : t.length -= 9
        }
        ,
        E.prototype.imulK = function(t) {
            t.words[t.length] = 0,
            t.words[t.length + 1] = 0,
            t.length += 2;
            for (var e = 0, n = 0; n < t.length; n++) {
                var r = 0 | t.words[n];
                e += 977 * r,
                t.words[n] = 67108863 & e,
                e = 64 * r + (e / 67108864 | 0)
            }
            return 0 === t.words[t.length - 1] && (t.length--,
            0 === t.words[t.length - 1] && t.length--),
            t
        }
        ,
        r(_, x),
        r(A, x),
        r(S, x),
        S.prototype.imulK = function(t) {
            for (var e = 0, n = 0; n < t.length; n++) {
                var r = 19 * (0 | t.words[n]) + e
                  , i = 67108863 & r;
                r >>>= 26,
                t.words[n] = i,
                e = r
            }
            return 0 !== e && (t.words[t.length++] = e),
            t
        }
        ,
        i._prime = function(t) {
            if (w[t])
                return w[t];
            var e;
            if ("k256" === t)
                e = new E;
            else if ("p224" === t)
                e = new _;
            else if ("p192" === t)
                e = new A;
            else {
                if ("p25519" !== t)
                    throw new Error("Unknown prime " + t);
                e = new S
            }
            return w[t] = e,
            e
        }
        ,
        T.prototype._verify1 = function(t) {
            n(0 === t.negative, "red works only with positives"),
            n(t.red, "red works only with red numbers")
        }
        ,
        T.prototype._verify2 = function(t, e) {
            n(0 == (t.negative | e.negative), "red works only with positives"),
            n(t.red && t.red === e.red, "red works only with red numbers")
        }
        ,
        T.prototype.imod = function(t) {
            return this.prime ? this.prime.ireduce(t)._forceRed(this) : (u(t, t.umod(this.m)._forceRed(this)),
            t)
        }
        ,
        T.prototype.neg = function(t) {
            return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this)
        }
        ,
        T.prototype.add = function(t, e) {
            this._verify2(t, e);
            var n = t.add(e);
            return n.cmp(this.m) >= 0 && n.isub(this.m),
            n._forceRed(this)
        }
        ,
        T.prototype.iadd = function(t, e) {
            this._verify2(t, e);
            var n = t.iadd(e);
            return n.cmp(this.m) >= 0 && n.isub(this.m),
            n
        }
        ,
        T.prototype.sub = function(t, e) {
            this._verify2(t, e);
            var n = t.sub(e);
            return n.cmpn(0) < 0 && n.iadd(this.m),
            n._forceRed(this)
        }
        ,
        T.prototype.isub = function(t, e) {
            this._verify2(t, e);
            var n = t.isub(e);
            return n.cmpn(0) < 0 && n.iadd(this.m),
            n
        }
        ,
        T.prototype.shl = function(t, e) {
            return this._verify1(t),
            this.imod(t.ushln(e))
        }
        ,
        T.prototype.imul = function(t, e) {
            return this._verify2(t, e),
            this.imod(t.imul(e))
        }
        ,
        T.prototype.mul = function(t, e) {
            return this._verify2(t, e),
            this.imod(t.mul(e))
        }
        ,
        T.prototype.isqr = function(t) {
            return this.imul(t, t.clone())
        }
        ,
        T.prototype.sqr = function(t) {
            return this.mul(t, t)
        }
        ,
        T.prototype.sqrt = function(t) {
            if (t.isZero())
                return t.clone();
            var e = this.m.andln(3);
            if (n(e % 2 == 1),
            3 === e) {
                var r = this.m.add(new i(1)).iushrn(2);
                return this.pow(t, r)
            }
            for (var s = this.m.subn(1), o = 0; !s.isZero() && 0 === s.andln(1); )
                o++,
                s.iushrn(1);
            n(!s.isZero());
            var a = new i(1).toRed(this)
              , l = a.redNeg()
              , c = this.m.subn(1).iushrn(1)
              , u = this.m.bitLength();
            for (u = new i(2 * u * u).toRed(this); 0 !== this.pow(u, c).cmp(l); )
                u.redIAdd(l);
            for (var h = this.pow(u, s), d = this.pow(t, s.addn(1).iushrn(1)), f = this.pow(t, s), p = o; 0 !== f.cmp(a); ) {
                for (var m = f, g = 0; 0 !== m.cmp(a); g++)
                    m = m.redSqr();
                n(g < p);
                var y = this.pow(h, new i(1).iushln(p - g - 1));
                d = d.redMul(y),
                h = y.redSqr(),
                f = f.redMul(h),
                p = g
            }
            return d
        }
        ,
        T.prototype.invm = function(t) {
            var e = t._invmp(this.m);
            return 0 !== e.negative ? (e.negative = 0,
            this.imod(e).redNeg()) : this.imod(e)
        }
        ,
        T.prototype.pow = function(t, e) {
            if (e.isZero())
                return new i(1).toRed(this);
            if (0 === e.cmpn(1))
                return t.clone();
            var n = new Array(16);
            n[0] = new i(1).toRed(this),
            n[1] = t;
            for (var r = 2; r < n.length; r++)
                n[r] = this.mul(n[r - 1], t);
            var s = n[0]
              , o = 0
              , a = 0
              , l = e.bitLength() % 26;
            for (0 === l && (l = 26),
            r = e.length - 1; r >= 0; r--) {
                for (var c = e.words[r], u = l - 1; u >= 0; u--) {
                    var h = c >> u & 1;
                    s !== n[0] && (s = this.sqr(s)),
                    0 !== h || 0 !== o ? (o <<= 1,
                    o |= h,
                    (4 === ++a || 0 === r && 0 === u) && (s = this.mul(s, n[o]),
                    a = 0,
                    o = 0)) : a = 0
                }
                l = 26
            }
            return s
        }
        ,
        T.prototype.convertTo = function(t) {
            var e = t.umod(this.m);
            return e === t ? e.clone() : e
        }
        ,
        T.prototype.convertFrom = function(t) {
            var e = t.clone();
            return e.red = null,
            e
        }
        ,
        i.mont = function(t) {
            return new k(t)
        }
        ,
        r(k, T),
        k.prototype.convertTo = function(t) {
            return this.imod(t.ushln(this.shift))
        }
        ,
        k.prototype.convertFrom = function(t) {
            var e = this.imod(t.mul(this.rinv));
            return e.red = null,
            e
        }
        ,
        k.prototype.imul = function(t, e) {
            if (t.isZero() || e.isZero())
                return t.words[0] = 0,
                t.length = 1,
                t;
            var n = t.imul(e)
              , r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , i = n.isub(r).iushrn(this.shift)
              , s = i;
            return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
            s._forceRed(this)
        }
        ,
        k.prototype.mul = function(t, e) {
            if (t.isZero() || e.isZero())
                return new i(0)._forceRed(this);
            var n = t.mul(e)
              , r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , s = n.isub(r).iushrn(this.shift)
              , o = s;
            return s.cmp(this.m) >= 0 ? o = s.isub(this.m) : s.cmpn(0) < 0 && (o = s.iadd(this.m)),
            o._forceRed(this)
        }
        ,
        k.prototype.invm = function(t) {
            return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this)
        }
    }(t, this)
}
)),
o.register("4UTkl", (function(t, e) {
    var n = o("0DhcF");
    t.exports = n("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
}
)),
o.register("0DhcF", (function(t, e) {
    var n = o("1U9GM").Buffer;
    t.exports = function(t) {
        if (t.length >= 255)
            throw new TypeError("Alphabet too long");
        for (var e = new Uint8Array(256), r = 0; r < e.length; r++)
            e[r] = 255;
        for (var i = 0; i < t.length; i++) {
            var s = t.charAt(i)
              , o = s.charCodeAt(0);
            if (255 !== e[o])
                throw new TypeError(s + " is ambiguous");
            e[o] = i
        }
        var a = t.length
          , l = t.charAt(0)
          , c = Math.log(a) / Math.log(256)
          , u = Math.log(256) / Math.log(a);
        function h(t) {
            if ("string" != typeof t)
                throw new TypeError("Expected String");
            if (0 === t.length)
                return n.alloc(0);
            for (var r = 0, i = 0, s = 0; t[r] === l; )
                i++,
                r++;
            for (var o = (t.length - r) * c + 1 >>> 0, u = new Uint8Array(o); t[r]; ) {
                var h = e[t.charCodeAt(r)];
                if (255 === h)
                    return;
                for (var d = 0, f = o - 1; (0 !== h || d < s) && -1 !== f; f--,
                d++)
                    h += a * u[f] >>> 0,
                    u[f] = h % 256 >>> 0,
                    h = h / 256 >>> 0;
                if (0 !== h)
                    throw new Error("Non-zero carry");
                s = d,
                r++
            }
            for (var p = o - s; p !== o && 0 === u[p]; )
                p++;
            var m = n.allocUnsafe(i + (o - p));
            m.fill(0, 0, i);
            for (var g = i; p !== o; )
                m[g++] = u[p++];
            return m
        }
        return {
            encode: function(e) {
                if ((Array.isArray(e) || e instanceof Uint8Array) && (e = n.from(e)),
                !n.isBuffer(e))
                    throw new TypeError("Expected Buffer");
                if (0 === e.length)
                    return "";
                for (var r = 0, i = 0, s = 0, o = e.length; s !== o && 0 === e[s]; )
                    s++,
                    r++;
                for (var c = (o - s) * u + 1 >>> 0, h = new Uint8Array(c); s !== o; ) {
                    for (var d = e[s], f = 0, p = c - 1; (0 !== d || f < i) && -1 !== p; p--,
                    f++)
                        d += 256 * h[p] >>> 0,
                        h[p] = d % a >>> 0,
                        d = d / a >>> 0;
                    if (0 !== d)
                        throw new Error("Non-zero carry");
                    i = f,
                    s++
                }
                for (var m = c - i; m !== c && 0 === h[m]; )
                    m++;
                for (var g = l.repeat(r); m < c; ++m)
                    g += t.charAt(h[m]);
                return g
            },
            decodeUnsafe: h,
            decode: function(t) {
                var e = h(t);
                if (e)
                    return e;
                throw new Error("Non-base" + a + " character")
            }
        }
    }
}
)),
o.register("1U9GM", (function(t, e) {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var n = o("6ZWSX")
      , r = n.Buffer;
    function i(t, e) {
        for (var n in t)
            e[n] = t[n]
    }
    function s(t, e, n) {
        return r(t, e, n)
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t.exports = n : (i(n, t.exports),
    t.exports.Buffer = s),
    s.prototype = Object.create(r.prototype),
    i(r, s),
    s.from = function(t, e, n) {
        if ("number" == typeof t)
            throw new TypeError("Argument must not be a number");
        return r(t, e, n)
    }
    ,
    s.alloc = function(t, e, n) {
        if ("number" != typeof t)
            throw new TypeError("Argument must be a number");
        var i = r(t);
        return void 0 !== e ? "string" == typeof n ? i.fill(e, n) : i.fill(e) : i.fill(0),
        i
    }
    ,
    s.allocUnsafe = function(t) {
        if ("number" != typeof t)
            throw new TypeError("Argument must be a number");
        return r(t)
    }
    ,
    s.allocUnsafeSlow = function(t) {
        if ("number" != typeof t)
            throw new TypeError("Argument must be a number");
        return n.SlowBuffer(t)
    }
}
)),
o.register("6XnWx", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.sha224 = t.exports.sha256 = void 0;
    var n = o("g9W9K")
      , r = o("3Bcdj");
    const i = (t,e,n)=>t & e ^ t & n ^ e & n
      , s = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
      , a = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
      , l = new Uint32Array(64);
    class c extends n.SHA2 {
        constructor() {
            super(64, 32, 8, !1),
            this.A = 0 | a[0],
            this.B = 0 | a[1],
            this.C = 0 | a[2],
            this.D = 0 | a[3],
            this.E = 0 | a[4],
            this.F = 0 | a[5],
            this.G = 0 | a[6],
            this.H = 0 | a[7]
        }
        get() {
            const {A: t, B: e, C: n, D: r, E: i, F: s, G: o, H: a} = this;
            return [t, e, n, r, i, s, o, a]
        }
        set(t, e, n, r, i, s, o, a) {
            this.A = 0 | t,
            this.B = 0 | e,
            this.C = 0 | n,
            this.D = 0 | r,
            this.E = 0 | i,
            this.F = 0 | s,
            this.G = 0 | o,
            this.H = 0 | a
        }
        process(t, e) {
            for (let n = 0; n < 16; n++,
            e += 4)
                l[n] = t.getUint32(e, !1);
            for (let t = 16; t < 64; t++) {
                const e = l[t - 15]
                  , n = l[t - 2]
                  , i = (0,
                r.rotr)(e, 7) ^ (0,
                r.rotr)(e, 18) ^ e >>> 3
                  , s = (0,
                r.rotr)(n, 17) ^ (0,
                r.rotr)(n, 19) ^ n >>> 10;
                l[t] = s + l[t - 7] + i + l[t - 16] | 0
            }
            let {A: n, B: o, C: a, D: c, E: u, F: h, G: d, H: f} = this;
            for (let t = 0; t < 64; t++) {
                const e = f + ((0,
                r.rotr)(u, 6) ^ (0,
                r.rotr)(u, 11) ^ (0,
                r.rotr)(u, 25)) + ((p = u) & h ^ ~p & d) + s[t] + l[t] | 0
                  , m = ((0,
                r.rotr)(n, 2) ^ (0,
                r.rotr)(n, 13) ^ (0,
                r.rotr)(n, 22)) + i(n, o, a) | 0;
                f = d,
                d = h,
                h = u,
                u = c + e | 0,
                c = a,
                a = o,
                o = n,
                n = e + m | 0
            }
            var p;
            n = n + this.A | 0,
            o = o + this.B | 0,
            a = a + this.C | 0,
            c = c + this.D | 0,
            u = u + this.E | 0,
            h = h + this.F | 0,
            d = d + this.G | 0,
            f = f + this.H | 0,
            this.set(n, o, a, c, u, h, d, f)
        }
        roundClean() {
            l.fill(0)
        }
        destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0),
            this.buffer.fill(0)
        }
    }
    class u extends c {
        constructor() {
            super(),
            this.A = -1056596264,
            this.B = 914150663,
            this.C = 812702999,
            this.D = -150054599,
            this.E = -4191439,
            this.F = 1750603025,
            this.G = 1694076839,
            this.H = -1090891868,
            this.outputLen = 28
        }
    }
    t.exports.sha256 = (0,
    r.wrapConstructor)((()=>new c)),
    t.exports.sha224 = (0,
    r.wrapConstructor)((()=>new u))
}
)),
o.register("75BJw", (function(t, e) {
    var n = o("6ZWSX").Buffer
      , r = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n),
        Object.defineProperty(t, r, {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        })
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , i = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , s = t.exports && t.exports.__decorate || function(t, e, n, r) {
        var i, s = arguments.length, o = s < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o = Reflect.decorate(t, e, n, r);
        else
            for (var a = t.length - 1; a >= 0; a--)
                (i = t[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(e, n, o) : i(e, n)) || o);
        return s > 3 && o && Object.defineProperty(e, n, o),
        o
    }
      , a = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var n in t)
                "default" !== n && Object.hasOwnProperty.call(t, n) && r(e, t, n);
        return i(e, t),
        e
    }
      , l = t.exports && t.exports.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.deserializeUnchecked = t.exports.deserialize = t.exports.serialize = t.exports.BinaryReader = t.exports.BinaryWriter = t.exports.BorshError = t.exports.baseDecode = t.exports.baseEncode = void 0;
    const c = l(o("dEXSZ"))
      , u = l(o("89V9C"))
      , h = a(o("kOaA4"))
      , d = new ("function" != typeof TextDecoder ? h.TextDecoder : TextDecoder)("utf-8",{
        fatal: !0
    });
    t.exports.baseEncode = function(t) {
        return "string" == typeof t && (t = n.from(t, "utf8")),
        u.default.encode(n.from(t))
    }
    ,
    t.exports.baseDecode = function(t) {
        return n.from(u.default.decode(t))
    }
    ;
    const f = 1024;
    class p extends Error {
        constructor(t) {
            super(t),
            this.fieldPath = [],
            this.originalMessage = t
        }
        addToFieldPath(t) {
            this.fieldPath.splice(0, 0, t),
            this.message = this.originalMessage + ": " + this.fieldPath.join(".")
        }
    }
    t.exports.BorshError = p;
    class m {
        constructor() {
            this.buf = n.alloc(f),
            this.length = 0
        }
        maybeResize() {
            this.buf.length < 16 + this.length && (this.buf = n.concat([this.buf, n.alloc(f)]))
        }
        writeU8(t) {
            this.maybeResize(),
            this.buf.writeUInt8(t, this.length),
            this.length += 1
        }
        writeU16(t) {
            this.maybeResize(),
            this.buf.writeUInt16LE(t, this.length),
            this.length += 2
        }
        writeU32(t) {
            this.maybeResize(),
            this.buf.writeUInt32LE(t, this.length),
            this.length += 4
        }
        writeU64(t) {
            this.maybeResize(),
            this.writeBuffer(n.from(new c.default(t).toArray("le", 8)))
        }
        writeU128(t) {
            this.maybeResize(),
            this.writeBuffer(n.from(new c.default(t).toArray("le", 16)))
        }
        writeU256(t) {
            this.maybeResize(),
            this.writeBuffer(n.from(new c.default(t).toArray("le", 32)))
        }
        writeU512(t) {
            this.maybeResize(),
            this.writeBuffer(n.from(new c.default(t).toArray("le", 64)))
        }
        writeBuffer(t) {
            this.buf = n.concat([n.from(this.buf.subarray(0, this.length)), t, n.alloc(f)]),
            this.length += t.length
        }
        writeString(t) {
            this.maybeResize();
            const e = n.from(t, "utf8");
            this.writeU32(e.length),
            this.writeBuffer(e)
        }
        writeFixedArray(t) {
            this.writeBuffer(n.from(t))
        }
        writeArray(t, e) {
            this.maybeResize(),
            this.writeU32(t.length);
            for (const n of t)
                this.maybeResize(),
                e(n)
        }
        toArray() {
            return this.buf.subarray(0, this.length)
        }
    }
    function g(t, e, n) {
        const r = n.value;
        n.value = function(...t) {
            try {
                return r.apply(this, t)
            } catch (t) {
                if (t instanceof RangeError) {
                    const e = t.code;
                    if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(e) >= 0)
                        throw new p("Reached the end of buffer when deserializing")
                }
                throw t
            }
        }
    }
    t.exports.BinaryWriter = m;
    class y {
        constructor(t) {
            this.buf = t,
            this.offset = 0
        }
        readU8() {
            const t = this.buf.readUInt8(this.offset);
            return this.offset += 1,
            t
        }
        readU16() {
            const t = this.buf.readUInt16LE(this.offset);
            return this.offset += 2,
            t
        }
        readU32() {
            const t = this.buf.readUInt32LE(this.offset);
            return this.offset += 4,
            t
        }
        readU64() {
            const t = this.readBuffer(8);
            return new c.default(t,"le")
        }
        readU128() {
            const t = this.readBuffer(16);
            return new c.default(t,"le")
        }
        readU256() {
            const t = this.readBuffer(32);
            return new c.default(t,"le")
        }
        readU512() {
            const t = this.readBuffer(64);
            return new c.default(t,"le")
        }
        readBuffer(t) {
            if (this.offset + t > this.buf.length)
                throw new p(`Expected buffer length ${t} isn't within bounds`);
            const e = this.buf.slice(this.offset, this.offset + t);
            return this.offset += t,
            e
        }
        readString() {
            const t = this.readU32()
              , e = this.readBuffer(t);
            try {
                return d.decode(e)
            } catch (t) {
                throw new p(`Error decoding UTF-8 string: ${t}`)
            }
        }
        readFixedArray(t) {
            return new Uint8Array(this.readBuffer(t))
        }
        readArray(t) {
            const e = this.readU32()
              , n = Array();
            for (let r = 0; r < e; ++r)
                n.push(t());
            return n
        }
    }
    function b(t) {
        return t.charAt(0).toUpperCase() + t.slice(1)
    }
    function v(t, e, n, r, i) {
        try {
            if ("string" == typeof r)
                i[`write${b(r)}`](n);
            else if (r instanceof Array)
                if ("number" == typeof r[0]) {
                    if (n.length !== r[0])
                        throw new p(`Expecting byte array of length ${r[0]}, but got ${n.length} bytes`);
                    i.writeFixedArray(n)
                } else if (2 === r.length && "number" == typeof r[1]) {
                    if (n.length !== r[1])
                        throw new p(`Expecting byte array of length ${r[1]}, but got ${n.length} bytes`);
                    for (let e = 0; e < r[1]; e++)
                        v(t, null, n[e], r[0], i)
                } else
                    i.writeArray(n, (n=>{
                        v(t, e, n, r[0], i)
                    }
                    ));
            else if (void 0 !== r.kind)
                switch (r.kind) {
                case "option":
                    null == n ? i.writeU8(0) : (i.writeU8(1),
                    v(t, e, n, r.type, i));
                    break;
                case "map":
                    i.writeU32(n.size),
                    n.forEach(((n,s)=>{
                        v(t, e, s, r.key, i),
                        v(t, e, n, r.value, i)
                    }
                    ));
                    break;
                default:
                    throw new p(`FieldType ${r} unrecognized`)
                }
            else
                w(t, n, i)
        } catch (t) {
            throw t instanceof p && t.addToFieldPath(e),
            t
        }
    }
    function w(t, e, n) {
        if ("function" == typeof e.borshSerialize)
            return void e.borshSerialize(n);
        const r = t.get(e.constructor);
        if (!r)
            throw new p(`Class ${e.constructor.name} is missing in schema`);
        if ("struct" === r.kind)
            r.fields.map((([r,i])=>{
                v(t, r, e[r], i, n)
            }
            ));
        else {
            if ("enum" !== r.kind)
                throw new p(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`);
            {
                const i = e[r.field];
                for (let s = 0; s < r.values.length; ++s) {
                    const [o,a] = r.values[s];
                    if (o === i) {
                        n.writeU8(s),
                        v(t, o, e[o], a, n);
                        break
                    }
                }
            }
        }
    }
    function x(t, e, n, r) {
        try {
            if ("string" == typeof n)
                return r[`read${b(n)}`]();
            if (n instanceof Array) {
                if ("number" == typeof n[0])
                    return r.readFixedArray(n[0]);
                if ("number" == typeof n[1]) {
                    const e = [];
                    for (let i = 0; i < n[1]; i++)
                        e.push(x(t, null, n[0], r));
                    return e
                }
                return r.readArray((()=>x(t, e, n[0], r)))
            }
            if ("option" === n.kind) {
                return r.readU8() ? x(t, e, n.type, r) : void 0
            }
            if ("map" === n.kind) {
                let i = new Map;
                const s = r.readU32();
                for (let o = 0; o < s; o++) {
                    const s = x(t, e, n.key, r)
                      , o = x(t, e, n.value, r);
                    i.set(s, o)
                }
                return i
            }
            return E(t, n, r)
        } catch (t) {
            throw t instanceof p && t.addToFieldPath(e),
            t
        }
    }
    function E(t, e, n) {
        if ("function" == typeof e.borshDeserialize)
            return e.borshDeserialize(n);
        const r = t.get(e);
        if (!r)
            throw new p(`Class ${e.name} is missing in schema`);
        if ("struct" === r.kind) {
            const r = {};
            for (const [i,s] of t.get(e).fields)
                r[i] = x(t, i, s, n);
            return new e(r)
        }
        if ("enum" === r.kind) {
            const i = n.readU8();
            if (i >= r.values.length)
                throw new p(`Enum index: ${i} is out of range`);
            const [s,o] = r.values[i];
            return new e({
                [s]: x(t, s, o, n)
            })
        }
        throw new p(`Unexpected schema kind: ${r.kind} for ${e.constructor.name}`)
    }
    s([g], y.prototype, "readU8", null),
    s([g], y.prototype, "readU16", null),
    s([g], y.prototype, "readU32", null),
    s([g], y.prototype, "readU64", null),
    s([g], y.prototype, "readU128", null),
    s([g], y.prototype, "readU256", null),
    s([g], y.prototype, "readU512", null),
    s([g], y.prototype, "readString", null),
    s([g], y.prototype, "readFixedArray", null),
    s([g], y.prototype, "readArray", null),
    t.exports.BinaryReader = y,
    t.exports.serialize = function(t, e, n=m) {
        const r = new n;
        return w(t, e, r),
        r.toArray()
    }
    ,
    t.exports.deserialize = function(t, e, n, r=y) {
        const i = new r(n)
          , s = E(t, e, i);
        if (i.offset < n.length)
            throw new p(`Unexpected ${n.length - i.offset} bytes after deserialized data`);
        return s
    }
    ,
    t.exports.deserializeUnchecked = function(t, e, n, r=y) {
        return E(t, e, new r(n))
    }
}
)),
o.register("89V9C", (function(t, e) {
    var n = o("0DhcF");
    t.exports = n("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
}
)),
o.register("kOaA4", (function(e, n) {
    var r, i;
    function s(t, e, n) {
        return e <= t && t <= n
    }
    function o(t) {
        if (void 0 === t)
            return {};
        if (t === Object(t))
            return t;
        throw TypeError("Could not convert argument to dictionary")
    }
    t(e.exports, "TextEncoder", (()=>r), (t=>r = t)),
    t(e.exports, "TextDecoder", (()=>i), (t=>i = t));
    var a = -1;
    function l(t) {
        this.tokens = [].slice.call(t)
    }
    l.prototype = {
        endOfStream: function() {
            return !this.tokens.length
        },
        read: function() {
            return this.tokens.length ? this.tokens.shift() : a
        },
        prepend: function(t) {
            if (Array.isArray(t))
                for (var e = t; e.length; )
                    this.tokens.unshift(e.pop());
            else
                this.tokens.unshift(t)
        },
        push: function(t) {
            if (Array.isArray(t))
                for (var e = t; e.length; )
                    this.tokens.push(e.shift());
            else
                this.tokens.push(t)
        }
    };
    var c = -1;
    function u(t, e) {
        if (t)
            throw TypeError("Decoder error");
        return e || 65533
    }
    var h = "utf-8";
    function d(t, e) {
        if (!(this instanceof d))
            return new d(t,e);
        if ((t = void 0 !== t ? String(t).toLowerCase() : h) !== h)
            throw new Error("Encoding not supported. Only utf-8 is supported");
        e = o(e),
        this._streaming = !1,
        this._BOMseen = !1,
        this._decoder = null,
        this._fatal = Boolean(e.fatal),
        this._ignoreBOM = Boolean(e.ignoreBOM),
        Object.defineProperty(this, "encoding", {
            value: "utf-8"
        }),
        Object.defineProperty(this, "fatal", {
            value: this._fatal
        }),
        Object.defineProperty(this, "ignoreBOM", {
            value: this._ignoreBOM
        })
    }
    function f(t, e) {
        if (!(this instanceof f))
            return new f(t,e);
        if ((t = void 0 !== t ? String(t).toLowerCase() : h) !== h)
            throw new Error("Encoding not supported. Only utf-8 is supported");
        e = o(e),
        this._streaming = !1,
        this._encoder = null,
        this._options = {
            fatal: Boolean(e.fatal)
        },
        Object.defineProperty(this, "encoding", {
            value: "utf-8"
        })
    }
    function p(t) {
        var e = t.fatal
          , n = 0
          , r = 0
          , i = 0
          , o = 128
          , l = 191;
        this.handler = function(t, h) {
            if (h === a && 0 !== i)
                return i = 0,
                u(e);
            if (h === a)
                return c;
            if (0 === i) {
                if (s(h, 0, 127))
                    return h;
                if (s(h, 194, 223))
                    i = 1,
                    n = h - 192;
                else if (s(h, 224, 239))
                    224 === h && (o = 160),
                    237 === h && (l = 159),
                    i = 2,
                    n = h - 224;
                else {
                    if (!s(h, 240, 244))
                        return u(e);
                    240 === h && (o = 144),
                    244 === h && (l = 143),
                    i = 3,
                    n = h - 240
                }
                return n <<= 6 * i,
                null
            }
            if (!s(h, o, l))
                return n = i = r = 0,
                o = 128,
                l = 191,
                t.prepend(h),
                u(e);
            if (o = 128,
            l = 191,
            n += h - 128 << 6 * (i - (r += 1)),
            r !== i)
                return null;
            var d = n;
            return n = i = r = 0,
            d
        }
    }
    function m(t) {
        t.fatal;
        this.handler = function(t, e) {
            if (e === a)
                return c;
            if (s(e, 0, 127))
                return e;
            var n, r;
            s(e, 128, 2047) ? (n = 1,
            r = 192) : s(e, 2048, 65535) ? (n = 2,
            r = 224) : s(e, 65536, 1114111) && (n = 3,
            r = 240);
            for (var i = [(e >> 6 * n) + r]; n > 0; ) {
                var o = e >> 6 * (n - 1);
                i.push(128 | 63 & o),
                n -= 1
            }
            return i
        }
    }
    d.prototype = {
        decode: function(t, e) {
            var n;
            n = "object" == typeof t && t instanceof ArrayBuffer ? new Uint8Array(t) : "object" == typeof t && "buffer"in t && t.buffer instanceof ArrayBuffer ? new Uint8Array(t.buffer,t.byteOffset,t.byteLength) : new Uint8Array(0),
            e = o(e),
            this._streaming || (this._decoder = new p({
                fatal: this._fatal
            }),
            this._BOMseen = !1),
            this._streaming = Boolean(e.stream);
            for (var r, i = new l(n), s = []; !i.endOfStream() && (r = this._decoder.handler(i, i.read())) !== c; )
                null !== r && (Array.isArray(r) ? s.push.apply(s, r) : s.push(r));
            if (!this._streaming) {
                do {
                    if ((r = this._decoder.handler(i, i.read())) === c)
                        break;
                    null !== r && (Array.isArray(r) ? s.push.apply(s, r) : s.push(r))
                } while (!i.endOfStream());
                this._decoder = null
            }
            return s.length && (-1 === ["utf-8"].indexOf(this.encoding) || this._ignoreBOM || this._BOMseen || (65279 === s[0] ? (this._BOMseen = !0,
            s.shift()) : this._BOMseen = !0)),
            function(t) {
                for (var e = "", n = 0; n < t.length; ++n) {
                    var r = t[n];
                    r <= 65535 ? e += String.fromCharCode(r) : (r -= 65536,
                    e += String.fromCharCode(55296 + (r >> 10), 56320 + (1023 & r)))
                }
                return e
            }(s)
        }
    },
    f.prototype = {
        encode: function(t, e) {
            t = t ? String(t) : "",
            e = o(e),
            this._streaming || (this._encoder = new m(this._options)),
            this._streaming = Boolean(e.stream);
            for (var n, r = [], i = new l(function(t) {
                for (var e = String(t), n = e.length, r = 0, i = []; r < n; ) {
                    var s = e.charCodeAt(r);
                    if (s < 55296 || s > 57343)
                        i.push(s);
                    else if (56320 <= s && s <= 57343)
                        i.push(65533);
                    else if (55296 <= s && s <= 56319)
                        if (r === n - 1)
                            i.push(65533);
                        else {
                            var o = t.charCodeAt(r + 1);
                            if (56320 <= o && o <= 57343) {
                                var a = 1023 & s
                                  , l = 1023 & o;
                                i.push(65536 + (a << 10) + l),
                                r += 1
                            } else
                                i.push(65533)
                        }
                    r += 1
                }
                return i
            }(t)); !i.endOfStream() && (n = this._encoder.handler(i, i.read())) !== c; )
                Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
            if (!this._streaming) {
                for (; (n = this._encoder.handler(i, i.read())) !== c; )
                    Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
                this._encoder = null
            }
            return new Uint8Array(r)
        }
    },
    r = f,
    i = d
}
)),
o.register("Q02IV", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.s16 = t.exports.s8 = t.exports.nu64be = t.exports.u48be = t.exports.u40be = t.exports.u32be = t.exports.u24be = t.exports.u16be = t.exports.nu64 = t.exports.u48 = t.exports.u40 = t.exports.u32 = t.exports.u24 = t.exports.u16 = t.exports.u8 = t.exports.offset = t.exports.greedy = t.exports.Constant = t.exports.UTF8 = t.exports.CString = t.exports.Blob = t.exports.Boolean = t.exports.BitField = t.exports.BitStructure = t.exports.VariantLayout = t.exports.Union = t.exports.UnionLayoutDiscriminator = t.exports.UnionDiscriminator = t.exports.Structure = t.exports.Sequence = t.exports.DoubleBE = t.exports.Double = t.exports.FloatBE = t.exports.Float = t.exports.NearInt64BE = t.exports.NearInt64 = t.exports.NearUInt64BE = t.exports.NearUInt64 = t.exports.IntBE = t.exports.Int = t.exports.UIntBE = t.exports.UInt = t.exports.OffsetLayout = t.exports.GreedyCount = t.exports.ExternalLayout = t.exports.bindConstructorLayout = t.exports.nameWithProperty = t.exports.Layout = t.exports.uint8ArrayToBuffer = t.exports.checkUint8Array = void 0,
    t.exports.constant = t.exports.utf8 = t.exports.cstr = t.exports.blob = t.exports.unionLayoutDiscriminator = t.exports.union = t.exports.seq = t.exports.bits = t.exports.struct = t.exports.f64be = t.exports.f64 = t.exports.f32be = t.exports.f32 = t.exports.ns64be = t.exports.s48be = t.exports.s40be = t.exports.s32be = t.exports.s24be = t.exports.s16be = t.exports.ns64 = t.exports.s48 = t.exports.s40 = t.exports.s32 = t.exports.s24 = void 0;
    var n = o("6ZWSX");
    function r(t) {
        if (!(t instanceof Uint8Array))
            throw new TypeError("b must be a Uint8Array")
    }
    function i(t) {
        return r(t),
        n.Buffer.from(t.buffer, t.byteOffset, t.length)
    }
    t.exports.checkUint8Array = r,
    t.exports.uint8ArrayToBuffer = i;
    class s {
        constructor(t, e) {
            if (!Number.isInteger(t))
                throw new TypeError("span must be an integer");
            this.span = t,
            this.property = e
        }
        makeDestinationObject() {
            return {}
        }
        getSpan(t, e) {
            if (0 > this.span)
                throw new RangeError("indeterminate span");
            return this.span
        }
        replicate(t) {
            const e = Object.create(this.constructor.prototype);
            return Object.assign(e, this),
            e.property = t,
            e
        }
        fromArray(t) {}
    }
    function a(t, e) {
        return e.property ? t + "[" + e.property + "]" : t
    }
    t.exports.Layout = s,
    t.exports.nameWithProperty = a,
    t.exports.bindConstructorLayout = function(t, e) {
        if ("function" != typeof t)
            throw new TypeError("Class must be constructor");
        if (Object.prototype.hasOwnProperty.call(t, "layout_"))
            throw new Error("Class is already bound to a layout");
        if (!(e && e instanceof s))
            throw new TypeError("layout must be a Layout");
        if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_"))
            throw new Error("layout is already bound to a constructor");
        t.layout_ = e,
        e.boundConstructor_ = t,
        e.makeDestinationObject = ()=>new t,
        Object.defineProperty(t.prototype, "encode", {
            value(t, n) {
                return e.encode(this, t, n)
            },
            writable: !0
        }),
        Object.defineProperty(t, "decode", {
            value: (t,n)=>e.decode(t, n),
            writable: !0
        })
    }
    ;
    class l extends s {
        isCount() {
            throw new Error("ExternalLayout is abstract")
        }
    }
    t.exports.ExternalLayout = l;
    class c extends l {
        constructor(t=1, e) {
            if (!Number.isInteger(t) || 0 >= t)
                throw new TypeError("elementSpan must be a (positive) integer");
            super(-1, e),
            this.elementSpan = t
        }
        isCount() {
            return !0
        }
        decode(t, e=0) {
            r(t);
            const n = t.length - e;
            return Math.floor(n / this.elementSpan)
        }
        encode(t, e, n) {
            return 0
        }
    }
    t.exports.GreedyCount = c;
    class u extends l {
        constructor(t, e=0, n) {
            if (!(t instanceof s))
                throw new TypeError("layout must be a Layout");
            if (!Number.isInteger(e))
                throw new TypeError("offset must be integer or undefined");
            super(t.span, n || t.property),
            this.layout = t,
            this.offset = e
        }
        isCount() {
            return this.layout instanceof h || this.layout instanceof d
        }
        decode(t, e=0) {
            return this.layout.decode(t, e + this.offset)
        }
        encode(t, e, n=0) {
            return this.layout.encode(t, e, n + this.offset)
        }
    }
    t.exports.OffsetLayout = u;
    class h extends s {
        constructor(t, e) {
            if (super(t, e),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(t, e=0) {
            return i(t).readUIntLE(e, this.span)
        }
        encode(t, e, n=0) {
            return i(e).writeUIntLE(t, n, this.span),
            this.span
        }
    }
    t.exports.UInt = h;
    class d extends s {
        constructor(t, e) {
            if (super(t, e),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(t, e=0) {
            return i(t).readUIntBE(e, this.span)
        }
        encode(t, e, n=0) {
            return i(e).writeUIntBE(t, n, this.span),
            this.span
        }
    }
    t.exports.UIntBE = d;
    class f extends s {
        constructor(t, e) {
            if (super(t, e),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(t, e=0) {
            return i(t).readIntLE(e, this.span)
        }
        encode(t, e, n=0) {
            return i(e).writeIntLE(t, n, this.span),
            this.span
        }
    }
    t.exports.Int = f;
    class p extends s {
        constructor(t, e) {
            if (super(t, e),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(t, e=0) {
            return i(t).readIntBE(e, this.span)
        }
        encode(t, e, n=0) {
            return i(e).writeIntBE(t, n, this.span),
            this.span
        }
    }
    t.exports.IntBE = p;
    const m = Math.pow(2, 32);
    function g(t) {
        const e = Math.floor(t / m);
        return {
            hi32: e,
            lo32: t - e * m
        }
    }
    function y(t, e) {
        return t * m + e
    }
    class b extends s {
        constructor(t) {
            super(8, t)
        }
        decode(t, e=0) {
            const n = i(t)
              , r = n.readUInt32LE(e);
            return y(n.readUInt32LE(e + 4), r)
        }
        encode(t, e, n=0) {
            const r = g(t)
              , s = i(e);
            return s.writeUInt32LE(r.lo32, n),
            s.writeUInt32LE(r.hi32, n + 4),
            8
        }
    }
    t.exports.NearUInt64 = b;
    class v extends s {
        constructor(t) {
            super(8, t)
        }
        decode(t, e=0) {
            const n = i(t);
            return y(n.readUInt32BE(e), n.readUInt32BE(e + 4))
        }
        encode(t, e, n=0) {
            const r = g(t)
              , s = i(e);
            return s.writeUInt32BE(r.hi32, n),
            s.writeUInt32BE(r.lo32, n + 4),
            8
        }
    }
    t.exports.NearUInt64BE = v;
    class w extends s {
        constructor(t) {
            super(8, t)
        }
        decode(t, e=0) {
            const n = i(t)
              , r = n.readUInt32LE(e);
            return y(n.readInt32LE(e + 4), r)
        }
        encode(t, e, n=0) {
            const r = g(t)
              , s = i(e);
            return s.writeUInt32LE(r.lo32, n),
            s.writeInt32LE(r.hi32, n + 4),
            8
        }
    }
    t.exports.NearInt64 = w;
    class x extends s {
        constructor(t) {
            super(8, t)
        }
        decode(t, e=0) {
            const n = i(t);
            return y(n.readInt32BE(e), n.readUInt32BE(e + 4))
        }
        encode(t, e, n=0) {
            const r = g(t)
              , s = i(e);
            return s.writeInt32BE(r.hi32, n),
            s.writeUInt32BE(r.lo32, n + 4),
            8
        }
    }
    t.exports.NearInt64BE = x;
    class E extends s {
        constructor(t) {
            super(4, t)
        }
        decode(t, e=0) {
            return i(t).readFloatLE(e)
        }
        encode(t, e, n=0) {
            return i(e).writeFloatLE(t, n),
            4
        }
    }
    t.exports.Float = E;
    class _ extends s {
        constructor(t) {
            super(4, t)
        }
        decode(t, e=0) {
            return i(t).readFloatBE(e)
        }
        encode(t, e, n=0) {
            return i(e).writeFloatBE(t, n),
            4
        }
    }
    t.exports.FloatBE = _;
    class A extends s {
        constructor(t) {
            super(8, t)
        }
        decode(t, e=0) {
            return i(t).readDoubleLE(e)
        }
        encode(t, e, n=0) {
            return i(e).writeDoubleLE(t, n),
            8
        }
    }
    t.exports.Double = A;
    class S extends s {
        constructor(t) {
            super(8, t)
        }
        decode(t, e=0) {
            return i(t).readDoubleBE(e)
        }
        encode(t, e, n=0) {
            return i(e).writeDoubleBE(t, n),
            8
        }
    }
    t.exports.DoubleBE = S;
    class T extends s {
        constructor(t, e, n) {
            if (!(t instanceof s))
                throw new TypeError("elementLayout must be a Layout");
            if (!(e instanceof l && e.isCount() || Number.isInteger(e) && 0 <= e))
                throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
            let r = -1;
            !(e instanceof l) && 0 < t.span && (r = e * t.span),
            super(r, n),
            this.elementLayout = t,
            this.count = e
        }
        getSpan(t, e=0) {
            if (0 <= this.span)
                return this.span;
            let n = 0
              , r = this.count;
            if (r instanceof l && (r = r.decode(t, e)),
            0 < this.elementLayout.span)
                n = r * this.elementLayout.span;
            else {
                let i = 0;
                for (; i < r; )
                    n += this.elementLayout.getSpan(t, e + n),
                    ++i
            }
            return n
        }
        decode(t, e=0) {
            const n = [];
            let r = 0
              , i = this.count;
            for (i instanceof l && (i = i.decode(t, e)); r < i; )
                n.push(this.elementLayout.decode(t, e)),
                e += this.elementLayout.getSpan(t, e),
                r += 1;
            return n
        }
        encode(t, e, n=0) {
            const r = this.elementLayout
              , i = t.reduce(((t,i)=>t + r.encode(i, e, n + t)), 0);
            return this.count instanceof l && this.count.encode(t.length, e, n),
            i
        }
    }
    t.exports.Sequence = T;
    class k extends s {
        constructor(t, e, n) {
            if (!Array.isArray(t) || !t.reduce(((t,e)=>t && e instanceof s), !0))
                throw new TypeError("fields must be array of Layout instances");
            "boolean" == typeof e && void 0 === n && (n = e,
            e = void 0);
            for (const e of t)
                if (0 > e.span && void 0 === e.property)
                    throw new Error("fields cannot contain unnamed variable-length layout");
            let r = -1;
            try {
                r = t.reduce(((t,e)=>t + e.getSpan()), 0)
            } catch (t) {}
            super(r, e),
            this.fields = t,
            this.decodePrefixes = !!n
        }
        getSpan(t, e=0) {
            if (0 <= this.span)
                return this.span;
            let n = 0;
            try {
                n = this.fields.reduce(((n,r)=>{
                    const i = r.getSpan(t, e);
                    return e += i,
                    n + i
                }
                ), 0)
            } catch (t) {
                throw new RangeError("indeterminate span")
            }
            return n
        }
        decode(t, e=0) {
            r(t);
            const n = this.makeDestinationObject();
            for (const r of this.fields)
                if (void 0 !== r.property && (n[r.property] = r.decode(t, e)),
                e += r.getSpan(t, e),
                this.decodePrefixes && t.length === e)
                    break;
            return n
        }
        encode(t, e, n=0) {
            const r = n;
            let i = 0
              , s = 0;
            for (const r of this.fields) {
                let o = r.span;
                if (s = 0 < o ? o : 0,
                void 0 !== r.property) {
                    const i = t[r.property];
                    void 0 !== i && (s = r.encode(i, e, n),
                    0 > o && (o = r.getSpan(e, n)))
                }
                i = n,
                n += o
            }
            return i + s - r
        }
        fromArray(t) {
            const e = this.makeDestinationObject();
            for (const n of this.fields)
                void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
            return e
        }
        layoutFor(t) {
            if ("string" != typeof t)
                throw new TypeError("property must be string");
            for (const e of this.fields)
                if (e.property === t)
                    return e
        }
        offsetOf(t) {
            if ("string" != typeof t)
                throw new TypeError("property must be string");
            let e = 0;
            for (const n of this.fields) {
                if (n.property === t)
                    return e;
                0 > n.span ? e = -1 : 0 <= e && (e += n.span)
            }
        }
    }
    t.exports.Structure = k;
    class I {
        constructor(t) {
            this.property = t
        }
        decode(t, e) {
            throw new Error("UnionDiscriminator is abstract")
        }
        encode(t, e, n) {
            throw new Error("UnionDiscriminator is abstract")
        }
    }
    t.exports.UnionDiscriminator = I;
    class M extends I {
        constructor(t, e) {
            if (!(t instanceof l && t.isCount()))
                throw new TypeError("layout must be an unsigned integer ExternalLayout");
            super(e || t.property || "variant"),
            this.layout = t
        }
        decode(t, e) {
            return this.layout.decode(t, e)
        }
        encode(t, e, n) {
            return this.layout.encode(t, e, n)
        }
    }
    t.exports.UnionLayoutDiscriminator = M;
    class C extends s {
        constructor(t, e, n) {
            let r;
            if (t instanceof h || t instanceof d)
                r = new M(new u(t));
            else if (t instanceof l && t.isCount())
                r = new M(t);
            else {
                if (!(t instanceof I))
                    throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                r = t
            }
            if (void 0 === e && (e = null),
            !(null === e || e instanceof s))
                throw new TypeError("defaultLayout must be null or a Layout");
            if (null !== e) {
                if (0 > e.span)
                    throw new Error("defaultLayout must have constant span");
                void 0 === e.property && (e = e.replicate("content"))
            }
            let i = -1;
            e && (i = e.span,
            0 <= i && (t instanceof h || t instanceof d) && (i += r.layout.span)),
            super(i, n),
            this.discriminator = r,
            this.usesPrefixDiscriminator = t instanceof h || t instanceof d,
            this.defaultLayout = e,
            this.registry = {};
            let o = this.defaultGetSourceVariant.bind(this);
            this.getSourceVariant = function(t) {
                return o(t)
            }
            ,
            this.configGetSourceVariant = function(t) {
                o = t.bind(this)
            }
        }
        getSpan(t, e=0) {
            if (0 <= this.span)
                return this.span;
            const n = this.getVariant(t, e);
            if (!n)
                throw new Error("unable to determine span for unrecognized variant");
            return n.getSpan(t, e)
        }
        defaultGetSourceVariant(t) {
            if (Object.prototype.hasOwnProperty.call(t, this.discriminator.property)) {
                if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(t, this.defaultLayout.property))
                    return;
                const e = this.registry[t[this.discriminator.property]];
                if (e && (!e.layout || e.property && Object.prototype.hasOwnProperty.call(t, e.property)))
                    return e
            } else
                for (const e in this.registry) {
                    const n = this.registry[e];
                    if (n.property && Object.prototype.hasOwnProperty.call(t, n.property))
                        return n
                }
            throw new Error("unable to infer src variant")
        }
        decode(t, e=0) {
            let n;
            const r = this.discriminator
              , i = r.decode(t, e)
              , s = this.registry[i];
            if (void 0 === s) {
                const s = this.defaultLayout;
                let o = 0;
                this.usesPrefixDiscriminator && (o = r.layout.span),
                n = this.makeDestinationObject(),
                n[r.property] = i,
                n[s.property] = s.decode(t, e + o)
            } else
                n = s.decode(t, e);
            return n
        }
        encode(t, e, n=0) {
            const r = this.getSourceVariant(t);
            if (void 0 === r) {
                const r = this.discriminator
                  , i = this.defaultLayout;
                let s = 0;
                return this.usesPrefixDiscriminator && (s = r.layout.span),
                r.encode(t[r.property], e, n),
                s + i.encode(t[i.property], e, n + s)
            }
            return r.encode(t, e, n)
        }
        addVariant(t, e, n) {
            const r = new P(this,t,e,n);
            return this.registry[t] = r,
            r
        }
        getVariant(t, e=0) {
            let n;
            return n = t instanceof Uint8Array ? this.discriminator.decode(t, e) : t,
            this.registry[n]
        }
    }
    t.exports.Union = C;
    class P extends s {
        constructor(t, e, n, r) {
            if (!(t instanceof C))
                throw new TypeError("union must be a Union");
            if (!Number.isInteger(e) || 0 > e)
                throw new TypeError("variant must be a (non-negative) integer");
            if ("string" == typeof n && void 0 === r && (r = n,
            n = null),
            n) {
                if (!(n instanceof s))
                    throw new TypeError("layout must be a Layout");
                if (null !== t.defaultLayout && 0 <= n.span && n.span > t.defaultLayout.span)
                    throw new Error("variant span exceeds span of containing union");
                if ("string" != typeof r)
                    throw new TypeError("variant must have a String property")
            }
            let i = t.span;
            0 > t.span && (i = n ? n.span : 0,
            0 <= i && t.usesPrefixDiscriminator && (i += t.discriminator.layout.span)),
            super(i, r),
            this.union = t,
            this.variant = e,
            this.layout = n || null
        }
        getSpan(t, e=0) {
            if (0 <= this.span)
                return this.span;
            let n = 0;
            this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span);
            let r = 0;
            return this.layout && (r = this.layout.getSpan(t, e + n)),
            n + r
        }
        decode(t, e=0) {
            const n = this.makeDestinationObject();
            if (this !== this.union.getVariant(t, e))
                throw new Error("variant mismatch");
            let r = 0;
            return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span),
            this.layout ? n[this.property] = this.layout.decode(t, e + r) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant),
            n
        }
        encode(t, e, n=0) {
            let r = 0;
            if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span),
            this.layout && !Object.prototype.hasOwnProperty.call(t, this.property))
                throw new TypeError("variant lacks property " + this.property);
            this.union.discriminator.encode(this.variant, e, n);
            let i = r;
            if (this.layout && (this.layout.encode(t[this.property], e, n + r),
            i += this.layout.getSpan(e, n + r),
            0 <= this.union.span && i > this.union.span))
                throw new Error("encoded variant overruns containing union");
            return i
        }
        fromArray(t) {
            if (this.layout)
                return this.layout.fromArray(t)
        }
    }
    function O(t) {
        return 0 > t && (t += 4294967296),
        t
    }
    t.exports.VariantLayout = P;
    class N extends s {
        constructor(t, e, n) {
            if (!(t instanceof h || t instanceof d))
                throw new TypeError("word must be a UInt or UIntBE layout");
            if ("string" == typeof e && void 0 === n && (n = e,
            e = !1),
            4 < t.span)
                throw new RangeError("word cannot exceed 32 bits");
            super(t.span, n),
            this.word = t,
            this.msb = !!e,
            this.fields = [];
            let r = 0;
            this._packedSetValue = function(t) {
                return r = O(t),
                this
            }
            ,
            this._packedGetValue = function() {
                return r
            }
        }
        decode(t, e=0) {
            const n = this.makeDestinationObject()
              , r = this.word.decode(t, e);
            this._packedSetValue(r);
            for (const e of this.fields)
                void 0 !== e.property && (n[e.property] = e.decode(t));
            return n
        }
        encode(t, e, n=0) {
            const r = this.word.decode(e, n);
            this._packedSetValue(r);
            for (const e of this.fields)
                if (void 0 !== e.property) {
                    const n = t[e.property];
                    void 0 !== n && e.encode(n)
                }
            return this.word.encode(this._packedGetValue(), e, n)
        }
        addField(t, e) {
            const n = new R(this,t,e);
            return this.fields.push(n),
            n
        }
        addBoolean(t) {
            const e = new D(this,t);
            return this.fields.push(e),
            e
        }
        fieldFor(t) {
            if ("string" != typeof t)
                throw new TypeError("property must be string");
            for (const e of this.fields)
                if (e.property === t)
                    return e
        }
    }
    t.exports.BitStructure = N;
    class R {
        constructor(t, e, n) {
            if (!(t instanceof N))
                throw new TypeError("container must be a BitStructure");
            if (!Number.isInteger(e) || 0 >= e)
                throw new TypeError("bits must be positive integer");
            const r = 8 * t.span
              , i = t.fields.reduce(((t,e)=>t + e.bits), 0);
            if (e + i > r)
                throw new Error("bits too long for span remainder (" + (r - i) + " of " + r + " remain)");
            this.container = t,
            this.bits = e,
            this.valueMask = (1 << e) - 1,
            32 === e && (this.valueMask = 4294967295),
            this.start = i,
            this.container.msb && (this.start = r - i - e),
            this.wordMask = O(this.valueMask << this.start),
            this.property = n
        }
        decode(t, e) {
            return O(this.container._packedGetValue() & this.wordMask) >>> this.start
        }
        encode(t) {
            if ("number" != typeof t || !Number.isInteger(t) || t !== O(t & this.valueMask))
                throw new TypeError(a("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
            const e = this.container._packedGetValue()
              , n = O(t << this.start);
            this.container._packedSetValue(O(e & ~this.wordMask) | n)
        }
    }
    t.exports.BitField = R;
    class D extends R {
        constructor(t, e) {
            super(t, 1, e)
        }
        decode(t, e) {
            return !!super.decode(t, e)
        }
        encode(t) {
            "boolean" == typeof t && (t = +t),
            super.encode(t)
        }
    }
    t.exports.Boolean = D;
    class B extends s {
        constructor(t, e) {
            if (!(t instanceof l && t.isCount() || Number.isInteger(t) && 0 <= t))
                throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
            let n = -1;
            t instanceof l || (n = t),
            super(n, e),
            this.length = t
        }
        getSpan(t, e) {
            let n = this.span;
            return 0 > n && (n = this.length.decode(t, e)),
            n
        }
        decode(t, e=0) {
            let n = this.span;
            return 0 > n && (n = this.length.decode(t, e)),
            i(t).slice(e, e + n)
        }
        encode(t, e, n) {
            let r = this.length;
            if (this.length instanceof l && (r = t.length),
            !(t instanceof Uint8Array && r === t.length))
                throw new TypeError(a("Blob.encode", this) + " requires (length " + r + ") Uint8Array as src");
            if (n + r > e.length)
                throw new RangeError("encoding overruns Uint8Array");
            const s = i(t);
            return i(e).write(s.toString("hex"), n, r, "hex"),
            this.length instanceof l && this.length.encode(r, e, n),
            r
        }
    }
    t.exports.Blob = B;
    class L extends s {
        constructor(t) {
            super(-1, t)
        }
        getSpan(t, e=0) {
            r(t);
            let n = e;
            for (; n < t.length && 0 !== t[n]; )
                n += 1;
            return 1 + n - e
        }
        decode(t, e=0) {
            const n = this.getSpan(t, e);
            return i(t).slice(e, e + n - 1).toString("utf-8")
        }
        encode(t, e, r=0) {
            "string" != typeof t && (t = String(t));
            const s = n.Buffer.from(t, "utf8")
              , o = s.length;
            if (r + o > e.length)
                throw new RangeError("encoding overruns Buffer");
            const a = i(e);
            return s.copy(a, r),
            a[r + o] = 0,
            o + 1
        }
    }
    t.exports.CString = L;
    class F extends s {
        constructor(t, e) {
            if ("string" == typeof t && void 0 === e && (e = t,
            t = void 0),
            void 0 === t)
                t = -1;
            else if (!Number.isInteger(t))
                throw new TypeError("maxSpan must be an integer");
            super(-1, e),
            this.maxSpan = t
        }
        getSpan(t, e=0) {
            return r(t),
            t.length - e
        }
        decode(t, e=0) {
            const n = this.getSpan(t, e);
            if (0 <= this.maxSpan && this.maxSpan < n)
                throw new RangeError("text length exceeds maxSpan");
            return i(t).slice(e, e + n).toString("utf-8")
        }
        encode(t, e, r=0) {
            "string" != typeof t && (t = String(t));
            const s = n.Buffer.from(t, "utf8")
              , o = s.length;
            if (0 <= this.maxSpan && this.maxSpan < o)
                throw new RangeError("text length exceeds maxSpan");
            if (r + o > e.length)
                throw new RangeError("encoding overruns Buffer");
            return s.copy(i(e), r),
            o
        }
    }
    t.exports.UTF8 = F;
    class j extends s {
        constructor(t, e) {
            super(0, e),
            this.value = t
        }
        decode(t, e) {
            return this.value
        }
        encode(t, e, n) {
            return 0
        }
    }
    t.exports.Constant = j,
    t.exports.greedy = (t,e)=>new c(t,e),
    t.exports.offset = (t,e,n)=>new u(t,e,n),
    t.exports.u8 = t=>new h(1,t),
    t.exports.u16 = t=>new h(2,t),
    t.exports.u24 = t=>new h(3,t),
    t.exports.u32 = t=>new h(4,t),
    t.exports.u40 = t=>new h(5,t),
    t.exports.u48 = t=>new h(6,t),
    t.exports.nu64 = t=>new b(t),
    t.exports.u16be = t=>new d(2,t),
    t.exports.u24be = t=>new d(3,t),
    t.exports.u32be = t=>new d(4,t),
    t.exports.u40be = t=>new d(5,t),
    t.exports.u48be = t=>new d(6,t),
    t.exports.nu64be = t=>new v(t),
    t.exports.s8 = t=>new f(1,t),
    t.exports.s16 = t=>new f(2,t),
    t.exports.s24 = t=>new f(3,t),
    t.exports.s32 = t=>new f(4,t),
    t.exports.s40 = t=>new f(5,t),
    t.exports.s48 = t=>new f(6,t),
    t.exports.ns64 = t=>new w(t),
    t.exports.s16be = t=>new p(2,t),
    t.exports.s24be = t=>new p(3,t),
    t.exports.s32be = t=>new p(4,t),
    t.exports.s40be = t=>new p(5,t),
    t.exports.s48be = t=>new p(6,t),
    t.exports.ns64be = t=>new x(t),
    t.exports.f32 = t=>new E(t),
    t.exports.f32be = t=>new _(t),
    t.exports.f64 = t=>new A(t),
    t.exports.f64be = t=>new S(t),
    t.exports.struct = (t,e,n)=>new k(t,e,n),
    t.exports.bits = (t,e,n)=>new N(t,e,n),
    t.exports.seq = (t,e,n)=>new T(t,e,n),
    t.exports.union = (t,e,n)=>new C(t,e,n),
    t.exports.unionLayoutDiscriminator = (t,e)=>new M(t,e),
    t.exports.blob = (t,e)=>new B(t,e),
    t.exports.cstr = t=>new L(t),
    t.exports.utf8 = (t,e)=>new F(t,e),
    t.exports.constant = (t,e)=>new j(t,e)
}
)),
o.register("gyRuj", (function(t, e) {
    var n = o("6ZWSX").Buffer;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.toBigIntLE = function(t) {
        {
            const e = n.from(t);
            e.reverse();
            const r = e.toString("hex");
            return 0 === r.length ? BigInt(0) : BigInt(`0x${r}`)
        }
    }
    ,
    t.exports.toBigIntBE = function(t) {
        {
            const e = t.toString("hex");
            return 0 === e.length ? BigInt(0) : BigInt(`0x${e}`)
        }
    }
    ,
    t.exports.toBufferLE = function(t, e) {
        {
            const r = t.toString(16)
              , i = n.from(r.padStart(2 * e, "0").slice(0, 2 * e), "hex");
            return i.reverse(),
            i
        }
    }
    ,
    t.exports.toBufferBE = function(t, e) {
        {
            const r = t.toString(16);
            return n.from(r.padStart(2 * e, "0").slice(0, 2 * e), "hex")
        }
    }
}
)),
o.register("fYtTx", (function(e, n) {
    t(e.exports, "assert", (()=>u)),
    t(e.exports, "create", (()=>h)),
    t(e.exports, "optional", (()=>_)),
    t(e.exports, "any", (()=>m)),
    t(e.exports, "array", (()=>g)),
    t(e.exports, "boolean", (()=>y)),
    t(e.exports, "instance", (()=>b)),
    t(e.exports, "literal", (()=>v)),
    t(e.exports, "nullable", (()=>x)),
    t(e.exports, "number", (()=>E)),
    t(e.exports, "record", (()=>A)),
    t(e.exports, "string", (()=>S)),
    t(e.exports, "tuple", (()=>T)),
    t(e.exports, "type", (()=>k)),
    t(e.exports, "union", (()=>I)),
    t(e.exports, "unknown", (()=>M)),
    t(e.exports, "coerce", (()=>C));
    class r extends TypeError {
        constructor(t, e) {
            let n;
            const {message: r, ...i} = t
              , {path: s} = t;
            super(0 === s.length ? r : "At path: " + s.join(".") + " -- " + r),
            Object.assign(this, i),
            this.name = this.constructor.name,
            this.failures = ()=>{
                var r;
                return null != (r = n) ? r : n = [t, ...e()]
            }
        }
    }
    function i(t) {
        return "object" == typeof t && null != t
    }
    function s(t) {
        return "string" == typeof t ? JSON.stringify(t) : "" + t
    }
    function o(t, e, n, r) {
        if (!0 === t)
            return;
        !1 === t ? t = {} : "string" == typeof t && (t = {
            message: t
        });
        const {path: i, branch: o} = e
          , {type: a} = n
          , {refinement: l, message: c="Expected a value of type `" + a + "`" + (l ? " with refinement `" + l + "`" : "") + ", but received: `" + s(r) + "`"} = t;
        return {
            value: r,
            type: a,
            refinement: l,
            key: i[i.length - 1],
            path: i,
            branch: o,
            ...t,
            message: c
        }
    }
    function *a(t, e, n, r) {
        var s;
        i(s = t) && "function" == typeof s[Symbol.iterator] || (t = [t]);
        for (const i of t) {
            const t = o(i, e, n, r);
            t && (yield t)
        }
    }
    function *l(t, e, n={}) {
        const {path: r=[], branch: s=[t], coerce: o=!1, mask: a=!1} = n
          , c = {
            path: r,
            branch: s
        };
        if (o && (t = e.coercer(t, c),
        a && "type" !== e.type && i(e.schema) && i(t) && !Array.isArray(t)))
            for (const n in t)
                void 0 === e.schema[n] && delete t[n];
        let u = !0;
        for (const n of e.validator(t, c))
            u = !1,
            yield[n, void 0];
        for (let[n,h,d] of e.entries(t, c)) {
            const e = l(h, d, {
                path: void 0 === n ? r : [...r, n],
                branch: void 0 === n ? s : [...s, h],
                coerce: o,
                mask: a
            });
            for (const r of e)
                r[0] ? (u = !1,
                yield[r[0], void 0]) : o && (h = r[1],
                void 0 === n ? t = h : t instanceof Map ? t.set(n, h) : t instanceof Set ? t.add(h) : i(t) && (t[n] = h))
        }
        if (u)
            for (const n of e.refiner(t, c))
                u = !1,
                yield[n, void 0];
        u && (yield[void 0, t])
    }
    class c {
        constructor(t) {
            const {type: e, schema: n, validator: r, refiner: i, coercer: s=(t=>t), entries: o=function*() {}
            } = t;
            this.type = e,
            this.schema = n,
            this.entries = o,
            this.coercer = s,
            this.validator = r ? (t,e)=>a(r(t, e), e, this, t) : ()=>[],
            this.refiner = i ? (t,e)=>a(i(t, e), e, this, t) : ()=>[]
        }
        assert(t) {
            return u(t, this)
        }
        create(t) {
            return h(t, this)
        }
        is(t) {
            return d(t, this)
        }
        mask(t) {
            return function(t, e) {
                const n = f(t, e, {
                    coerce: !0,
                    mask: !0
                });
                if (n[0])
                    throw n[0];
                return n[1]
            }(t, this)
        }
        validate(t, e={}) {
            return f(t, this, e)
        }
    }
    function u(t, e) {
        const n = f(t, e);
        if (n[0])
            throw n[0]
    }
    function h(t, e) {
        const n = f(t, e, {
            coerce: !0
        });
        if (n[0])
            throw n[0];
        return n[1]
    }
    function d(t, e) {
        return !f(t, e)[0]
    }
    function f(t, e, n={}) {
        const i = l(t, e, n)
          , s = function(t) {
            const {done: e, value: n} = t.next();
            return e ? void 0 : n
        }(i);
        if (s[0]) {
            return [new r(s[0],(function*() {
                for (const t of i)
                    t[0] && (yield t[0])
            }
            )), void 0]
        }
        return [void 0, s[1]]
    }
    function p(t, e) {
        return new c({
            type: t,
            schema: null,
            validator: e
        })
    }
    function m() {
        return p("any", (()=>!0))
    }
    function g(t) {
        return new c({
            type: "array",
            schema: t,
            *entries(e) {
                if (t && Array.isArray(e))
                    for (const [n,r] of e.entries())
                        yield[n, r, t]
            },
            coercer: t=>Array.isArray(t) ? t.slice() : t,
            validator: t=>Array.isArray(t) || "Expected an array value, but received: " + s(t)
        })
    }
    function y() {
        return p("boolean", (t=>"boolean" == typeof t))
    }
    function b(t) {
        return p("instance", (e=>e instanceof t || "Expected a `" + t.name + "` instance, but received: " + s(e)))
    }
    function v(t) {
        const e = s(t)
          , n = typeof t;
        return new c({
            type: "literal",
            schema: "string" === n || "number" === n || "boolean" === n ? t : null,
            validator: n=>n === t || "Expected the literal `" + e + "`, but received: " + s(n)
        })
    }
    function w() {
        return p("never", (()=>!1))
    }
    function x(t) {
        return new c({
            ...t,
            validator: (e,n)=>null === e || t.validator(e, n),
            refiner: (e,n)=>null === e || t.refiner(e, n)
        })
    }
    function E() {
        return p("number", (t=>"number" == typeof t && !isNaN(t) || "Expected a number, but received: " + s(t)))
    }
    function _(t) {
        return new c({
            ...t,
            validator: (e,n)=>void 0 === e || t.validator(e, n),
            refiner: (e,n)=>void 0 === e || t.refiner(e, n)
        })
    }
    function A(t, e) {
        return new c({
            type: "record",
            schema: null,
            *entries(n) {
                if (i(n))
                    for (const r in n) {
                        const i = n[r];
                        yield[r, r, t],
                        yield[r, i, e]
                    }
            },
            validator: t=>i(t) || "Expected an object, but received: " + s(t)
        })
    }
    function S() {
        return p("string", (t=>"string" == typeof t || "Expected a string, but received: " + s(t)))
    }
    function T(t) {
        const e = w();
        return new c({
            type: "tuple",
            schema: null,
            *entries(n) {
                if (Array.isArray(n)) {
                    const r = Math.max(t.length, n.length);
                    for (let i = 0; i < r; i++)
                        yield[i, n[i], t[i] || e]
                }
            },
            validator: t=>Array.isArray(t) || "Expected an array, but received: " + s(t)
        })
    }
    function k(t) {
        const e = Object.keys(t);
        return new c({
            type: "type",
            schema: t,
            *entries(n) {
                if (i(n))
                    for (const r of e)
                        yield[r, n[r], t[r]]
            },
            validator: t=>i(t) || "Expected an object, but received: " + s(t)
        })
    }
    function I(t) {
        const e = t.map((t=>t.type)).join(" | ");
        return new c({
            type: "union",
            schema: null,
            validator(n, r) {
                const i = [];
                for (const e of t) {
                    const [...t] = l(n, e, r)
                      , [s] = t;
                    if (!s[0])
                        return [];
                    for (const [e] of t)
                        e && i.push(e)
                }
                return ["Expected the value to satisfy a union of `" + e + "`, but received: " + s(n), ...i]
            }
        })
    }
    function M() {
        return p("unknown", (()=>!0))
    }
    function C(t, e, n) {
        return new c({
            ...t,
            coercer: (r,i)=>d(r, e) ? t.coercer(n(r, i), i) : t.coercer(r, i)
        })
    }
}
)),
o.register("eB9mD", (function(t, e) {
    var n = o("5sKyw").default
      , r = o("ePvL4");
    const i = function(t, e) {
        if (!(this instanceof i))
            return new i(t,e);
        e || (e = {}),
        this.options = {
            reviver: void 0 !== e.reviver ? e.reviver : null,
            replacer: void 0 !== e.replacer ? e.replacer : null,
            generator: void 0 !== e.generator ? e.generator : function() {
                return n()
            }
            ,
            version: void 0 !== e.version ? e.version : 2,
            notificationIdNull: "boolean" == typeof e.notificationIdNull && e.notificationIdNull
        },
        this.callServer = t
    };
    t.exports = i,
    i.prototype.request = function(t, e, n, i) {
        const s = this;
        let o = null;
        const a = Array.isArray(t) && "function" == typeof e;
        if (1 === this.options.version && a)
            throw new TypeError("JSON-RPC 1.0 does not support batching");
        if (a || !a && t && "object" == typeof t && "function" == typeof e)
            i = e,
            o = t;
        else {
            "function" == typeof n && (i = n,
            n = void 0);
            const s = "function" == typeof i;
            try {
                o = r(t, e, n, {
                    generator: this.options.generator,
                    version: this.options.version,
                    notificationIdNull: this.options.notificationIdNull
                })
            } catch (t) {
                if (s)
                    return i(t);
                throw t
            }
            if (!s)
                return o
        }
        let l;
        try {
            l = JSON.stringify(o, this.options.replacer)
        } catch (t) {
            return i(t)
        }
        return this.callServer(l, (function(t, e) {
            s._parseResponse(t, e, i)
        }
        )),
        o
    }
    ,
    i.prototype._parseResponse = function(t, e, n) {
        if (t)
            return void n(t);
        if (!e)
            return n();
        let r;
        try {
            r = JSON.parse(e, this.options.reviver)
        } catch (t) {
            return n(t)
        }
        if (3 === n.length) {
            if (Array.isArray(r)) {
                const t = function(t) {
                    return void 0 !== t.error
                }
                  , e = function(e) {
                    return !t(e)
                };
                return n(null, r.filter(t), r.filter(e))
            }
            return n(null, r.error, r.result)
        }
        n(null, r)
    }
}
)),
o.register("5sKyw", (function(e, n) {
    t(e.exports, "default", (()=>s));
    var r = o("7qKRb")
      , i = o("2uohp");
    var s = function(t, e, n) {
        var s = (t = t || {}).random || (t.rng || r.default)();
        if (s[6] = 15 & s[6] | 64,
        s[8] = 63 & s[8] | 128,
        e) {
            n = n || 0;
            for (var o = 0; o < 16; ++o)
                e[n + o] = s[o];
            return e
        }
        return (0,
        i.default)(s)
    }
}
)),
o.register("7qKRb", (function(e, n) {
    var r;
    t(e.exports, "default", (()=>s));
    var i = new Uint8Array(16);
    function s() {
        if (!r && !(r = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto)))
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return r(i)
    }
}
)),
o.register("2uohp", (function(e, n) {
    t(e.exports, "default", (()=>a));
    for (var r = o("64ZUg"), i = [], s = 0; s < 256; ++s)
        i.push((s + 256).toString(16).substr(1));
    var a = function(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
          , n = (i[t[e + 0]] + i[t[e + 1]] + i[t[e + 2]] + i[t[e + 3]] + "-" + i[t[e + 4]] + i[t[e + 5]] + "-" + i[t[e + 6]] + i[t[e + 7]] + "-" + i[t[e + 8]] + i[t[e + 9]] + "-" + i[t[e + 10]] + i[t[e + 11]] + i[t[e + 12]] + i[t[e + 13]] + i[t[e + 14]] + i[t[e + 15]]).toLowerCase();
        if (!(0,
        r.default)(n))
            throw TypeError("Stringified UUID is invalid");
        return n
    }
}
)),
o.register("64ZUg", (function(e, n) {
    t(e.exports, "default", (()=>i));
    var r = o("4meF0");
    var i = function(t) {
        return "string" == typeof t && r.default.test(t)
    }
}
)),
o.register("4meF0", (function(e, n) {
    t(e.exports, "default", (()=>r));
    var r = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
}
)),
o.register("ePvL4", (function(t, e) {
    var n = o("5sKyw").default;
    t.exports = function(t, e, r, i) {
        if ("string" != typeof t)
            throw new TypeError(t + " must be a string");
        const s = "number" == typeof (i = i || {}).version ? i.version : 2;
        if (1 !== s && 2 !== s)
            throw new TypeError(s + " must be 1 or 2");
        const o = {
            method: t
        };
        if (2 === s && (o.jsonrpc = "2.0"),
        e) {
            if ("object" != typeof e && !Array.isArray(e))
                throw new TypeError(e + " must be an object, array or omitted");
            o.params = e
        }
        if (void 0 === r) {
            const t = "function" == typeof i.generator ? i.generator : function() {
                return n()
            }
            ;
            o.id = t(o, i)
        } else
            2 === s && null === r ? i.notificationIdNull && (o.id = null) : o.id = r;
        return o
    }
}
)),
o.register("9aP4M", (function(t, e) {
    var n = o("6ZWSX").Buffer
      , r = o("1jnue");
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.default = void 0;
    var i = r(o("h1Oiy"))
      , s = r(o("fOd0O"))
      , a = r(o("41YNz"))
      , l = r(o("fu0YK"))
      , c = r(o("lR7jo"))
      , u = r(o("f8wIT"))
      , h = r(o("eN9hz"))
      , d = r(o("cGTaw"))
      , f = o("3vRz3");
    function p(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, r = (0,
            d.default)(t);
            if (e) {
                var i = (0,
                d.default)(this).constructor;
                n = Reflect.construct(r, arguments, i)
            } else
                n = r.apply(this, arguments);
            return (0,
            h.default)(this, n)
        }
    }
    var m = function(t) {
        (0,
        u.default)(f, t);
        var e, r, o, h, d = p(f);
        function f(t) {
            var e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "ws://localhost:8080", r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0;
            (0,
            l.default)(this, f);
            var s = r.autoconnect
              , o = void 0 === s || s
              , a = r.reconnect
              , c = void 0 === a || a
              , u = r.reconnect_interval
              , h = void 0 === u ? 1e3 : u
              , p = r.max_reconnects
              , m = void 0 === p ? 5 : p
              , g = function(t, e) {
                var n = {};
                for (var r in t)
                    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
                if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
                    var i = 0;
                    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                        e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]])
                }
                return n
            }(r, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
            return (e = d.call(this)).webSocketFactory = t,
            e.queue = {},
            e.rpc_id = 0,
            e.address = n,
            e.autoconnect = o,
            e.ready = !1,
            e.reconnect = c,
            e.reconnect_timer_id = void 0,
            e.reconnect_interval = h,
            e.max_reconnects = m,
            e.rest_options = g,
            e.current_reconnects = 0,
            e.generate_request_id = i || function() {
                return ++e.rpc_id
            }
            ,
            e.autoconnect && e._connect(e.address, Object.assign({
                autoconnect: e.autoconnect,
                reconnect: e.reconnect,
                reconnect_interval: e.reconnect_interval,
                max_reconnects: e.max_reconnects
            }, e.rest_options)),
            e
        }
        return (0,
        c.default)(f, [{
            key: "connect",
            value: function() {
                this.socket || this._connect(this.address, Object.assign({
                    autoconnect: this.autoconnect,
                    reconnect: this.reconnect,
                    reconnect_interval: this.reconnect_interval,
                    max_reconnects: this.max_reconnects
                }, this.rest_options))
            }
        }, {
            key: "call",
            value: function(t, e, n, r) {
                var i = this;
                return r || "object" !== (0,
                a.default)(n) || (r = n,
                n = null),
                new Promise((function(s, o) {
                    if (!i.ready)
                        return o(new Error("socket not ready"));
                    var a = i.generate_request_id(t, e)
                      , l = {
                        jsonrpc: "2.0",
                        method: t,
                        params: e || null,
                        id: a
                    };
                    i.socket.send(JSON.stringify(l), r, (function(t) {
                        if (t)
                            return o(t);
                        i.queue[a] = {
                            promise: [s, o]
                        },
                        n && (i.queue[a].timeout = setTimeout((function() {
                            delete i.queue[a],
                            o(new Error("reply timeout"))
                        }
                        ), n))
                    }
                    ))
                }
                ))
            }
        }, {
            key: "login",
            value: (h = (0,
            s.default)(i.default.mark((function t(e) {
                var n;
                return i.default.wrap((function(t) {
                    for (; ; )
                        switch (t.prev = t.next) {
                        case 0:
                            return t.next = 2,
                            this.call("rpc.login", e);
                        case 2:
                            if (n = t.sent) {
                                t.next = 5;
                                break
                            }
                            throw new Error("authentication failed");
                        case 5:
                            return t.abrupt("return", n);
                        case 6:
                        case "end":
                            return t.stop()
                        }
                }
                ), t, this)
            }
            ))),
            function(t) {
                return h.apply(this, arguments)
            }
            )
        }, {
            key: "listMethods",
            value: (o = (0,
            s.default)(i.default.mark((function t() {
                return i.default.wrap((function(t) {
                    for (; ; )
                        switch (t.prev = t.next) {
                        case 0:
                            return t.next = 2,
                            this.call("__listMethods");
                        case 2:
                            return t.abrupt("return", t.sent);
                        case 3:
                        case "end":
                            return t.stop()
                        }
                }
                ), t, this)
            }
            ))),
            function() {
                return o.apply(this, arguments)
            }
            )
        }, {
            key: "notify",
            value: function(t, e) {
                var n = this;
                return new Promise((function(r, i) {
                    if (!n.ready)
                        return i(new Error("socket not ready"));
                    var s = {
                        jsonrpc: "2.0",
                        method: t,
                        params: e || null
                    };
                    n.socket.send(JSON.stringify(s), (function(t) {
                        if (t)
                            return i(t);
                        r()
                    }
                    ))
                }
                ))
            }
        }, {
            key: "subscribe",
            value: (r = (0,
            s.default)(i.default.mark((function t(e) {
                var n;
                return i.default.wrap((function(t) {
                    for (; ; )
                        switch (t.prev = t.next) {
                        case 0:
                            return "string" == typeof e && (e = [e]),
                            t.next = 3,
                            this.call("rpc.on", e);
                        case 3:
                            if (n = t.sent,
                            "string" != typeof e || "ok" === n[e]) {
                                t.next = 6;
                                break
                            }
                            throw new Error("Failed subscribing to an event '" + e + "' with: " + n[e]);
                        case 6:
                            return t.abrupt("return", n);
                        case 7:
                        case "end":
                            return t.stop()
                        }
                }
                ), t, this)
            }
            ))),
            function(t) {
                return r.apply(this, arguments)
            }
            )
        }, {
            key: "unsubscribe",
            value: (e = (0,
            s.default)(i.default.mark((function t(e) {
                var n;
                return i.default.wrap((function(t) {
                    for (; ; )
                        switch (t.prev = t.next) {
                        case 0:
                            return "string" == typeof e && (e = [e]),
                            t.next = 3,
                            this.call("rpc.off", e);
                        case 3:
                            if (n = t.sent,
                            "string" != typeof e || "ok" === n[e]) {
                                t.next = 6;
                                break
                            }
                            throw new Error("Failed unsubscribing from an event with: " + n);
                        case 6:
                            return t.abrupt("return", n);
                        case 7:
                        case "end":
                            return t.stop()
                        }
                }
                ), t, this)
            }
            ))),
            function(t) {
                return e.apply(this, arguments)
            }
            )
        }, {
            key: "close",
            value: function(t, e) {
                this.socket.close(t || 1e3, e)
            }
        }, {
            key: "_connect",
            value: function(t, e) {
                var r = this;
                clearTimeout(this.reconnect_timer_id),
                this.socket = this.webSocketFactory(t, e),
                this.socket.addEventListener("open", (function() {
                    r.ready = !0,
                    r.emit("open"),
                    r.current_reconnects = 0
                }
                )),
                this.socket.addEventListener("message", (function(t) {
                    var e = t.data;
                    e instanceof ArrayBuffer && (e = n.from(e).toString());
                    try {
                        e = JSON.parse(e)
                    } catch (t) {
                        return
                    }
                    if (e.notification && r.listeners(e.notification).length) {
                        if (!Object.keys(e.params).length)
                            return r.emit(e.notification);
                        var i = [e.notification];
                        if (e.params.constructor === Object)
                            i.push(e.params);
                        else
                            for (var s = 0; s < e.params.length; s++)
                                i.push(e.params[s]);
                        return Promise.resolve().then((function() {
                            r.emit.apply(r, i)
                        }
                        ))
                    }
                    if (!r.queue[e.id])
                        return e.method && e.params ? Promise.resolve().then((function() {
                            r.emit(e.method, e.params)
                        }
                        )) : void 0;
                    "error"in e == "result"in e && r.queue[e.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),
                    r.queue[e.id].timeout && clearTimeout(r.queue[e.id].timeout),
                    e.error ? r.queue[e.id].promise[1](e.error) : r.queue[e.id].promise[0](e.result),
                    delete r.queue[e.id]
                }
                )),
                this.socket.addEventListener("error", (function(t) {
                    return r.emit("error", t)
                }
                )),
                this.socket.addEventListener("close", (function(n) {
                    var i = n.code
                      , s = n.reason;
                    r.ready && setTimeout((function() {
                        return r.emit("close", i, s)
                    }
                    ), 0),
                    r.ready = !1,
                    r.socket = void 0,
                    1e3 !== i && (r.current_reconnects++,
                    r.reconnect && (r.max_reconnects > r.current_reconnects || 0 === r.max_reconnects) && (r.reconnect_timer_id = setTimeout((function() {
                        return r._connect(t, e)
                    }
                    ), r.reconnect_interval)))
                }
                ))
            }
        }]),
        f
    }(f.EventEmitter);
    t.exports.default = m
}
)),
o.register("1jnue", (function(t, e) {
    t.exports = function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("h1Oiy", (function(t, e) {
    var n = o("8HV7i")();
    t.exports = n;
    try {
        regeneratorRuntime = n
    } catch (t) {
        "object" == typeof globalThis ? globalThis.regeneratorRuntime = n : Function("r", "regeneratorRuntime = r")(n)
    }
}
)),
o.register("8HV7i", (function(t, e) {
    var n = o("41YNz").default;
    function r() {
        /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
        t.exports = r = function() {
            return e
        }
        ,
        t.exports.__esModule = !0,
        t.exports.default = t.exports;
        var e = {}
          , i = Object.prototype
          , s = i.hasOwnProperty
          , o = Object.defineProperty || function(t, e, n) {
            t[e] = n.value
        }
          , a = "function" == typeof Symbol ? Symbol : {}
          , l = a.iterator || "@@iterator"
          , c = a.asyncIterator || "@@asyncIterator"
          , u = a.toStringTag || "@@toStringTag";
        function h(t, e, n) {
            return Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }),
            t[e]
        }
        try {
            h({}, "")
        } catch (t) {
            h = function(t, e, n) {
                return t[e] = n
            }
        }
        function d(t, e, n, r) {
            var i = e && e.prototype instanceof m ? e : m
              , s = Object.create(i.prototype)
              , a = new I(r || []);
            return o(s, "_invoke", {
                value: A(t, n, a)
            }),
            s
        }
        function f(t, e, n) {
            try {
                return {
                    type: "normal",
                    arg: t.call(e, n)
                }
            } catch (t) {
                return {
                    type: "throw",
                    arg: t
                }
            }
        }
        e.wrap = d;
        var p = {};
        function m() {}
        function g() {}
        function y() {}
        var b = {};
        h(b, l, (function() {
            return this
        }
        ));
        var v = Object.getPrototypeOf
          , w = v && v(v(M([])));
        w && w !== i && s.call(w, l) && (b = w);
        var x = y.prototype = m.prototype = Object.create(b);
        function E(t) {
            ["next", "throw", "return"].forEach((function(e) {
                h(t, e, (function(t) {
                    return this._invoke(e, t)
                }
                ))
            }
            ))
        }
        function _(t, e) {
            function r(i, o, a, l) {
                var c = f(t[i], t, o);
                if ("throw" !== c.type) {
                    var u = c.arg
                      , h = u.value;
                    return h && "object" == n(h) && s.call(h, "__await") ? e.resolve(h.__await).then((function(t) {
                        r("next", t, a, l)
                    }
                    ), (function(t) {
                        r("throw", t, a, l)
                    }
                    )) : e.resolve(h).then((function(t) {
                        u.value = t,
                        a(u)
                    }
                    ), (function(t) {
                        return r("throw", t, a, l)
                    }
                    ))
                }
                l(c.arg)
            }
            var i;
            o(this, "_invoke", {
                value: function(t, n) {
                    function s() {
                        return new e((function(e, i) {
                            r(t, n, e, i)
                        }
                        ))
                    }
                    return i = i ? i.then(s, s) : s()
                }
            })
        }
        function A(t, e, n) {
            var r = "suspendedStart";
            return function(i, s) {
                if ("executing" === r)
                    throw new Error("Generator is already running");
                if ("completed" === r) {
                    if ("throw" === i)
                        throw s;
                    return C()
                }
                for (n.method = i,
                n.arg = s; ; ) {
                    var o = n.delegate;
                    if (o) {
                        var a = S(o, n);
                        if (a) {
                            if (a === p)
                                continue;
                            return a
                        }
                    }
                    if ("next" === n.method)
                        n.sent = n._sent = n.arg;
                    else if ("throw" === n.method) {
                        if ("suspendedStart" === r)
                            throw r = "completed",
                            n.arg;
                        n.dispatchException(n.arg)
                    } else
                        "return" === n.method && n.abrupt("return", n.arg);
                    r = "executing";
                    var l = f(t, e, n);
                    if ("normal" === l.type) {
                        if (r = n.done ? "completed" : "suspendedYield",
                        l.arg === p)
                            continue;
                        return {
                            value: l.arg,
                            done: n.done
                        }
                    }
                    "throw" === l.type && (r = "completed",
                    n.method = "throw",
                    n.arg = l.arg)
                }
            }
        }
        function S(t, e) {
            var n = e.method
              , r = t.iterator[n];
            if (void 0 === r)
                return e.delegate = null,
                "throw" === n && t.iterator.return && (e.method = "return",
                e.arg = void 0,
                S(t, e),
                "throw" === e.method) || "return" !== n && (e.method = "throw",
                e.arg = new TypeError("The iterator does not provide a '" + n + "' method")),
                p;
            var i = f(r, t.iterator, e.arg);
            if ("throw" === i.type)
                return e.method = "throw",
                e.arg = i.arg,
                e.delegate = null,
                p;
            var s = i.arg;
            return s ? s.done ? (e[t.resultName] = s.value,
            e.next = t.nextLoc,
            "return" !== e.method && (e.method = "next",
            e.arg = void 0),
            e.delegate = null,
            p) : s : (e.method = "throw",
            e.arg = new TypeError("iterator result is not an object"),
            e.delegate = null,
            p)
        }
        function T(t) {
            var e = {
                tryLoc: t[0]
            };
            1 in t && (e.catchLoc = t[1]),
            2 in t && (e.finallyLoc = t[2],
            e.afterLoc = t[3]),
            this.tryEntries.push(e)
        }
        function k(t) {
            var e = t.completion || {};
            e.type = "normal",
            delete e.arg,
            t.completion = e
        }
        function I(t) {
            this.tryEntries = [{
                tryLoc: "root"
            }],
            t.forEach(T, this),
            this.reset(!0)
        }
        function M(t) {
            if (t) {
                var e = t[l];
                if (e)
                    return e.call(t);
                if ("function" == typeof t.next)
                    return t;
                if (!isNaN(t.length)) {
                    var n = -1
                      , r = function e() {
                        for (; ++n < t.length; )
                            if (s.call(t, n))
                                return e.value = t[n],
                                e.done = !1,
                                e;
                        return e.value = void 0,
                        e.done = !0,
                        e
                    };
                    return r.next = r
                }
            }
            return {
                next: C
            }
        }
        function C() {
            return {
                value: void 0,
                done: !0
            }
        }
        return g.prototype = y,
        o(x, "constructor", {
            value: y,
            configurable: !0
        }),
        o(y, "constructor", {
            value: g,
            configurable: !0
        }),
        g.displayName = h(y, u, "GeneratorFunction"),
        e.isGeneratorFunction = function(t) {
            var e = "function" == typeof t && t.constructor;
            return !!e && (e === g || "GeneratorFunction" === (e.displayName || e.name))
        }
        ,
        e.mark = function(t) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(t, y) : (t.__proto__ = y,
            h(t, u, "GeneratorFunction")),
            t.prototype = Object.create(x),
            t
        }
        ,
        e.awrap = function(t) {
            return {
                __await: t
            }
        }
        ,
        E(_.prototype),
        h(_.prototype, c, (function() {
            return this
        }
        )),
        e.AsyncIterator = _,
        e.async = function(t, n, r, i, s) {
            void 0 === s && (s = Promise);
            var o = new _(d(t, n, r, i),s);
            return e.isGeneratorFunction(n) ? o : o.next().then((function(t) {
                return t.done ? t.value : o.next()
            }
            ))
        }
        ,
        E(x),
        h(x, u, "Generator"),
        h(x, l, (function() {
            return this
        }
        )),
        h(x, "toString", (function() {
            return "[object Generator]"
        }
        )),
        e.keys = function(t) {
            var e = Object(t)
              , n = [];
            for (var r in e)
                n.push(r);
            return n.reverse(),
            function t() {
                for (; n.length; ) {
                    var r = n.pop();
                    if (r in e)
                        return t.value = r,
                        t.done = !1,
                        t
                }
                return t.done = !0,
                t
            }
        }
        ,
        e.values = M,
        I.prototype = {
            constructor: I,
            reset: function(t) {
                if (this.prev = 0,
                this.next = 0,
                this.sent = this._sent = void 0,
                this.done = !1,
                this.delegate = null,
                this.method = "next",
                this.arg = void 0,
                this.tryEntries.forEach(k),
                !t)
                    for (var e in this)
                        "t" === e.charAt(0) && s.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0)
            },
            stop: function() {
                this.done = !0;
                var t = this.tryEntries[0].completion;
                if ("throw" === t.type)
                    throw t.arg;
                return this.rval
            },
            dispatchException: function(t) {
                if (this.done)
                    throw t;
                var e = this;
                function n(n, r) {
                    return o.type = "throw",
                    o.arg = t,
                    e.next = n,
                    r && (e.method = "next",
                    e.arg = void 0),
                    !!r
                }
                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                    var i = this.tryEntries[r]
                      , o = i.completion;
                    if ("root" === i.tryLoc)
                        return n("end");
                    if (i.tryLoc <= this.prev) {
                        var a = s.call(i, "catchLoc")
                          , l = s.call(i, "finallyLoc");
                        if (a && l) {
                            if (this.prev < i.catchLoc)
                                return n(i.catchLoc, !0);
                            if (this.prev < i.finallyLoc)
                                return n(i.finallyLoc)
                        } else if (a) {
                            if (this.prev < i.catchLoc)
                                return n(i.catchLoc, !0)
                        } else {
                            if (!l)
                                throw new Error("try statement without catch or finally");
                            if (this.prev < i.finallyLoc)
                                return n(i.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function(t, e) {
                for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                    var r = this.tryEntries[n];
                    if (r.tryLoc <= this.prev && s.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                        var i = r;
                        break
                    }
                }
                i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
                var o = i ? i.completion : {};
                return o.type = t,
                o.arg = e,
                i ? (this.method = "next",
                this.next = i.finallyLoc,
                p) : this.complete(o)
            },
            complete: function(t, e) {
                if ("throw" === t.type)
                    throw t.arg;
                return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg,
                this.method = "return",
                this.next = "end") : "normal" === t.type && e && (this.next = e),
                p
            },
            finish: function(t) {
                for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                    var n = this.tryEntries[e];
                    if (n.finallyLoc === t)
                        return this.complete(n.completion, n.afterLoc),
                        k(n),
                        p
                }
            },
            catch: function(t) {
                for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                    var n = this.tryEntries[e];
                    if (n.tryLoc === t) {
                        var r = n.completion;
                        if ("throw" === r.type) {
                            var i = r.arg;
                            k(n)
                        }
                        return i
                    }
                }
                throw new Error("illegal catch attempt")
            },
            delegateYield: function(t, e, n) {
                return this.delegate = {
                    iterator: M(t),
                    resultName: e,
                    nextLoc: n
                },
                "next" === this.method && (this.arg = void 0),
                p
            }
        },
        e
    }
    t.exports = r,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("41YNz", (function(t, e) {
    function n(e) {
        return t.exports = n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        ,
        t.exports.__esModule = !0,
        t.exports.default = t.exports,
        n(e)
    }
    t.exports = n,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("fOd0O", (function(t, e) {
    function n(t, e, n, r, i, s, o) {
        try {
            var a = t[s](o)
              , l = a.value
        } catch (t) {
            return void n(t)
        }
        a.done ? e(l) : Promise.resolve(l).then(r, i)
    }
    t.exports = function(t) {
        return function() {
            var e = this
              , r = arguments;
            return new Promise((function(i, s) {
                var o = t.apply(e, r);
                function a(t) {
                    n(o, i, s, a, l, "next", t)
                }
                function l(t) {
                    n(o, i, s, a, l, "throw", t)
                }
                a(void 0)
            }
            ))
        }
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("fu0YK", (function(t, e) {
    t.exports = function(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("lR7jo", (function(t, e) {
    var n = o("5DKOa");
    function r(t, e) {
        for (var r = 0; r < e.length; r++) {
            var i = e[r];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, n(i.key), i)
        }
    }
    t.exports = function(t, e, n) {
        return e && r(t.prototype, e),
        n && r(t, n),
        Object.defineProperty(t, "prototype", {
            writable: !1
        }),
        t
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("5DKOa", (function(t, e) {
    var n = o("41YNz").default
      , r = o("fKGZD");
    t.exports = function(t) {
        var e = r(t, "string");
        return "symbol" === n(e) ? e : String(e)
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("fKGZD", (function(t, e) {
    var n = o("41YNz").default;
    t.exports = function(t, e) {
        if ("object" !== n(t) || null === t)
            return t;
        var r = t[Symbol.toPrimitive];
        if (void 0 !== r) {
            var i = r.call(t, e || "default");
            if ("object" !== n(i))
                return i;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return ("string" === e ? String : Number)(t)
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("f8wIT", (function(t, e) {
    var n = o("aAhot");
    t.exports = function(t, e) {
        if ("function" != typeof e && null !== e)
            throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(t, "prototype", {
            writable: !1
        }),
        e && n(t, e)
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("aAhot", (function(t, e) {
    function n(e, r) {
        return t.exports = n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
            return t.__proto__ = e,
            t
        }
        ,
        t.exports.__esModule = !0,
        t.exports.default = t.exports,
        n(e, r)
    }
    t.exports = n,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("eN9hz", (function(t, e) {
    var n = o("41YNz").default
      , r = o("6zC7B");
    t.exports = function(t, e) {
        if (e && ("object" === n(e) || "function" == typeof e))
            return e;
        if (void 0 !== e)
            throw new TypeError("Derived constructors may only return object or undefined");
        return r(t)
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("6zC7B", (function(t, e) {
    t.exports = function(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("cGTaw", (function(t, e) {
    function n(e) {
        return t.exports = n = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        }
        ,
        t.exports.__esModule = !0,
        t.exports.default = t.exports,
        n(e)
    }
    t.exports = n,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("3vRz3", (function(t, e) {
    var n = Object.prototype.hasOwnProperty
      , r = "~";
    function i() {}
    function s(t, e, n) {
        this.fn = t,
        this.context = e,
        this.once = n || !1
    }
    function o(t, e, n, i, o) {
        if ("function" != typeof n)
            throw new TypeError("The listener must be a function");
        var a = new s(n,i || t,o)
          , l = r ? r + e : e;
        return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], a] : t._events[l].push(a) : (t._events[l] = a,
        t._eventsCount++),
        t
    }
    function a(t, e) {
        0 == --t._eventsCount ? t._events = new i : delete t._events[e]
    }
    function l() {
        this._events = new i,
        this._eventsCount = 0
    }
    Object.create && (i.prototype = Object.create(null),
    (new i).__proto__ || (r = !1)),
    l.prototype.eventNames = function() {
        var t, e, i = [];
        if (0 === this._eventsCount)
            return i;
        for (e in t = this._events)
            n.call(t, e) && i.push(r ? e.slice(1) : e);
        return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
    }
    ,
    l.prototype.listeners = function(t) {
        var e = r ? r + t : t
          , n = this._events[e];
        if (!n)
            return [];
        if (n.fn)
            return [n.fn];
        for (var i = 0, s = n.length, o = new Array(s); i < s; i++)
            o[i] = n[i].fn;
        return o
    }
    ,
    l.prototype.listenerCount = function(t) {
        var e = r ? r + t : t
          , n = this._events[e];
        return n ? n.fn ? 1 : n.length : 0
    }
    ,
    l.prototype.emit = function(t, e, n, i, s, o) {
        var a = r ? r + t : t;
        if (!this._events[a])
            return !1;
        var l, c, u = this._events[a], h = arguments.length;
        if (u.fn) {
            switch (u.once && this.removeListener(t, u.fn, void 0, !0),
            h) {
            case 1:
                return u.fn.call(u.context),
                !0;
            case 2:
                return u.fn.call(u.context, e),
                !0;
            case 3:
                return u.fn.call(u.context, e, n),
                !0;
            case 4:
                return u.fn.call(u.context, e, n, i),
                !0;
            case 5:
                return u.fn.call(u.context, e, n, i, s),
                !0;
            case 6:
                return u.fn.call(u.context, e, n, i, s, o),
                !0
            }
            for (c = 1,
            l = new Array(h - 1); c < h; c++)
                l[c - 1] = arguments[c];
            u.fn.apply(u.context, l)
        } else {
            var d, f = u.length;
            for (c = 0; c < f; c++)
                switch (u[c].once && this.removeListener(t, u[c].fn, void 0, !0),
                h) {
                case 1:
                    u[c].fn.call(u[c].context);
                    break;
                case 2:
                    u[c].fn.call(u[c].context, e);
                    break;
                case 3:
                    u[c].fn.call(u[c].context, e, n);
                    break;
                case 4:
                    u[c].fn.call(u[c].context, e, n, i);
                    break;
                default:
                    if (!l)
                        for (d = 1,
                        l = new Array(h - 1); d < h; d++)
                            l[d - 1] = arguments[d];
                    u[c].fn.apply(u[c].context, l)
                }
        }
        return !0
    }
    ,
    l.prototype.on = function(t, e, n) {
        return o(this, t, e, n, !1)
    }
    ,
    l.prototype.once = function(t, e, n) {
        return o(this, t, e, n, !0)
    }
    ,
    l.prototype.removeListener = function(t, e, n, i) {
        var s = r ? r + t : t;
        if (!this._events[s])
            return this;
        if (!e)
            return a(this, s),
            this;
        var o = this._events[s];
        if (o.fn)
            o.fn !== e || i && !o.once || n && o.context !== n || a(this, s);
        else {
            for (var l = 0, c = [], u = o.length; l < u; l++)
                (o[l].fn !== e || i && !o[l].once || n && o[l].context !== n) && c.push(o[l]);
            c.length ? this._events[s] = 1 === c.length ? c[0] : c : a(this, s)
        }
        return this
    }
    ,
    l.prototype.removeAllListeners = function(t) {
        var e;
        return t ? (e = r ? r + t : t,
        this._events[e] && a(this, e)) : (this._events = new i,
        this._eventsCount = 0),
        this
    }
    ,
    l.prototype.off = l.prototype.removeListener,
    l.prototype.addListener = l.prototype.on,
    l.prefixed = r,
    l.EventEmitter = l,
    t.exports = l
}
)),
o.register("ckEgg", (function(t, e) {
    var n = o("1jnue");
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.default = function(t, e) {
        return new u(t,e)
    }
    ;
    var r = n(o("fu0YK"))
      , i = n(o("lR7jo"))
      , s = n(o("f8wIT"))
      , a = n(o("eN9hz"))
      , l = n(o("cGTaw"));
    function c(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, r = (0,
            l.default)(t);
            if (e) {
                var i = (0,
                l.default)(this).constructor;
                n = Reflect.construct(r, arguments, i)
            } else
                n = r.apply(this, arguments);
            return (0,
            a.default)(this, n)
        }
    }
    var u = function(t) {
        (0,
        s.default)(n, t);
        var e = c(n);
        function n(t, i, s) {
            var o;
            return (0,
            r.default)(this, n),
            (o = e.call(this)).socket = new window.WebSocket(t,s),
            o.socket.onopen = function() {
                return o.emit("open")
            }
            ,
            o.socket.onmessage = function(t) {
                return o.emit("message", t.data)
            }
            ,
            o.socket.onerror = function(t) {
                return o.emit("error", t)
            }
            ,
            o.socket.onclose = function(t) {
                o.emit("close", t.code, t.reason)
            }
            ,
            o
        }
        return (0,
        i.default)(n, [{
            key: "send",
            value: function(t, e, n) {
                var r = n || e;
                try {
                    this.socket.send(t),
                    r()
                } catch (t) {
                    r(t)
                }
            }
        }, {
            key: "close",
            value: function(t, e) {
                this.socket.close(t, e)
            }
        }, {
            key: "addEventListener",
            value: function(t, e, n) {
                this.socket.addEventListener(t, e, n)
            }
        }]),
        n
    }(o("3vRz3").EventEmitter)
}
)),
o.register("J0sDk", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.shake256 = t.exports.shake128 = t.exports.keccak_512 = t.exports.keccak_384 = t.exports.keccak_256 = t.exports.keccak_224 = t.exports.sha3_512 = t.exports.sha3_384 = t.exports.sha3_256 = t.exports.sha3_224 = t.exports.Keccak = t.exports.keccakP = void 0;
    var n = o("dNiq9")
      , r = o("eDgKs")
      , i = o("3Bcdj");
    const [s,a,l] = [[], [], []]
      , c = BigInt(0)
      , u = BigInt(1)
      , h = BigInt(2)
      , d = BigInt(7)
      , f = BigInt(256)
      , p = BigInt(113);
    for (let t = 0, e = u, n = 1, r = 0; t < 24; t++) {
        [n,r] = [r, (2 * n + 3 * r) % 5],
        s.push(2 * (5 * r + n)),
        a.push((t + 1) * (t + 2) / 2 % 64);
        let i = c;
        for (let t = 0; t < 7; t++)
            e = (e << u ^ (e >> d) * p) % f,
            e & h && (i ^= u << (u << BigInt(t)) - u);
        l.push(i)
    }
    const [m,g] = r.default.split(l, !0)
      , y = (t,e,n)=>n > 32 ? r.default.rotlBH(t, e, n) : r.default.rotlSH(t, e, n)
      , b = (t,e,n)=>n > 32 ? r.default.rotlBL(t, e, n) : r.default.rotlSL(t, e, n);
    function v(t, e=24) {
        const n = new Uint32Array(10);
        for (let r = 24 - e; r < 24; r++) {
            for (let e = 0; e < 10; e++)
                n[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
            for (let e = 0; e < 10; e += 2) {
                const r = (e + 8) % 10
                  , i = (e + 2) % 10
                  , s = n[i]
                  , o = n[i + 1]
                  , a = y(s, o, 1) ^ n[r]
                  , l = b(s, o, 1) ^ n[r + 1];
                for (let n = 0; n < 50; n += 10)
                    t[e + n] ^= a,
                    t[e + n + 1] ^= l
            }
            let e = t[2]
              , i = t[3];
            for (let n = 0; n < 24; n++) {
                const r = a[n]
                  , o = y(e, i, r)
                  , l = b(e, i, r)
                  , c = s[n];
                e = t[c],
                i = t[c + 1],
                t[c] = o,
                t[c + 1] = l
            }
            for (let e = 0; e < 50; e += 10) {
                for (let r = 0; r < 10; r++)
                    n[r] = t[e + r];
                for (let r = 0; r < 10; r++)
                    t[e + r] ^= ~n[(r + 2) % 10] & n[(r + 4) % 10]
            }
            t[0] ^= m[r],
            t[1] ^= g[r]
        }
        n.fill(0)
    }
    t.exports.keccakP = v;
    class w extends i.Hash {
        constructor(t, e, r, s=!1, o=24) {
            if (super(),
            this.blockLen = t,
            this.suffix = e,
            this.outputLen = r,
            this.enableXOF = s,
            this.rounds = o,
            this.pos = 0,
            this.posOut = 0,
            this.finished = !1,
            this.destroyed = !1,
            n.default.number(r),
            0 >= this.blockLen || this.blockLen >= 200)
                throw new Error("Sha3 supports only keccak-f1600 function");
            this.state = new Uint8Array(200),
            this.state32 = (0,
            i.u32)(this.state)
        }
        keccak() {
            v(this.state32, this.rounds),
            this.posOut = 0,
            this.pos = 0
        }
        update(t) {
            n.default.exists(this);
            const {blockLen: e, state: r} = this
              , s = (t = (0,
            i.toBytes)(t)).length;
            for (let n = 0; n < s; ) {
                const i = Math.min(e - this.pos, s - n);
                for (let e = 0; e < i; e++)
                    r[this.pos++] ^= t[n++];
                this.pos === e && this.keccak()
            }
            return this
        }
        finish() {
            if (this.finished)
                return;
            this.finished = !0;
            const {state: t, suffix: e, pos: n, blockLen: r} = this;
            t[n] ^= e,
            0 != (128 & e) && n === r - 1 && this.keccak(),
            t[r - 1] ^= 128,
            this.keccak()
        }
        writeInto(t) {
            n.default.exists(this, !1),
            n.default.bytes(t),
            this.finish();
            const e = this.state
              , {blockLen: r} = this;
            for (let n = 0, i = t.length; n < i; ) {
                this.posOut >= r && this.keccak();
                const s = Math.min(r - this.posOut, i - n);
                t.set(e.subarray(this.posOut, this.posOut + s), n),
                this.posOut += s,
                n += s
            }
            return t
        }
        xofInto(t) {
            if (!this.enableXOF)
                throw new Error("XOF is not possible for this instance");
            return this.writeInto(t)
        }
        xof(t) {
            return n.default.number(t),
            this.xofInto(new Uint8Array(t))
        }
        digestInto(t) {
            if (n.default.output(t, this),
            this.finished)
                throw new Error("digest() was already called");
            return this.writeInto(t),
            this.destroy(),
            t
        }
        digest() {
            return this.digestInto(new Uint8Array(this.outputLen))
        }
        destroy() {
            this.destroyed = !0,
            this.state.fill(0)
        }
        _cloneInto(t) {
            const {blockLen: e, suffix: n, outputLen: r, rounds: i, enableXOF: s} = this;
            return t || (t = new w(e,n,r,s,i)),
            t.state32.set(this.state32),
            t.pos = this.pos,
            t.posOut = this.posOut,
            t.finished = this.finished,
            t.rounds = i,
            t.suffix = n,
            t.outputLen = r,
            t.enableXOF = s,
            t.destroyed = this.destroyed,
            t
        }
    }
    t.exports.Keccak = w;
    const x = (t,e,n)=>(0,
    i.wrapConstructor)((()=>new w(e,t,n)));
    t.exports.sha3_224 = x(6, 144, 28),
    t.exports.sha3_256 = x(6, 136, 32),
    t.exports.sha3_384 = x(6, 104, 48),
    t.exports.sha3_512 = x(6, 72, 64),
    t.exports.keccak_224 = x(1, 144, 28),
    t.exports.keccak_256 = x(1, 136, 32),
    t.exports.keccak_384 = x(1, 104, 48),
    t.exports.keccak_512 = x(1, 72, 64);
    const E = (t,e,n)=>(0,
    i.wrapConstructorWithOpts)(((r={})=>new w(e,t,void 0 === r.dkLen ? n : r.dkLen,!0)));
    t.exports.shake128 = E(31, 168, 16),
    t.exports.shake256 = E(31, 136, 32)
}
)),
o.register("70Xw9", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.hmac = void 0;
    var n = o("dNiq9")
      , r = o("3Bcdj");
    class i extends r.Hash {
        constructor(t, e) {
            super(),
            this.finished = !1,
            this.destroyed = !1,
            n.default.hash(t);
            const i = (0,
            r.toBytes)(e);
            if (this.iHash = t.create(),
            "function" != typeof this.iHash.update)
                throw new TypeError("Expected instance of class which extends utils.Hash");
            this.blockLen = this.iHash.blockLen,
            this.outputLen = this.iHash.outputLen;
            const s = this.blockLen
              , o = new Uint8Array(s);
            o.set(i.length > s ? t.create().update(i).digest() : i);
            for (let t = 0; t < o.length; t++)
                o[t] ^= 54;
            this.iHash.update(o),
            this.oHash = t.create();
            for (let t = 0; t < o.length; t++)
                o[t] ^= 106;
            this.oHash.update(o),
            o.fill(0)
        }
        update(t) {
            return n.default.exists(this),
            this.iHash.update(t),
            this
        }
        digestInto(t) {
            n.default.exists(this),
            n.default.bytes(t, this.outputLen),
            this.finished = !0,
            this.iHash.digestInto(t),
            this.oHash.update(t),
            this.oHash.digestInto(t),
            this.destroy()
        }
        digest() {
            const t = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(t),
            t
        }
        _cloneInto(t) {
            t || (t = Object.create(Object.getPrototypeOf(this), {}));
            const {oHash: e, iHash: n, finished: r, destroyed: i, blockLen: s, outputLen: o} = this;
            return t.finished = r,
            t.destroyed = i,
            t.blockLen = s,
            t.outputLen = o,
            t.oHash = e._cloneInto(t.oHash),
            t.iHash = n._cloneInto(t.iHash),
            t
        }
        destroy() {
            this.destroyed = !0,
            this.oHash.destroy(),
            this.iHash.destroy()
        }
    }
    t.exports.hmac = (t,e,n)=>new i(t,e).update(n).digest(),
    t.exports.hmac.create = (t,e)=>new i(t,e)
}
)),
o.register("7Rh2L", (function(e, n) {
    t(e.exports, "utils", (()=>lt)),
    t(e.exports, "getPublicKey", (()=>J)),
    t(e.exports, "signSync", (()=>st));
    /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
    var r = o("kjyEk");
    const i = BigInt(0)
      , s = BigInt(1)
      , a = BigInt(2)
      , l = BigInt(3)
      , c = BigInt(8)
      , u = Object.freeze({
        a: i,
        b: BigInt(7),
        P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: s,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    })
      , h = (t,e)=>(t + e / a) / e
      , d = {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar(t) {
            const {n: e} = u
              , n = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
              , r = -s * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
              , i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
              , o = n
              , a = BigInt("0x100000000000000000000000000000000")
              , l = h(o * t, e)
              , c = h(-r * t, e);
            let d = z(t - l * n - c * i, e)
              , f = z(-l * r - c * o, e);
            const p = d > a
              , m = f > a;
            if (p && (d = e - d),
            m && (f = e - f),
            d > a || f > a)
                throw new Error("splitScalarEndo: Endomorphism failed, k=" + t);
            return {
                k1neg: p,
                k1: d,
                k2neg: m,
                k2: f
            }
        }
    }
      , f = 32
      , p = 32
      , m = 32
      , g = f + 1
      , y = 2 * f + 1;
    function b(t) {
        const {a: e, b: n} = u
          , r = z(t * t)
          , i = z(r * t);
        return z(i + e * t + n)
    }
    const v = u.a === i;
    class w extends Error {
        constructor(t) {
            super(t)
        }
    }
    function x(t) {
        if (!(t instanceof E))
            throw new TypeError("JacobianPoint expected")
    }
    class E {
        constructor(t, e, n) {
            this.x = t,
            this.y = e,
            this.z = n
        }
        static fromAffine(t) {
            if (!(t instanceof S))
                throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return t.equals(S.ZERO) ? E.ZERO : new E(t.x,t.y,s)
        }
        static toAffineBatch(t) {
            const e = function(t, e=u.P) {
                const n = new Array(t.length)
                  , r = W(t.reduce(((t,r,s)=>r === i ? t : (n[s] = t,
                z(t * r, e))), s), e);
                return t.reduceRight(((t,r,s)=>r === i ? t : (n[s] = z(t * n[s], e),
                z(t * r, e))), r),
                n
            }(t.map((t=>t.z)));
            return t.map(((t,n)=>t.toAffine(e[n])))
        }
        static normalizeZ(t) {
            return E.toAffineBatch(t).map(E.fromAffine)
        }
        equals(t) {
            x(t);
            const {x: e, y: n, z: r} = this
              , {x: i, y: s, z: o} = t
              , a = z(r * r)
              , l = z(o * o)
              , c = z(e * l)
              , u = z(i * a)
              , h = z(z(n * o) * l)
              , d = z(z(s * r) * a);
            return c === u && h === d
        }
        negate() {
            return new E(this.x,z(-this.y),this.z)
        }
        double() {
            const {x: t, y: e, z: n} = this
              , r = z(t * t)
              , i = z(e * e)
              , s = z(i * i)
              , o = t + i
              , u = z(a * (z(o * o) - r - s))
              , h = z(l * r)
              , d = z(h * h)
              , f = z(d - a * u)
              , p = z(h * (u - f) - c * s)
              , m = z(a * e * n);
            return new E(f,p,m)
        }
        add(t) {
            x(t);
            const {x: e, y: n, z: r} = this
              , {x: s, y: o, z: l} = t;
            if (s === i || o === i)
                return this;
            if (e === i || n === i)
                return t;
            const c = z(r * r)
              , u = z(l * l)
              , h = z(e * u)
              , d = z(s * c)
              , f = z(z(n * l) * u)
              , p = z(z(o * r) * c)
              , m = z(d - h)
              , g = z(p - f);
            if (m === i)
                return g === i ? this.double() : E.ZERO;
            const y = z(m * m)
              , b = z(m * y)
              , v = z(h * y)
              , w = z(g * g - b - a * v)
              , _ = z(g * (v - w) - f * b)
              , A = z(r * l * m);
            return new E(w,_,A)
        }
        subtract(t) {
            return this.add(t.negate())
        }
        multiplyUnsafe(t) {
            const e = E.ZERO;
            if ("bigint" == typeof t && t === i)
                return e;
            let n = U(t);
            if (n === s)
                return this;
            if (!v) {
                let t = e
                  , r = this;
                for (; n > i; )
                    n & s && (t = t.add(r)),
                    r = r.double(),
                    n >>= s;
                return t
            }
            let {k1neg: r, k1: o, k2neg: a, k2: l} = d.splitScalar(n)
              , c = e
              , u = e
              , h = this;
            for (; o > i || l > i; )
                o & s && (c = c.add(h)),
                l & s && (u = u.add(h)),
                h = h.double(),
                o >>= s,
                l >>= s;
            return r && (c = c.negate()),
            a && (u = u.negate()),
            u = new E(z(u.x * d.beta),u.y,u.z),
            c.add(u)
        }
        precomputeWindow(t) {
            const e = v ? 128 / t + 1 : 256 / t + 1
              , n = [];
            let r = this
              , i = r;
            for (let s = 0; s < e; s++) {
                i = r,
                n.push(i);
                for (let e = 1; e < 2 ** (t - 1); e++)
                    i = i.add(r),
                    n.push(i);
                r = i.double()
            }
            return n
        }
        wNAF(t, e) {
            !e && this.equals(E.BASE) && (e = S.BASE);
            const n = e && e._WINDOW_SIZE || 1;
            if (256 % n)
                throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
            let r = e && A.get(e);
            r || (r = this.precomputeWindow(n),
            e && 1 !== n && (r = E.normalizeZ(r),
            A.set(e, r)));
            let i = E.ZERO
              , o = E.BASE;
            const a = 1 + (v ? 128 / n : 256 / n)
              , l = 2 ** (n - 1)
              , c = BigInt(2 ** n - 1)
              , u = 2 ** n
              , h = BigInt(n);
            for (let e = 0; e < a; e++) {
                const n = e * l;
                let a = Number(t & c);
                t >>= h,
                a > l && (a -= u,
                t += s);
                const d = n
                  , f = n + Math.abs(a) - 1
                  , p = e % 2 != 0
                  , m = a < 0;
                0 === a ? o = o.add(_(p, r[d])) : i = i.add(_(m, r[f]))
            }
            return {
                p: i,
                f: o
            }
        }
        multiply(t, e) {
            let n, r, i = U(t);
            if (v) {
                const {k1neg: t, k1: s, k2neg: o, k2: a} = d.splitScalar(i);
                let {p: l, f: c} = this.wNAF(s, e)
                  , {p: u, f: h} = this.wNAF(a, e);
                l = _(t, l),
                u = _(o, u),
                u = new E(z(u.x * d.beta),u.y,u.z),
                n = l.add(u),
                r = c.add(h)
            } else {
                const {p: t, f: s} = this.wNAF(i, e);
                n = t,
                r = s
            }
            return E.normalizeZ([n, r])[0]
        }
        toAffine(t) {
            const {x: e, y: n, z: r} = this
              , i = this.equals(E.ZERO);
            null == t && (t = i ? c : W(r));
            const o = t
              , a = z(o * o)
              , l = z(a * o)
              , u = z(e * a)
              , h = z(n * l)
              , d = z(r * o);
            if (i)
                return S.ZERO;
            if (d !== s)
                throw new Error("invZ was invalid");
            return new S(u,h)
        }
    }
    function _(t, e) {
        const n = e.negate();
        return t ? n : e
    }
    E.BASE = new E(u.Gx,u.Gy,s),
    E.ZERO = new E(i,s,i);
    const A = new WeakMap;
    class S {
        constructor(t, e) {
            this.x = t,
            this.y = e
        }
        _setWindowSize(t) {
            this._WINDOW_SIZE = t,
            A.delete(this)
        }
        hasEvenY() {
            return this.y % a === i
        }
        static fromCompressedHex(t) {
            const e = 32 === t.length
              , n = F(e ? t : t.subarray(1));
            if (!q(n))
                throw new Error("Point is not on curve");
            let r = function(t) {
                const {P: e} = u
                  , n = BigInt(6)
                  , r = BigInt(11)
                  , i = BigInt(22)
                  , s = BigInt(23)
                  , o = BigInt(44)
                  , c = BigInt(88)
                  , h = t * t * t % e
                  , d = h * h * t % e
                  , f = V(d, l) * d % e
                  , p = V(f, l) * d % e
                  , m = V(p, a) * h % e
                  , g = V(m, r) * m % e
                  , y = V(g, i) * g % e
                  , b = V(y, o) * y % e
                  , v = V(b, c) * b % e
                  , w = V(v, o) * y % e
                  , x = V(w, l) * d % e
                  , E = V(x, s) * g % e
                  , _ = V(E, n) * h % e
                  , A = V(_, a);
                if (A * A % e !== t)
                    throw new Error("Cannot find square root");
                return A
            }(b(n));
            const i = (r & s) === s;
            if (e)
                i && (r = z(-r));
            else {
                1 == (1 & t[0]) !== i && (r = z(-r))
            }
            const o = new S(n,r);
            return o.assertValidity(),
            o
        }
        static fromUncompressedHex(t) {
            const e = F(t.subarray(1, f + 1))
              , n = F(t.subarray(f + 1, 2 * f + 1))
              , r = new S(e,n);
            return r.assertValidity(),
            r
        }
        static fromHex(t) {
            const e = j(t)
              , n = e.length
              , r = e[0];
            if (n === f)
                return this.fromCompressedHex(e);
            if (n === g && (2 === r || 3 === r))
                return this.fromCompressedHex(e);
            if (n === y && 4 === r)
                return this.fromUncompressedHex(e);
            throw new Error(`Point.fromHex: received invalid point. Expected 32-${g} compressed bytes or ${y} uncompressed bytes, not ${n}`)
        }
        static fromPrivateKey(t) {
            return S.BASE.multiply(Q(t))
        }
        static fromSignature(t, e, n) {
            const {r: r, s: i} = Z(e);
            if (![0, 1, 2, 3].includes(n))
                throw new Error("Cannot recover: invalid recovery bit");
            const s = Y(j(t))
              , {n: o} = u
              , a = 2 === n || 3 === n ? r + o : r
              , l = W(a, o)
              , c = z(-s * l, o)
              , h = z(i * l, o)
              , d = 1 & n ? "03" : "02"
              , f = S.fromHex(d + N(a))
              , p = S.BASE.multiplyAndAddUnsafe(f, c, h);
            if (!p)
                throw new Error("Cannot recover signature: point at infinify");
            return p.assertValidity(),
            p
        }
        toRawBytes(t=!1) {
            return L(this.toHex(t))
        }
        toHex(t=!1) {
            const e = N(this.x);
            if (t) {
                return `${this.hasEvenY() ? "02" : "03"}${e}`
            }
            return `04${e}${N(this.y)}`
        }
        toHexX() {
            return this.toHex(!0).slice(2)
        }
        toRawX() {
            return this.toRawBytes(!0).slice(1)
        }
        assertValidity() {
            const t = "Point is not on elliptic curve"
              , {x: e, y: n} = this;
            if (!q(e) || !q(n))
                throw new Error(t);
            const r = z(n * n);
            if (z(r - b(e)) !== i)
                throw new Error(t)
        }
        equals(t) {
            return this.x === t.x && this.y === t.y
        }
        negate() {
            return new S(this.x,z(-this.y))
        }
        double() {
            return E.fromAffine(this).double().toAffine()
        }
        add(t) {
            return E.fromAffine(this).add(E.fromAffine(t)).toAffine()
        }
        subtract(t) {
            return this.add(t.negate())
        }
        multiply(t) {
            return E.fromAffine(this).multiply(t, this).toAffine()
        }
        multiplyAndAddUnsafe(t, e, n) {
            const r = E.fromAffine(this)
              , o = e === i || e === s || this !== S.BASE ? r.multiplyUnsafe(e) : r.multiply(e)
              , a = E.fromAffine(t).multiplyUnsafe(n)
              , l = o.add(a);
            return l.equals(E.ZERO) ? void 0 : l.toAffine()
        }
    }
    function T(t) {
        return Number.parseInt(t[0], 16) >= 8 ? "00" + t : t
    }
    function k(t) {
        if (t.length < 2 || 2 !== t[0])
            throw new Error(`Invalid signature integer tag: ${P(t)}`);
        const e = t[1]
          , n = t.subarray(2, e + 2);
        if (!e || n.length !== e)
            throw new Error("Invalid signature integer: wrong length");
        if (0 === n[0] && n[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
        return {
            data: F(n),
            left: t.subarray(e + 2)
        }
    }
    S.BASE = new S(u.Gx,u.Gy),
    S.ZERO = new S(i,i);
    class I {
        constructor(t, e) {
            this.r = t,
            this.s = e,
            this.assertValidity()
        }
        static fromCompact(t) {
            const e = t instanceof Uint8Array
              , n = "Signature.fromCompact";
            if ("string" != typeof t && !e)
                throw new TypeError(`${n}: Expected string or Uint8Array`);
            const r = e ? P(t) : t;
            if (128 !== r.length)
                throw new Error(`${n}: Expected 64-byte hex`);
            return new I(B(r.slice(0, 64)),B(r.slice(64, 128)))
        }
        static fromDER(t) {
            const e = t instanceof Uint8Array;
            if ("string" != typeof t && !e)
                throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
            const {r: n, s: r} = function(t) {
                if (t.length < 2 || 48 != t[0])
                    throw new Error(`Invalid signature tag: ${P(t)}`);
                if (t[1] !== t.length - 2)
                    throw new Error("Invalid signature: incorrect length");
                const {data: e, left: n} = k(t.subarray(2))
                  , {data: r, left: i} = k(n);
                if (i.length)
                    throw new Error(`Invalid signature: left bytes after parsing: ${P(i)}`);
                return {
                    r: e,
                    s: r
                }
            }(e ? t : L(t));
            return new I(n,r)
        }
        static fromHex(t) {
            return this.fromDER(t)
        }
        assertValidity() {
            const {r: t, s: e} = this;
            if (!X(t))
                throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!X(e))
                throw new Error("Invalid Signature: s must be 0 < s < n")
        }
        hasHighS() {
            const t = u.n >> s;
            return this.s > t
        }
        normalizeS() {
            return this.hasHighS() ? new I(this.r,z(-this.s, u.n)) : this
        }
        toDERRawBytes() {
            return L(this.toDERHex())
        }
        toDERHex() {
            const t = T(D(this.s))
              , e = T(D(this.r))
              , n = t.length / 2
              , r = e.length / 2
              , i = D(n)
              , s = D(r);
            return `30${D(r + n + 4)}02${s}${e}02${i}${t}`
        }
        toRawBytes() {
            return this.toDERRawBytes()
        }
        toHex() {
            return this.toDERHex()
        }
        toCompactRawBytes() {
            return L(this.toCompactHex())
        }
        toCompactHex() {
            return N(this.r) + N(this.s)
        }
    }
    function M(...t) {
        if (!t.every((t=>t instanceof Uint8Array)))
            throw new Error("Uint8Array list expected");
        if (1 === t.length)
            return t[0];
        const e = t.reduce(((t,e)=>t + e.length), 0)
          , n = new Uint8Array(e);
        for (let e = 0, r = 0; e < t.length; e++) {
            const i = t[e];
            n.set(i, r),
            r += i.length
        }
        return n
    }
    const C = Array.from({
        length: 256
    }, ((t,e)=>e.toString(16).padStart(2, "0")));
    function P(t) {
        if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
        let e = "";
        for (let n = 0; n < t.length; n++)
            e += C[t[n]];
        return e
    }
    const O = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    function N(t) {
        if ("bigint" != typeof t)
            throw new Error("Expected bigint");
        if (!(i <= t && t < O))
            throw new Error("Expected number 0 <= n < 2^256");
        return t.toString(16).padStart(64, "0")
    }
    function R(t) {
        const e = L(N(t));
        if (32 !== e.length)
            throw new Error("Error: expected 32 bytes");
        return e
    }
    function D(t) {
        const e = t.toString(16);
        return 1 & e.length ? `0${e}` : e
    }
    function B(t) {
        if ("string" != typeof t)
            throw new TypeError("hexToNumber: expected string, got " + typeof t);
        return BigInt(`0x${t}`)
    }
    function L(t) {
        if ("string" != typeof t)
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
        if (t.length % 2)
            throw new Error("hexToBytes: received invalid unpadded hex" + t.length);
        const e = new Uint8Array(t.length / 2);
        for (let n = 0; n < e.length; n++) {
            const r = 2 * n
              , i = t.slice(r, r + 2)
              , s = Number.parseInt(i, 16);
            if (Number.isNaN(s) || s < 0)
                throw new Error("Invalid byte sequence");
            e[n] = s
        }
        return e
    }
    function F(t) {
        return B(P(t))
    }
    function j(t) {
        return t instanceof Uint8Array ? Uint8Array.from(t) : L(t)
    }
    function U(t) {
        if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            return BigInt(t);
        if ("bigint" == typeof t && X(t))
            return t;
        throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")
    }
    function z(t, e=u.P) {
        const n = t % e;
        return n >= i ? n : e + n
    }
    function V(t, e) {
        const {P: n} = u;
        let r = t;
        for (; e-- > i; )
            r *= r,
            r %= n;
        return r
    }
    function W(t, e=u.P) {
        if (t === i || e <= i)
            throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
        let n = z(t, e)
          , r = e
          , o = i
          , a = s
          , l = s
          , c = i;
        for (; n !== i; ) {
            const t = r / n
              , e = r % n
              , i = o - l * t
              , s = a - c * t;
            r = n,
            n = e,
            o = l,
            a = c,
            l = i,
            c = s
        }
        if (r !== s)
            throw new Error("invert: does not exist");
        return z(o, e)
    }
    function Y(t, e=!1) {
        const n = function(t) {
            const e = 8 * t.length - 8 * p
              , n = F(t);
            return e > 0 ? n >> BigInt(e) : n
        }(t);
        if (e)
            return n;
        const {n: r} = u;
        return n >= r ? n - r : n
    }
    let H, $;
    class G {
        constructor(t, e) {
            if (this.hashLen = t,
            this.qByteLen = e,
            "number" != typeof t || t < 2)
                throw new Error("hashLen must be a number");
            if ("number" != typeof e || e < 2)
                throw new Error("qByteLen must be a number");
            this.v = new Uint8Array(t).fill(1),
            this.k = new Uint8Array(t).fill(0),
            this.counter = 0
        }
        hmac(...t) {
            return lt.hmacSha256(this.k, ...t)
        }
        hmacSync(...t) {
            return $(this.k, ...t)
        }
        checkSync() {
            if ("function" != typeof $)
                throw new w("hmacSha256Sync needs to be set")
        }
        incr() {
            if (this.counter >= 1e3)
                throw new Error("Tried 1,000 k values for sign(), all were invalid");
            this.counter += 1
        }
        async reseed(t=new Uint8Array) {
            this.k = await this.hmac(this.v, Uint8Array.from([0]), t),
            this.v = await this.hmac(this.v),
            0 !== t.length && (this.k = await this.hmac(this.v, Uint8Array.from([1]), t),
            this.v = await this.hmac(this.v))
        }
        reseedSync(t=new Uint8Array) {
            this.checkSync(),
            this.k = this.hmacSync(this.v, Uint8Array.from([0]), t),
            this.v = this.hmacSync(this.v),
            0 !== t.length && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), t),
            this.v = this.hmacSync(this.v))
        }
        async generate() {
            this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
                this.v = await this.hmac(this.v);
                const n = this.v.slice();
                e.push(n),
                t += this.v.length
            }
            return M(...e)
        }
        generateSync() {
            this.checkSync(),
            this.incr();
            let t = 0;
            const e = [];
            for (; t < this.qByteLen; ) {
                this.v = this.hmacSync(this.v);
                const n = this.v.slice();
                e.push(n),
                t += this.v.length
            }
            return M(...e)
        }
    }
    function X(t) {
        return i < t && t < u.n
    }
    function q(t) {
        return i < t && t < u.P
    }
    function K(t, e, n, r=!0) {
        const {n: o} = u
          , a = Y(t, !0);
        if (!X(a))
            return;
        const l = W(a, o)
          , c = S.BASE.multiply(a)
          , h = z(c.x, o);
        if (h === i)
            return;
        const d = z(l * z(e + n * h, o), o);
        if (d === i)
            return;
        let f = new I(h,d)
          , p = (c.x === f.r ? 0 : 2) | Number(c.y & s);
        return r && f.hasHighS() && (f = f.normalizeS(),
        p ^= 1),
        {
            sig: f,
            recovery: p
        }
    }
    function Q(t) {
        let e;
        if ("bigint" == typeof t)
            e = t;
        else if ("number" == typeof t && Number.isSafeInteger(t) && t > 0)
            e = BigInt(t);
        else if ("string" == typeof t) {
            if (t.length !== 2 * p)
                throw new Error("Expected 32 bytes of private key");
            e = B(t)
        } else {
            if (!(t instanceof Uint8Array))
                throw new TypeError("Expected valid private key");
            if (t.length !== p)
                throw new Error("Expected 32 bytes of private key");
            e = F(t)
        }
        if (!X(e))
            throw new Error("Expected private key: 0 < key < n");
        return e
    }
    function Z(t) {
        if (t instanceof I)
            return t.assertValidity(),
            t;
        try {
            return I.fromDER(t)
        } catch (e) {
            return I.fromCompact(t)
        }
    }
    function J(t, e=!1) {
        return S.fromPrivateKey(t).toRawBytes(e)
    }
    function tt(t) {
        return F(t.length > f ? t.slice(0, f) : t)
    }
    function et(t) {
        const e = tt(t)
          , n = z(e, u.n);
        return nt(n < i ? e : n)
    }
    function nt(t) {
        return R(t)
    }
    function rt(t, e, n) {
        if (null == t)
            throw new Error(`sign: expected valid message hash, not "${t}"`);
        const r = j(t)
          , i = Q(e)
          , s = [nt(i), et(r)];
        if (null != n) {
            !0 === n && (n = lt.randomBytes(f));
            const t = j(n);
            if (t.length !== f)
                throw new Error(`sign: Expected ${f} bytes of extra data`);
            s.push(t)
        }
        return {
            seed: M(...s),
            m: tt(r),
            d: i
        }
    }
    function it(t, e) {
        const {sig: n, recovery: r} = t
          , {der: i, recovered: s} = Object.assign({
            canonical: !0,
            der: !0
        }, e)
          , o = i ? n.toDERRawBytes() : n.toCompactRawBytes();
        return s ? [o, r] : o
    }
    function st(t, e, n={}) {
        const {seed: r, m: i, d: s} = rt(t, e, n.extraEntropy)
          , o = new G(m,p);
        let a;
        for (o.reseedSync(r); !(a = K(o.generateSync(), i, s, n.canonical)); )
            o.reseedSync();
        return it(a, n)
    }
    S.BASE._setWindowSize(8);
    const ot = {
        node: r,
        web: "object" == typeof self && "crypto"in self ? self.crypto : void 0
    }
      , at = {}
      , lt = {
        bytesToHex: P,
        hexToBytes: L,
        concatBytes: M,
        mod: z,
        invert: W,
        isValidPrivateKey(t) {
            try {
                return Q(t),
                !0
            } catch (t) {
                return !1
            }
        },
        _bigintTo32Bytes: R,
        _normalizePrivateKey: Q,
        hashToPrivateKey: t=>{
            t = j(t);
            const e = p + 8;
            if (t.length < e || t.length > 1024)
                throw new Error("Expected valid bytes of private key as per FIPS 186");
            return R(z(F(t), u.n - s) + s)
        }
        ,
        randomBytes: (t=32)=>{
            if (ot.web)
                return ot.web.getRandomValues(new Uint8Array(t));
            if (ot.node) {
                const {randomBytes: e} = ot.node;
                return Uint8Array.from(e(t))
            }
            throw new Error("The environment doesn't have randomBytes function")
        }
        ,
        randomPrivateKey: ()=>lt.hashToPrivateKey(lt.randomBytes(p + 8)),
        precompute(t=8, e=S.BASE) {
            const n = e === S.BASE ? e : new S(e.x,e.y);
            return n._setWindowSize(t),
            n.multiply(l),
            n
        },
        sha256: async(...t)=>{
            if (ot.web) {
                const e = await ot.web.subtle.digest("SHA-256", M(...t));
                return new Uint8Array(e)
            }
            if (ot.node) {
                const {createHash: e} = ot.node
                  , n = e("sha256");
                return t.forEach((t=>n.update(t))),
                Uint8Array.from(n.digest())
            }
            throw new Error("The environment doesn't have sha256 function")
        }
        ,
        hmacSha256: async(t,...e)=>{
            if (ot.web) {
                const n = await ot.web.subtle.importKey("raw", t, {
                    name: "HMAC",
                    hash: {
                        name: "SHA-256"
                    }
                }, !1, ["sign"])
                  , r = M(...e)
                  , i = await ot.web.subtle.sign("HMAC", n, r);
                return new Uint8Array(i)
            }
            if (ot.node) {
                const {createHmac: n} = ot.node
                  , r = n("sha256", t);
                return e.forEach((t=>r.update(t))),
                Uint8Array.from(r.digest())
            }
            throw new Error("The environment doesn't have hmac-sha256 function")
        }
        ,
        sha256Sync: void 0,
        hmacSha256Sync: void 0,
        taggedHash: async(t,...e)=>{
            let n = at[t];
            if (void 0 === n) {
                const e = await lt.sha256(Uint8Array.from(t, (t=>t.charCodeAt(0))));
                n = M(e, e),
                at[t] = n
            }
            return lt.sha256(n, ...e)
        }
        ,
        taggedHashSync: (t,...e)=>{
            if ("function" != typeof H)
                throw new w("sha256Sync is undefined, you need to set it");
            let n = at[t];
            if (void 0 === n) {
                const e = H(Uint8Array.from(t, (t=>t.charCodeAt(0))));
                n = M(e, e),
                at[t] = n
            }
            return H(n, ...e)
        }
        ,
        _JacobianPoint: E
    };
    Object.defineProperties(lt, {
        sha256Sync: {
            configurable: !1,
            get: ()=>H,
            set(t) {
                H || (H = t)
            }
        },
        hmacSha256Sync: {
            configurable: !1,
            get: ()=>$,
            set(t) {
                $ || ($ = t)
            }
        }
    })
}
)),
o.register("hOzOt", (function(t, e) {
    var n = o("kZO5c");
    function r() {}
    function i() {}
    i.resetWarningCache = r,
    t.exports = function() {
        function t(t, e, r, i, s, o) {
            if (o !== n) {
                var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw a.name = "Invariant Violation",
                a
            }
        }
        function e() {
            return t
        }
        t.isRequired = t;
        var s = {
            array: t,
            bigint: t,
            bool: t,
            func: t,
            number: t,
            object: t,
            string: t,
            symbol: t,
            any: t,
            arrayOf: e,
            element: t,
            elementType: t,
            instanceOf: e,
            node: t,
            objectOf: e,
            oneOf: e,
            oneOfType: e,
            shape: e,
            exact: e,
            checkPropTypes: i,
            resetWarningCache: r
        };
        return s.PropTypes = s,
        s
    }
}
)),
o.register("kZO5c", (function(t, e) {
    t.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
}
)),
o.register("bYkMz", (function(t, e) {
    var n = o("5ltpn");
    t.exports = n("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
}
)),
o.register("5ltpn", (function(t, e) {
    t.exports = function(t) {
        if (t.length >= 255)
            throw new TypeError("Alphabet too long");
        for (var e = new Uint8Array(256), n = 0; n < e.length; n++)
            e[n] = 255;
        for (var r = 0; r < t.length; r++) {
            var i = t.charAt(r)
              , s = i.charCodeAt(0);
            if (255 !== e[s])
                throw new TypeError(i + " is ambiguous");
            e[s] = r
        }
        var o = t.length
          , a = t.charAt(0)
          , l = Math.log(o) / Math.log(256)
          , c = Math.log(256) / Math.log(o);
        function u(t) {
            if ("string" != typeof t)
                throw new TypeError("Expected String");
            if (0 === t.length)
                return new Uint8Array;
            for (var n = 0, r = 0, i = 0; t[n] === a; )
                r++,
                n++;
            for (var s = (t.length - n) * l + 1 >>> 0, c = new Uint8Array(s); t[n]; ) {
                var u = e[t.charCodeAt(n)];
                if (255 === u)
                    return;
                for (var h = 0, d = s - 1; (0 !== u || h < i) && -1 !== d; d--,
                h++)
                    u += o * c[d] >>> 0,
                    c[d] = u % 256 >>> 0,
                    u = u / 256 >>> 0;
                if (0 !== u)
                    throw new Error("Non-zero carry");
                i = h,
                n++
            }
            for (var f = s - i; f !== s && 0 === c[f]; )
                f++;
            for (var p = new Uint8Array(r + (s - f)), m = r; f !== s; )
                p[m++] = c[f++];
            return p
        }
        return {
            encode: function(e) {
                if (e instanceof Uint8Array || (ArrayBuffer.isView(e) ? e = new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : Array.isArray(e) && (e = Uint8Array.from(e))),
                !(e instanceof Uint8Array))
                    throw new TypeError("Expected Uint8Array");
                if (0 === e.length)
                    return "";
                for (var n = 0, r = 0, i = 0, s = e.length; i !== s && 0 === e[i]; )
                    i++,
                    n++;
                for (var l = (s - i) * c + 1 >>> 0, u = new Uint8Array(l); i !== s; ) {
                    for (var h = e[i], d = 0, f = l - 1; (0 !== h || d < r) && -1 !== f; f--,
                    d++)
                        h += 256 * u[f] >>> 0,
                        u[f] = h % o >>> 0,
                        h = h / o >>> 0;
                    if (0 !== h)
                        throw new Error("Non-zero carry");
                    r = d,
                    i++
                }
                for (var p = l - r; p !== l && 0 === u[p]; )
                    p++;
                for (var m = a.repeat(n); p < l; ++p)
                    m += t.charAt(u[p]);
                return m
            },
            decodeUnsafe: u,
            decode: function(t) {
                var e = u(t);
                if (e)
                    return e;
                throw new Error("Non-base" + o + " character")
            }
        }
    }
}
)),
o.register("4KAV8", (function(n, r) {
    t(n.exports, "default", (()=>p), (t=>p = t)),
    t(n.exports, "TransportError", (()=>o("degpm").TransportError), (t=>o("degpm").TransportError = t)),
    t(n.exports, "TransportStatusError", (()=>o("degpm").TransportStatusError), (t=>o("degpm").TransportStatusError = t)),
    t(n.exports, "StatusCodes", (()=>o("degpm").StatusCodes), (t=>o("degpm").StatusCodes = t)),
    t(n.exports, "getAltStatusMessage", (()=>$375818ecee1623c3$re_export$getAltStatusMessage), (t=>$375818ecee1623c3$re_export$getAltStatusMessage = t));
    var i = o("7etJZ")
      , s = o("degpm")
      , a = o("6ZWSX").Buffer
      , l = function(t, e, n, r) {
        return new (n || (n = Promise))((function(i, s) {
            function o(t) {
                try {
                    l(r.next(t))
                } catch (t) {
                    s(t)
                }
            }
            function a(t) {
                try {
                    l(r.throw(t))
                } catch (t) {
                    s(t)
                }
            }
            function l(t) {
                var e;
                t.done ? i(t.value) : (e = t.value,
                e instanceof n ? e : new n((function(t) {
                    t(e)
                }
                ))).then(o, a)
            }
            l((r = r.apply(t, e || [])).next())
        }
        ))
    }
      , c = function(t, e) {
        var n, r, i, s, o = {
            label: 0,
            sent: function() {
                if (1 & i[0])
                    throw i[1];
                return i[1]
            },
            trys: [],
            ops: []
        };
        return s = {
            next: a(0),
            throw: a(1),
            return: a(2)
        },
        "function" == typeof Symbol && (s[Symbol.iterator] = function() {
            return this
        }
        ),
        s;
        function a(s) {
            return function(a) {
                return function(s) {
                    if (n)
                        throw new TypeError("Generator is already executing.");
                    for (; o; )
                        try {
                            if (n = 1,
                            r && (i = 2 & s[0] ? r.return : s[0] ? r.throw || ((i = r.return) && i.call(r),
                            0) : r.next) && !(i = i.call(r, s[1])).done)
                                return i;
                            switch (r = 0,
                            i && (s = [2 & s[0], i.value]),
                            s[0]) {
                            case 0:
                            case 1:
                                i = s;
                                break;
                            case 4:
                                return o.label++,
                                {
                                    value: s[1],
                                    done: !1
                                };
                            case 5:
                                o.label++,
                                r = s[1],
                                s = [0];
                                continue;
                            case 7:
                                s = o.ops.pop(),
                                o.trys.pop();
                                continue;
                            default:
                                if (!(i = o.trys,
                                (i = i.length > 0 && i[i.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                    o = 0;
                                    continue
                                }
                                if (3 === s[0] && (!i || s[1] > i[0] && s[1] < i[3])) {
                                    o.label = s[1];
                                    break
                                }
                                if (6 === s[0] && o.label < i[1]) {
                                    o.label = i[1],
                                    i = s;
                                    break
                                }
                                if (i && o.label < i[2]) {
                                    o.label = i[2],
                                    o.ops.push(s);
                                    break
                                }
                                i[2] && o.ops.pop(),
                                o.trys.pop();
                                continue
                            }
                            s = e.call(t, o)
                        } catch (t) {
                            s = [6, t],
                            r = 0
                        } finally {
                            n = i = 0
                        }
                    if (5 & s[0])
                        throw s[1];
                    return {
                        value: s[0] ? s[1] : void 0,
                        done: !0
                    }
                }([s, a])
            }
        }
    }
      , u = function(t, e) {
        var n = "function" == typeof Symbol && t[Symbol.iterator];
        if (!n)
            return t;
        var r, i, s = n.call(t), o = [];
        try {
            for (; (void 0 === e || e-- > 0) && !(r = s.next()).done; )
                o.push(r.value)
        } catch (t) {
            i = {
                error: t
            }
        } finally {
            try {
                r && !r.done && (n = s.return) && n.call(s)
            } finally {
                if (i)
                    throw i.error
            }
        }
        return o
    }
      , h = function(t, e, n) {
        if (n || 2 === arguments.length)
            for (var r, i = 0, s = e.length; i < s; i++)
                !r && i in e || (r || (r = Array.prototype.slice.call(e, 0, i)),
                r[i] = e[i]);
        return t.concat(r || Array.prototype.slice.call(e))
    }
      , d = function(t) {
        var e = "function" == typeof Symbol && Symbol.iterator
          , n = e && t[e]
          , r = 0;
        if (n)
            return n.call(t);
        if (t && "number" == typeof t.length)
            return {
                next: function() {
                    return t && r >= t.length && (t = void 0),
                    {
                        value: t && t[r++],
                        done: !t
                    }
                }
            };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }
      , f = function() {
        function t() {
            var t = this;
            this.exchangeTimeout = 3e4,
            this.unresponsiveTimeout = 15e3,
            this.deviceModel = null,
            this._events = new (e(i)),
            this.send = function(e, n, r, i, o, u) {
                return void 0 === o && (o = a.alloc(0)),
                void 0 === u && (u = [s.StatusCodes.OK]),
                l(t, void 0, void 0, (function() {
                    var t, l;
                    return c(this, (function(c) {
                        switch (c.label) {
                        case 0:
                            if (o.length >= 256)
                                throw new (0,
                                s.TransportError)("data.length exceed 256 bytes limit. Got: " + o.length,"DataLengthTooBig");
                            return [4, this.exchange(a.concat([a.from([e, n, r, i]), a.from([o.length]), o]))];
                        case 1:
                            if (t = c.sent(),
                            l = t.readUInt16BE(t.length - 2),
                            !u.some((function(t) {
                                return t === l
                            }
                            )))
                                throw new (0,
                                s.TransportStatusError)(l);
                            return [2, t]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            this.exchangeAtomicImpl = function(e) {
                return l(t, void 0, void 0, (function() {
                    var t, n, r, i, o, a = this;
                    return c(this, (function(l) {
                        switch (l.label) {
                        case 0:
                            if (this.exchangeBusyPromise)
                                throw new (0,
                                s.TransportRaceCondition)("An action was already pending on the Ledger device. Please deny or reconnect.");
                            n = new Promise((function(e) {
                                t = e
                            }
                            )),
                            this.exchangeBusyPromise = n,
                            r = !1,
                            i = setTimeout((function() {
                                r = !0,
                                a.emit("unresponsive")
                            }
                            ), this.unresponsiveTimeout),
                            l.label = 1;
                        case 1:
                            return l.trys.push([1, , 3, 4]),
                            [4, e()];
                        case 2:
                            return o = l.sent(),
                            r && this.emit("responsive"),
                            [2, o];
                        case 3:
                            return clearTimeout(i),
                            t && t(),
                            this.exchangeBusyPromise = null,
                            [7];
                        case 4:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            this._appAPIlock = null
        }
        return t.prototype.exchange = function(t) {
            throw new Error("exchange not implemented")
        }
        ,
        t.prototype.setScrambleKey = function(t) {}
        ,
        t.prototype.close = function() {
            return Promise.resolve()
        }
        ,
        t.prototype.on = function(t, e) {
            this._events.on(t, e)
        }
        ,
        t.prototype.off = function(t, e) {
            this._events.removeListener(t, e)
        }
        ,
        t.prototype.emit = function(t) {
            for (var e, n = [], r = 1; r < arguments.length; r++)
                n[r - 1] = arguments[r];
            (e = this._events).emit.apply(e, h([t], u(n), !1))
        }
        ,
        t.prototype.setDebugMode = function() {
            console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.")
        }
        ,
        t.prototype.setExchangeTimeout = function(t) {
            this.exchangeTimeout = t
        }
        ,
        t.prototype.setExchangeUnresponsiveTimeout = function(t) {
            this.unresponsiveTimeout = t
        }
        ,
        t.create = function(t, e) {
            var n = this;
            return void 0 === t && (t = 3e3),
            new Promise((function(r, i) {
                var o = !1
                  , a = n.listen({
                    next: function(e) {
                        o = !0,
                        a && a.unsubscribe(),
                        l && clearTimeout(l),
                        n.open(e.descriptor, t).then(r, i)
                    },
                    error: function(t) {
                        l && clearTimeout(l),
                        i(t)
                    },
                    complete: function() {
                        l && clearTimeout(l),
                        o || i(new (0,
                        s.TransportError)(n.ErrorMessage_NoDeviceFound,"NoDeviceFound"))
                    }
                })
                  , l = e ? setTimeout((function() {
                    a.unsubscribe(),
                    i(new (0,
                    s.TransportError)(n.ErrorMessage_ListenTimeout,"ListenTimeout"))
                }
                ), e) : null
            }
            ))
        }
        ,
        t.prototype.decorateAppAPIMethods = function(t, e, n) {
            var r, i;
            try {
                for (var s = d(e), o = s.next(); !o.done; o = s.next()) {
                    var a = o.value;
                    t[a] = this.decorateAppAPIMethod(a, t[a], t, n)
                }
            } catch (t) {
                r = {
                    error: t
                }
            } finally {
                try {
                    o && !o.done && (i = s.return) && i.call(s)
                } finally {
                    if (r)
                        throw r.error
                }
            }
        }
        ,
        t.prototype.decorateAppAPIMethod = function(t, e, n, r) {
            var i = this;
            return function() {
                for (var o = [], a = 0; a < arguments.length; a++)
                    o[a] = arguments[a];
                return l(i, void 0, void 0, (function() {
                    var i;
                    return c(this, (function(a) {
                        switch (a.label) {
                        case 0:
                            if (i = this._appAPIlock)
                                return [2, Promise.reject(new (0,
                                s.TransportError)("Ledger Device is busy (lock " + i + ")","TransportLocked"))];
                            a.label = 1;
                        case 1:
                            return a.trys.push([1, , 3, 4]),
                            this._appAPIlock = t,
                            this.setScrambleKey(r),
                            [4, e.apply(n, o)];
                        case 2:
                            return [2, a.sent()];
                        case 3:
                            return this._appAPIlock = null,
                            [7];
                        case 4:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
        }
        ,
        t.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)",
        t.ErrorMessage_NoDeviceFound = "No Ledger device found",
        t
    }()
      , p = f
}
)),
o.register("7etJZ", (function(t, e) {
    var n, r = "object" == typeof Reflect ? Reflect : null, i = r && "function" == typeof r.apply ? r.apply : function(t, e, n) {
        return Function.prototype.apply.call(t, e, n)
    }
    ;
    n = r && "function" == typeof r.ownKeys ? r.ownKeys : Object.getOwnPropertySymbols ? function(t) {
        return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
    }
    : function(t) {
        return Object.getOwnPropertyNames(t)
    }
    ;
    var s = Number.isNaN || function(t) {
        return t != t
    }
    ;
    function o() {
        o.init.call(this)
    }
    t.exports = o,
    t.exports.once = function(t, e) {
        return new Promise((function(n, r) {
            function i(n) {
                t.removeListener(e, s),
                r(n)
            }
            function s() {
                "function" == typeof t.removeListener && t.removeListener("error", i),
                n([].slice.call(arguments))
            }
            g(t, e, s, {
                once: !0
            }),
            "error" !== e && function(t, e, n) {
                "function" == typeof t.on && g(t, "error", e, n)
            }(t, i, {
                once: !0
            })
        }
        ))
    }
    ,
    o.EventEmitter = o,
    o.prototype._events = void 0,
    o.prototype._eventsCount = 0,
    o.prototype._maxListeners = void 0;
    var a = 10;
    function l(t) {
        if ("function" != typeof t)
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
    }
    function c(t) {
        return void 0 === t._maxListeners ? o.defaultMaxListeners : t._maxListeners
    }
    function u(t, e, n, r) {
        var i, s, o, a;
        if (l(n),
        void 0 === (s = t._events) ? (s = t._events = Object.create(null),
        t._eventsCount = 0) : (void 0 !== s.newListener && (t.emit("newListener", e, n.listener ? n.listener : n),
        s = t._events),
        o = s[e]),
        void 0 === o)
            o = s[e] = n,
            ++t._eventsCount;
        else if ("function" == typeof o ? o = s[e] = r ? [n, o] : [o, n] : r ? o.unshift(n) : o.push(n),
        (i = c(t)) > 0 && o.length > i && !o.warned) {
            o.warned = !0;
            var u = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            u.name = "MaxListenersExceededWarning",
            u.emitter = t,
            u.type = e,
            u.count = o.length,
            a = u,
            console && console.warn && console.warn(a)
        }
        return t
    }
    function h() {
        if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn),
            this.fired = !0,
            0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }
    function d(t, e, n) {
        var r = {
            fired: !1,
            wrapFn: void 0,
            target: t,
            type: e,
            listener: n
        }
          , i = h.bind(r);
        return i.listener = n,
        r.wrapFn = i,
        i
    }
    function f(t, e, n) {
        var r = t._events;
        if (void 0 === r)
            return [];
        var i = r[e];
        return void 0 === i ? [] : "function" == typeof i ? n ? [i.listener || i] : [i] : n ? function(t) {
            for (var e = new Array(t.length), n = 0; n < e.length; ++n)
                e[n] = t[n].listener || t[n];
            return e
        }(i) : m(i, i.length)
    }
    function p(t) {
        var e = this._events;
        if (void 0 !== e) {
            var n = e[t];
            if ("function" == typeof n)
                return 1;
            if (void 0 !== n)
                return n.length
        }
        return 0
    }
    function m(t, e) {
        for (var n = new Array(e), r = 0; r < e; ++r)
            n[r] = t[r];
        return n
    }
    function g(t, e, n, r) {
        if ("function" == typeof t.on)
            r.once ? t.once(e, n) : t.on(e, n);
        else {
            if ("function" != typeof t.addEventListener)
                throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
            t.addEventListener(e, (function i(s) {
                r.once && t.removeEventListener(e, i),
                n(s)
            }
            ))
        }
    }
    Object.defineProperty(o, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return a
        },
        set: function(t) {
            if ("number" != typeof t || t < 0 || s(t))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
            a = t
        }
    }),
    o.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null),
        this._eventsCount = 0),
        this._maxListeners = this._maxListeners || void 0
    }
    ,
    o.prototype.setMaxListeners = function(t) {
        if ("number" != typeof t || t < 0 || s(t))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
        return this._maxListeners = t,
        this
    }
    ,
    o.prototype.getMaxListeners = function() {
        return c(this)
    }
    ,
    o.prototype.emit = function(t) {
        for (var e = [], n = 1; n < arguments.length; n++)
            e.push(arguments[n]);
        var r = "error" === t
          , s = this._events;
        if (void 0 !== s)
            r = r && void 0 === s.error;
        else if (!r)
            return !1;
        if (r) {
            var o;
            if (e.length > 0 && (o = e[0]),
            o instanceof Error)
                throw o;
            var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
            throw a.context = o,
            a
        }
        var l = s[t];
        if (void 0 === l)
            return !1;
        if ("function" == typeof l)
            i(l, this, e);
        else {
            var c = l.length
              , u = m(l, c);
            for (n = 0; n < c; ++n)
                i(u[n], this, e)
        }
        return !0
    }
    ,
    o.prototype.addListener = function(t, e) {
        return u(this, t, e, !1)
    }
    ,
    o.prototype.on = o.prototype.addListener,
    o.prototype.prependListener = function(t, e) {
        return u(this, t, e, !0)
    }
    ,
    o.prototype.once = function(t, e) {
        return l(e),
        this.on(t, d(this, t, e)),
        this
    }
    ,
    o.prototype.prependOnceListener = function(t, e) {
        return l(e),
        this.prependListener(t, d(this, t, e)),
        this
    }
    ,
    o.prototype.removeListener = function(t, e) {
        var n, r, i, s, o;
        if (l(e),
        void 0 === (r = this._events))
            return this;
        if (void 0 === (n = r[t]))
            return this;
        if (n === e || n.listener === e)
            0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[t],
            r.removeListener && this.emit("removeListener", t, n.listener || e));
        else if ("function" != typeof n) {
            for (i = -1,
            s = n.length - 1; s >= 0; s--)
                if (n[s] === e || n[s].listener === e) {
                    o = n[s].listener,
                    i = s;
                    break
                }
            if (i < 0)
                return this;
            0 === i ? n.shift() : function(t, e) {
                for (; e + 1 < t.length; e++)
                    t[e] = t[e + 1];
                t.pop()
            }(n, i),
            1 === n.length && (r[t] = n[0]),
            void 0 !== r.removeListener && this.emit("removeListener", t, o || e)
        }
        return this
    }
    ,
    o.prototype.off = o.prototype.removeListener,
    o.prototype.removeAllListeners = function(t) {
        var e, n, r;
        if (void 0 === (n = this._events))
            return this;
        if (void 0 === n.removeListener)
            return 0 === arguments.length ? (this._events = Object.create(null),
            this._eventsCount = 0) : void 0 !== n[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[t]),
            this;
        if (0 === arguments.length) {
            var i, s = Object.keys(n);
            for (r = 0; r < s.length; ++r)
                "removeListener" !== (i = s[r]) && this.removeAllListeners(i);
            return this.removeAllListeners("removeListener"),
            this._events = Object.create(null),
            this._eventsCount = 0,
            this
        }
        if ("function" == typeof (e = n[t]))
            this.removeListener(t, e);
        else if (void 0 !== e)
            for (r = e.length - 1; r >= 0; r--)
                this.removeListener(t, e[r]);
        return this
    }
    ,
    o.prototype.listeners = function(t) {
        return f(this, t, !0)
    }
    ,
    o.prototype.rawListeners = function(t) {
        return f(this, t, !1)
    }
    ,
    o.listenerCount = function(t, e) {
        return "function" == typeof t.listenerCount ? t.listenerCount(e) : p.call(t, e)
    }
    ,
    o.prototype.listenerCount = p,
    o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? n(this._events) : []
    }
}
)),
o.register("degpm", (function(e, n) {
    t(e.exports, "DisconnectedDevice", (()=>u), (t=>u = t)),
    t(e.exports, "DisconnectedDeviceDuringOperation", (()=>h), (t=>h = t)),
    t(e.exports, "TransportOpenUserCancelled", (()=>d), (t=>d = t)),
    t(e.exports, "TransportRaceCondition", (()=>f), (t=>f = t)),
    t(e.exports, "TransportError", (()=>p), (t=>p = t)),
    t(e.exports, "StatusCodes", (()=>m), (t=>m = t)),
    t(e.exports, "TransportStatusError", (()=>g), (t=>g = t));
    var r, i, s, a = o("6Sb0P"), l = (r = function(t, e) {
        return r = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(t, e) {
            t.__proto__ = e
        }
        || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }
        ,
        r(t, e)
    }
    ,
    function(t, e) {
        if ("function" != typeof e && null !== e)
            throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
        function n() {
            this.constructor = t
        }
        r(t, e),
        t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
        new n)
    }
    ), c = ((0,
    a.createCustomErrorClass)("AccountNameRequired"),
    (0,
    a.createCustomErrorClass)("AccountNotSupported"),
    (0,
    a.createCustomErrorClass)("AmountRequired"),
    (0,
    a.createCustomErrorClass)("BluetoothRequired"),
    (0,
    a.createCustomErrorClass)("BtcUnmatchedApp"),
    (0,
    a.createCustomErrorClass)("CantOpenDevice"),
    (0,
    a.createCustomErrorClass)("CashAddrNotSupported"),
    (0,
    a.createCustomErrorClass)("CurrencyNotSupported"),
    (0,
    a.createCustomErrorClass)("DeviceAppVerifyNotSupported"),
    (0,
    a.createCustomErrorClass)("DeviceGenuineSocketEarlyClose"),
    (0,
    a.createCustomErrorClass)("DeviceNotGenuine"),
    (0,
    a.createCustomErrorClass)("DeviceOnDashboardExpected"),
    (0,
    a.createCustomErrorClass)("DeviceOnDashboardUnexpected"),
    (0,
    a.createCustomErrorClass)("DeviceInOSUExpected"),
    (0,
    a.createCustomErrorClass)("DeviceHalted"),
    (0,
    a.createCustomErrorClass)("DeviceNameInvalid"),
    (0,
    a.createCustomErrorClass)("DeviceSocketFail"),
    (0,
    a.createCustomErrorClass)("DeviceSocketNoBulkStatus"),
    (0,
    a.createCustomErrorClass)("LockedDeviceError")), u = (0,
    a.createCustomErrorClass)("DisconnectedDevice"), h = (0,
    a.createCustomErrorClass)("DisconnectedDeviceDuringOperation"), d = ((0,
    a.createCustomErrorClass)("DeviceExtractOnboardingStateError"),
    (0,
    a.createCustomErrorClass)("DeviceOnboardingStatePollingError"),
    (0,
    a.createCustomErrorClass)("EnpointConfig"),
    (0,
    a.createCustomErrorClass)("EthAppPleaseEnableContractData"),
    (0,
    a.createCustomErrorClass)("FeeEstimationFailed"),
    (0,
    a.createCustomErrorClass)("FirmwareNotRecognized"),
    (0,
    a.createCustomErrorClass)("HardResetFail"),
    (0,
    a.createCustomErrorClass)("InvalidXRPTag"),
    (0,
    a.createCustomErrorClass)("InvalidAddress"),
    (0,
    a.createCustomErrorClass)("InvalidAddressBecauseDestinationIsAlsoSource"),
    (0,
    a.createCustomErrorClass)("LatestMCUInstalledError"),
    (0,
    a.createCustomErrorClass)("UnknownMCU"),
    (0,
    a.createCustomErrorClass)("LedgerAPIError"),
    (0,
    a.createCustomErrorClass)("LedgerAPIErrorWithMessage"),
    (0,
    a.createCustomErrorClass)("LedgerAPINotAvailable"),
    (0,
    a.createCustomErrorClass)("ManagerAppAlreadyInstalled"),
    (0,
    a.createCustomErrorClass)("ManagerAppRelyOnBTC"),
    (0,
    a.createCustomErrorClass)("ManagerAppDepInstallRequired"),
    (0,
    a.createCustomErrorClass)("ManagerAppDepUninstallRequired"),
    (0,
    a.createCustomErrorClass)("ManagerDeviceLocked"),
    (0,
    a.createCustomErrorClass)("ManagerFirmwareNotEnoughSpace"),
    (0,
    a.createCustomErrorClass)("ManagerNotEnoughSpace"),
    (0,
    a.createCustomErrorClass)("ManagerUninstallBTCDep"),
    (0,
    a.createCustomErrorClass)("NetworkDown"),
    (0,
    a.createCustomErrorClass)("NoAddressesFound"),
    (0,
    a.createCustomErrorClass)("NotEnoughBalance"),
    (0,
    a.createCustomErrorClass)("NotEnoughBalanceToDelegate"),
    (0,
    a.createCustomErrorClass)("NotEnoughBalanceInParentAccount"),
    (0,
    a.createCustomErrorClass)("NotEnoughSpendableBalance"),
    (0,
    a.createCustomErrorClass)("NotEnoughBalanceBecauseDestinationNotCreated"),
    (0,
    a.createCustomErrorClass)("NoAccessToCamera"),
    (0,
    a.createCustomErrorClass)("NotEnoughGas"),
    (0,
    a.createCustomErrorClass)("NotSupportedLegacyAddress"),
    (0,
    a.createCustomErrorClass)("GasLessThanEstimate"),
    (0,
    a.createCustomErrorClass)("PriorityFeeTooLow"),
    (0,
    a.createCustomErrorClass)("PriorityFeeTooHigh"),
    (0,
    a.createCustomErrorClass)("PriorityFeeHigherThanMaxFee"),
    (0,
    a.createCustomErrorClass)("MaxFeeTooLow"),
    (0,
    a.createCustomErrorClass)("PasswordsDontMatch"),
    (0,
    a.createCustomErrorClass)("PasswordIncorrect"),
    (0,
    a.createCustomErrorClass)("RecommendSubAccountsToEmpty"),
    (0,
    a.createCustomErrorClass)("RecommendUndelegation"),
    (0,
    a.createCustomErrorClass)("TimeoutTagged"),
    (0,
    a.createCustomErrorClass)("UnexpectedBootloader"),
    (0,
    a.createCustomErrorClass)("MCUNotGenuineToDashboard"),
    (0,
    a.createCustomErrorClass)("RecipientRequired"),
    (0,
    a.createCustomErrorClass)("UnavailableTezosOriginatedAccountReceive"),
    (0,
    a.createCustomErrorClass)("UnavailableTezosOriginatedAccountSend"),
    (0,
    a.createCustomErrorClass)("UpdateFetchFileFail"),
    (0,
    a.createCustomErrorClass)("UpdateIncorrectHash"),
    (0,
    a.createCustomErrorClass)("UpdateIncorrectSig"),
    (0,
    a.createCustomErrorClass)("UpdateYourApp"),
    (0,
    a.createCustomErrorClass)("UserRefusedDeviceNameChange"),
    (0,
    a.createCustomErrorClass)("UserRefusedAddress"),
    (0,
    a.createCustomErrorClass)("UserRefusedFirmwareUpdate"),
    (0,
    a.createCustomErrorClass)("UserRefusedAllowManager"),
    (0,
    a.createCustomErrorClass)("UserRefusedOnDevice"),
    (0,
    a.createCustomErrorClass)("TransportOpenUserCancelled")), f = ((0,
    a.createCustomErrorClass)("TransportInterfaceNotAvailable"),
    (0,
    a.createCustomErrorClass)("TransportRaceCondition"));
    (0,
    a.createCustomErrorClass)("TransportWebUSBGestureRequired"),
    (0,
    a.createCustomErrorClass)("DeviceShouldStayInApp"),
    (0,
    a.createCustomErrorClass)("WebsocketConnectionError"),
    (0,
    a.createCustomErrorClass)("WebsocketConnectionFailed"),
    (0,
    a.createCustomErrorClass)("WrongDeviceForAccount"),
    (0,
    a.createCustomErrorClass)("WrongAppForCurrency"),
    (0,
    a.createCustomErrorClass)("ETHAddressNonEIP"),
    (0,
    a.createCustomErrorClass)("CantScanQRCode"),
    (0,
    a.createCustomErrorClass)("FeeNotLoaded"),
    (0,
    a.createCustomErrorClass)("FeeRequired"),
    (0,
    a.createCustomErrorClass)("FeeTooHigh"),
    (0,
    a.createCustomErrorClass)("DustLimit"),
    (0,
    a.createCustomErrorClass)("PendingOperation"),
    (0,
    a.createCustomErrorClass)("SyncError"),
    (0,
    a.createCustomErrorClass)("PairingFailed"),
    (0,
    a.createCustomErrorClass)("GenuineCheckFailed"),
    (0,
    a.createCustomErrorClass)("LedgerAPI4xx"),
    (0,
    a.createCustomErrorClass)("LedgerAPI5xx"),
    (0,
    a.createCustomErrorClass)("FirmwareOrAppUpdateRequired"),
    (0,
    a.createCustomErrorClass)("LanguageNotFound"),
    (0,
    a.createCustomErrorClass)("NoDBPathGiven"),
    (0,
    a.createCustomErrorClass)("DBWrongPassword"),
    (0,
    a.createCustomErrorClass)("DBNotReset");
    (s = i || (i = {}))[s.Unknown = 0] = "Unknown",
    s[s.BleLocationServicesDisabled = 1] = "BleLocationServicesDisabled",
    s[s.BleBluetoothUnauthorized = 2] = "BleBluetoothUnauthorized",
    s[s.BleScanStartFailed = 3] = "BleScanStartFailed";
    !function(t) {
        function e(n, r) {
            var i = t.call(this, r) || this;
            return i.name = "HwTransportError",
            i.type = n,
            Object.setPrototypeOf(i, e.prototype),
            i
        }
        l(e, t)
    }(Error);
    var p = function(t) {
        function e(e, n) {
            var r = this
              , i = "TransportError";
            return (r = t.call(this, e || i) || this).name = i,
            r.message = e,
            r.stack = (new Error).stack,
            r.id = n,
            r
        }
        return l(e, t),
        e
    }(Error);
    (0,
    a.addCustomErrorDeserializer)("TransportError", (function(t) {
        return new p(t.message,t.id)
    }
    ));
    var m = {
        ACCESS_CONDITION_NOT_FULFILLED: 38916,
        ALGORITHM_NOT_SUPPORTED: 38020,
        CLA_NOT_SUPPORTED: 28160,
        CODE_BLOCKED: 38976,
        CODE_NOT_INITIALIZED: 38914,
        COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
        CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
        CONTRADICTION_INVALIDATION: 38928,
        CONTRADICTION_SECRET_CODE_STATUS: 38920,
        CUSTOM_IMAGE_BOOTLOADER: 26159,
        CUSTOM_IMAGE_EMPTY: 26158,
        FILE_ALREADY_EXISTS: 27273,
        FILE_NOT_FOUND: 37892,
        GP_AUTH_FAILED: 25344,
        HALTED: 28586,
        INCONSISTENT_FILE: 37896,
        INCORRECT_DATA: 27264,
        INCORRECT_LENGTH: 26368,
        INCORRECT_P1_P2: 27392,
        INS_NOT_SUPPORTED: 27904,
        INVALID_KCV: 38021,
        INVALID_OFFSET: 37890,
        LICENSING: 28482,
        LOCKED_DEVICE: 21781,
        MAX_VALUE_REACHED: 38992,
        MEMORY_PROBLEM: 37440,
        MISSING_CRITICAL_PARAMETER: 26624,
        NO_EF_SELECTED: 37888,
        NOT_ENOUGH_MEMORY_SPACE: 27268,
        OK: 36864,
        PIN_REMAINING_ATTEMPTS: 25536,
        REFERENCED_DATA_NOT_FOUND: 27272,
        SECURITY_STATUS_NOT_SATISFIED: 27010,
        TECHNICAL_PROBLEM: 28416,
        UNKNOWN_APDU: 27906,
        USER_REFUSED_ON_DEVICE: 21761
    };
    function g(t) {
        var e = Object.keys(m).find((function(e) {
            return m[e] === t
        }
        )) || "UNKNOWN_ERROR"
          , n = function(t) {
            switch (t) {
            case 26368:
                return "Incorrect length";
            case 26624:
                return "Missing critical parameter";
            case 27010:
                return "Security not satisfied (dongle locked or have invalid access rights)";
            case 27013:
                return "Condition of use not satisfied (denied by the user?)";
            case 27264:
                return "Invalid data received";
            case 27392:
                return "Invalid parameter received";
            case 21781:
                return "Locked device"
            }
            if (28416 <= t && t <= 28671)
                return "Internal error, please report"
        }(t) || e
          , r = t.toString(16)
          , i = "Ledger device: ".concat(n, " (0x").concat(r, ")");
        if (t === m.LOCKED_DEVICE)
            throw new c(i);
        this.name = "TransportStatusError",
        this.message = i,
        this.stack = (new Error).stack,
        this.statusCode = t,
        this.statusText = e
    }
    g.prototype = new Error,
    (0,
    a.addCustomErrorDeserializer)("TransportStatusError", (function(t) {
        return new g(t.statusCode)
    }
    ))
}
)),
o.register("6Sb0P", (function(e, n) {
    t(e.exports, "addCustomErrorDeserializer", (()=>a), (t=>a = t)),
    t(e.exports, "createCustomErrorClass", (()=>l), (t=>l = t));
    var r, i = (r = function(t, e) {
        return r = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(t, e) {
            t.__proto__ = e
        }
        || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }
        ,
        r(t, e)
    }
    ,
    function(t, e) {
        if ("function" != typeof e && null !== e)
            throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
        function n() {
            this.constructor = t
        }
        r(t, e),
        t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
        new n)
    }
    ), s = {}, o = {}, a = function(t, e) {
        o[t] = e
    }, l = function(t) {
        var e = function(e) {
            function n(r, i, s) {
                var o = e.call(this, r || t, s) || this;
                if (Object.setPrototypeOf(o, n.prototype),
                o.name = t,
                i)
                    for (var a in i)
                        o[a] = i[a];
                if (s && "object" == typeof s && "cause"in s && !("cause"in o)) {
                    var l = s.cause;
                    o.cause = l,
                    "stack"in l && (o.stack = o.stack + "\nCAUSE: " + l.stack)
                }
                return o
            }
            return i(n, e),
            n
        }(Error);
        return s[t] = e,
        e
    }
}
)),
o.register("3scHN", (function(t, e) {
    t.exports = import("./" + o("27Lyk").resolve("bSJWN")).then((()=>o("fUHqW")))
}
)),
o.register("lWt5S", (function(t, e) {
    t.exports = import("./" + o("27Lyk").resolve("2Wmvo")).then((()=>o("8VMga")))
}
)),
o.register("2fzOa", (function(t, e) {
    t.exports = import("./" + o("27Lyk").resolve("avSDn")).then((()=>o("88wHM")))
}
)),
o.register("b8sjQ", (function(t, e) {
    !function(n, r) {
        var i = "function"
          , s = "undefined"
          , o = "object"
          , a = "string"
          , l = "major"
          , c = "model"
          , u = "name"
          , h = "type"
          , d = "vendor"
          , f = "version"
          , p = "architecture"
          , m = "console"
          , g = "mobile"
          , y = "tablet"
          , b = "smarttv"
          , v = "wearable"
          , w = "embedded"
          , x = "Amazon"
          , E = "Apple"
          , _ = "ASUS"
          , A = "BlackBerry"
          , S = "Browser"
          , T = "Chrome"
          , k = "Firefox"
          , I = "Google"
          , M = "Huawei"
          , C = "LG"
          , P = "Microsoft"
          , O = "Motorola"
          , N = "Opera"
          , R = "Samsung"
          , D = "Sharp"
          , B = "Sony"
          , L = "Xiaomi"
          , F = "Zebra"
          , j = "Facebook"
          , U = "Chromium OS"
          , z = "Mac OS"
          , V = function(t) {
            for (var e = {}, n = 0; n < t.length; n++)
                e[t[n].toUpperCase()] = t[n];
            return e
        }
          , W = function(t, e) {
            return typeof t === a && -1 !== Y(e).indexOf(Y(t))
        }
          , Y = function(t) {
            return t.toLowerCase()
        }
          , H = function(t, e) {
            if (typeof t === a)
                return t = t.replace(/^\s\s*/, ""),
                typeof e === s ? t : t.substring(0, 350)
        }
          , $ = function(t, e) {
            for (var n, s, a, l, c, u, h = 0; h < e.length && !c; ) {
                var d = e[h]
                  , f = e[h + 1];
                for (n = s = 0; n < d.length && !c && d[n]; )
                    if (c = d[n++].exec(t))
                        for (a = 0; a < f.length; a++)
                            u = c[++s],
                            typeof (l = f[a]) === o && l.length > 0 ? 2 === l.length ? typeof l[1] == i ? this[l[0]] = l[1].call(this, u) : this[l[0]] = l[1] : 3 === l.length ? typeof l[1] !== i || l[1].exec && l[1].test ? this[l[0]] = u ? u.replace(l[1], l[2]) : r : this[l[0]] = u ? l[1].call(this, u, l[2]) : r : 4 === l.length && (this[l[0]] = u ? l[3].call(this, u.replace(l[1], l[2])) : r) : this[l] = u || r;
                h += 2
            }
        }
          , G = function(t, e) {
            for (var n in e)
                if (typeof e[n] === o && e[n].length > 0) {
                    for (var i = 0; i < e[n].length; i++)
                        if (W(e[n][i], t))
                            return "?" === n ? r : n
                } else if (W(e[n], t))
                    return "?" === n ? r : n;
            return t
        }
          , X = {
            ME: "4.90",
            "NT 3.11": "NT3.51",
            "NT 4.0": "NT4.0",
            2e3: "NT 5.0",
            XP: ["NT 5.1", "NT 5.2"],
            Vista: "NT 6.0",
            7: "NT 6.1",
            8: "NT 6.2",
            8.1: "NT 6.3",
            10: ["NT 6.4", "NT 10.0"],
            RT: "ARM"
        }
          , q = {
            browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [f, [u, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [f, [u, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [u, f], [/opios[\/ ]+([\w\.]+)/i], [f, [u, N + " Mini"]], [/\bopr\/([\w\.]+)/i], [f, [u, N]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [u, f], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [f, [u, "UC" + S]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [f, [u, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [f, [u, "WeChat"]], [/konqueror\/([\w\.]+)/i], [f, [u, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [f, [u, "IE"]], [/yabrowser\/([\w\.]+)/i], [f, [u, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[u, /(.+)/, "$1 Secure " + S], f], [/\bfocus\/([\w\.]+)/i], [f, [u, k + " Focus"]], [/\bopt\/([\w\.]+)/i], [f, [u, N + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [f, [u, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [f, [u, "Dolphin"]], [/coast\/([\w\.]+)/i], [f, [u, N + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [f, [u, "MIUI " + S]], [/fxios\/([-\w\.]+)/i], [f, [u, k]], [/\bqihu|(qi?ho?o?|360)browser/i], [[u, "360 " + S]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[u, /(.+)/, "$1 " + S], f], [/(comodo_dragon)\/([\w\.]+)/i], [[u, /_/g, " "], f], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [u, f], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [u], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[u, j], f], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [u, f], [/\bgsa\/([\w\.]+) .*safari\//i], [f, [u, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [f, [u, T + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[u, T + " WebView"], f], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [f, [u, "Android " + S]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [u, f], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [f, [u, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [f, u], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [u, [f, G, {
                "1.0": "/8",
                1.2: "/1",
                1.3: "/3",
                "2.0": "/412",
                "2.0.2": "/416",
                "2.0.3": "/417",
                "2.0.4": "/419",
                "?": "/"
            }]], [/(webkit|khtml)\/([\w\.]+)/i], [u, f], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[u, "Netscape"], f], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [f, [u, k + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [u, f], [/(cobalt)\/([\w\.]+)/i], [u, [f, /master.|lts./, ""]]],
            cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[p, "amd64"]], [/(ia32(?=;))/i], [[p, Y]], [/((?:i[346]|x)86)[;\)]/i], [[p, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[p, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[p, "armhf"]], [/windows (ce|mobile); ppc;/i], [[p, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[p, /ower/, "", Y]], [/(sun4\w)[;\)]/i], [[p, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[p, Y]]],
            device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [c, [d, R], [h, y]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [c, [d, R], [h, g]], [/\((ip(?:hone|od)[\w ]*);/i], [c, [d, E], [h, g]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [c, [d, E], [h, y]], [/(macintosh);/i], [c, [d, E]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [c, [d, D], [h, g]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [c, [d, M], [h, y]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [c, [d, M], [h, g]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[c, /_/g, " "], [d, L], [h, g]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[c, /_/g, " "], [d, L], [h, y]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [c, [d, "OPPO"], [h, g]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [c, [d, "Vivo"], [h, g]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [c, [d, "Realme"], [h, g]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [c, [d, O], [h, g]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [c, [d, O], [h, y]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [c, [d, C], [h, y]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [c, [d, C], [h, g]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [c, [d, "Lenovo"], [h, y]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[c, /_/g, " "], [d, "Nokia"], [h, g]], [/(pixel c)\b/i], [c, [d, I], [h, y]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [c, [d, I], [h, g]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [c, [d, B], [h, g]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[c, "Xperia Tablet"], [d, B], [h, y]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [c, [d, "OnePlus"], [h, g]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [c, [d, x], [h, y]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[c, /(.+)/g, "Fire Phone $1"], [d, x], [h, g]], [/(playbook);[-\w\),; ]+(rim)/i], [c, d, [h, y]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [c, [d, A], [h, g]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [c, [d, _], [h, y]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [c, [d, _], [h, g]], [/(nexus 9)/i], [c, [d, "HTC"], [h, y]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [d, [c, /_/g, " "], [h, g]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [c, [d, "Acer"], [h, y]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [c, [d, "Meizu"], [h, g]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [d, c, [h, g]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [d, c, [h, y]], [/(surface duo)/i], [c, [d, P], [h, y]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [c, [d, "Fairphone"], [h, g]], [/(u304aa)/i], [c, [d, "AT&T"], [h, g]], [/\bsie-(\w*)/i], [c, [d, "Siemens"], [h, g]], [/\b(rct\w+) b/i], [c, [d, "RCA"], [h, y]], [/\b(venue[\d ]{2,7}) b/i], [c, [d, "Dell"], [h, y]], [/\b(q(?:mv|ta)\w+) b/i], [c, [d, "Verizon"], [h, y]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [c, [d, "Barnes & Noble"], [h, y]], [/\b(tm\d{3}\w+) b/i], [c, [d, "NuVision"], [h, y]], [/\b(k88) b/i], [c, [d, "ZTE"], [h, y]], [/\b(nx\d{3}j) b/i], [c, [d, "ZTE"], [h, g]], [/\b(gen\d{3}) b.+49h/i], [c, [d, "Swiss"], [h, g]], [/\b(zur\d{3}) b/i], [c, [d, "Swiss"], [h, y]], [/\b((zeki)?tb.*\b) b/i], [c, [d, "Zeki"], [h, y]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[d, "Dragon Touch"], c, [h, y]], [/\b(ns-?\w{0,9}) b/i], [c, [d, "Insignia"], [h, y]], [/\b((nxa|next)-?\w{0,9}) b/i], [c, [d, "NextBook"], [h, y]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[d, "Voice"], c, [h, g]], [/\b(lvtel\-)?(v1[12]) b/i], [[d, "LvTel"], c, [h, g]], [/\b(ph-1) /i], [c, [d, "Essential"], [h, g]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [c, [d, "Envizen"], [h, y]], [/\b(trio[-\w\. ]+) b/i], [c, [d, "MachSpeed"], [h, y]], [/\btu_(1491) b/i], [c, [d, "Rotor"], [h, y]], [/(shield[\w ]+) b/i], [c, [d, "Nvidia"], [h, y]], [/(sprint) (\w+)/i], [d, c, [h, g]], [/(kin\.[onetw]{3})/i], [[c, /\./g, " "], [d, P], [h, g]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [c, [d, F], [h, y]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [c, [d, F], [h, g]], [/smart-tv.+(samsung)/i], [d, [h, b]], [/hbbtv.+maple;(\d+)/i], [[c, /^/, "SmartTV"], [d, R], [h, b]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[d, C], [h, b]], [/(apple) ?tv/i], [d, [c, E + " TV"], [h, b]], [/crkey/i], [[c, T + "cast"], [d, I], [h, b]], [/droid.+aft(\w)( bui|\))/i], [c, [d, x], [h, b]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [c, [d, D], [h, b]], [/(bravia[\w ]+)( bui|\))/i], [c, [d, B], [h, b]], [/(mitv-\w{5}) bui/i], [c, [d, L], [h, b]], [/Hbbtv.*(technisat) (.*);/i], [d, c, [h, b]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[d, H], [c, H], [h, b]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[h, b]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [d, c, [h, m]], [/droid.+; (shield) bui/i], [c, [d, "Nvidia"], [h, m]], [/(playstation [345portablevi]+)/i], [c, [d, B], [h, m]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [c, [d, P], [h, m]], [/((pebble))app/i], [d, c, [h, v]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [c, [d, E], [h, v]], [/droid.+; (glass) \d/i], [c, [d, I], [h, v]], [/droid.+; (wt63?0{2,3})\)/i], [c, [d, F], [h, v]], [/(quest( 2| pro)?)/i], [c, [d, j], [h, v]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [d, [h, w]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [c, [h, g]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [c, [h, y]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[h, y]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[h, g]], [/(android[-\w\. ]{0,9});.+buil/i], [c, [d, "Generic"]]],
            engine: [[/windows.+ edge\/([\w\.]+)/i], [f, [u, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [f, [u, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [u, f], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [f, u]],
            os: [[/microsoft (windows) (vista|xp)/i], [u, f], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [u, [f, G, X]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[u, "Windows"], [f, G, X]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[f, /_/g, "."], [u, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[u, z], [f, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [f, u], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [u, f], [/\(bb(10);/i], [f, [u, A]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [f, [u, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [f, [u, k + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [f, [u, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [f, [u, "watchOS"]], [/crkey\/([\d\.]+)/i], [f, [u, T + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[u, U], f], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [u, f], [/(sunos) ?([\w\.\d]*)/i], [[u, "Solaris"], f], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [u, f]]
        }
          , K = function(t, e) {
            if (typeof t === o && (e = t,
            t = r),
            !(this instanceof K))
                return new K(t,e).getResult();
            var m = typeof n !== s && n.navigator ? n.navigator : r
              , b = t || (m && m.userAgent ? m.userAgent : "")
              , v = m && m.userAgentData ? m.userAgentData : r
              , w = e ? function(t, e) {
                var n = {};
                for (var r in t)
                    e[r] && e[r].length % 2 == 0 ? n[r] = e[r].concat(t[r]) : n[r] = t[r];
                return n
            }(q, e) : q;
            return this.getBrowser = function() {
                var t, e = {};
                return e[u] = r,
                e[f] = r,
                $.call(e, b, w.browser),
                e[l] = typeof (t = e[f]) === a ? t.replace(/[^\d\.]/g, "").split(".")[0] : r,
                m && m.brave && typeof m.brave.isBrave == i && (e[u] = "Brave"),
                e
            }
            ,
            this.getCPU = function() {
                var t = {};
                return t[p] = r,
                $.call(t, b, w.cpu),
                t
            }
            ,
            this.getDevice = function() {
                var t = {};
                return t[d] = r,
                t[c] = r,
                t[h] = r,
                $.call(t, b, w.device),
                !t[h] && v && v.mobile && (t[h] = g),
                "Macintosh" == t[c] && m && typeof m.standalone !== s && m.maxTouchPoints && m.maxTouchPoints > 2 && (t[c] = "iPad",
                t[h] = y),
                t
            }
            ,
            this.getEngine = function() {
                var t = {};
                return t[u] = r,
                t[f] = r,
                $.call(t, b, w.engine),
                t
            }
            ,
            this.getOS = function() {
                var t = {};
                return t[u] = r,
                t[f] = r,
                $.call(t, b, w.os),
                !t[u] && v && "Unknown" != v.platform && (t[u] = v.platform.replace(/chrome os/i, U).replace(/macos/i, z)),
                t
            }
            ,
            this.getResult = function() {
                return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU()
                }
            }
            ,
            this.getUA = function() {
                return b
            }
            ,
            this.setUA = function(t) {
                return b = typeof t === a && t.length > 350 ? H(t, 350) : t,
                this
            }
            ,
            this.setUA(b),
            this
        };
        K.VERSION = "1.0.34",
        K.BROWSER = V([u, f, l]),
        K.CPU = V([p]),
        K.DEVICE = V([c, d, h, m, g, b, y, v, w]),
        K.ENGINE = K.OS = V([u, f]),
        t.exports && (e = t.exports = K),
        e.UAParser = K;
        var Q = typeof n !== s && (n.jQuery || n.Zepto);
        if (Q && !Q.ua) {
            var Z = new K;
            Q.ua = Z.getResult(),
            Q.ua.get = function() {
                return Z.getUA()
            }
            ,
            Q.ua.set = function(t) {
                Z.setUA(t);
                var e = Z.getResult();
                for (var n in e)
                    Q.ua[n] = e[n]
            }
        }
    }("object" == typeof window ? window : this)
}
)),
o.register("dBHwk", (function(t, e) {
    !function(r) {
        var i = e && !e.nodeType && e
          , s = t && !t.nodeType && t
          , o = "object" == typeof n && n;
        o.global !== o && o.window !== o && o.self !== o || (r = o);
        var a, l, c = 2147483647, u = 36, h = 1, d = 26, f = 38, p = 700, m = 72, g = 128, y = "-", b = /^xn--/, v = /[^\x20-\x7E]/, w = /[\x2E\u3002\uFF0E\uFF61]/g, x = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, E = u - h, _ = Math.floor, A = String.fromCharCode;
        function S(t) {
            throw new RangeError(x[t])
        }
        function T(t, e) {
            for (var n = t.length, r = []; n--; )
                r[n] = e(t[n]);
            return r
        }
        function k(t, e) {
            var n = t.split("@")
              , r = "";
            return n.length > 1 && (r = n[0] + "@",
            t = n[1]),
            r + T((t = t.replace(w, ".")).split("."), e).join(".")
        }
        function I(t) {
            for (var e, n, r = [], i = 0, s = t.length; i < s; )
                (e = t.charCodeAt(i++)) >= 55296 && e <= 56319 && i < s ? 56320 == (64512 & (n = t.charCodeAt(i++))) ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e),
                i--) : r.push(e);
            return r
        }
        function M(t) {
            return T(t, (function(t) {
                var e = "";
                return t > 65535 && (e += A((t -= 65536) >>> 10 & 1023 | 55296),
                t = 56320 | 1023 & t),
                e += A(t)
            }
            )).join("")
        }
        function C(t, e) {
            return t + 22 + 75 * (t < 26) - ((0 != e) << 5)
        }
        function P(t, e, n) {
            var r = 0;
            for (t = n ? _(t / p) : t >> 1,
            t += _(t / e); t > E * d >> 1; r += u)
                t = _(t / E);
            return _(r + (E + 1) * t / (t + f))
        }
        function O(t) {
            var e, n, r, i, s, o, a, l, f, p, b, v = [], w = t.length, x = 0, E = g, A = m;
            for ((n = t.lastIndexOf(y)) < 0 && (n = 0),
            r = 0; r < n; ++r)
                t.charCodeAt(r) >= 128 && S("not-basic"),
                v.push(t.charCodeAt(r));
            for (i = n > 0 ? n + 1 : 0; i < w; ) {
                for (s = x,
                o = 1,
                a = u; i >= w && S("invalid-input"),
                ((l = (b = t.charCodeAt(i++)) - 48 < 10 ? b - 22 : b - 65 < 26 ? b - 65 : b - 97 < 26 ? b - 97 : u) >= u || l > _((c - x) / o)) && S("overflow"),
                x += l * o,
                !(l < (f = a <= A ? h : a >= A + d ? d : a - A)); a += u)
                    o > _(c / (p = u - f)) && S("overflow"),
                    o *= p;
                A = P(x - s, e = v.length + 1, 0 == s),
                _(x / e) > c - E && S("overflow"),
                E += _(x / e),
                x %= e,
                v.splice(x++, 0, E)
            }
            return M(v)
        }
        function N(t) {
            var e, n, r, i, s, o, a, l, f, p, b, v, w, x, E, T = [];
            for (v = (t = I(t)).length,
            e = g,
            n = 0,
            s = m,
            o = 0; o < v; ++o)
                (b = t[o]) < 128 && T.push(A(b));
            for (r = i = T.length,
            i && T.push(y); r < v; ) {
                for (a = c,
                o = 0; o < v; ++o)
                    (b = t[o]) >= e && b < a && (a = b);
                for (a - e > _((c - n) / (w = r + 1)) && S("overflow"),
                n += (a - e) * w,
                e = a,
                o = 0; o < v; ++o)
                    if ((b = t[o]) < e && ++n > c && S("overflow"),
                    b == e) {
                        for (l = n,
                        f = u; !(l < (p = f <= s ? h : f >= s + d ? d : f - s)); f += u)
                            E = l - p,
                            x = u - p,
                            T.push(A(C(p + E % x, 0))),
                            l = _(E / x);
                        T.push(A(C(l, 0))),
                        s = P(n, w, r == i),
                        n = 0,
                        ++r
                    }
                ++n,
                ++e
            }
            return T.join("")
        }
        if (a = {
            version: "1.4.1",
            ucs2: {
                decode: I,
                encode: M
            },
            decode: O,
            encode: N,
            toASCII: function(t) {
                return k(t, (function(t) {
                    return v.test(t) ? "xn--" + N(t) : t
                }
                ))
            },
            toUnicode: function(t) {
                return k(t, (function(t) {
                    return b.test(t) ? O(t.slice(4).toLowerCase()) : t
                }
                ))
            }
        },
        "function" == typeof define && "object" == typeof define.amd && define.amd)
            define("punycode", (function() {
                return a
            }
            ));
        else if (i && s)
            if (t.exports == i)
                s.exports = a;
            else
                for (l in a)
                    a.hasOwnProperty(l) && (i[l] = a[l]);
        else
            r.punycode = a
    }(this)
}
)),
o.register("kzGqM", (function(t, e) {
    function n(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    t.exports = function(t, e, i, s) {
        e = e || "&",
        i = i || "=";
        var o = {};
        if ("string" != typeof t || 0 === t.length)
            return o;
        var a = /\+/g;
        t = t.split(e);
        var l = 1e3;
        s && "number" == typeof s.maxKeys && (l = s.maxKeys);
        var c = t.length;
        l > 0 && c > l && (c = l);
        for (var u = 0; u < c; ++u) {
            var h, d, f, p, m = t[u].replace(a, "%20"), g = m.indexOf(i);
            g >= 0 ? (h = m.substr(0, g),
            d = m.substr(g + 1)) : (h = m,
            d = ""),
            f = decodeURIComponent(h),
            p = decodeURIComponent(d),
            n(o, f) ? r(o[f]) ? o[f].push(p) : o[f] = [o[f], p] : o[f] = p
        }
        return o
    }
    ;
    var r = Array.isArray || function(t) {
        return "[object Array]" === Object.prototype.toString.call(t)
    }
}
)),
o.register("kWD7b", (function(t, e) {
    var n = function(t) {
        switch (typeof t) {
        case "string":
            return t;
        case "boolean":
            return t ? "true" : "false";
        case "number":
            return isFinite(t) ? t : "";
        default:
            return ""
        }
    };
    t.exports = function(t, e, o, a) {
        return e = e || "&",
        o = o || "=",
        null === t && (t = void 0),
        "object" == typeof t ? i(s(t), (function(s) {
            var a = encodeURIComponent(n(s)) + o;
            return r(t[s]) ? i(t[s], (function(t) {
                return a + encodeURIComponent(n(t))
            }
            )).join(e) : a + encodeURIComponent(n(t[s]))
        }
        )).join(e) : a ? encodeURIComponent(n(a)) + o + encodeURIComponent(n(t)) : ""
    }
    ;
    var r = Array.isArray || function(t) {
        return "[object Array]" === Object.prototype.toString.call(t)
    }
    ;
    function i(t, e) {
        if (t.map)
            return t.map(e);
        for (var n = [], r = 0; r < t.length; r++)
            n.push(e(t[r], r));
        return n
    }
    var s = Object.keys || function(t) {
        var e = [];
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && e.push(n);
        return e
    }
}
)),
o.register("5dlKa", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__exportStar || function(t, e) {
        for (var r in t)
            "default" === r || Object.prototype.hasOwnProperty.call(e, r) || n(e, t, r)
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.PROGRAM_ID = t.exports.PROGRAM_ADDRESS = void 0;
    var i = o("gNDby");
    r(o("6WDOb"), t.exports),
    r(o("apO5D"), t.exports),
    r(o("46mYT"), t.exports),
    r(o("dtie9"), t.exports),
    t.exports.PROGRAM_ADDRESS = "BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY",
    t.exports.PROGRAM_ID = new i.PublicKey(t.exports.PROGRAM_ADDRESS)
}
)),
o.register("6WDOb", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__exportStar || function(t, e) {
        for (var r in t)
            "default" === r || Object.prototype.hasOwnProperty.call(e, r) || n(e, t, r)
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.accountProviders = void 0,
    r(o("2P1un"), t.exports),
    r(o("6iBPp"), t.exports),
    t.exports.accountProviders = {
        TreeConfig: o("2P1un").TreeConfig,
        Voucher: o("6iBPp").Voucher
    }
}
)),
o.register("2P1un", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.treeConfigBeet = t.exports.TreeConfig = t.exports.treeConfigDiscriminator = void 0;
    const s = i(o("gNDby"))
      , a = i(o("1DULh"))
      , l = i(o("9dESI"));
    t.exports.treeConfigDiscriminator = [122, 245, 175, 248, 171, 34, 0, 207];
    class c {
        constructor(t, e, n, r, i) {
            this.treeCreator = t,
            this.treeDelegate = e,
            this.totalMintCapacity = n,
            this.numMinted = r,
            this.isPublic = i
        }
        static fromArgs(t) {
            return new c(t.treeCreator,t.treeDelegate,t.totalMintCapacity,t.numMinted,t.isPublic)
        }
        static fromAccountInfo(t, e=0) {
            return c.deserialize(t.data, e)
        }
        static async fromAccountAddress(t, e, n) {
            const r = await t.getAccountInfo(e, n);
            if (null == r)
                throw new Error(`Unable to find TreeConfig account at ${e}`);
            return c.fromAccountInfo(r, 0)[0]
        }
        static gpaBuilder(e=new s.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
            return l.GpaBuilder.fromStruct(e, t.exports.treeConfigBeet)
        }
        static deserialize(e, n=0) {
            return t.exports.treeConfigBeet.deserialize(e, n)
        }
        serialize() {
            return t.exports.treeConfigBeet.serialize({
                accountDiscriminator: t.exports.treeConfigDiscriminator,
                ...this
            })
        }
        static get byteSize() {
            return t.exports.treeConfigBeet.byteSize
        }
        static async getMinimumBalanceForRentExemption(t, e) {
            return t.getMinimumBalanceForRentExemption(c.byteSize, e)
        }
        static hasCorrectByteSize(t, e=0) {
            return t.byteLength - e === c.byteSize
        }
        pretty() {
            return {
                treeCreator: this.treeCreator.toBase58(),
                treeDelegate: this.treeDelegate.toBase58(),
                totalMintCapacity: (()=>{
                    const t = this.totalMintCapacity;
                    if ("function" == typeof t.toNumber)
                        try {
                            return t.toNumber()
                        } catch (e) {
                            return t
                        }
                    return t
                }
                )(),
                numMinted: (()=>{
                    const t = this.numMinted;
                    if ("function" == typeof t.toNumber)
                        try {
                            return t.toNumber()
                        } catch (e) {
                            return t
                        }
                    return t
                }
                )(),
                isPublic: this.isPublic
            }
        }
    }
    t.exports.TreeConfig = c,
    t.exports.treeConfigBeet = new a.BeetStruct([["accountDiscriminator", a.uniformFixedSizeArray(a.u8, 8)], ["treeCreator", l.publicKey], ["treeDelegate", l.publicKey], ["totalMintCapacity", a.u64], ["numMinted", a.u64], ["isPublic", a.bool]],c.fromArgs,"TreeConfig")
}
)),
o.register("1DULh", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__exportStar || function(t, e) {
        for (var r in t)
            "default" === r || Object.prototype.hasOwnProperty.call(e, r) || n(e, t, r)
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.supportedTypeMap = void 0,
    r(o("5vXUZ"), t.exports),
    r(o("3rgjF"), t.exports),
    r(o("iadi0"), t.exports),
    r(o("3MHbE"), t.exports),
    r(o("ipcLD"), t.exports),
    r(o("7RrfS"), t.exports),
    r(o("dWJUH"), t.exports),
    r(o("981vi"), t.exports),
    r(o("ioTrE"), t.exports),
    r(o("i0sX8"), t.exports),
    r(o("l9HYk"), t.exports),
    r(o("inPTV"), t.exports),
    r(o("4kKfe"), t.exports),
    r(o("d5fNB"), t.exports),
    r(o("kOHSh"), t.exports),
    t.exports.supportedTypeMap = {
        ...o("3rgjF").collectionsTypeMap,
        ...o("981vi").stringTypeMap,
        ...o("iadi0").compositesTypeMap,
        ...o("3MHbE").enumsTypeMap,
        ...o("7RrfS").numbersTypeMap,
        ...o("5vXUZ").aliasesTypeMap,
        ...o("ioTrE").tuplesTypeMap,
        ...o("ipcLD").mapsTypeMap,
        ...o("dWJUH").setsTypeMap,
        ...o("i0sX8").unitTypeMap
    }
}
)),
o.register("3rgjF", (function(t, e) {
    var n = o("6ZWSX").Buffer;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.collectionsTypeMap = t.exports.uint8Array = t.exports.fixedSizeUint8Array = t.exports.fixedSizeBuffer = t.exports.array = t.exports.fixedSizeArray = t.exports.uniformFixedSizeArray = void 0;
    var r = o("kOHSh")
      , i = o("aLUwE")
      , s = o("7RrfS")
      , a = (r = o("kOHSh"),
    o("2xd6i"))
      , l = o("l9HYk");
    function c(t, e) {
        const n = t.length
          , r = 0 === n ? "<EMPTY>" : t[0].description;
        return {
            write: function(e, r, o) {
                i.strict.equal(o.length, n, `array length ${o.length} should match len ${n}`),
                s.u32.write(e, r, n);
                let a = r + 4;
                for (let r = 0; r < n; r++) {
                    const n = t[r];
                    n.write(e, a, o[r]),
                    a += n.byteSize
                }
            },
            read: function(e, r) {
                const o = s.u32.read(e, r);
                i.strict.equal(o, n, "invalid byte size");
                let a = r + 4;
                const l = new Array(n);
                for (let r = 0; r < n; r++) {
                    const n = t[r];
                    l[r] = n.read(e, a),
                    a += n.byteSize
                }
                return l
            },
            byteSize: 4 + e,
            length: n,
            description: `Array<${r}>(${n})[ 4 + ${e} ]`
        }
    }
    function u(t) {
        return {
            write: function(e, n, r) {
                r.copy(e, n, 0, t)
            },
            read: function(e, n) {
                return e.slice(n, n + t)
            },
            byteSize: t,
            description: `Buffer(${t})`
        }
    }
    function h(t, e=!1) {
        const r = u(t);
        return {
            write: function(o, a, l) {
                i.strict.equal(l.byteLength, t, `Uint8Array length ${l.byteLength} should match len ${t}`),
                e && (s.u32.write(o, a, t),
                a += 4);
                const c = n.from(l);
                r.write(o, a, c)
            },
            read: function(n, o) {
                if (e) {
                    const e = s.u32.read(n, o);
                    i.strict.equal(e, t, "invalid byte size"),
                    o += 4
                }
                const a = r.read(n, o);
                return Uint8Array.from(a)
            },
            byteSize: e ? t + 4 : t,
            description: `Uint8Array(${t})`
        }
    }
    t.exports.uniformFixedSizeArray = function(t, e, n=!1) {
        const r = t.byteSize * e;
        return {
            write: function(r, o, a) {
                i.strict.equal(a.length, e, `array length ${a.length} should match len ${e}`),
                n && (s.u32.write(r, o, e),
                o += 4);
                for (let n = 0; n < e; n++)
                    t.write(r, o + n * t.byteSize, a[n])
            },
            read: function(r, o) {
                if (n) {
                    const t = s.u32.read(r, o);
                    i.strict.equal(t, e, "invalid byte size"),
                    o += 4
                }
                const a = new Array(e);
                for (let n = 0; n < e; n++)
                    a[n] = t.read(r, o + n * t.byteSize);
                return a
            },
            byteSize: n ? 4 + r : r,
            length: e,
            elementByteSize: t.byteSize,
            lenPrefixByteSize: 4,
            description: `Array<${t.description}>(${e})`
        }
    }
    ,
    t.exports.fixedSizeArray = c,
    t.exports.array = function(t) {
        return {
            toFixedFromData(e, n) {
                const r = s.u32.read(e, n);
                (0,
                a.logTrace)(`${this.description}[${r}]`);
                const i = n + 4;
                let o = i;
                const u = new Array(r);
                for (let n = 0; n < r; n++) {
                    const r = (0,
                    l.fixBeetFromData)(t, e, o);
                    u[n] = r,
                    o += r.byteSize
                }
                return c(u, o - i)
            },
            toFixedFromValue(e) {
                (0,
                i.strict)(Array.isArray(e), `${e} should be an array`);
                let n = 0;
                const r = new Array(e.length);
                for (let i = 0; i < e.length; i++) {
                    const s = (0,
                    l.fixBeetFromValue)(t, e[i]);
                    r[i] = s,
                    n += s.byteSize
                }
                return c(r, n)
            },
            description: "array"
        }
    }
    ,
    t.exports.fixedSizeBuffer = u,
    t.exports.fixedSizeUint8Array = h,
    t.exports.uint8Array = {
        toFixedFromData(t, e) {
            const n = s.u32.read(t, e);
            return (0,
            a.logTrace)(`${this.description}[${n}]`),
            h(n, !0)
        },
        toFixedFromValue: t=>h(t.byteLength, !0),
        description: "Uint8Array"
    },
    t.exports.collectionsTypeMap = {
        Array: {
            beet: "array",
            isFixable: !0,
            sourcePack: r.BEET_PACKAGE,
            ts: "Array",
            arg: r.BEET_TYPE_ARG_LEN
        },
        FixedSizeArray: {
            beet: "fixedSizeArray",
            isFixable: !1,
            sourcePack: r.BEET_PACKAGE,
            ts: "Array",
            arg: r.BEET_TYPE_ARG_LEN
        },
        UniformFixedSizeArray: {
            beet: "uniformFixedSizeArray",
            isFixable: !1,
            sourcePack: r.BEET_PACKAGE,
            ts: "Array",
            arg: r.BEET_TYPE_ARG_LEN
        },
        Buffer: {
            beet: "fixedSizeBuffer",
            isFixable: !1,
            sourcePack: r.BEET_PACKAGE,
            ts: "Buffer",
            arg: r.BEET_TYPE_ARG_LEN
        },
        FixedSizeUint8Array: {
            beet: "fixedSizeUint8Array",
            isFixable: !1,
            sourcePack: r.BEET_PACKAGE,
            ts: "Uint8Array",
            arg: r.BEET_TYPE_ARG_LEN
        },
        Uint8Array: {
            beet: "uint8Array",
            isFixable: !0,
            sourcePack: r.BEET_PACKAGE,
            ts: "Uint8Array",
            arg: r.BEET_TYPE_ARG_LEN
        }
    }
}
)),
o.register("kOHSh", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.isElementCollectionFixedSizeBeet = t.exports.isFixableBeet = t.exports.assertFixedSizeBeet = t.exports.isFixedSizeBeet = t.exports.BEET_TYPE_ARG_INNER = t.exports.BEET_TYPE_ARG_LEN = t.exports.BEET_PACKAGE = void 0;
    var n = o("aLUwE");
    function r(t) {
        return Object.keys(t).includes("byteSize")
    }
    t.exports.BEET_PACKAGE = "@metaplex-foundation/beet",
    t.exports.BEET_TYPE_ARG_LEN = "len",
    t.exports.BEET_TYPE_ARG_INNER = "Beet<{innner}>",
    t.exports.isFixedSizeBeet = r,
    t.exports.assertFixedSizeBeet = function(t, e=`${t} should have been a fixed beet`) {
        (0,
        n.strict)(r(t), e)
    }
    ,
    t.exports.isFixableBeet = function(t) {
        return "function" == typeof t.toFixedFromData && "function" == typeof t.toFixedFromValue
    }
    ,
    t.exports.isElementCollectionFixedSizeBeet = function(t) {
        const e = Object.keys(t);
        return e.includes("length") && e.includes("elementByteSize") && e.includes("lenPrefixByteSize")
    }
}
)),
o.register("aLUwE", (function(t, e) {
    var n = o("hPtJY");
    function r(t) {
        return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        ,
        r(t)
    }
    var i, s, a = o("cCihK").codes, l = a.ERR_AMBIGUOUS_ARGUMENT, c = a.ERR_INVALID_ARG_TYPE, u = a.ERR_INVALID_ARG_VALUE, h = a.ERR_INVALID_RETURN_VALUE, d = a.ERR_MISSING_ARGS, f = o("8pS6q"), p = o("N7Lcz").inspect, m = o("N7Lcz").types, g = m.isPromise, y = m.isRegExp, b = Object.assign ? Object.assign : o("dYBnA").assign, v = Object.is ? Object.is : o("eT9RM");
    new Map;
    function w() {
        var t = o("3LKhK");
        i = t.isDeepEqual,
        s = t.isDeepStrictEqual
    }
    var x = !1
      , E = t.exports = T
      , _ = {};
    function A(t) {
        if (t.message instanceof Error)
            throw t.message;
        throw new f(t)
    }
    function S(t, e, n, r) {
        if (!n) {
            var i = !1;
            if (0 === e)
                i = !0,
                r = "No value argument passed to `assert.ok()`";
            else if (r instanceof Error)
                throw r;
            var s = new f({
                actual: n,
                expected: !0,
                message: r,
                operator: "==",
                stackStartFn: t
            });
            throw s.generatedMessage = i,
            s
        }
    }
    function T() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
        S.apply(void 0, [T, e.length].concat(e))
    }
    E.fail = function t(e, r, i, s, o) {
        var a, l = arguments.length;
        if (0 === l)
            a = "Failed";
        else if (1 === l)
            i = e,
            e = void 0;
        else {
            if (!1 === x)
                x = !0,
                (n.emitWarning ? n.emitWarning : console.warn.bind(console))("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
            2 === l && (s = "!=")
        }
        if (i instanceof Error)
            throw i;
        var c = {
            actual: e,
            expected: r,
            operator: void 0 === s ? "fail" : s,
            stackStartFn: o || t
        };
        void 0 !== i && (c.message = i);
        var u = new f(c);
        throw a && (u.message = a,
        u.generatedMessage = !0),
        u
    }
    ,
    E.AssertionError = f,
    E.ok = T,
    E.equal = function t(e, n, r) {
        if (arguments.length < 2)
            throw new d("actual","expected");
        e != n && A({
            actual: e,
            expected: n,
            message: r,
            operator: "==",
            stackStartFn: t
        })
    }
    ,
    E.notEqual = function t(e, n, r) {
        if (arguments.length < 2)
            throw new d("actual","expected");
        e == n && A({
            actual: e,
            expected: n,
            message: r,
            operator: "!=",
            stackStartFn: t
        })
    }
    ,
    E.deepEqual = function t(e, n, r) {
        if (arguments.length < 2)
            throw new d("actual","expected");
        void 0 === i && w(),
        i(e, n) || A({
            actual: e,
            expected: n,
            message: r,
            operator: "deepEqual",
            stackStartFn: t
        })
    }
    ,
    E.notDeepEqual = function t(e, n, r) {
        if (arguments.length < 2)
            throw new d("actual","expected");
        void 0 === i && w(),
        i(e, n) && A({
            actual: e,
            expected: n,
            message: r,
            operator: "notDeepEqual",
            stackStartFn: t
        })
    }
    ,
    E.deepStrictEqual = function t(e, n, r) {
        if (arguments.length < 2)
            throw new d("actual","expected");
        void 0 === i && w(),
        s(e, n) || A({
            actual: e,
            expected: n,
            message: r,
            operator: "deepStrictEqual",
            stackStartFn: t
        })
    }
    ,
    E.notDeepStrictEqual = function t(e, n, r) {
        if (arguments.length < 2)
            throw new d("actual","expected");
        void 0 === i && w();
        s(e, n) && A({
            actual: e,
            expected: n,
            message: r,
            operator: "notDeepStrictEqual",
            stackStartFn: t
        })
    }
    ,
    E.strictEqual = function t(e, n, r) {
        if (arguments.length < 2)
            throw new d("actual","expected");
        v(e, n) || A({
            actual: e,
            expected: n,
            message: r,
            operator: "strictEqual",
            stackStartFn: t
        })
    }
    ,
    E.notStrictEqual = function t(e, n, r) {
        if (arguments.length < 2)
            throw new d("actual","expected");
        v(e, n) && A({
            actual: e,
            expected: n,
            message: r,
            operator: "notStrictEqual",
            stackStartFn: t
        })
    }
    ;
    var k = function t(e, n, r) {
        var i = this;
        !function(t, e) {
            if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function")
        }(this, t),
        n.forEach((function(t) {
            t in e && (void 0 !== r && "string" == typeof r[t] && y(e[t]) && e[t].test(r[t]) ? i[t] = r[t] : i[t] = e[t])
        }
        ))
    };
    function I(t, e, n, o) {
        if ("function" != typeof e) {
            if (y(e))
                return e.test(t);
            if (2 === arguments.length)
                throw new c("expected",["Function", "RegExp"],e);
            if ("object" !== r(t) || null === t) {
                var a = new f({
                    actual: t,
                    expected: e,
                    message: n,
                    operator: "deepStrictEqual",
                    stackStartFn: o
                });
                throw a.operator = o.name,
                a
            }
            var l = Object.keys(e);
            if (e instanceof Error)
                l.push("name", "message");
            else if (0 === l.length)
                throw new u("error",e,"may not be an empty object");
            return void 0 === i && w(),
            l.forEach((function(r) {
                "string" == typeof t[r] && y(e[r]) && e[r].test(t[r]) || function(t, e, n, r, i, o) {
                    if (!(n in t) || !s(t[n], e[n])) {
                        if (!r) {
                            var a = new k(t,i)
                              , l = new k(e,i,t)
                              , c = new f({
                                actual: a,
                                expected: l,
                                operator: "deepStrictEqual",
                                stackStartFn: o
                            });
                            throw c.actual = t,
                            c.expected = e,
                            c.operator = o.name,
                            c
                        }
                        A({
                            actual: t,
                            expected: e,
                            message: r,
                            operator: o.name,
                            stackStartFn: o
                        })
                    }
                }(t, e, r, n, l, o)
            }
            )),
            !0
        }
        return void 0 !== e.prototype && t instanceof e || !Error.isPrototypeOf(e) && !0 === e.call({}, t)
    }
    function M(t) {
        if ("function" != typeof t)
            throw new c("fn","Function",t);
        try {
            t()
        } catch (t) {
            return t
        }
        return _
    }
    function C(t) {
        return g(t) || null !== t && "object" === r(t) && "function" == typeof t.then && "function" == typeof t.catch
    }
    function P(t) {
        return Promise.resolve().then((function() {
            var e;
            if ("function" == typeof t) {
                if (!C(e = t()))
                    throw new h("instance of Promise","promiseFn",e)
            } else {
                if (!C(t))
                    throw new c("promiseFn",["Function", "Promise"],t);
                e = t
            }
            return Promise.resolve().then((function() {
                return e
            }
            )).then((function() {
                return _
            }
            )).catch((function(t) {
                return t
            }
            ))
        }
        ))
    }
    function O(t, e, n, i) {
        if ("string" == typeof n) {
            if (4 === arguments.length)
                throw new c("error",["Object", "Error", "Function", "RegExp"],n);
            if ("object" === r(e) && null !== e) {
                if (e.message === n)
                    throw new l("error/message",'The error message "'.concat(e.message, '" is identical to the message.'))
            } else if (e === n)
                throw new l("error/message",'The error "'.concat(e, '" is identical to the message.'));
            i = n,
            n = void 0
        } else if (null != n && "object" !== r(n) && "function" != typeof n)
            throw new c("error",["Object", "Error", "Function", "RegExp"],n);
        if (e === _) {
            var s = "";
            n && n.name && (s += " (".concat(n.name, ")")),
            s += i ? ": ".concat(i) : ".";
            var o = "rejects" === t.name ? "rejection" : "exception";
            A({
                actual: void 0,
                expected: n,
                operator: t.name,
                message: "Missing expected ".concat(o).concat(s),
                stackStartFn: t
            })
        }
        if (n && !I(e, n, i, t))
            throw e
    }
    function N(t, e, n, r) {
        if (e !== _) {
            if ("string" == typeof n && (r = n,
            n = void 0),
            !n || I(e, n)) {
                var i = r ? ": ".concat(r) : "."
                  , s = "doesNotReject" === t.name ? "rejection" : "exception";
                A({
                    actual: e,
                    expected: n,
                    operator: t.name,
                    message: "Got unwanted ".concat(s).concat(i, "\n") + 'Actual message: "'.concat(e && e.message, '"'),
                    stackStartFn: t
                })
            }
            throw e
        }
    }
    function R() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
        S.apply(void 0, [R, e.length].concat(e))
    }
    E.throws = function t(e) {
        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
            r[i - 1] = arguments[i];
        O.apply(void 0, [t, M(e)].concat(r))
    }
    ,
    E.rejects = function t(e) {
        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
            r[i - 1] = arguments[i];
        return P(e).then((function(e) {
            return O.apply(void 0, [t, e].concat(r))
        }
        ))
    }
    ,
    E.doesNotThrow = function t(e) {
        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
            r[i - 1] = arguments[i];
        N.apply(void 0, [t, M(e)].concat(r))
    }
    ,
    E.doesNotReject = function t(e) {
        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
            r[i - 1] = arguments[i];
        return P(e).then((function(e) {
            return N.apply(void 0, [t, e].concat(r))
        }
        ))
    }
    ,
    E.ifError = function t(e) {
        if (null != e) {
            var n = "ifError got unwanted exception: ";
            "object" === r(e) && "string" == typeof e.message ? 0 === e.message.length && e.constructor ? n += e.constructor.name : n += e.message : n += p(e);
            var i = new f({
                actual: e,
                expected: null,
                operator: "ifError",
                message: n,
                stackStartFn: t
            })
              , s = e.stack;
            if ("string" == typeof s) {
                var o = s.split("\n");
                o.shift();
                for (var a = i.stack.split("\n"), l = 0; l < o.length; l++) {
                    var c = a.indexOf(o[l]);
                    if (-1 !== c) {
                        a = a.slice(0, c);
                        break
                    }
                }
                i.stack = "".concat(a.join("\n"), "\n").concat(o.join("\n"))
            }
            throw i
        }
    }
    ,
    E.strict = b(R, E, {
        equal: E.strictEqual,
        deepEqual: E.deepStrictEqual,
        notEqual: E.notStrictEqual,
        notDeepEqual: E.notDeepStrictEqual
    }),
    E.strict.strict = E.strict
}
)),
o.register("hPtJY", (function(t, e) {
    var n, r, i = t.exports = {};
    function s() {
        throw new Error("setTimeout has not been defined")
    }
    function o() {
        throw new Error("clearTimeout has not been defined")
    }
    function a(t) {
        if (n === setTimeout)
            return setTimeout(t, 0);
        if ((n === s || !n) && setTimeout)
            return n = setTimeout,
            setTimeout(t, 0);
        try {
            return n(t, 0)
        } catch (e) {
            try {
                return n.call(null, t, 0)
            } catch (e) {
                return n.call(this, t, 0)
            }
        }
    }
    !function() {
        try {
            n = "function" == typeof setTimeout ? setTimeout : s
        } catch (t) {
            n = s
        }
        try {
            r = "function" == typeof clearTimeout ? clearTimeout : o
        } catch (t) {
            r = o
        }
    }();
    var l, c = [], u = !1, h = -1;
    function d() {
        u && l && (u = !1,
        l.length ? c = l.concat(c) : h = -1,
        c.length && f())
    }
    function f() {
        if (!u) {
            var t = a(d);
            u = !0;
            for (var e = c.length; e; ) {
                for (l = c,
                c = []; ++h < e; )
                    l && l[h].run();
                h = -1,
                e = c.length
            }
            l = null,
            u = !1,
            function(t) {
                if (r === clearTimeout)
                    return clearTimeout(t);
                if ((r === o || !r) && clearTimeout)
                    return r = clearTimeout,
                    clearTimeout(t);
                try {
                    return r(t)
                } catch (e) {
                    try {
                        return r.call(null, t)
                    } catch (e) {
                        return r.call(this, t)
                    }
                }
            }(t)
        }
    }
    function p(t, e) {
        this.fun = t,
        this.array = e
    }
    function m() {}
    i.nextTick = function(t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var n = 1; n < arguments.length; n++)
                e[n - 1] = arguments[n];
        c.push(new p(t,e)),
        1 !== c.length || u || a(f)
    }
    ,
    p.prototype.run = function() {
        this.fun.apply(null, this.array)
    }
    ,
    i.title = "browser",
    i.browser = !0,
    i.env = {},
    i.argv = [],
    i.version = "",
    i.versions = {},
    i.on = m,
    i.addListener = m,
    i.once = m,
    i.off = m,
    i.removeListener = m,
    i.removeAllListeners = m,
    i.emit = m,
    i.prependListener = m,
    i.prependOnceListener = m,
    i.listeners = function(t) {
        return []
    }
    ,
    i.binding = function(t) {
        throw new Error("process.binding is not supported")
    }
    ,
    i.cwd = function() {
        return "/"
    }
    ,
    i.chdir = function(t) {
        throw new Error("process.chdir is not supported")
    }
    ,
    i.umask = function() {
        return 0
    }
}
)),
o.register("cCihK", (function(e, n) {
    var r;
    function i(t) {
        return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        ,
        i(t)
    }
    function s(t, e) {
        return !e || "object" !== i(e) && "function" != typeof e ? function(t) {
            if (void 0 === t)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }
    function a(t) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        }
        ,
        a(t)
    }
    function l(t, e) {
        return l = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e,
            t
        }
        ,
        l(t, e)
    }
    t(e.exports, "codes", (()=>r), (t=>r = t));
    var c, u, h = {};
    function d(t, e, n) {
        n || (n = Error);
        var r = function(n) {
            function r(n, i, o) {
                var l;
                return function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, r),
                l = s(this, a(r).call(this, function(t, n, r) {
                    return "string" == typeof e ? e : e(t, n, r)
                }(n, i, o))),
                l.code = t,
                l
            }
            return function(t, e) {
                if ("function" != typeof e && null !== e)
                    throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }),
                e && l(t, e)
            }(r, n),
            r
        }(n);
        h[t] = r
    }
    function f(t, e) {
        if (Array.isArray(t)) {
            var n = t.length;
            return t = t.map((function(t) {
                return String(t)
            }
            )),
            n > 2 ? "one of ".concat(e, " ").concat(t.slice(0, n - 1).join(", "), ", or ") + t[n - 1] : 2 === n ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0])
        }
        return "of ".concat(e, " ").concat(String(t))
    }
    d("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError),
    d("ERR_INVALID_ARG_TYPE", (function(t, e, n) {
        var r, s, a, l;
        if (void 0 === c && (c = o("aLUwE")),
        c("string" == typeof t, "'name' must be a string"),
        "string" == typeof e && (s = "not ",
        e.substr(!a || a < 0 ? 0 : +a, s.length) === s) ? (r = "must not be",
        e = e.replace(/^not /, "")) : r = "must be",
        function(t, e, n) {
            return (void 0 === n || n > t.length) && (n = t.length),
            t.substring(n - e.length, n) === e
        }(t, " argument"))
            l = "The ".concat(t, " ").concat(r, " ").concat(f(e, "type"));
        else {
            var u = function(t, e, n) {
                return "number" != typeof n && (n = 0),
                !(n + e.length > t.length) && -1 !== t.indexOf(e, n)
            }(t, ".") ? "property" : "argument";
            l = 'The "'.concat(t, '" ').concat(u, " ").concat(r, " ").concat(f(e, "type"))
        }
        return l += ". Received type ".concat(i(n))
    }
    ), TypeError),
    d("ERR_INVALID_ARG_VALUE", (function(t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
        void 0 === u && (u = o("N7Lcz"));
        var r = u.inspect(e);
        return r.length > 128 && (r = "".concat(r.slice(0, 128), "...")),
        "The argument '".concat(t, "' ").concat(n, ". Received ").concat(r)
    }
    ), TypeError, RangeError),
    d("ERR_INVALID_RETURN_VALUE", (function(t, e, n) {
        var r;
        return r = n && n.constructor && n.constructor.name ? "instance of ".concat(n.constructor.name) : "type ".concat(i(n)),
        "Expected ".concat(t, ' to be returned from the "').concat(e, '"') + " function but got ".concat(r, ".")
    }
    ), TypeError),
    d("ERR_MISSING_ARGS", (function() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
        void 0 === c && (c = o("aLUwE")),
        c(e.length > 0, "At least one arg needs to be specified");
        var r = "The "
          , i = e.length;
        switch (e = e.map((function(t) {
            return '"'.concat(t, '"')
        }
        )),
        i) {
        case 1:
            r += "".concat(e[0], " argument");
            break;
        case 2:
            r += "".concat(e[0], " and ").concat(e[1], " arguments");
            break;
        default:
            r += e.slice(0, i - 1).join(", "),
            r += ", and ".concat(e[i - 1], " arguments")
        }
        return "".concat(r, " must be specified")
    }
    ), TypeError),
    r = h
}
)),
o.register("N7Lcz", (function(t, e) {
    var n = o("hPtJY")
      , r = Object.getOwnPropertyDescriptors || function(t) {
        for (var e = Object.keys(t), n = {}, r = 0; r < e.length; r++)
            n[e[r]] = Object.getOwnPropertyDescriptor(t, e[r]);
        return n
    }
      , i = /%[sdj%]/g;
    t.exports.format = function(t) {
        if (!b(t)) {
            for (var e = [], n = 0; n < arguments.length; n++)
                e.push(l(arguments[n]));
            return e.join(" ")
        }
        n = 1;
        for (var r = arguments, s = r.length, o = String(t).replace(i, (function(t) {
            if ("%%" === t)
                return "%";
            if (n >= s)
                return t;
            switch (t) {
            case "%s":
                return String(r[n++]);
            case "%d":
                return Number(r[n++]);
            case "%j":
                try {
                    return JSON.stringify(r[n++])
                } catch (t) {
                    return "[Circular]"
                }
            default:
                return t
            }
        }
        )), a = r[n]; n < s; a = r[++n])
            g(a) || !x(a) ? o += " " + a : o += " " + l(a);
        return o
    }
    ,
    t.exports.deprecate = function(e, r) {
        if (void 0 !== n && !0 === n.noDeprecation)
            return e;
        if (void 0 === n)
            return function() {
                return t.exports.deprecate(e, r).apply(this, arguments)
            }
            ;
        var i = !1;
        return function() {
            if (!i) {
                if (n.throwDeprecation)
                    throw new Error(r);
                n.traceDeprecation ? console.trace(r) : console.error(r),
                i = !0
            }
            return e.apply(this, arguments)
        }
    }
    ;
    var s = {}
      , a = /^$/;
    function l(e, n) {
        var r = {
            seen: [],
            stylize: u
        };
        return arguments.length >= 3 && (r.depth = arguments[2]),
        arguments.length >= 4 && (r.colors = arguments[3]),
        m(n) ? r.showHidden = n : n && t.exports._extend(r, n),
        v(r.showHidden) && (r.showHidden = !1),
        v(r.depth) && (r.depth = 2),
        v(r.colors) && (r.colors = !1),
        v(r.customInspect) && (r.customInspect = !0),
        r.colors && (r.stylize = c),
        h(r, e, r.depth)
    }
    function c(t, e) {
        var n = l.styles[e];
        return n ? "[" + l.colors[n][0] + "m" + t + "[" + l.colors[n][1] + "m" : t
    }
    function u(t, e) {
        return t
    }
    function h(e, n, r) {
        if (e.customInspect && n && A(n.inspect) && n.inspect !== t.exports.inspect && (!n.constructor || n.constructor.prototype !== n)) {
            var i = n.inspect(r, e);
            return b(i) || (i = h(e, i, r)),
            i
        }
        var s = function(t, e) {
            if (v(e))
                return t.stylize("undefined", "undefined");
            if (b(e)) {
                var n = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return t.stylize(n, "string")
            }
            if (y(e))
                return t.stylize("" + e, "number");
            if (m(e))
                return t.stylize("" + e, "boolean");
            if (g(e))
                return t.stylize("null", "null")
        }(e, n);
        if (s)
            return s;
        var o = Object.keys(n)
          , a = function(t) {
            var e = {};
            return t.forEach((function(t, n) {
                e[t] = !0
            }
            )),
            e
        }(o);
        if (e.showHidden && (o = Object.getOwnPropertyNames(n)),
        _(n) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0))
            return d(n);
        if (0 === o.length) {
            if (A(n)) {
                var l = n.name ? ": " + n.name : "";
                return e.stylize("[Function" + l + "]", "special")
            }
            if (w(n))
                return e.stylize(RegExp.prototype.toString.call(n), "regexp");
            if (E(n))
                return e.stylize(Date.prototype.toString.call(n), "date");
            if (_(n))
                return d(n)
        }
        var c, u = "", x = !1, S = ["{", "}"];
        (p(n) && (x = !0,
        S = ["[", "]"]),
        A(n)) && (u = " [Function" + (n.name ? ": " + n.name : "") + "]");
        return w(n) && (u = " " + RegExp.prototype.toString.call(n)),
        E(n) && (u = " " + Date.prototype.toUTCString.call(n)),
        _(n) && (u = " " + d(n)),
        0 !== o.length || x && 0 != n.length ? r < 0 ? w(n) ? e.stylize(RegExp.prototype.toString.call(n), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(n),
        c = x ? function(t, e, n, r, i) {
            for (var s = [], o = 0, a = e.length; o < a; ++o)
                I(e, String(o)) ? s.push(f(t, e, n, r, String(o), !0)) : s.push("");
            return i.forEach((function(i) {
                i.match(/^\d+$/) || s.push(f(t, e, n, r, i, !0))
            }
            )),
            s
        }(e, n, r, a, o) : o.map((function(t) {
            return f(e, n, r, a, t, x)
        }
        )),
        e.seen.pop(),
        function(t, e, n) {
            var r = t.reduce((function(t, e) {
                return e.indexOf("\n") >= 0 && 0,
                t + e.replace(/\u001b\[\d\d?m/g, "").length + 1
            }
            ), 0);
            return r > 60 ? n[0] + ("" === e ? "" : e + "\n ") + " " + t.join(",\n  ") + " " + n[1] : n[0] + e + " " + t.join(", ") + " " + n[1]
        }(c, u, S)) : S[0] + u + S[1]
    }
    function d(t) {
        return "[" + Error.prototype.toString.call(t) + "]"
    }
    function f(t, e, n, r, i, s) {
        var o, a, l;
        if ((l = Object.getOwnPropertyDescriptor(e, i) || {
            value: e[i]
        }).get ? a = l.set ? t.stylize("[Getter/Setter]", "special") : t.stylize("[Getter]", "special") : l.set && (a = t.stylize("[Setter]", "special")),
        I(r, i) || (o = "[" + i + "]"),
        a || (t.seen.indexOf(l.value) < 0 ? (a = g(n) ? h(t, l.value, null) : h(t, l.value, n - 1)).indexOf("\n") > -1 && (a = s ? a.split("\n").map((function(t) {
            return "  " + t
        }
        )).join("\n").slice(2) : "\n" + a.split("\n").map((function(t) {
            return "   " + t
        }
        )).join("\n")) : a = t.stylize("[Circular]", "special")),
        v(o)) {
            if (s && i.match(/^\d+$/))
                return a;
            (o = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.slice(1, -1),
            o = t.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"),
            o = t.stylize(o, "string"))
        }
        return o + ": " + a
    }
    function p(t) {
        return Array.isArray(t)
    }
    function m(t) {
        return "boolean" == typeof t
    }
    function g(t) {
        return null === t
    }
    function y(t) {
        return "number" == typeof t
    }
    function b(t) {
        return "string" == typeof t
    }
    function v(t) {
        return void 0 === t
    }
    function w(t) {
        return x(t) && "[object RegExp]" === S(t)
    }
    function x(t) {
        return "object" == typeof t && null !== t
    }
    function E(t) {
        return x(t) && "[object Date]" === S(t)
    }
    function _(t) {
        return x(t) && ("[object Error]" === S(t) || t instanceof Error)
    }
    function A(t) {
        return "function" == typeof t
    }
    function S(t) {
        return Object.prototype.toString.call(t)
    }
    function T(t) {
        return t < 10 ? "0" + t.toString(10) : t.toString(10)
    }
    t.exports.debuglog = function(e) {
        if (e = e.toUpperCase(),
        !s[e])
            if (a.test(e)) {
                var r = n.pid;
                s[e] = function() {
                    var n = t.exports.format.apply(t.exports, arguments);
                    console.error("%s %d: %s", e, r, n)
                }
            } else
                s[e] = function() {}
                ;
        return s[e]
    }
    ,
    t.exports.inspect = l,
    l.colors = {
        bold: [1, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        white: [37, 39],
        grey: [90, 39],
        black: [30, 39],
        blue: [34, 39],
        cyan: [36, 39],
        green: [32, 39],
        magenta: [35, 39],
        red: [31, 39],
        yellow: [33, 39]
    },
    l.styles = {
        special: "cyan",
        number: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        date: "magenta",
        regexp: "red"
    },
    t.exports.types = o("7He6T"),
    t.exports.isArray = p,
    t.exports.isBoolean = m,
    t.exports.isNull = g,
    t.exports.isNullOrUndefined = function(t) {
        return null == t
    }
    ,
    t.exports.isNumber = y,
    t.exports.isString = b,
    t.exports.isSymbol = function(t) {
        return "symbol" == typeof t
    }
    ,
    t.exports.isUndefined = v,
    t.exports.isRegExp = w,
    t.exports.types.isRegExp = w,
    t.exports.isObject = x,
    t.exports.isDate = E,
    t.exports.types.isDate = E,
    t.exports.isError = _,
    t.exports.types.isNativeError = _,
    t.exports.isFunction = A,
    t.exports.isPrimitive = function(t) {
        return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t
    }
    ,
    t.exports.isBuffer = o("kotBY");
    var k = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function I(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    t.exports.log = function() {
        var e, n;
        console.log("%s - %s", (e = new Date,
        n = [T(e.getHours()), T(e.getMinutes()), T(e.getSeconds())].join(":"),
        [e.getDate(), k[e.getMonth()], n].join(" ")), t.exports.format.apply(t.exports, arguments))
    }
    ,
    t.exports.inherits = o("dlqwk"),
    t.exports._extend = function(t, e) {
        if (!e || !x(e))
            return t;
        for (var n = Object.keys(e), r = n.length; r--; )
            t[n[r]] = e[n[r]];
        return t
    }
    ;
    var M = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
    function C(t, e) {
        if (!t) {
            var n = new Error("Promise was rejected with a falsy value");
            n.reason = t,
            t = n
        }
        return e(t)
    }
    t.exports.promisify = function(t) {
        if ("function" != typeof t)
            throw new TypeError('The "original" argument must be of type Function');
        if (M && t[M]) {
            var e;
            if ("function" != typeof (e = t[M]))
                throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(e, M, {
                value: e,
                enumerable: !1,
                writable: !1,
                configurable: !0
            }),
            e
        }
        function e() {
            for (var e, n, r = new Promise((function(t, r) {
                e = t,
                n = r
            }
            )), i = [], s = 0; s < arguments.length; s++)
                i.push(arguments[s]);
            i.push((function(t, r) {
                t ? n(t) : e(r)
            }
            ));
            try {
                t.apply(this, i)
            } catch (t) {
                n(t)
            }
            return r
        }
        return Object.setPrototypeOf(e, Object.getPrototypeOf(t)),
        M && Object.defineProperty(e, M, {
            value: e,
            enumerable: !1,
            writable: !1,
            configurable: !0
        }),
        Object.defineProperties(e, r(t))
    }
    ,
    t.exports.promisify.custom = M,
    t.exports.callbackify = function(t) {
        if ("function" != typeof t)
            throw new TypeError('The "original" argument must be of type Function');
        function e() {
            for (var e = [], r = 0; r < arguments.length; r++)
                e.push(arguments[r]);
            var i = e.pop();
            if ("function" != typeof i)
                throw new TypeError("The last argument must be of type Function");
            var s = this
              , o = function() {
                return i.apply(s, arguments)
            };
            t.apply(this, e).then((function(t) {
                n.nextTick(o.bind(null, null, t))
            }
            ), (function(t) {
                n.nextTick(C.bind(null, t, o))
            }
            ))
        }
        return Object.setPrototypeOf(e, Object.getPrototypeOf(t)),
        Object.defineProperties(e, r(t)),
        e
    }
}
)),
o.register("7He6T", (function(t, e) {
    var n = o("f4HGZ")
      , r = o("5WnCa")
      , i = o("gJrpv")
      , s = o("hN833");
    function a(t) {
        return t.call.bind(t)
    }
    var l = "undefined" != typeof BigInt
      , c = "undefined" != typeof Symbol
      , u = a(Object.prototype.toString)
      , h = a(Number.prototype.valueOf)
      , d = a(String.prototype.valueOf)
      , f = a(Boolean.prototype.valueOf);
    if (l)
        var p = a(BigInt.prototype.valueOf);
    if (c)
        var m = a(Symbol.prototype.valueOf);
    function g(t, e) {
        if ("object" != typeof t)
            return !1;
        try {
            return e(t),
            !0
        } catch (t) {
            return !1
        }
    }
    function y(t) {
        return "[object Map]" === u(t)
    }
    function b(t) {
        return "[object Set]" === u(t)
    }
    function v(t) {
        return "[object WeakMap]" === u(t)
    }
    function w(t) {
        return "[object WeakSet]" === u(t)
    }
    function x(t) {
        return "[object ArrayBuffer]" === u(t)
    }
    function E(t) {
        return "undefined" != typeof ArrayBuffer && (x.working ? x(t) : t instanceof ArrayBuffer)
    }
    function _(t) {
        return "[object DataView]" === u(t)
    }
    function A(t) {
        return "undefined" != typeof DataView && (_.working ? _(t) : t instanceof DataView)
    }
    t.exports.isArgumentsObject = n,
    t.exports.isGeneratorFunction = r,
    t.exports.isTypedArray = s,
    t.exports.isPromise = function(t) {
        return "undefined" != typeof Promise && t instanceof Promise || null !== t && "object" == typeof t && "function" == typeof t.then && "function" == typeof t.catch
    }
    ,
    t.exports.isArrayBufferView = function(t) {
        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : s(t) || A(t)
    }
    ,
    t.exports.isUint8Array = function(t) {
        return "Uint8Array" === i(t)
    }
    ,
    t.exports.isUint8ClampedArray = function(t) {
        return "Uint8ClampedArray" === i(t)
    }
    ,
    t.exports.isUint16Array = function(t) {
        return "Uint16Array" === i(t)
    }
    ,
    t.exports.isUint32Array = function(t) {
        return "Uint32Array" === i(t)
    }
    ,
    t.exports.isInt8Array = function(t) {
        return "Int8Array" === i(t)
    }
    ,
    t.exports.isInt16Array = function(t) {
        return "Int16Array" === i(t)
    }
    ,
    t.exports.isInt32Array = function(t) {
        return "Int32Array" === i(t)
    }
    ,
    t.exports.isFloat32Array = function(t) {
        return "Float32Array" === i(t)
    }
    ,
    t.exports.isFloat64Array = function(t) {
        return "Float64Array" === i(t)
    }
    ,
    t.exports.isBigInt64Array = function(t) {
        return "BigInt64Array" === i(t)
    }
    ,
    t.exports.isBigUint64Array = function(t) {
        return "BigUint64Array" === i(t)
    }
    ,
    y.working = "undefined" != typeof Map && y(new Map),
    t.exports.isMap = function(t) {
        return "undefined" != typeof Map && (y.working ? y(t) : t instanceof Map)
    }
    ,
    b.working = "undefined" != typeof Set && b(new Set),
    t.exports.isSet = function(t) {
        return "undefined" != typeof Set && (b.working ? b(t) : t instanceof Set)
    }
    ,
    v.working = "undefined" != typeof WeakMap && v(new WeakMap),
    t.exports.isWeakMap = function(t) {
        return "undefined" != typeof WeakMap && (v.working ? v(t) : t instanceof WeakMap)
    }
    ,
    w.working = "undefined" != typeof WeakSet && w(new WeakSet),
    t.exports.isWeakSet = function(t) {
        return w(t)
    }
    ,
    x.working = "undefined" != typeof ArrayBuffer && x(new ArrayBuffer),
    t.exports.isArrayBuffer = E,
    _.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && _(new DataView(new ArrayBuffer(1),0,1)),
    t.exports.isDataView = A;
    var S = "undefined" != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
    function T(t) {
        return "[object SharedArrayBuffer]" === u(t)
    }
    function k(t) {
        return void 0 !== S && (void 0 === T.working && (T.working = T(new S)),
        T.working ? T(t) : t instanceof S)
    }
    function I(t) {
        return g(t, h)
    }
    function M(t) {
        return g(t, d)
    }
    function C(t) {
        return g(t, f)
    }
    function P(t) {
        return l && g(t, p)
    }
    function O(t) {
        return c && g(t, m)
    }
    t.exports.isSharedArrayBuffer = k,
    t.exports.isAsyncFunction = function(t) {
        return "[object AsyncFunction]" === u(t)
    }
    ,
    t.exports.isMapIterator = function(t) {
        return "[object Map Iterator]" === u(t)
    }
    ,
    t.exports.isSetIterator = function(t) {
        return "[object Set Iterator]" === u(t)
    }
    ,
    t.exports.isGeneratorObject = function(t) {
        return "[object Generator]" === u(t)
    }
    ,
    t.exports.isWebAssemblyCompiledModule = function(t) {
        return "[object WebAssembly.Module]" === u(t)
    }
    ,
    t.exports.isNumberObject = I,
    t.exports.isStringObject = M,
    t.exports.isBooleanObject = C,
    t.exports.isBigIntObject = P,
    t.exports.isSymbolObject = O,
    t.exports.isBoxedPrimitive = function(t) {
        return I(t) || M(t) || C(t) || P(t) || O(t)
    }
    ,
    t.exports.isAnyArrayBuffer = function(t) {
        return "undefined" != typeof Uint8Array && (E(t) || k(t))
    }
    ,
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach((function(e) {
        Object.defineProperty(t.exports, e, {
            enumerable: !1,
            value: function() {
                throw new Error(e + " is not supported in userland")
            }
        })
    }
    ))
}
)),
o.register("f4HGZ", (function(t, e) {
    var n = o("3KyxH")()
      , r = o("hXu6F")("Object.prototype.toString")
      , i = function(t) {
        return !(n && t && "object" == typeof t && Symbol.toStringTag in t) && "[object Arguments]" === r(t)
    }
      , s = function(t) {
        return !!i(t) || null !== t && "object" == typeof t && "number" == typeof t.length && t.length >= 0 && "[object Array]" !== r(t) && "[object Function]" === r(t.callee)
    }
      , a = function() {
        return i(arguments)
    }();
    i.isLegacyArguments = s,
    t.exports = a ? i : s
}
)),
o.register("3KyxH", (function(t, e) {
    var n = o("7YWkK");
    t.exports = function() {
        return n() && !!Symbol.toStringTag
    }
}
)),
o.register("7YWkK", (function(t, e) {
    t.exports = function() {
        if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
            return !1;
        if ("symbol" == typeof Symbol.iterator)
            return !0;
        var t = {}
          , e = Symbol("test")
          , n = Object(e);
        if ("string" == typeof e)
            return !1;
        if ("[object Symbol]" !== Object.prototype.toString.call(e))
            return !1;
        if ("[object Symbol]" !== Object.prototype.toString.call(n))
            return !1;
        for (e in t[e] = 42,
        t)
            return !1;
        if ("function" == typeof Object.keys && 0 !== Object.keys(t).length)
            return !1;
        if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t).length)
            return !1;
        var r = Object.getOwnPropertySymbols(t);
        if (1 !== r.length || r[0] !== e)
            return !1;
        if (!Object.prototype.propertyIsEnumerable.call(t, e))
            return !1;
        if ("function" == typeof Object.getOwnPropertyDescriptor) {
            var i = Object.getOwnPropertyDescriptor(t, e);
            if (42 !== i.value || !0 !== i.enumerable)
                return !1
        }
        return !0
    }
}
)),
o.register("hXu6F", (function(t, e) {
    var n = o("1zENl")
      , r = o("cOB0F")
      , i = r(n("String.prototype.indexOf"));
    t.exports = function(t, e) {
        var s = n(t, !!e);
        return "function" == typeof s && i(t, ".prototype.") > -1 ? r(s) : s
    }
}
)),
o.register("1zENl", (function(t, e) {
    var n, r = SyntaxError, i = Function, s = TypeError, a = function(t) {
        try {
            return i('"use strict"; return (' + t + ").constructor;")()
        } catch (t) {}
    }, l = Object.getOwnPropertyDescriptor;
    if (l)
        try {
            l({}, "")
        } catch (t) {
            l = null
        }
    var c = function() {
        throw new s
    }
      , u = l ? function() {
        try {
            return c
        } catch (t) {
            try {
                return l(arguments, "callee").get
            } catch (t) {
                return c
            }
        }
    }() : c
      , h = o("24qIq")()
      , d = Object.getPrototypeOf || function(t) {
        return t.__proto__
    }
      , f = {}
      , p = "undefined" == typeof Uint8Array ? n : d(Uint8Array)
      , m = {
        "%AggregateError%": "undefined" == typeof AggregateError ? n : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? n : ArrayBuffer,
        "%ArrayIteratorPrototype%": h ? d([][Symbol.iterator]()) : n,
        "%AsyncFromSyncIteratorPrototype%": n,
        "%AsyncFunction%": f,
        "%AsyncGenerator%": f,
        "%AsyncGeneratorFunction%": f,
        "%AsyncIteratorPrototype%": f,
        "%Atomics%": "undefined" == typeof Atomics ? n : Atomics,
        "%BigInt%": "undefined" == typeof BigInt ? n : BigInt,
        "%BigInt64Array%": "undefined" == typeof BigInt64Array ? n : BigInt64Array,
        "%BigUint64Array%": "undefined" == typeof BigUint64Array ? n : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": "undefined" == typeof DataView ? n : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": "undefined" == typeof Float32Array ? n : Float32Array,
        "%Float64Array%": "undefined" == typeof Float64Array ? n : Float64Array,
        "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? n : FinalizationRegistry,
        "%Function%": i,
        "%GeneratorFunction%": f,
        "%Int8Array%": "undefined" == typeof Int8Array ? n : Int8Array,
        "%Int16Array%": "undefined" == typeof Int16Array ? n : Int16Array,
        "%Int32Array%": "undefined" == typeof Int32Array ? n : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": h ? d(d([][Symbol.iterator]())) : n,
        "%JSON%": "object" == typeof JSON ? JSON : n,
        "%Map%": "undefined" == typeof Map ? n : Map,
        "%MapIteratorPrototype%": "undefined" != typeof Map && h ? d((new Map)[Symbol.iterator]()) : n,
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": "undefined" == typeof Promise ? n : Promise,
        "%Proxy%": "undefined" == typeof Proxy ? n : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": "undefined" == typeof Reflect ? n : Reflect,
        "%RegExp%": RegExp,
        "%Set%": "undefined" == typeof Set ? n : Set,
        "%SetIteratorPrototype%": "undefined" != typeof Set && h ? d((new Set)[Symbol.iterator]()) : n,
        "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? n : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": h ? d(""[Symbol.iterator]()) : n,
        "%Symbol%": h ? Symbol : n,
        "%SyntaxError%": r,
        "%ThrowTypeError%": u,
        "%TypedArray%": p,
        "%TypeError%": s,
        "%Uint8Array%": "undefined" == typeof Uint8Array ? n : Uint8Array,
        "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? n : Uint8ClampedArray,
        "%Uint16Array%": "undefined" == typeof Uint16Array ? n : Uint16Array,
        "%Uint32Array%": "undefined" == typeof Uint32Array ? n : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": "undefined" == typeof WeakMap ? n : WeakMap,
        "%WeakRef%": "undefined" == typeof WeakRef ? n : WeakRef,
        "%WeakSet%": "undefined" == typeof WeakSet ? n : WeakSet
    };
    try {
        null.error
    } catch (t) {
        var g = d(d(t));
        m["%Error.prototype%"] = g
    }
    var y = function t(e) {
        var n;
        if ("%AsyncFunction%" === e)
            n = a("async function () {}");
        else if ("%GeneratorFunction%" === e)
            n = a("function* () {}");
        else if ("%AsyncGeneratorFunction%" === e)
            n = a("async function* () {}");
        else if ("%AsyncGenerator%" === e) {
            var r = t("%AsyncGeneratorFunction%");
            r && (n = r.prototype)
        } else if ("%AsyncIteratorPrototype%" === e) {
            var i = t("%AsyncGenerator%");
            i && (n = d(i.prototype))
        }
        return m[e] = n,
        n
    }
      , b = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }
      , v = o("gvair")
      , w = o("8aKn2")
      , x = v.call(Function.call, Array.prototype.concat)
      , E = v.call(Function.apply, Array.prototype.splice)
      , _ = v.call(Function.call, String.prototype.replace)
      , A = v.call(Function.call, String.prototype.slice)
      , S = v.call(Function.call, RegExp.prototype.exec)
      , T = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
      , k = /\\(\\)?/g
      , I = function(t, e) {
        var n, i = t;
        if (w(b, i) && (i = "%" + (n = b[i])[0] + "%"),
        w(m, i)) {
            var o = m[i];
            if (o === f && (o = y(i)),
            void 0 === o && !e)
                throw new s("intrinsic " + t + " exists, but is not available. Please file an issue!");
            return {
                alias: n,
                name: i,
                value: o
            }
        }
        throw new r("intrinsic " + t + " does not exist!")
    };
    t.exports = function(t, e) {
        if ("string" != typeof t || 0 === t.length)
            throw new s("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" != typeof e)
            throw new s('"allowMissing" argument must be a boolean');
        if (null === S(/^%?[^%]*%?$/, t))
            throw new r("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var n = function(t) {
            var e = A(t, 0, 1)
              , n = A(t, -1);
            if ("%" === e && "%" !== n)
                throw new r("invalid intrinsic syntax, expected closing `%`");
            if ("%" === n && "%" !== e)
                throw new r("invalid intrinsic syntax, expected opening `%`");
            var i = [];
            return _(t, T, (function(t, e, n, r) {
                i[i.length] = n ? _(r, k, "$1") : e || t
            }
            )),
            i
        }(t)
          , i = n.length > 0 ? n[0] : ""
          , o = I("%" + i + "%", e)
          , a = o.name
          , c = o.value
          , u = !1
          , h = o.alias;
        h && (i = h[0],
        E(n, x([0, 1], h)));
        for (var d = 1, f = !0; d < n.length; d += 1) {
            var p = n[d]
              , g = A(p, 0, 1)
              , y = A(p, -1);
            if (('"' === g || "'" === g || "`" === g || '"' === y || "'" === y || "`" === y) && g !== y)
                throw new r("property names with quotes must have matching quotes");
            if ("constructor" !== p && f || (u = !0),
            w(m, a = "%" + (i += "." + p) + "%"))
                c = m[a];
            else if (null != c) {
                if (!(p in c)) {
                    if (!e)
                        throw new s("base intrinsic for " + t + " exists, but the property is not available.");
                    return
                }
                if (l && d + 1 >= n.length) {
                    var b = l(c, p);
                    c = (f = !!b) && "get"in b && !("originalValue"in b.get) ? b.get : c[p]
                } else
                    f = w(c, p),
                    c = c[p];
                f && !u && (m[a] = c)
            }
        }
        return c
    }
}
)),
o.register("24qIq", (function(t, e) {
    var n = "undefined" != typeof Symbol && Symbol
      , r = o("7YWkK");
    t.exports = function() {
        return "function" == typeof n && ("function" == typeof Symbol && ("symbol" == typeof n("foo") && ("symbol" == typeof Symbol("bar") && r())))
    }
}
)),
o.register("gvair", (function(t, e) {
    var n = o("kAGnA");
    t.exports = Function.prototype.bind || n
}
)),
o.register("kAGnA", (function(t, e) {
    var n = Array.prototype.slice
      , r = Object.prototype.toString;
    t.exports = function(t) {
        var e = this;
        if ("function" != typeof e || "[object Function]" !== r.call(e))
            throw new TypeError("Function.prototype.bind called on incompatible " + e);
        for (var i, s = n.call(arguments, 1), o = Math.max(0, e.length - s.length), a = [], l = 0; l < o; l++)
            a.push("$" + l);
        if (i = Function("binder", "return function (" + a.join(",") + "){ return binder.apply(this,arguments); }")((function() {
            if (this instanceof i) {
                var r = e.apply(this, s.concat(n.call(arguments)));
                return Object(r) === r ? r : this
            }
            return e.apply(t, s.concat(n.call(arguments)))
        }
        )),
        e.prototype) {
            var c = function() {};
            c.prototype = e.prototype,
            i.prototype = new c,
            c.prototype = null
        }
        return i
    }
}
)),
o.register("8aKn2", (function(t, e) {
    var n = o("gvair");
    t.exports = n.call(Function.call, Object.prototype.hasOwnProperty)
}
)),
o.register("cOB0F", (function(t, e) {
    var n = o("gvair")
      , r = o("1zENl")
      , i = r("%Function.prototype.apply%")
      , s = r("%Function.prototype.call%")
      , a = r("%Reflect.apply%", !0) || n.call(s, i)
      , l = r("%Object.getOwnPropertyDescriptor%", !0)
      , c = r("%Object.defineProperty%", !0)
      , u = r("%Math.max%");
    if (c)
        try {
            c({}, "a", {
                value: 1
            })
        } catch (t) {
            c = null
        }
    t.exports = function(t) {
        var e = a(n, s, arguments);
        l && c && (l(e, "length").configurable && c(e, "length", {
            value: 1 + u(0, t.length - (arguments.length - 1))
        }));
        return e
    }
    ;
    var h = function() {
        return a(n, i, arguments)
    };
    c ? c(t.exports, "apply", {
        value: h
    }) : t.exports.apply = h
}
)),
o.register("5WnCa", (function(t, e) {
    var n, r = Object.prototype.toString, i = Function.prototype.toString, s = /^\s*(?:function)?\*/, a = o("3KyxH")(), l = Object.getPrototypeOf;
    t.exports = function(t) {
        if ("function" != typeof t)
            return !1;
        if (s.test(i.call(t)))
            return !0;
        if (!a)
            return "[object GeneratorFunction]" === r.call(t);
        if (!l)
            return !1;
        if (void 0 === n) {
            var e = function() {
                if (!a)
                    return !1;
                try {
                    return Function("return function*() {}")()
                } catch (t) {}
            }();
            n = !!e && l(e)
        }
        return l(t) === n
    }
}
)),
o.register("gJrpv", (function(t, e) {
    var r = o("gFhA7")
      , i = o("8yXCr")
      , s = o("hXu6F")
      , a = o("dYOee")
      , l = s("Object.prototype.toString")
      , c = o("3KyxH")()
      , u = "undefined" == typeof globalThis ? n : globalThis
      , h = i()
      , d = s("String.prototype.slice")
      , f = {}
      , p = Object.getPrototypeOf;
    c && a && p && r(h, (function(t) {
        if ("function" == typeof u[t]) {
            var e = new u[t];
            if (Symbol.toStringTag in e) {
                var n = p(e)
                  , r = a(n, Symbol.toStringTag);
                if (!r) {
                    var i = p(n);
                    r = a(i, Symbol.toStringTag)
                }
                f[t] = r.get
            }
        }
    }
    ));
    var m = o("hN833");
    t.exports = function(t) {
        return !!m(t) && (c && Symbol.toStringTag in t ? function(t) {
            var e = !1;
            return r(f, (function(n, r) {
                if (!e)
                    try {
                        var i = n.call(t);
                        i === r && (e = i)
                    } catch (t) {}
            }
            )),
            e
        }(t) : d(l(t), 8, -1))
    }
}
)),
o.register("gFhA7", (function(t, e) {
    var n = o("63RD0")
      , r = Object.prototype.toString
      , i = Object.prototype.hasOwnProperty;
    t.exports = function(t, e, s) {
        if (!n(e))
            throw new TypeError("iterator must be a function");
        var o;
        arguments.length >= 3 && (o = s),
        "[object Array]" === r.call(t) ? function(t, e, n) {
            for (var r = 0, s = t.length; r < s; r++)
                i.call(t, r) && (null == n ? e(t[r], r, t) : e.call(n, t[r], r, t))
        }(t, e, o) : "string" == typeof t ? function(t, e, n) {
            for (var r = 0, i = t.length; r < i; r++)
                null == n ? e(t.charAt(r), r, t) : e.call(n, t.charAt(r), r, t)
        }(t, e, o) : function(t, e, n) {
            for (var r in t)
                i.call(t, r) && (null == n ? e(t[r], r, t) : e.call(n, t[r], r, t))
        }(t, e, o)
    }
}
)),
o.register("63RD0", (function(t, e) {
    var n, r, i = Function.prototype.toString, s = "object" == typeof Reflect && null !== Reflect && Reflect.apply;
    if ("function" == typeof s && "function" == typeof Object.defineProperty)
        try {
            n = Object.defineProperty({}, "length", {
                get: function() {
                    throw r
                }
            }),
            r = {},
            s((function() {
                throw 42
            }
            ), null, n)
        } catch (t) {
            t !== r && (s = null)
        }
    else
        s = null;
    var o = /^\s*class\b/
      , a = function(t) {
        try {
            var e = i.call(t);
            return o.test(e)
        } catch (t) {
            return !1
        }
    }
      , l = function(t) {
        try {
            return !a(t) && (i.call(t),
            !0)
        } catch (t) {
            return !1
        }
    }
      , c = Object.prototype.toString
      , u = "function" == typeof Symbol && !!Symbol.toStringTag
      , h = !(0 in [, ])
      , d = function() {
        return !1
    };
    if ("object" == typeof document) {
        var f = document.all;
        c.call(f) === c.call(document.all) && (d = function(t) {
            if ((h || !t) && (void 0 === t || "object" == typeof t))
                try {
                    var e = c.call(t);
                    return ("[object HTMLAllCollection]" === e || "[object HTML document.all class]" === e || "[object HTMLCollection]" === e || "[object Object]" === e) && null == t("")
                } catch (t) {}
            return !1
        }
        )
    }
    t.exports = s ? function(t) {
        if (d(t))
            return !0;
        if (!t)
            return !1;
        if ("function" != typeof t && "object" != typeof t)
            return !1;
        try {
            s(t, null, n)
        } catch (t) {
            if (t !== r)
                return !1
        }
        return !a(t) && l(t)
    }
    : function(t) {
        if (d(t))
            return !0;
        if (!t)
            return !1;
        if ("function" != typeof t && "object" != typeof t)
            return !1;
        if (u)
            return l(t);
        if (a(t))
            return !1;
        var e = c.call(t);
        return !("[object Function]" !== e && "[object GeneratorFunction]" !== e && !/^\[object HTML/.test(e)) && l(t)
    }
}
)),
o.register("8yXCr", (function(t, e) {
    var r = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"]
      , i = "undefined" == typeof globalThis ? n : globalThis;
    t.exports = function() {
        for (var t = [], e = 0; e < r.length; e++)
            "function" == typeof i[r[e]] && (t[t.length] = r[e]);
        return t
    }
}
)),
o.register("dYOee", (function(t, e) {
    var n = o("1zENl")("%Object.getOwnPropertyDescriptor%", !0);
    if (n)
        try {
            n([], "length")
        } catch (t) {
            n = null
        }
    t.exports = n
}
)),
o.register("hN833", (function(t, e) {
    var r = o("gFhA7")
      , i = o("8yXCr")
      , s = o("hXu6F")
      , a = s("Object.prototype.toString")
      , l = o("3KyxH")()
      , c = o("dYOee")
      , u = "undefined" == typeof globalThis ? n : globalThis
      , h = i()
      , d = s("Array.prototype.indexOf", !0) || function(t, e) {
        for (var n = 0; n < t.length; n += 1)
            if (t[n] === e)
                return n;
        return -1
    }
      , f = s("String.prototype.slice")
      , p = {}
      , m = Object.getPrototypeOf;
    l && c && m && r(h, (function(t) {
        var e = new u[t];
        if (Symbol.toStringTag in e) {
            var n = m(e)
              , r = c(n, Symbol.toStringTag);
            if (!r) {
                var i = m(n);
                r = c(i, Symbol.toStringTag)
            }
            p[t] = r.get
        }
    }
    ));
    t.exports = function(t) {
        if (!t || "object" != typeof t)
            return !1;
        if (!l || !(Symbol.toStringTag in t)) {
            var e = f(a(t), 8, -1);
            return d(h, e) > -1
        }
        return !!c && function(t) {
            var e = !1;
            return r(p, (function(n, r) {
                if (!e)
                    try {
                        e = n.call(t) === r
                    } catch (t) {}
            }
            )),
            e
        }(t)
    }
}
)),
o.register("kotBY", (function(t, e) {
    t.exports = function(t) {
        return t && "object" == typeof t && "function" == typeof t.copy && "function" == typeof t.fill && "function" == typeof t.readUInt8
    }
}
)),
o.register("dlqwk", (function(t, e) {
    "function" == typeof Object.create ? t.exports = function(t, e) {
        e && (t.super_ = e,
        t.prototype = Object.create(e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }))
    }
    : t.exports = function(t, e) {
        if (e) {
            t.super_ = e;
            var n = function() {};
            n.prototype = e.prototype,
            t.prototype = new n,
            t.prototype.constructor = t
        }
    }
}
)),
o.register("8pS6q", (function(t, e) {
    var n = o("hPtJY");
    function r(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n,
        t
    }
    function i(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            r.enumerable = r.enumerable || !1,
            r.configurable = !0,
            "value"in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r)
        }
    }
    function s(t, e) {
        return !e || "object" !== d(e) && "function" != typeof e ? a(t) : e
    }
    function a(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    function l(t) {
        var e = "function" == typeof Map ? new Map : void 0;
        return l = function(t) {
            if (null === t || (n = t,
            -1 === Function.toString.call(n).indexOf("[native code]")))
                return t;
            var n;
            if ("function" != typeof t)
                throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== e) {
                if (e.has(t))
                    return e.get(t);
                e.set(t, r)
            }
            function r() {
                return c(t, arguments, h(this).constructor)
            }
            return r.prototype = Object.create(t.prototype, {
                constructor: {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }),
            u(r, t)
        }
        ,
        l(t)
    }
    function c(t, e, n) {
        return c = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }() ? Reflect.construct : function(t, e, n) {
            var r = [null];
            r.push.apply(r, e);
            var i = new (Function.bind.apply(t, r));
            return n && u(i, n.prototype),
            i
        }
        ,
        c.apply(null, arguments)
    }
    function u(t, e) {
        return u = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e,
            t
        }
        ,
        u(t, e)
    }
    function h(t) {
        return h = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        }
        ,
        h(t)
    }
    function d(t) {
        return d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        ,
        d(t)
    }
    var f = o("N7Lcz").inspect
      , p = o("cCihK").codes.ERR_INVALID_ARG_TYPE;
    function m(t, e, n) {
        return (void 0 === n || n > t.length) && (n = t.length),
        t.substring(n - e.length, n) === e
    }
    var g = ""
      , y = ""
      , b = ""
      , v = ""
      , w = {
        deepStrictEqual: "Expected values to be strictly deep-equal:",
        strictEqual: "Expected values to be strictly equal:",
        strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
        deepEqual: "Expected values to be loosely deep-equal:",
        equal: "Expected values to be loosely equal:",
        notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
        notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
        notEqual: 'Expected "actual" to be loosely unequal to:',
        notIdentical: "Values identical but not reference-equal:"
    }
      , x = 10;
    function E(t) {
        var e = Object.keys(t)
          , n = Object.create(Object.getPrototypeOf(t));
        return e.forEach((function(e) {
            n[e] = t[e]
        }
        )),
        Object.defineProperty(n, "message", {
            value: t.message
        }),
        n
    }
    function _(t) {
        return f(t, {
            compact: !1,
            customInspect: !1,
            depth: 1e3,
            maxArrayLength: 1 / 0,
            showHidden: !1,
            breakLength: 1 / 0,
            showProxy: !1,
            sorted: !0,
            getters: !0
        })
    }
    function A(t, e, r) {
        var i = ""
          , s = ""
          , o = 0
          , a = ""
          , l = !1
          , c = _(t)
          , u = c.split("\n")
          , h = _(e).split("\n")
          , f = 0
          , p = "";
        if ("strictEqual" === r && "object" === d(t) && "object" === d(e) && null !== t && null !== e && (r = "strictEqualObject"),
        1 === u.length && 1 === h.length && u[0] !== h[0]) {
            var E = u[0].length + h[0].length;
            if (E <= x) {
                if (!("object" === d(t) && null !== t || "object" === d(e) && null !== e || 0 === t && 0 === e))
                    return "".concat(w[r], "\n\n") + "".concat(u[0], " !== ").concat(h[0], "\n")
            } else if ("strictEqualObject" !== r) {
                if (E < (n.stderr && n.stderr.isTTY ? n.stderr.columns : 80)) {
                    for (; u[0][f] === h[0][f]; )
                        f++;
                    f > 2 && (p = "\n  ".concat(function(t, e) {
                        if (e = Math.floor(e),
                        0 == t.length || 0 == e)
                            return "";
                        var n = t.length * e;
                        for (e = Math.floor(Math.log(e) / Math.log(2)); e; )
                            t += t,
                            e--;
                        return t + t.substring(0, n - t.length)
                    }(" ", f), "^"),
                    f = 0)
                }
            }
        }
        for (var A = u[u.length - 1], S = h[h.length - 1]; A === S && (f++ < 2 ? a = "\n  ".concat(A).concat(a) : i = A,
        u.pop(),
        h.pop(),
        0 !== u.length && 0 !== h.length); )
            A = u[u.length - 1],
            S = h[h.length - 1];
        var T = Math.max(u.length, h.length);
        if (0 === T) {
            var k = c.split("\n");
            if (k.length > 30)
                for (k[26] = "".concat(g, "...").concat(v); k.length > 27; )
                    k.pop();
            return "".concat(w.notIdentical, "\n\n").concat(k.join("\n"), "\n")
        }
        f > 3 && (a = "\n".concat(g, "...").concat(v).concat(a),
        l = !0),
        "" !== i && (a = "\n  ".concat(i).concat(a),
        i = "");
        var I = 0
          , M = w[r] + "\n".concat(y, "+ actual").concat(v, " ").concat(b, "- expected").concat(v)
          , C = " ".concat(g, "...").concat(v, " Lines skipped");
        for (f = 0; f < T; f++) {
            var P = f - o;
            if (u.length < f + 1)
                P > 1 && f > 2 && (P > 4 ? (s += "\n".concat(g, "...").concat(v),
                l = !0) : P > 3 && (s += "\n  ".concat(h[f - 2]),
                I++),
                s += "\n  ".concat(h[f - 1]),
                I++),
                o = f,
                i += "\n".concat(b, "-").concat(v, " ").concat(h[f]),
                I++;
            else if (h.length < f + 1)
                P > 1 && f > 2 && (P > 4 ? (s += "\n".concat(g, "...").concat(v),
                l = !0) : P > 3 && (s += "\n  ".concat(u[f - 2]),
                I++),
                s += "\n  ".concat(u[f - 1]),
                I++),
                o = f,
                s += "\n".concat(y, "+").concat(v, " ").concat(u[f]),
                I++;
            else {
                var O = h[f]
                  , N = u[f]
                  , R = N !== O && (!m(N, ",") || N.slice(0, -1) !== O);
                R && m(O, ",") && O.slice(0, -1) === N && (R = !1,
                N += ","),
                R ? (P > 1 && f > 2 && (P > 4 ? (s += "\n".concat(g, "...").concat(v),
                l = !0) : P > 3 && (s += "\n  ".concat(u[f - 2]),
                I++),
                s += "\n  ".concat(u[f - 1]),
                I++),
                o = f,
                s += "\n".concat(y, "+").concat(v, " ").concat(N),
                i += "\n".concat(b, "-").concat(v, " ").concat(O),
                I += 2) : (s += i,
                i = "",
                1 !== P && 0 !== f || (s += "\n  ".concat(N),
                I++))
            }
            if (I > 20 && f < T - 2)
                return "".concat(M).concat(C, "\n").concat(s, "\n").concat(g, "...").concat(v).concat(i, "\n") + "".concat(g, "...").concat(v)
        }
        return "".concat(M).concat(l ? C : "", "\n").concat(s).concat(i).concat(a).concat(p)
    }
    var S = function(t) {
        function e(t) {
            var r;
            if (function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            "object" !== d(t) || null === t)
                throw new p("options","Object",t);
            var i = t.message
              , o = t.operator
              , l = t.stackStartFn
              , c = t.actual
              , u = t.expected
              , f = Error.stackTraceLimit;
            if (Error.stackTraceLimit = 0,
            null != i)
                r = s(this, h(e).call(this, String(i)));
            else if (n.stderr && n.stderr.isTTY && (n.stderr && n.stderr.getColorDepth && 1 !== n.stderr.getColorDepth() ? (g = "[34m",
            y = "[32m",
            v = "[39m",
            b = "[31m") : (g = "",
            y = "",
            v = "",
            b = "")),
            "object" === d(c) && null !== c && "object" === d(u) && null !== u && "stack"in c && c instanceof Error && "stack"in u && u instanceof Error && (c = E(c),
            u = E(u)),
            "deepStrictEqual" === o || "strictEqual" === o)
                r = s(this, h(e).call(this, A(c, u, o)));
            else if ("notDeepStrictEqual" === o || "notStrictEqual" === o) {
                var m = w[o]
                  , x = _(c).split("\n");
                if ("notStrictEqual" === o && "object" === d(c) && null !== c && (m = w.notStrictEqualObject),
                x.length > 30)
                    for (x[26] = "".concat(g, "...").concat(v); x.length > 27; )
                        x.pop();
                r = 1 === x.length ? s(this, h(e).call(this, "".concat(m, " ").concat(x[0]))) : s(this, h(e).call(this, "".concat(m, "\n\n").concat(x.join("\n"), "\n")))
            } else {
                var S = _(c)
                  , T = ""
                  , k = w[o];
                "notDeepEqual" === o || "notEqual" === o ? (S = "".concat(w[o], "\n\n").concat(S)).length > 1024 && (S = "".concat(S.slice(0, 1021), "...")) : (T = "".concat(_(u)),
                S.length > 512 && (S = "".concat(S.slice(0, 509), "...")),
                T.length > 512 && (T = "".concat(T.slice(0, 509), "...")),
                "deepEqual" === o || "equal" === o ? S = "".concat(k, "\n\n").concat(S, "\n\nshould equal\n\n") : T = " ".concat(o, " ").concat(T)),
                r = s(this, h(e).call(this, "".concat(S).concat(T)))
            }
            return Error.stackTraceLimit = f,
            r.generatedMessage = !i,
            Object.defineProperty(a(r), "name", {
                value: "AssertionError [ERR_ASSERTION]",
                enumerable: !1,
                writable: !0,
                configurable: !0
            }),
            r.code = "ERR_ASSERTION",
            r.actual = c,
            r.expected = u,
            r.operator = o,
            Error.captureStackTrace && Error.captureStackTrace(a(r), l),
            r.stack,
            r.name = "AssertionError",
            s(r)
        }
        var o, l, c;
        return function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }),
            e && u(t, e)
        }(e, t),
        o = e,
        l = [{
            key: "toString",
            value: function() {
                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message)
            }
        }, {
            key: f.custom,
            value: function(t, e) {
                return f(this, function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var n = null != arguments[e] ? arguments[e] : {}
                          , i = Object.keys(n);
                        "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(t) {
                            return Object.getOwnPropertyDescriptor(n, t).enumerable
                        }
                        )))),
                        i.forEach((function(e) {
                            r(t, e, n[e])
                        }
                        ))
                    }
                    return t
                }({}, e, {
                    customInspect: !1,
                    depth: 0
                }))
            }
        }],
        l && i(o.prototype, l),
        c && i(o, c),
        e
    }(l(Error));
    t.exports = S
}
)),
o.register("dYBnA", (function(t, e) {
    function n(t, e) {
        if (null == t)
            throw new TypeError("Cannot convert first argument to object");
        for (var n = Object(t), r = 1; r < arguments.length; r++) {
            var i = arguments[r];
            if (null != i)
                for (var s = Object.keys(Object(i)), o = 0, a = s.length; o < a; o++) {
                    var l = s[o]
                      , c = Object.getOwnPropertyDescriptor(i, l);
                    void 0 !== c && c.enumerable && (n[l] = i[l])
                }
        }
        return n
    }
    t.exports = {
        assign: n,
        polyfill: function() {
            Object.assign || Object.defineProperty(Object, "assign", {
                enumerable: !1,
                configurable: !0,
                writable: !0,
                value: n
            })
        }
    }
}
)),
o.register("eT9RM", (function(t, e) {
    var n = o("1UbTr")
      , r = o("cOB0F")
      , i = o("6wuPW")
      , s = o("5SxoI")
      , a = o("bNbuK")
      , l = r(s(), Object);
    n(l, {
        getPolyfill: s,
        implementation: i,
        shim: a
    }),
    t.exports = l
}
)),
o.register("1UbTr", (function(t, e) {
    var n = o("81enX")
      , r = "function" == typeof Symbol && "symbol" == typeof Symbol("foo")
      , i = Object.prototype.toString
      , s = Array.prototype.concat
      , a = Object.defineProperty
      , l = o("i16wS")()
      , c = a && l
      , u = function(t, e, n, r) {
        if (e in t)
            if (!0 === r) {
                if (t[e] === n)
                    return
            } else if ("function" != typeof (s = r) || "[object Function]" !== i.call(s) || !r())
                return;
        var s;
        c ? a(t, e, {
            configurable: !0,
            enumerable: !1,
            value: n,
            writable: !0
        }) : t[e] = n
    }
      , h = function(t, e) {
        var i = arguments.length > 2 ? arguments[2] : {}
          , o = n(e);
        r && (o = s.call(o, Object.getOwnPropertySymbols(e)));
        for (var a = 0; a < o.length; a += 1)
            u(t, o[a], e[o[a]], i[o[a]])
    };
    h.supportsDescriptors = !!c,
    t.exports = h
}
)),
o.register("81enX", (function(t, e) {
    var n = Array.prototype.slice
      , r = o("z1gio")
      , i = Object.keys
      , s = i ? function(t) {
        return i(t)
    }
    : o("4nFCC")
      , a = Object.keys;
    s.shim = function() {
        if (Object.keys) {
            var t = function() {
                var t = Object.keys(arguments);
                return t && t.length === arguments.length
            }(1, 2);
            t || (Object.keys = function(t) {
                return r(t) ? a(n.call(t)) : a(t)
            }
            )
        } else
            Object.keys = s;
        return Object.keys || s
    }
    ,
    t.exports = s
}
)),
o.register("z1gio", (function(t, e) {
    var n = Object.prototype.toString;
    t.exports = function(t) {
        var e = n.call(t)
          , r = "[object Arguments]" === e;
        return r || (r = "[object Array]" !== e && null !== t && "object" == typeof t && "number" == typeof t.length && t.length >= 0 && "[object Function]" === n.call(t.callee)),
        r
    }
}
)),
o.register("4nFCC", (function(t, e) {
    var n;
    if (!Object.keys) {
        var r = Object.prototype.hasOwnProperty
          , i = Object.prototype.toString
          , s = o("z1gio")
          , a = Object.prototype.propertyIsEnumerable
          , l = !a.call({
            toString: null
        }, "toString")
          , c = a.call((function() {}
        ), "prototype")
          , u = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"]
          , h = function(t) {
            var e = t.constructor;
            return e && e.prototype === t
        }
          , d = {
            $applicationCache: !0,
            $console: !0,
            $external: !0,
            $frame: !0,
            $frameElement: !0,
            $frames: !0,
            $innerHeight: !0,
            $innerWidth: !0,
            $onmozfullscreenchange: !0,
            $onmozfullscreenerror: !0,
            $outerHeight: !0,
            $outerWidth: !0,
            $pageXOffset: !0,
            $pageYOffset: !0,
            $parent: !0,
            $scrollLeft: !0,
            $scrollTop: !0,
            $scrollX: !0,
            $scrollY: !0,
            $self: !0,
            $webkitIndexedDB: !0,
            $webkitStorageInfo: !0,
            $window: !0
        }
          , f = function() {
            if ("undefined" == typeof window)
                return !1;
            for (var t in window)
                try {
                    if (!d["$" + t] && r.call(window, t) && null !== window[t] && "object" == typeof window[t])
                        try {
                            h(window[t])
                        } catch (t) {
                            return !0
                        }
                } catch (t) {
                    return !0
                }
            return !1
        }();
        n = function(t) {
            var e = null !== t && "object" == typeof t
              , n = "[object Function]" === i.call(t)
              , o = s(t)
              , a = e && "[object String]" === i.call(t)
              , d = [];
            if (!e && !n && !o)
                throw new TypeError("Object.keys called on a non-object");
            var p = c && n;
            if (a && t.length > 0 && !r.call(t, 0))
                for (var m = 0; m < t.length; ++m)
                    d.push(String(m));
            if (o && t.length > 0)
                for (var g = 0; g < t.length; ++g)
                    d.push(String(g));
            else
                for (var y in t)
                    p && "prototype" === y || !r.call(t, y) || d.push(String(y));
            if (l)
                for (var b = function(t) {
                    if ("undefined" == typeof window || !f)
                        return h(t);
                    try {
                        return h(t)
                    } catch (t) {
                        return !1
                    }
                }(t), v = 0; v < u.length; ++v)
                    b && "constructor" === u[v] || !r.call(t, u[v]) || d.push(u[v]);
            return d
        }
    }
    t.exports = n
}
)),
o.register("i16wS", (function(t, e) {
    var n = o("1zENl")("%Object.defineProperty%", !0)
      , r = function() {
        if (n)
            try {
                return n({}, "a", {
                    value: 1
                }),
                !0
            } catch (t) {
                return !1
            }
        return !1
    };
    r.hasArrayLengthDefineBug = function() {
        if (!r())
            return null;
        try {
            return 1 !== n([], "length", {
                value: 1
            }).length
        } catch (t) {
            return !0
        }
    }
    ,
    t.exports = r
}
)),
o.register("6wuPW", (function(t, e) {
    var n = function(t) {
        return t != t
    };
    t.exports = function(t, e) {
        return 0 === t && 0 === e ? 1 / t == 1 / e : t === e || !(!n(t) || !n(e))
    }
}
)),
o.register("5SxoI", (function(t, e) {
    var n = o("6wuPW");
    t.exports = function() {
        return "function" == typeof Object.is ? Object.is : n
    }
}
)),
o.register("bNbuK", (function(t, e) {
    var n = o("5SxoI")
      , r = o("1UbTr");
    t.exports = function() {
        var t = n();
        return r(Object, {
            is: t
        }, {
            is: function() {
                return Object.is !== t
            }
        }),
        t
    }
}
)),
o.register("3LKhK", (function(t, e) {
    function n(t, e) {
        return function(t) {
            if (Array.isArray(t))
                return t
        }(t) || function(t, e) {
            var n = []
              , r = !0
              , i = !1
              , s = void 0;
            try {
                for (var o, a = t[Symbol.iterator](); !(r = (o = a.next()).done) && (n.push(o.value),
                !e || n.length !== e); r = !0)
                    ;
            } catch (t) {
                i = !0,
                s = t
            } finally {
                try {
                    r || null == a.return || a.return()
                } finally {
                    if (i)
                        throw s
                }
            }
            return n
        }(t, e) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }()
    }
    function r(t) {
        return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        ,
        r(t)
    }
    var i = void 0 !== /a/g.flags
      , s = function(t) {
        var e = [];
        return t.forEach((function(t) {
            return e.push(t)
        }
        )),
        e
    }
      , a = function(t) {
        var e = [];
        return t.forEach((function(t, n) {
            return e.push([n, t])
        }
        )),
        e
    }
      , l = Object.is ? Object.is : o("eT9RM")
      , c = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return []
    }
      , u = Number.isNaN ? Number.isNaN : o("c8Cyq");
    function h(t) {
        return t.call.bind(t)
    }
    var d = h(Object.prototype.hasOwnProperty)
      , f = h(Object.prototype.propertyIsEnumerable)
      , p = h(Object.prototype.toString)
      , m = o("N7Lcz").types
      , g = m.isAnyArrayBuffer
      , y = m.isArrayBufferView
      , b = m.isDate
      , v = m.isMap
      , w = m.isRegExp
      , x = m.isSet
      , E = m.isNativeError
      , _ = m.isBoxedPrimitive
      , A = m.isNumberObject
      , S = m.isStringObject
      , T = m.isBooleanObject
      , k = m.isBigIntObject
      , I = m.isSymbolObject
      , M = m.isFloat32Array
      , C = m.isFloat64Array;
    function P(t) {
        if (0 === t.length || t.length > 10)
            return !0;
        for (var e = 0; e < t.length; e++) {
            var n = t.charCodeAt(e);
            if (n < 48 || n > 57)
                return !0
        }
        return 10 === t.length && t >= Math.pow(2, 32)
    }
    function O(t) {
        return Object.keys(t).filter(P).concat(c(t).filter(Object.prototype.propertyIsEnumerable.bind(t)))
    }
    /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
    function N(t, e) {
        if (t === e)
            return 0;
        for (var n = t.length, r = e.length, i = 0, s = Math.min(n, r); i < s; ++i)
            if (t[i] !== e[i]) {
                n = t[i],
                r = e[i];
                break
            }
        return n < r ? -1 : r < n ? 1 : 0
    }
    var R = !0
      , D = !1
      , B = 0
      , L = 1
      , F = 2
      , j = 3;
    function U(t, e, n, s) {
        if (t === e)
            return 0 !== t || (!n || l(t, e));
        if (n) {
            if ("object" !== r(t))
                return "number" == typeof t && u(t) && u(e);
            if ("object" !== r(e) || null === t || null === e)
                return !1;
            if (Object.getPrototypeOf(t) !== Object.getPrototypeOf(e))
                return !1
        } else {
            if (null === t || "object" !== r(t))
                return (null === e || "object" !== r(e)) && t == e;
            if (null === e || "object" !== r(e))
                return !1
        }
        var o, a, c, h, d = p(t);
        if (d !== p(e))
            return !1;
        if (Array.isArray(t)) {
            if (t.length !== e.length)
                return !1;
            var f = O(t)
              , m = O(e);
            return f.length === m.length && V(t, e, n, s, L, f)
        }
        if ("[object Object]" === d && (!v(t) && v(e) || !x(t) && x(e)))
            return !1;
        if (b(t)) {
            if (!b(e) || Date.prototype.getTime.call(t) !== Date.prototype.getTime.call(e))
                return !1
        } else if (w(t)) {
            if (!w(e) || (c = t,
            h = e,
            !(i ? c.source === h.source && c.flags === h.flags : RegExp.prototype.toString.call(c) === RegExp.prototype.toString.call(h))))
                return !1
        } else if (E(t) || t instanceof Error) {
            if (t.message !== e.message || t.name !== e.name)
                return !1
        } else {
            if (y(t)) {
                if (n || !M(t) && !C(t)) {
                    if (!function(t, e) {
                        return t.byteLength === e.byteLength && 0 === N(new Uint8Array(t.buffer,t.byteOffset,t.byteLength), new Uint8Array(e.buffer,e.byteOffset,e.byteLength))
                    }(t, e))
                        return !1
                } else if (!function(t, e) {
                    if (t.byteLength !== e.byteLength)
                        return !1;
                    for (var n = 0; n < t.byteLength; n++)
                        if (t[n] !== e[n])
                            return !1;
                    return !0
                }(t, e))
                    return !1;
                var P = O(t)
                  , R = O(e);
                return P.length === R.length && V(t, e, n, s, B, P)
            }
            if (x(t))
                return !(!x(e) || t.size !== e.size) && V(t, e, n, s, F);
            if (v(t))
                return !(!v(e) || t.size !== e.size) && V(t, e, n, s, j);
            if (g(t)) {
                if (a = e,
                (o = t).byteLength !== a.byteLength || 0 !== N(new Uint8Array(o), new Uint8Array(a)))
                    return !1
            } else if (_(t) && !function(t, e) {
                return A(t) ? A(e) && l(Number.prototype.valueOf.call(t), Number.prototype.valueOf.call(e)) : S(t) ? S(e) && String.prototype.valueOf.call(t) === String.prototype.valueOf.call(e) : T(t) ? T(e) && Boolean.prototype.valueOf.call(t) === Boolean.prototype.valueOf.call(e) : k(t) ? k(e) && BigInt.prototype.valueOf.call(t) === BigInt.prototype.valueOf.call(e) : I(e) && Symbol.prototype.valueOf.call(t) === Symbol.prototype.valueOf.call(e)
            }(t, e))
                return !1
        }
        return V(t, e, n, s, B)
    }
    function z(t, e) {
        return e.filter((function(e) {
            return f(t, e)
        }
        ))
    }
    function V(t, e, i, o, l, u) {
        if (5 === arguments.length) {
            u = Object.keys(t);
            var h = Object.keys(e);
            if (u.length !== h.length)
                return !1
        }
        for (var p = 0; p < u.length; p++)
            if (!d(e, u[p]))
                return !1;
        if (i && 5 === arguments.length) {
            var m = c(t);
            if (0 !== m.length) {
                var g = 0;
                for (p = 0; p < m.length; p++) {
                    var y = m[p];
                    if (f(t, y)) {
                        if (!f(e, y))
                            return !1;
                        u.push(y),
                        g++
                    } else if (f(e, y))
                        return !1
                }
                var b = c(e);
                if (m.length !== b.length && z(e, b).length !== g)
                    return !1
            } else {
                var v = c(e);
                if (0 !== v.length && 0 !== z(e, v).length)
                    return !1
            }
        }
        if (0 === u.length && (l === B || l === L && 0 === t.length || 0 === t.size))
            return !0;
        if (void 0 === o)
            o = {
                val1: new Map,
                val2: new Map,
                position: 0
            };
        else {
            var w = o.val1.get(t);
            if (void 0 !== w) {
                var x = o.val2.get(e);
                if (void 0 !== x)
                    return w === x
            }
            o.position++
        }
        o.val1.set(t, o.position),
        o.val2.set(e, o.position);
        var E = function(t, e, i, o, l, c) {
            var u = 0;
            if (c === F) {
                if (!function(t, e, n, i) {
                    for (var o = null, a = s(t), l = 0; l < a.length; l++) {
                        var c = a[l];
                        if ("object" === r(c) && null !== c)
                            null === o && (o = new Set),
                            o.add(c);
                        else if (!e.has(c)) {
                            if (n)
                                return !1;
                            if (!H(t, e, c))
                                return !1;
                            null === o && (o = new Set),
                            o.add(c)
                        }
                    }
                    if (null !== o) {
                        for (var u = s(e), h = 0; h < u.length; h++) {
                            var d = u[h];
                            if ("object" === r(d) && null !== d) {
                                if (!W(o, d, n, i))
                                    return !1
                            } else if (!n && !t.has(d) && !W(o, d, n, i))
                                return !1
                        }
                        return 0 === o.size
                    }
                    return !0
                }(t, e, i, l))
                    return !1
            } else if (c === j) {
                if (!function(t, e, i, s) {
                    for (var o = null, l = a(t), c = 0; c < l.length; c++) {
                        var u = n(l[c], 2)
                          , h = u[0]
                          , d = u[1];
                        if ("object" === r(h) && null !== h)
                            null === o && (o = new Set),
                            o.add(h);
                        else {
                            var f = e.get(h);
                            if (void 0 === f && !e.has(h) || !U(d, f, i, s)) {
                                if (i)
                                    return !1;
                                if (!$(t, e, h, d, s))
                                    return !1;
                                null === o && (o = new Set),
                                o.add(h)
                            }
                        }
                    }
                    if (null !== o) {
                        for (var p = a(e), m = 0; m < p.length; m++) {
                            var g = n(p[m], 2)
                              , y = (h = g[0],
                            g[1]);
                            if ("object" === r(h) && null !== h) {
                                if (!G(o, t, h, y, i, s))
                                    return !1
                            } else if (!(i || t.has(h) && U(t.get(h), y, !1, s) || G(o, t, h, y, !1, s)))
                                return !1
                        }
                        return 0 === o.size
                    }
                    return !0
                }(t, e, i, l))
                    return !1
            } else if (c === L)
                for (; u < t.length; u++) {
                    if (!d(t, u)) {
                        if (d(e, u))
                            return !1;
                        for (var h = Object.keys(t); u < h.length; u++) {
                            var f = h[u];
                            if (!d(e, f) || !U(t[f], e[f], i, l))
                                return !1
                        }
                        return h.length === Object.keys(e).length
                    }
                    if (!d(e, u) || !U(t[u], e[u], i, l))
                        return !1
                }
            for (u = 0; u < o.length; u++) {
                var p = o[u];
                if (!U(t[p], e[p], i, l))
                    return !1
            }
            return !0
        }(t, e, i, u, o, l);
        return o.val1.delete(t),
        o.val2.delete(e),
        E
    }
    function W(t, e, n, r) {
        for (var i = s(t), o = 0; o < i.length; o++) {
            var a = i[o];
            if (U(e, a, n, r))
                return t.delete(a),
                !0
        }
        return !1
    }
    function Y(t) {
        switch (r(t)) {
        case "undefined":
            return null;
        case "object":
            return;
        case "symbol":
            return !1;
        case "string":
            t = +t;
        case "number":
            if (u(t))
                return !1
        }
        return !0
    }
    function H(t, e, n) {
        var r = Y(n);
        return null != r ? r : e.has(r) && !t.has(r)
    }
    function $(t, e, n, r, i) {
        var s = Y(n);
        if (null != s)
            return s;
        var o = e.get(s);
        return !(void 0 === o && !e.has(s) || !U(r, o, !1, i)) && (!t.has(s) && U(r, o, !1, i))
    }
    function G(t, e, n, r, i, o) {
        for (var a = s(t), l = 0; l < a.length; l++) {
            var c = a[l];
            if (U(n, c, i, o) && U(r, e.get(c), i, o))
                return t.delete(c),
                !0
        }
        return !1
    }
    t.exports = {
        isDeepEqual: function(t, e) {
            return U(t, e, D)
        },
        isDeepStrictEqual: function(t, e) {
            return U(t, e, R)
        }
    }
}
)),
o.register("c8Cyq", (function(t, e) {
    var n = o("cOB0F")
      , r = o("1UbTr")
      , i = o("8sYH2")
      , s = o("91M8b")
      , a = o("hCf9I")
      , l = n(s(), Number);
    r(l, {
        getPolyfill: s,
        implementation: i,
        shim: a
    }),
    t.exports = l
}
)),
o.register("8sYH2", (function(t, e) {
    t.exports = function(t) {
        return t != t
    }
}
)),
o.register("91M8b", (function(t, e) {
    var n = o("8sYH2");
    t.exports = function() {
        return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : n
    }
}
)),
o.register("hCf9I", (function(t, e) {
    var n = o("1UbTr")
      , r = o("91M8b");
    t.exports = function() {
        var t = r();
        return n(Number, {
            isNaN: t
        }, {
            isNaN: function() {
                return Number.isNaN !== t
            }
        }),
        t
    }
}
)),
o.register("7RrfS", (function(t, e) {
    var n = o("6ZWSX").Buffer
      , r = t.exports && t.exports.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.numbersTypeMap = t.exports.bool = t.exports.i512 = t.exports.i256 = t.exports.i128 = t.exports.i64 = t.exports.i32 = t.exports.i16 = t.exports.i8 = t.exports.u512 = t.exports.u256 = t.exports.u128 = t.exports.u64 = t.exports.u32 = t.exports.u16 = t.exports.u8 = void 0;
    const i = r(o("dEXSZ"));
    var s = o("kOHSh");
    function a(t, e) {
        return {
            write: function(t, e, r) {
                const s = (i.default.isBN(r) ? r : new i.default(r)).toArray("le", this.byteSize);
                n.from(s).copy(t, e, 0, this.byteSize)
            },
            read: function(t, e) {
                const n = t.slice(e, e + this.byteSize);
                return new i.default(n,"le")
            },
            byteSize: t,
            description: e
        }
    }
    function l(t, e) {
        const r = 8 * t;
        return {
            write: function(t, e, s) {
                const o = (i.default.isBN(s) ? s : new i.default(s)).toTwos(r).toArray("le", this.byteSize);
                n.from(o).copy(t, e, 0, this.byteSize)
            },
            read: function(t, e) {
                const n = t.slice(e, e + this.byteSize);
                return new i.default(n,"le").fromTwos(r)
            },
            byteSize: t,
            description: e
        }
    }
    t.exports.u8 = {
        write: function(t, e, n) {
            t.writeUInt8(n, e)
        },
        read: function(t, e) {
            return t.readUInt8(e)
        },
        byteSize: 1,
        description: "u8"
    },
    t.exports.u16 = {
        write: function(t, e, n) {
            t.writeUInt16LE(n, e)
        },
        read: function(t, e) {
            return t.readUInt16LE(e)
        },
        byteSize: 2,
        description: "u16"
    },
    t.exports.u32 = {
        write: function(t, e, n) {
            t.writeUInt32LE(n, e)
        },
        read: function(t, e) {
            return t.readUInt32LE(e)
        },
        byteSize: 4,
        description: "u32"
    },
    t.exports.u64 = a(8, "u64"),
    t.exports.u128 = a(16, "u128"),
    t.exports.u256 = a(32, "u256"),
    t.exports.u512 = a(64, "u512"),
    t.exports.i8 = {
        write: function(t, e, n) {
            t.writeInt8(n, e)
        },
        read: function(t, e) {
            return t.readInt8(e)
        },
        byteSize: 1,
        description: "i8"
    },
    t.exports.i16 = {
        write: function(t, e, n) {
            t.writeInt16LE(n, e)
        },
        read: function(t, e) {
            return t.readInt16LE(e)
        },
        byteSize: 2,
        description: "i16"
    },
    t.exports.i32 = {
        write: function(t, e, n) {
            t.writeInt32LE(n, e)
        },
        read: function(t, e) {
            return t.readInt32LE(e)
        },
        byteSize: 4,
        description: "i32"
    },
    t.exports.i64 = l(8, "i64"),
    t.exports.i128 = l(16, "i128"),
    t.exports.i256 = l(32, "i256"),
    t.exports.i512 = l(64, "i512"),
    t.exports.bool = {
        write: function(e, n, r) {
            const i = r ? 1 : 0;
            t.exports.u8.write(e, n, i)
        },
        read: function(e, n) {
            return 1 === t.exports.u8.read(e, n)
        },
        byteSize: 1,
        description: "bool"
    },
    t.exports.numbersTypeMap = {
        u8: {
            beet: "u8",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "number"
        },
        u16: {
            beet: "u16",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "number"
        },
        u32: {
            beet: "u32",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "number"
        },
        i8: {
            beet: "i8",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "number"
        },
        i16: {
            beet: "i16",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "number"
        },
        i32: {
            beet: "i32",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "number"
        },
        bool: {
            beet: "bool",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "boolean"
        },
        u64: {
            beet: "u64",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "bignum",
            pack: s.BEET_PACKAGE
        },
        u128: {
            beet: "u128",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "bignum",
            pack: s.BEET_PACKAGE
        },
        u256: {
            beet: "u256",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "bignum",
            pack: s.BEET_PACKAGE
        },
        u512: {
            beet: "u512",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "bignum",
            pack: s.BEET_PACKAGE
        },
        i64: {
            beet: "i64",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "bignum",
            pack: s.BEET_PACKAGE
        },
        i128: {
            beet: "i128",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "bignum",
            pack: s.BEET_PACKAGE
        },
        i256: {
            beet: "i256",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "bignum",
            pack: s.BEET_PACKAGE
        },
        i512: {
            beet: "i512",
            isFixable: !1,
            sourcePack: s.BEET_PACKAGE,
            ts: "bignum",
            pack: s.BEET_PACKAGE
        }
    }
}
)),
o.register("2xd6i", (function(t, e) {
    var n = t.exports && t.exports.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.UnreachableCaseError = t.exports.stringify = t.exports.bytes = t.exports.beetBytes = t.exports.logTrace = t.exports.logDebug = t.exports.logInfo = t.exports.logError = void 0;
    const r = n(o("1SXIy"))
      , i = n(o("5wDjf"));
    var s = o("kOHSh");
    const {brightBlack: a} = i.default;
    t.exports.logError = (0,
    r.default)("beet:error"),
    t.exports.logInfo = (0,
    r.default)("beet:info"),
    t.exports.logDebug = (0,
    r.default)("beet:debug"),
    t.exports.logTrace = (0,
    r.default)("beet:trace"),
    t.exports.beetBytes = function(t, e=!1) {
        let n;
        if ((0,
        s.isFixableBeet)(t))
            n = "? B";
        else if ((0,
        s.isElementCollectionFixedSizeBeet)(t)) {
            const r = e ? "length" : t.length
              , i = t.lenPrefixByteSize;
            n = i > 0 ? `${i} + (${t.elementByteSize} * ${r}) B  (${t.byteSize} B)` : `(${t.elementByteSize} * ${r}) B (${t.byteSize} B)`
        } else
            n = `${t.byteSize} B`;
        return a(n)
    }
    ,
    t.exports.bytes = function(t) {
        return a(`${t} B`)
    }
    ,
    t.exports.stringify = function(t) {
        return "function" === t.toString ? t.toString() : t
    }
    ;
    class l extends Error {
        constructor(t) {
            super(`Unreachable case: ${t}`)
        }
    }
    t.exports.UnreachableCaseError = l
}
)),
o.register("1SXIy", (function(t, e) {
    var n = o("hPtJY");
    t.exports.formatArgs = function(e) {
        if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff),
        !this.useColors)
            return;
        const n = "color: " + this.color;
        e.splice(1, 0, n, "color: inherit");
        let r = 0
          , i = 0;
        e[0].replace(/%[a-zA-Z%]/g, (t=>{
            "%%" !== t && (r++,
            "%c" === t && (i = r))
        }
        )),
        e.splice(i, 0, n)
    }
    ,
    t.exports.save = function(e) {
        try {
            e ? t.exports.storage.setItem("debug", e) : t.exports.storage.removeItem("debug")
        } catch (t) {}
    }
    ,
    t.exports.load = function() {
        let e;
        try {
            e = t.exports.storage.getItem("debug")
        } catch (t) {}
        !e && void 0 !== n && "env"in n && (e = void 0);
        return e
    }
    ,
    t.exports.useColors = function() {
        return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    }
    ,
    t.exports.storage = function() {
        try {
            return localStorage
        } catch (t) {}
    }(),
    t.exports.destroy = (()=>{
        let t = !1;
        return ()=>{
            t || (t = !0,
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
        }
    }
    )(),
    t.exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"],
    t.exports.log = console.debug || console.log || (()=>{}
    ),
    t.exports = o("7kBR8")(t.exports);
    const {formatters: r} = t.exports;
    r.j = function(t) {
        try {
            return JSON.stringify(t)
        } catch (t) {
            return "[UnexpectedJSONParseError]: " + t.message
        }
    }
}
)),
o.register("7kBR8", (function(t, e) {
    t.exports = function(t) {
        function e(t) {
            let r, i, s, o = null;
            function a(...t) {
                if (!a.enabled)
                    return;
                const n = a
                  , i = Number(new Date)
                  , s = i - (r || i);
                n.diff = s,
                n.prev = r,
                n.curr = i,
                r = i,
                t[0] = e.coerce(t[0]),
                "string" != typeof t[0] && t.unshift("%O");
                let o = 0;
                t[0] = t[0].replace(/%([a-zA-Z%])/g, ((r,i)=>{
                    if ("%%" === r)
                        return "%";
                    o++;
                    const s = e.formatters[i];
                    if ("function" == typeof s) {
                        const e = t[o];
                        r = s.call(n, e),
                        t.splice(o, 1),
                        o--
                    }
                    return r
                }
                )),
                e.formatArgs.call(n, t);
                (n.log || e.log).apply(n, t)
            }
            return a.namespace = t,
            a.useColors = e.useColors(),
            a.color = e.selectColor(t),
            a.extend = n,
            a.destroy = e.destroy,
            Object.defineProperty(a, "enabled", {
                enumerable: !0,
                configurable: !1,
                get: ()=>null !== o ? o : (i !== e.namespaces && (i = e.namespaces,
                s = e.enabled(t)),
                s),
                set: t=>{
                    o = t
                }
            }),
            "function" == typeof e.init && e.init(a),
            a
        }
        function n(t, n) {
            const r = e(this.namespace + (void 0 === n ? ":" : n) + t);
            return r.log = this.log,
            r
        }
        function r(t) {
            return t.toString().substring(2, t.toString().length - 2).replace(/\.\*\?$/, "*")
        }
        return e.debug = e,
        e.default = e,
        e.coerce = function(t) {
            return t instanceof Error ? t.stack || t.message : t
        }
        ,
        e.disable = function() {
            const t = [...e.names.map(r), ...e.skips.map(r).map((t=>"-" + t))].join(",");
            return e.enable(""),
            t
        }
        ,
        e.enable = function(t) {
            let n;
            e.save(t),
            e.namespaces = t,
            e.names = [],
            e.skips = [];
            const r = ("string" == typeof t ? t : "").split(/[\s,]+/)
              , i = r.length;
            for (n = 0; n < i; n++)
                r[n] && ("-" === (t = r[n].replace(/\*/g, ".*?"))[0] ? e.skips.push(new RegExp("^" + t.slice(1) + "$")) : e.names.push(new RegExp("^" + t + "$")))
        }
        ,
        e.enabled = function(t) {
            if ("*" === t[t.length - 1])
                return !0;
            let n, r;
            for (n = 0,
            r = e.skips.length; n < r; n++)
                if (e.skips[n].test(t))
                    return !1;
            for (n = 0,
            r = e.names.length; n < r; n++)
                if (e.names[n].test(t))
                    return !0;
            return !1
        }
        ,
        e.humanize = o("3pRq5"),
        e.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
        }
        ,
        Object.keys(t).forEach((n=>{
            e[n] = t[n]
        }
        )),
        e.names = [],
        e.skips = [],
        e.formatters = {},
        e.selectColor = function(t) {
            let n = 0;
            for (let e = 0; e < t.length; e++)
                n = (n << 5) - n + t.charCodeAt(e),
                n |= 0;
            return e.colors[Math.abs(n) % e.colors.length]
        }
        ,
        e.enable(e.load()),
        e
    }
}
)),
o.register("3pRq5", (function(t, e) {
    var n = 1e3
      , r = 60 * n
      , i = 60 * r
      , s = 24 * i
      , o = 7 * s
      , a = 365.25 * s;
    function l(t, e, n, r) {
        var i = e >= 1.5 * n;
        return Math.round(t / n) + " " + r + (i ? "s" : "")
    }
    t.exports = function(t, e) {
        e = e || {};
        var c, u, h = typeof t;
        if ("string" === h && t.length > 0)
            return function(t) {
                if ((t = String(t)).length > 100)
                    return;
                var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);
                if (!e)
                    return;
                var l = parseFloat(e[1]);
                switch ((e[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                    return l * a;
                case "weeks":
                case "week":
                case "w":
                    return l * o;
                case "days":
                case "day":
                case "d":
                    return l * s;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                    return l * i;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                    return l * r;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                    return l * n;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                    return l;
                default:
                    return
                }
            }(t);
        if ("number" === h && isFinite(t))
            return e.long ? (c = t,
            (u = Math.abs(c)) >= s ? l(c, u, s, "day") : u >= i ? l(c, u, i, "hour") : u >= r ? l(c, u, r, "minute") : u >= n ? l(c, u, n, "second") : c + " ms") : function(t) {
                var e = Math.abs(t);
                return e >= s ? Math.round(t / s) + "d" : e >= i ? Math.round(t / i) + "h" : e >= r ? Math.round(t / r) + "m" : e >= n ? Math.round(t / n) + "s" : t + "ms"
            }(t);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t))
    }
}
)),
o.register("5wDjf", (function(t, e) {
    var n = {
        white: 37,
        black: 30,
        blue: 34,
        cyan: 36,
        green: 32,
        magenta: 35,
        red: 31,
        yellow: 33,
        brightBlack: 90,
        brightRed: 91,
        brightGreen: 92,
        brightYellow: 93,
        brightBlue: 94,
        brightMagenta: 95,
        brightCyan: 96,
        brightWhite: 97
    }
      , r = {
        bgBlack: 40,
        bgRed: 41,
        bgGreen: 42,
        bgYellow: 43,
        bgBlue: 44,
        bgMagenta: 45,
        bgCyan: 46,
        bgWhite: 47,
        bgBrightBlack: 100,
        bgBrightRed: 101,
        bgBrightGreen: 102,
        bgBrightYellow: 103,
        bgBrightBlue: 104,
        bgBrightMagenta: 105,
        bgBrightCyan: 106,
        bgBrightWhite: 107
    }
      , i = {}
      , s = {}
      , o = {};
    Object.keys(n).forEach((function(t) {
        var e = i[t] = "[" + n[t] + "m"
          , r = s[t] = "[39m";
        o[t] = function(t) {
            return e + t + r
        }
    }
    )),
    Object.keys(r).forEach((function(t) {
        var e = i[t] = "[" + r[t] + "m"
          , n = s[t] = "[49m";
        o[t] = function(t) {
            return e + t + n
        }
    }
    )),
    t.exports = o,
    o.open = i,
    o.close = s
}
)),
o.register("l9HYk", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.fixBeetFromValue = t.exports.fixBeetFromData = void 0;
    var n = o("kOHSh")
      , r = o("2xd6i");
    t.exports.fixBeetFromData = function(t, e, i) {
        if ((0,
        n.isFixedSizeBeet)(t))
            return t;
        if ((0,
        n.isFixableBeet)(t))
            return t.toFixedFromData(e, i);
        throw new r.UnreachableCaseError(t)
    }
    ,
    t.exports.fixBeetFromValue = function(t, e) {
        if ((0,
        n.isFixedSizeBeet)(t))
            return t;
        if ((0,
        n.isFixableBeet)(t))
            return t.toFixedFromValue(e);
        throw new r.UnreachableCaseError(t)
    }
}
)),
o.register("iadi0", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.compositesTypeMap = t.exports.coption = t.exports.coptionSome = t.exports.coptionNone = t.exports.isNoneBuffer = t.exports.isSomeBuffer = void 0;
    var n = o("aLUwE")
      , r = o("kOHSh")
      , i = (r = o("kOHSh"),
    o("2xd6i"))
      , s = o("l9HYk");
    const a = 0
      , l = 1;
    function c(t, e) {
        return t[e] === l
    }
    function u(t, e) {
        return t[e] === a
    }
    function h(t) {
        return (0,
        i.logTrace)(`coptionNone(${t})`),
        {
            write: function(t, e, r) {
                (0,
                n.strict)(null == r, "coptionNone can only handle `null` values"),
                t[e] = a
            },
            read: function(t, e) {
                return (0,
                n.strict)(u(t, e), "coptionNone can only handle `NONE` data"),
                null
            },
            byteSize: 1,
            description: `COption<None(${t})>`
        }
    }
    function d(t) {
        const e = 1 + t.byteSize
          , s = {
            write: function(e, i, s) {
                (0,
                r.assertFixedSizeBeet)(t, `coption inner type ${t.description} needs to be fixed before calling write`),
                (0,
                n.strict)(null != s, "coptionSome cannot handle `null` values"),
                e[i] = l,
                t.write(e, i + 1, s)
            },
            read: function(e, i) {
                return (0,
                r.assertFixedSizeBeet)(t, `coption inner type ${t.description} needs to be fixed before calling read`),
                (0,
                n.strict)(c(e, i), "coptionSome can only handle `SOME` data"),
                t.read(e, i + 1)
            },
            description: `COption<${t.description}>[1 + ${t.byteSize}]`,
            byteSize: e,
            inner: t
        };
        return (0,
        i.logTrace)(s.description),
        s
    }
    t.exports.isSomeBuffer = c,
    t.exports.isNoneBuffer = u,
    t.exports.coptionNone = h,
    t.exports.coptionSome = d,
    t.exports.coption = function(t) {
        return {
            toFixedFromData(e, r) {
                if (c(e, r)) {
                    return d((0,
                    s.fixBeetFromData)(t, e, r + 1))
                }
                return (0,
                n.strict)(u(e, r), `Expected ${e} to hold a COption`),
                h(t.description)
            },
            toFixedFromValue: e=>null == e ? h(t.description) : d((0,
            s.fixBeetFromValue)(t, e)),
            description: `COption<${t.description}>`
        }
    }
    ,
    t.exports.compositesTypeMap = {
        option: {
            beet: "coption",
            isFixable: !0,
            sourcePack: r.BEET_PACKAGE,
            ts: "COption<Inner>",
            arg: r.BEET_TYPE_ARG_INNER,
            pack: r.BEET_PACKAGE
        }
    }
}
)),
o.register("981vi", (function(t, e) {
    var n = o("6ZWSX").Buffer;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.stringTypeMap = t.exports.utf8String = t.exports.fixedSizeUtf8String = void 0;
    var r = o("kOHSh")
      , i = o("aLUwE")
      , s = o("7RrfS")
      , a = o("2xd6i");
    t.exports.fixedSizeUtf8String = t=>({
        write: function(e, r, o) {
            const a = n.from(o, "utf8");
            i.strict.equal(a.byteLength, t, `${o} has invalid byte size`),
            s.u32.write(e, r, t),
            a.copy(e, r + 4, 0, t)
        },
        read: function(e, n) {
            const r = s.u32.read(e, n);
            i.strict.equal(r, t, "invalid byte size");
            return e.slice(n + 4, n + 4 + t).toString("utf8")
        },
        elementByteSize: 1,
        length: t,
        lenPrefixByteSize: 4,
        byteSize: 4 + t,
        description: `Utf8String(4 + ${t})`
    }),
    t.exports.utf8String = {
        toFixedFromData(e, n) {
            const r = s.u32.read(e, n);
            return (0,
            a.logTrace)(`${this.description}[${r}]`),
            (0,
            t.exports.fixedSizeUtf8String)(r)
        },
        toFixedFromValue(e) {
            const r = n.from(e).byteLength;
            return (0,
            t.exports.fixedSizeUtf8String)(r)
        },
        description: "Utf8String"
    },
    t.exports.stringTypeMap = {
        fixedSizeString: {
            beet: "fixedSizeUtf8String",
            isFixable: !1,
            sourcePack: r.BEET_PACKAGE,
            ts: "string",
            arg: r.BEET_TYPE_ARG_LEN
        },
        string: {
            beet: "utf8String",
            isFixable: !0,
            sourcePack: r.BEET_PACKAGE,
            ts: "string"
        }
    }
}
)),
o.register("3MHbE", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.enumsTypeMap = t.exports.dataEnum = t.exports.uniformDataEnum = t.exports.fixedScalarEnum = void 0;
    var n = o("kOHSh")
      , r = o("7RrfS")
      , i = o("aLUwE")
      , s = o("4kKfe")
      , a = o("d5fNB")
      , l = o("i0sX8");
    function c(t, e) {
        return e ? `${t}` : t
    }
    function u(t, e, n) {
        return {
            write(n, i, s) {
                r.u8.write(n, i, e),
                t.write(n, i + r.u8.byteSize, s)
            },
            read(e, i) {
                const s = t.read(e, i + r.u8.byteSize);
                return {
                    __kind: n,
                    ...s
                }
            },
            byteSize: t.byteSize + r.u8.byteSize,
            description: `EnumData<${t.description}>`
        }
    }
    t.exports.fixedScalarEnum = function(t) {
        const e = Object.keys(t);
        return {
            write(n, s, o) {
                const a = "number" == typeof o
                  , l = c(o, a);
                if (e.includes(l) || i.strict.fail(`${o} should be a variant of the provided enum type, i.e. [ ${Object.values(t).join(", ")} ], but isn't`),
                a)
                    r.u8.write(n, s, o);
                else {
                    const e = t[l];
                    r.u8.write(n, s, e)
                }
            },
            read(n, s) {
                const o = r.u8.read(n, s)
                  , a = "number" == typeof o
                  , l = c(o, a);
                return e.includes(l) || i.strict.fail(`${o} should be a of a variant of the provided enum type, i.e. [ ${Object.values(t).join(", ")} ], but isn't`),
                a ? o : t[l]
            },
            byteSize: r.u8.byteSize,
            description: "Enum"
        }
    }
    ,
    t.exports.uniformDataEnum = function(t) {
        return {
            write: function(e, n, i) {
                r.u8.write(e, n, i.kind),
                t.write(e, n + 1, i.data)
            },
            read: function(e, n) {
                return {
                    kind: r.u8.read(e, n),
                    data: t.read(e, n + 1)
                }
            },
            byteSize: 1 + t.byteSize,
            description: `UniformDataEnum<${t.description}>`
        }
    }
    ,
    t.exports.dataEnum = function(t) {
        for (const [e,n] of t)
            (0,
            i.strict)((0,
            s.isBeetStruct)(n) || (0,
            a.isFixableBeetStruct)(n) || n === l.unit, "dataEnum: variants must be a data beet struct or a scalar unit");
        return {
            toFixedFromData(e, s) {
                const o = r.u8.read(e, s)
                  , a = t[o];
                (0,
                i.strict)(null != a, `Discriminant ${o} out of range for ${t.length} variants`);
                const [l,c] = a;
                return u((0,
                n.isFixedSizeBeet)(c) ? c : c.toFixedFromData(e, s + 1), o, l)
            },
            toFixedFromValue(e) {
                if (null == e.__kind) {
                    const n = Object.keys(e).join(", ")
                      , r = t.map((([t])=>t)).join(", ");
                    i.strict.fail(`Value with fields [ ${n} ] is missing __kind, which needs to be set to one of [ ${r} ]`)
                }
                const r = t.findIndex((([t])=>t === e.__kind));
                if (r < 0) {
                    const n = t.map((([t])=>t)).join(", ");
                    i.strict.fail(`${e.__kind} is not a valid kind, needs to be one of [ ${n} ]`)
                }
                const s = t[r]
                  , {__kind: o, ...a} = e
                  , [l,c] = s;
                return u((0,
                n.isFixedSizeBeet)(c) ? c : c.toFixedFromValue(a), r, l)
            },
            description: `DataEnum<${t.length} variants>`
        }
    }
    ,
    t.exports.enumsTypeMap = {
        fixedScalarEnum: {
            beet: "fixedScalarEnum",
            isFixable: !1,
            sourcePack: n.BEET_PACKAGE,
            ts: "<TypeName>",
            arg: n.BEET_TYPE_ARG_INNER,
            pack: n.BEET_PACKAGE
        },
        dataEnum: {
            beet: "dataEnum",
            isFixable: !1,
            sourcePack: n.BEET_PACKAGE,
            ts: "DataEnum<Kind, Inner>",
            arg: n.BEET_TYPE_ARG_INNER,
            pack: n.BEET_PACKAGE
        }
    }
}
)),
o.register("4kKfe", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.BeetArgsStruct = t.exports.isBeetStruct = t.exports.BeetStruct = void 0;
    var n = o("inPTV")
      , r = o("2xd6i");
    class i {
        constructor(t, e, n=i.description) {
            if (this.fields = t,
            this.construct = e,
            this.description = n,
            this.byteSize = this.getByteSize(),
            r.logDebug.enabled) {
                const e = t.map((([t,e])=>`${String(t)}: ${e.description} ${(0,
                r.beetBytes)(e)}`)).join("\n  ");
                (0,
                r.logDebug)(`struct ${n} {\n  ${e}\n} ${(0,
                r.beetBytes)(this)}`)
            }
        }
        read(t, e) {
            const [n] = this.deserialize(t, e);
            return n
        }
        write(t, e, n) {
            const [r,i] = this.serialize(n);
            r.copy(t, e, 0, i)
        }
        deserialize(t, e=0) {
            r.logTrace.enabled && ((0,
            r.logTrace)("deserializing [%s] from %d bytes buffer", this.description, t.byteLength),
            (0,
            r.logTrace)(t),
            (0,
            r.logTrace)(t.toJSON().data));
            const i = new n.BeetReader(t,e)
              , s = i.readStruct(this.fields);
            return [this.construct(s), i.offset]
        }
        serialize(t, e=this.byteSize) {
            (0,
            r.logTrace)("serializing [%s] %o to %d bytes buffer", this.description, t, e);
            const i = new n.BeetWriter(e);
            return i.writeStruct(t, this.fields),
            [i.buffer, i.offset]
        }
        getByteSize() {
            return this.fields.reduce(((t,[e,n])=>t + n.byteSize), 0)
        }
        get type() {
            return i.TYPE
        }
    }
    t.exports.BeetStruct = i,
    i.description = "BeetStruct",
    i.TYPE = "BeetStruct",
    t.exports.isBeetStruct = function(t) {
        return t.type === i.TYPE
    }
    ;
    class s extends i {
        constructor(t, e=s.description) {
            super(t, (t=>t), e)
        }
    }
    t.exports.BeetArgsStruct = s,
    s.description = "BeetArgsStruct"
}
)),
o.register("inPTV", (function(t, e) {
    var n = o("6ZWSX").Buffer;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.BeetReader = t.exports.BeetWriter = void 0;
    var r = o("aLUwE");
    t.exports.BeetWriter = class {
        constructor(t) {
            this.buf = n.alloc(t),
            this._offset = 0
        }
        get buffer() {
            return this.buf
        }
        get offset() {
            return this._offset
        }
        maybeResize(t) {
            this._offset + t > this.buf.length && r.strict.fail(`We shouldn't ever need to resize, but ${this._offset + t} > ${this.buf.length}`)
        }
        write(t, e) {
            this.maybeResize(t.byteSize),
            t.write(this.buf, this._offset, e),
            this._offset += t.byteSize
        }
        writeStruct(t, e) {
            for (const [n,r] of e) {
                const e = t[n];
                this.write(r, e)
            }
        }
    }
    ;
    t.exports.BeetReader = class {
        constructor(t, e=0) {
            this.buffer = t,
            this._offset = e
        }
        get offset() {
            return this._offset
        }
        read(t) {
            const e = t.read(this.buffer, this._offset);
            return this._offset += t.byteSize,
            e
        }
        readStruct(t) {
            const e = {};
            for (const [n,r] of t)
                e[n] = this.read(r);
            return e
        }
    }
}
)),
o.register("d5fNB", (function(t, e) {
    var n = t.exports && t.exports.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.FixableBeetArgsStruct = t.exports.isFixableBeetStruct = t.exports.FixableBeetStruct = void 0;
    var r = o("l9HYk")
      , i = o("4kKfe")
      , s = o("kOHSh")
      , a = o("aLUwE")
      , l = o("2xd6i");
    const c = n(o("5wDjf"))
      , {brightBlack: u} = c.default;
    class h {
        constructor(t, e, n=h.description) {
            this.fields = t,
            this.construct = e,
            this.description = n;
            let r = 0;
            if (l.logDebug.enabled) {
                const e = t.map((([t,e])=>((0,
                s.isFixedSizeBeet)(e) && (r += e.byteSize),
                `${t}: ${e.description} ${(0,
                l.beetBytes)(e)}`))).join("\n  ")
                  , i = `> ${r} B`;
                (0,
                l.logDebug)(`struct ${n} {\n  ${e}\n} ${u(i)}`)
            }
        }
        deserialize(t, e=0) {
            return this.toFixedFromData(t, e).deserialize(t, e)
        }
        serialize(t, e) {
            return this.toFixedFromValue(t).serialize(t, e)
        }
        toFixedFromData(t, e) {
            let n = e;
            const s = new Array(this.fields.length);
            for (let e = 0; e < this.fields.length; e++) {
                const [i,o] = this.fields[e]
                  , a = (0,
                r.fixBeetFromData)(o, t, n);
                s[e] = [i, a],
                n += a.byteSize
            }
            return this.description !== h.description ? new i.BeetStruct(s,this.construct,this.description) : new i.BeetStruct(s,this.construct)
        }
        toFixedFromValue(t) {
            const e = Object.keys(t)
              , n = new Array(this.fields.length);
            for (let i = 0; i < this.fields.length; i++) {
                const [s,o] = this.fields[i];
                (0,
                a.strict)(e.includes(s), `Value with keys [ ${e} ] should include struct key '${s}' but doesn't.`);
                const l = t[s]
                  , c = (0,
                r.fixBeetFromValue)(o, l);
                n[i] = [s, c]
            }
            return this.description !== h.description ? new i.BeetStruct(n,this.construct,this.description) : new i.BeetStruct(n,this.construct)
        }
        get type() {
            return h.TYPE
        }
    }
    t.exports.FixableBeetStruct = h,
    h.description = "FixableBeetStruct",
    h.TYPE = "FixableBeetStruct",
    t.exports.isFixableBeetStruct = function(t) {
        return t.type === h.TYPE
    }
    ;
    class d extends h {
        constructor(t, e=d.description) {
            super(t, (t=>t), e)
        }
    }
    t.exports.FixableBeetArgsStruct = d,
    d.description = "FixableBeetArgsStruct"
}
)),
o.register("i0sX8", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.unitTypeMap = t.exports.unit = void 0;
    var n = o("kOHSh");
    t.exports.unit = {
        write: function(t, e, n) {},
        read: function(t, e) {},
        byteSize: 0,
        description: "unit"
    },
    t.exports.unitTypeMap = {
        unit: {
            beet: "unit",
            isFixable: !1,
            sourcePack: n.BEET_PACKAGE,
            ts: "void"
        }
    }
}
)),
o.register("5vXUZ", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.aliasesTypeMap = t.exports.bytes = void 0;
    var n = o("3rgjF");
    t.exports.bytes = n.uint8Array,
    t.exports.aliasesTypeMap = {
        bytes: n.collectionsTypeMap.Uint8Array
    }
}
)),
o.register("ioTrE", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.tuplesTypeMap = t.exports.tuple = t.exports.fixedSizeTuple = void 0;
    var n = o("kOHSh")
      , r = o("aLUwE")
      , i = o("l9HYk");
    function s(t) {
        const e = t.length
          , n = t.map((t=>t.description))
          , i = t.map((t=>t.byteSize));
        return {
            write: function(n, i, s) {
                r.strict.equal(s.length, e, `tuple value element size ${s.length} should match len ${e}`);
                let o = i;
                for (let r = 0; r < e; r++) {
                    const e = s[r]
                      , i = t[r];
                    i.write(n, o, e),
                    o += i.byteSize
                }
            },
            read: function(n, r) {
                const i = [];
                let s = r;
                for (let r = 0; r < e; r++) {
                    const e = t[r];
                    i[r] = e.read(n, s),
                    s += e.byteSize
                }
                return i
            },
            byteSize: i.reduce(((t,e)=>t + e), 0),
            length: e,
            description: `FixedSizeTuple<${n.join(",")}>[ ${i.join(", ")} ]`
        }
    }
    t.exports.fixedSizeTuple = s,
    t.exports.tuple = function(t) {
        const e = t.length;
        return {
            toFixedFromData(n, r) {
                let o = r;
                const a = new Array(e);
                for (let r = 0; r < e; r++) {
                    const e = (0,
                    i.fixBeetFromData)(t[r], n, o);
                    a[r] = e,
                    o += e.byteSize
                }
                return s(a)
            },
            toFixedFromValue(n) {
                (0,
                r.strict)(Array.isArray(n), `${n} should be an array of tuple values`),
                r.strict.equal(n.length, e, `There should be ${e} tuple values, but there are ${n.length}`);
                const o = new Array(e);
                for (let e = 0; e < n.length; e++) {
                    const r = (0,
                    i.fixBeetFromValue)(t[e], n[e]);
                    o[e] = r
                }
                return s(o)
            },
            description: `Tuple<${t.map((t=>t.description)).join(",")}>`
        }
    }
    ,
    t.exports.tuplesTypeMap = {
        Tuple: {
            beet: "tuple",
            isFixable: !0,
            sourcePack: n.BEET_PACKAGE,
            ts: "[__tuple_elements__]"
        },
        FixedSizeTuple: {
            beet: "fixedSizeTuple",
            isFixable: !1,
            sourcePack: n.BEET_PACKAGE,
            ts: "[__tuple_elements__]"
        }
    }
}
)),
o.register("ipcLD", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.mapsTypeMap = t.exports.map = void 0;
    var n = o("kOHSh")
      , r = o("7RrfS")
      , i = o("2xd6i")
      , s = o("aLUwE");
    function a(t, e, o, a) {
        const l = (0,
        n.isFixedSizeBeet)(t)
          , c = (0,
        n.isFixedSizeBeet)(e);
        const {elementByteSize: u, byteSize: h} = function() {
            if (l && c) {
                const n = t.byteSize + e.byteSize;
                return {
                    elementByteSize: n,
                    byteSize: 4 + a * n
                }
            }
            if (l) {
                let e = 0;
                for (const [t,n] of o.values())
                    e += n.byteSize;
                return {
                    elementByteSize: t.byteSize + Math.ceil(e / a),
                    byteSize: 4 + t.byteSize * a + e
                }
            }
            if (c) {
                let t = 0;
                for (const [e,n] of o.values())
                    t += e.byteSize;
                return {
                    elementByteSize: Math.ceil(t / a) + e.byteSize,
                    byteSize: 4 + t + e.byteSize * a
                }
            }
            {
                let t = 0
                  , e = 0;
                for (const [n,r] of o.values())
                    t += n.byteSize,
                    e += r.byteSize;
                return {
                    elementByteSize: Math.ceil(t / a + e / a),
                    byteSize: 4 + t + e
                }
            }
        }();
        return {
            write: function(n, u, h) {
                let d = u + 4
                  , f = 0;
                for (const [r,a] of h.entries()) {
                    let u = l ? t : null
                      , h = c ? e : null;
                    if (null == u || null == h) {
                        const t = o.get(r);
                        (0,
                        s.strict)(null != t, `Should be able to find beet els for ${(0,
                        i.stringify)(r)}, but could not`),
                        null != u || (u = t[0]),
                        null != h || (h = t[1])
                    }
                    u.write(n, d, r),
                    d += u.byteSize,
                    h.write(n, d, a),
                    d += h.byteSize,
                    f++
                }
                r.u32.write(n, u, f),
                s.strict.equal(f, a, `Expected map to have size ${a}, but has ${f}.`)
            },
            read: function(n, i) {
                const o = r.u32.read(n, i);
                s.strict.equal(o, a, `Expected map to have size ${a}, but has ${o}.`);
                let u = i + 4;
                const h = new Map;
                for (let r = 0; r < o; r++) {
                    const r = l ? t : t.toFixedFromData(n, u)
                      , i = r.read(n, u);
                    u += r.byteSize;
                    const s = c ? e : e.toFixedFromData(n, u)
                      , o = s.read(n, u);
                    u += s.byteSize,
                    h.set(i, o)
                }
                return h
            },
            elementByteSize: u,
            byteSize: h,
            length: a,
            lenPrefixByteSize: 4,
            description: `Map<${t.description}, ${e.description}>`
        }
    }
    t.exports.map = function(t, e) {
        const i = (0,
        n.isFixedSizeBeet)(t)
          , s = (0,
        n.isFixedSizeBeet)(e);
        return {
            toFixedFromData(n, o) {
                const l = r.u32.read(n, o);
                let c = o + 4;
                if (i && s)
                    return a(t, e, new Map, l);
                const u = new Map;
                for (let r = 0; r < l; r++) {
                    const r = i ? t : t.toFixedFromData(n, c)
                      , o = r.read(n, c);
                    c += r.byteSize;
                    const a = s ? e : e.toFixedFromData(n, c);
                    c += a.byteSize,
                    u.set(o, [r, a])
                }
                return a(t, e, u, l)
            },
            toFixedFromValue(n) {
                const r = n.size;
                if (i && s)
                    return a(t, e, new Map, r);
                const o = new Map;
                for (const [r,a] of n) {
                    const n = i ? t : t.toFixedFromValue(r)
                      , l = s ? e : e.toFixedFromValue(a);
                    o.set(r, [n, l])
                }
                return a(t, e, o, r)
            },
            description: `FixableMap<${t.description}, ${e.description}>`
        }
    }
    ,
    t.exports.mapsTypeMap = {
        Map: {
            beet: "map",
            isFixable: !0,
            sourcePack: n.BEET_PACKAGE,
            ts: "Map"
        }
    }
}
)),
o.register("dWJUH", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.setsTypeMap = t.exports.set = void 0;
    var n = o("kOHSh")
      , r = o("7RrfS")
      , i = o("2xd6i")
      , s = o("aLUwE");
    function a(t, e, o) {
        const a = (0,
        n.isFixedSizeBeet)(t);
        const {elementByteSize: l, byteSize: c} = function() {
            if (a) {
                const e = t.byteSize;
                return {
                    elementByteSize: e,
                    byteSize: 4 + o * e
                }
            }
            {
                let t = 0;
                for (const n of e.values())
                    t += n.byteSize;
                return {
                    elementByteSize: Math.ceil(t / o),
                    byteSize: 4 + t
                }
            }
        }();
        return {
            write: function(n, l, c) {
                let u = l + 4
                  , h = 0;
                for (const r of c.keys()) {
                    let o = a ? t : null;
                    if (null == o) {
                        const t = e.get(r);
                        (0,
                        s.strict)(null != t, `Should be able to find beet el for ${(0,
                        i.stringify)(r)}, but could not`),
                        null != o || (o = t)
                    }
                    o.write(n, u, r),
                    u += o.byteSize,
                    h++
                }
                r.u32.write(n, l, h),
                s.strict.equal(h, o, `Expected set to have size ${o}, but has ${h}.`)
            },
            read: function(e, n) {
                const i = r.u32.read(e, n);
                s.strict.equal(i, o, `Expected set to have size ${o}, but has ${i}.`);
                let l = n + 4;
                const c = new Set;
                for (let n = 0; n < i; n++) {
                    const n = a ? t : t.toFixedFromData(e, l)
                      , r = n.read(e, l);
                    l += n.byteSize,
                    c.add(r)
                }
                return c
            },
            elementByteSize: l,
            byteSize: c,
            length: o,
            lenPrefixByteSize: 4,
            description: `Set<${t.description}>`
        }
    }
    t.exports.set = function(t) {
        const e = (0,
        n.isFixedSizeBeet)(t);
        return {
            toFixedFromData(n, i) {
                const s = r.u32.read(n, i);
                let o = i + 4;
                if (e)
                    return a(t, new Map, s);
                const l = new Map;
                for (let r = 0; r < s; r++) {
                    const r = e ? t : t.toFixedFromData(n, o)
                      , i = r.read(n, o);
                    o += r.byteSize,
                    l.set(i, r)
                }
                return a(t, l, s)
            },
            toFixedFromValue(n) {
                const r = n.size;
                if (e)
                    return a(t, new Map, r);
                const i = new Map;
                for (const r of n) {
                    const n = e ? t : t.toFixedFromValue(r);
                    i.set(r, n)
                }
                return a(t, i, r)
            },
            description: `FixableSet<${t.description}>`
        }
    }
    ,
    t.exports.setsTypeMap = {
        Set: {
            beet: "set",
            isFixable: !0,
            sourcePack: n.BEET_PACKAGE,
            ts: "Set"
        }
    }
}
)),
o.register("9dESI", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__exportStar || function(t, e) {
        for (var r in t)
            "default" === r || Object.prototype.hasOwnProperty.call(e, r) || n(e, t, r)
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.supportedTypeMap = void 0,
    r(o("1Th4m"), t.exports),
    r(o("if0AM"), t.exports),
    t.exports.supportedTypeMap = o("1Th4m").keysTypeMap
}
)),
o.register("1Th4m", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.keysTypeMap = t.exports.publicKey = void 0;
    var n = o("gNDby");
    const r = (0,
    o("1DULh").fixedSizeUint8Array)(32);
    t.exports.publicKey = {
        write: function(t, e, n) {
            const i = n.toBytes();
            r.write(t, e, i)
        },
        read: function(t, e) {
            const i = r.read(t, e);
            return new n.PublicKey(i)
        },
        byteSize: r.byteSize,
        description: "PublicKey"
    },
    t.exports.keysTypeMap = {
        publicKey: {
            beet: "publicKey",
            isFixable: !1,
            sourcePack: "@metaplex-foundation/beet-solana",
            ts: "PublicKey",
            pack: "@solana/web3.js"
        }
    }
}
)),
o.register("if0AM", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.GpaBuilder = void 0;
    var n = o("1DULh")
      , r = o("aLUwE")
      , i = o("4C3Qc")
      , s = o("cRI1e");
    class a {
        constructor(t, e, n) {
            this.programId = t,
            this.beets = e,
            this.accountSize = n,
            this.config = {}
        }
        _addFilter(t) {
            return null == this.config.filters && (this.config.filters = []),
            this.config.filters.push(t),
            this
        }
        _addInnerFilter(t, e, o) {
            (0,
            i.logTrace)(`gpa.addInnerFilter: ${t}.${e}`);
            const a = this.beets.get(t);
            (0,
            r.strict)(null != a, "Outer filter key needs to be an existing field name");
            const l = a.beet;
            let c = a.offset;
            const u = (0,
            n.isFixedSizeBeet)(l) ? l : l.toFixedFromValue(o);
            let h;
            for (const [t,n] of u.fields) {
                if (t === e) {
                    h = n;
                    break
                }
                c += n.byteSize
            }
            (0,
            r.strict)(null != h, `${e} is not a field of the ${t} struct`);
            const d = (0,
            s.encodeFixedBeet)(h, o);
            return this._addFilter({
                memcmp: {
                    offset: c,
                    bytes: d
                }
            }),
            this
        }
        addInnerFilter(t, e) {
            const n = t.split(".");
            r.strict.equal(n.length, 2, "inner filters can go only one level deep, i.e. 'outer.inner' is ok, but 'outer.inner.deep' is not");
            const [i,s] = n;
            return this._addInnerFilter(i, s, e)
        }
        addFilter(t, e) {
            const i = this.beets.get(t);
            (0,
            r.strict)(null != i, "Filter key needs to be an existing field name");
            const o = (0,
            n.isFixedSizeBeet)(i.beet) ? i.beet : i.beet.toFixedFromValue(e)
              , a = (0,
            s.encodeFixedBeet)(o, e);
            return this._addFilter({
                memcmp: {
                    offset: i.offset,
                    bytes: a
                }
            }),
            this
        }
        dataSize(t) {
            return t = null != t ? t : this.accountSize,
            (0,
            r.strict)(null != t, "for accounts of dynamic size the dataSize arg needs to be provided"),
            this._addFilter({
                dataSize: t
            })
        }
        run(t) {
            return t.getProgramAccounts(this.programId, this.config)
        }
        static fromBeetFields(t, e) {
            const r = new Map;
            let i = 0
              , s = !1;
            for (const [t,o] of e) {
                if (r.set(t, {
                    beet: o,
                    offset: i
                }),
                !(0,
                n.isFixedSizeBeet)(o)) {
                    s = !0;
                    break
                }
                i += o.byteSize
            }
            return new a(t,r,s ? void 0 : i)
        }
        static fromStruct(t, e) {
            return a.fromBeetFields(t, e.fields)
        }
    }
    t.exports.GpaBuilder = a
}
)),
o.register("4C3Qc", (function(t, e) {
    var n = t.exports && t.exports.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.logTrace = t.exports.logDebug = t.exports.logInfo = t.exports.logError = void 0;
    const r = n(o("1SXIy"));
    t.exports.logError = (0,
    r.default)("beet:error"),
    t.exports.logInfo = (0,
    r.default)("beet:info"),
    t.exports.logDebug = (0,
    r.default)("beet:debug"),
    t.exports.logTrace = (0,
    r.default)("beet:trace")
}
)),
o.register("cRI1e", (function(t, e) {
    var n = o("6ZWSX").Buffer
      , r = t.exports && t.exports.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.encodeFixedBeet = void 0;
    const i = r(o("bYkMz"));
    t.exports.encodeFixedBeet = function(t, e) {
        const r = n.alloc(t.byteSize);
        return t.write(r, 0, e),
        i.default.encode(r)
    }
}
)),
o.register("6iBPp", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.voucherBeet = t.exports.Voucher = t.exports.voucherDiscriminator = void 0;
    const s = i(o("gNDby"))
      , a = i(o("1DULh"))
      , l = i(o("9dESI"));
    var c = o("fwbNs");
    t.exports.voucherDiscriminator = [191, 204, 149, 234, 213, 165, 13, 65];
    class u {
        constructor(t, e, n) {
            this.leafSchema = t,
            this.index = e,
            this.merkleTree = n
        }
        static fromArgs(t) {
            return new u(t.leafSchema,t.index,t.merkleTree)
        }
        static fromAccountInfo(t, e=0) {
            return u.deserialize(t.data, e)
        }
        static async fromAccountAddress(t, e, n) {
            const r = await t.getAccountInfo(e, n);
            if (null == r)
                throw new Error(`Unable to find Voucher account at ${e}`);
            return u.fromAccountInfo(r, 0)[0]
        }
        static gpaBuilder(e=new s.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
            return l.GpaBuilder.fromStruct(e, t.exports.voucherBeet)
        }
        static deserialize(e, n=0) {
            return t.exports.voucherBeet.deserialize(e, n)
        }
        serialize() {
            return t.exports.voucherBeet.serialize({
                accountDiscriminator: t.exports.voucherDiscriminator,
                ...this
            })
        }
        static byteSize(e) {
            const n = u.fromArgs(e);
            return t.exports.voucherBeet.toFixedFromValue({
                accountDiscriminator: t.exports.voucherDiscriminator,
                ...n
            }).byteSize
        }
        static async getMinimumBalanceForRentExemption(t, e, n) {
            return e.getMinimumBalanceForRentExemption(u.byteSize(t), n)
        }
        pretty() {
            return {
                leafSchema: this.leafSchema.__kind,
                index: this.index,
                merkleTree: this.merkleTree.toBase58()
            }
        }
    }
    t.exports.Voucher = u,
    t.exports.voucherBeet = new a.FixableBeetStruct([["accountDiscriminator", a.uniformFixedSizeArray(a.u8, 8)], ["leafSchema", c.leafSchemaBeet], ["index", a.u32], ["merkleTree", l.publicKey]],u.fromArgs,"Voucher")
}
)),
o.register("fwbNs", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.leafSchemaBeet = t.exports.isLeafSchemaV1 = void 0;
    const s = i(o("1DULh"))
      , a = i(o("9dESI"));
    t.exports.isLeafSchemaV1 = t=>"V1" === t.__kind,
    t.exports.leafSchemaBeet = s.dataEnum([["V1", new s.BeetArgsStruct([["id", a.publicKey], ["owner", a.publicKey], ["delegate", a.publicKey], ["nonce", s.u64], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)]],'LeafSchemaRecord["V1"]')]])
}
)),
o.register("apO5D", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.errorFromName = t.exports.errorFromCode = t.exports.CollectionMustBeSizedError = t.exports.LeafAuthorityMustSignError = t.exports.UpdateAuthorityIncorrectError = t.exports.AlreadyUnverifiedError = t.exports.AlreadyVerifiedError = t.exports.CollectionNotFoundError = t.exports.CollectionCannotBeVerifiedInThisInstructionError = t.exports.IncorrectOwnerError = t.exports.NumericalOverflowErrorError = t.exports.InsufficientMintCapacityError = t.exports.TreeAuthorityIncorrectError = t.exports.MetadataBasisPointsTooHighError = t.exports.MetadataUriTooLongError = t.exports.MetadataSymbolTooLongError = t.exports.MetadataNameTooLongError = t.exports.CreatorsTooLongError = t.exports.DataHashMismatchError = t.exports.CreatorHashMismatchError = t.exports.NoCreatorsPresentError = t.exports.CreatorNotFoundError = t.exports.CreatorDidNotVerifyError = t.exports.DuplicateCreatorAddressError = t.exports.CreatorShareTotalMustBe100Error = t.exports.UnsupportedSchemaVersionError = t.exports.HashingMismatchError = t.exports.PublicKeyMismatchError = t.exports.AssetOwnerMismatchError = void 0;
    const n = new Map
      , r = new Map;
    class i extends Error {
        constructor() {
            super("Asset Owner Does not match"),
            this.code = 6e3,
            this.name = "AssetOwnerMismatch",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, i)
        }
    }
    t.exports.AssetOwnerMismatchError = i,
    n.set(6e3, (()=>new i)),
    r.set("AssetOwnerMismatch", (()=>new i));
    class s extends Error {
        constructor() {
            super("PublicKeyMismatch"),
            this.code = 6001,
            this.name = "PublicKeyMismatch",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, s)
        }
    }
    t.exports.PublicKeyMismatchError = s,
    n.set(6001, (()=>new s)),
    r.set("PublicKeyMismatch", (()=>new s));
    class o extends Error {
        constructor() {
            super("Hashing Mismatch Within Leaf Schema"),
            this.code = 6002,
            this.name = "HashingMismatch",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, o)
        }
    }
    t.exports.HashingMismatchError = o,
    n.set(6002, (()=>new o)),
    r.set("HashingMismatch", (()=>new o));
    class a extends Error {
        constructor() {
            super("Unsupported Schema Version"),
            this.code = 6003,
            this.name = "UnsupportedSchemaVersion",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, a)
        }
    }
    t.exports.UnsupportedSchemaVersionError = a,
    n.set(6003, (()=>new a)),
    r.set("UnsupportedSchemaVersion", (()=>new a));
    class l extends Error {
        constructor() {
            super("Creator shares must sum to 100"),
            this.code = 6004,
            this.name = "CreatorShareTotalMustBe100",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, l)
        }
    }
    t.exports.CreatorShareTotalMustBe100Error = l,
    n.set(6004, (()=>new l)),
    r.set("CreatorShareTotalMustBe100", (()=>new l));
    class c extends Error {
        constructor() {
            super("No duplicate creator addresses in metadata"),
            this.code = 6005,
            this.name = "DuplicateCreatorAddress",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, c)
        }
    }
    t.exports.DuplicateCreatorAddressError = c,
    n.set(6005, (()=>new c)),
    r.set("DuplicateCreatorAddress", (()=>new c));
    class u extends Error {
        constructor() {
            super("Creator did not verify the metadata"),
            this.code = 6006,
            this.name = "CreatorDidNotVerify",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, u)
        }
    }
    t.exports.CreatorDidNotVerifyError = u,
    n.set(6006, (()=>new u)),
    r.set("CreatorDidNotVerify", (()=>new u));
    class h extends Error {
        constructor() {
            super("Creator not found in creator Vec"),
            this.code = 6007,
            this.name = "CreatorNotFound",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, h)
        }
    }
    t.exports.CreatorNotFoundError = h,
    n.set(6007, (()=>new h)),
    r.set("CreatorNotFound", (()=>new h));
    class d extends Error {
        constructor() {
            super("No creators in creator Vec"),
            this.code = 6008,
            this.name = "NoCreatorsPresent",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, d)
        }
    }
    t.exports.NoCreatorsPresentError = d,
    n.set(6008, (()=>new d)),
    r.set("NoCreatorsPresent", (()=>new d));
    class f extends Error {
        constructor() {
            super("User-provided creator Vec must result in same user-provided creator hash"),
            this.code = 6009,
            this.name = "CreatorHashMismatch",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, f)
        }
    }
    t.exports.CreatorHashMismatchError = f,
    n.set(6009, (()=>new f)),
    r.set("CreatorHashMismatch", (()=>new f));
    class p extends Error {
        constructor() {
            super("User-provided metadata must result in same user-provided data hash"),
            this.code = 6010,
            this.name = "DataHashMismatch",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, p)
        }
    }
    t.exports.DataHashMismatchError = p,
    n.set(6010, (()=>new p)),
    r.set("DataHashMismatch", (()=>new p));
    class m extends Error {
        constructor() {
            super("Creators list too long"),
            this.code = 6011,
            this.name = "CreatorsTooLong",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, m)
        }
    }
    t.exports.CreatorsTooLongError = m,
    n.set(6011, (()=>new m)),
    r.set("CreatorsTooLong", (()=>new m));
    class g extends Error {
        constructor() {
            super("Name in metadata is too long"),
            this.code = 6012,
            this.name = "MetadataNameTooLong",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, g)
        }
    }
    t.exports.MetadataNameTooLongError = g,
    n.set(6012, (()=>new g)),
    r.set("MetadataNameTooLong", (()=>new g));
    class y extends Error {
        constructor() {
            super("Symbol in metadata is too long"),
            this.code = 6013,
            this.name = "MetadataSymbolTooLong",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, y)
        }
    }
    t.exports.MetadataSymbolTooLongError = y,
    n.set(6013, (()=>new y)),
    r.set("MetadataSymbolTooLong", (()=>new y));
    class b extends Error {
        constructor() {
            super("Uri in metadata is too long"),
            this.code = 6014,
            this.name = "MetadataUriTooLong",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, b)
        }
    }
    t.exports.MetadataUriTooLongError = b,
    n.set(6014, (()=>new b)),
    r.set("MetadataUriTooLong", (()=>new b));
    class v extends Error {
        constructor() {
            super("Basis points in metadata cannot exceed 10000"),
            this.code = 6015,
            this.name = "MetadataBasisPointsTooHigh",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, v)
        }
    }
    t.exports.MetadataBasisPointsTooHighError = v,
    n.set(6015, (()=>new v)),
    r.set("MetadataBasisPointsTooHigh", (()=>new v));
    class w extends Error {
        constructor() {
            super("Tree creator or tree delegate must sign."),
            this.code = 6016,
            this.name = "TreeAuthorityIncorrect",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, w)
        }
    }
    t.exports.TreeAuthorityIncorrectError = w,
    n.set(6016, (()=>new w)),
    r.set("TreeAuthorityIncorrect", (()=>new w));
    class x extends Error {
        constructor() {
            super("Not enough unapproved mints left"),
            this.code = 6017,
            this.name = "InsufficientMintCapacity",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, x)
        }
    }
    t.exports.InsufficientMintCapacityError = x,
    n.set(6017, (()=>new x)),
    r.set("InsufficientMintCapacity", (()=>new x));
    class E extends Error {
        constructor() {
            super("NumericalOverflowError"),
            this.code = 6018,
            this.name = "NumericalOverflowError",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, E)
        }
    }
    t.exports.NumericalOverflowErrorError = E,
    n.set(6018, (()=>new E)),
    r.set("NumericalOverflowError", (()=>new E));
    class _ extends Error {
        constructor() {
            super("Incorrect account owner"),
            this.code = 6019,
            this.name = "IncorrectOwner",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, _)
        }
    }
    t.exports.IncorrectOwnerError = _,
    n.set(6019, (()=>new _)),
    r.set("IncorrectOwner", (()=>new _));
    class A extends Error {
        constructor() {
            super("Cannot Verify Collection in this Instruction"),
            this.code = 6020,
            this.name = "CollectionCannotBeVerifiedInThisInstruction",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, A)
        }
    }
    t.exports.CollectionCannotBeVerifiedInThisInstructionError = A,
    n.set(6020, (()=>new A)),
    r.set("CollectionCannotBeVerifiedInThisInstruction", (()=>new A));
    class S extends Error {
        constructor() {
            super("Collection Not Found on Metadata"),
            this.code = 6021,
            this.name = "CollectionNotFound",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, S)
        }
    }
    t.exports.CollectionNotFoundError = S,
    n.set(6021, (()=>new S)),
    r.set("CollectionNotFound", (()=>new S));
    class T extends Error {
        constructor() {
            super("Collection item is already verified."),
            this.code = 6022,
            this.name = "AlreadyVerified",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, T)
        }
    }
    t.exports.AlreadyVerifiedError = T,
    n.set(6022, (()=>new T)),
    r.set("AlreadyVerified", (()=>new T));
    class k extends Error {
        constructor() {
            super("Collection item is already unverified."),
            this.code = 6023,
            this.name = "AlreadyUnverified",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, k)
        }
    }
    t.exports.AlreadyUnverifiedError = k,
    n.set(6023, (()=>new k)),
    r.set("AlreadyUnverified", (()=>new k));
    class I extends Error {
        constructor() {
            super("Incorrect leaf metadata update authority."),
            this.code = 6024,
            this.name = "UpdateAuthorityIncorrect",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, I)
        }
    }
    t.exports.UpdateAuthorityIncorrectError = I,
    n.set(6024, (()=>new I)),
    r.set("UpdateAuthorityIncorrect", (()=>new I));
    class M extends Error {
        constructor() {
            super("This transaction must be signed by either the leaf owner or leaf delegate"),
            this.code = 6025,
            this.name = "LeafAuthorityMustSign",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, M)
        }
    }
    t.exports.LeafAuthorityMustSignError = M,
    n.set(6025, (()=>new M)),
    r.set("LeafAuthorityMustSign", (()=>new M));
    class C extends Error {
        constructor() {
            super("Collection Not Compatable with Compression, Must be Sized"),
            this.code = 6026,
            this.name = "CollectionMustBeSized",
            "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, C)
        }
    }
    t.exports.CollectionMustBeSizedError = C,
    n.set(6026, (()=>new C)),
    r.set("CollectionMustBeSized", (()=>new C)),
    t.exports.errorFromCode = function(t) {
        const e = n.get(t);
        return null != e ? e() : null
    }
    ,
    t.exports.errorFromName = function(t) {
        const e = r.get(t);
        return null != e ? e() : null
    }
}
)),
o.register("46mYT", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__exportStar || function(t, e) {
        for (var r in t)
            "default" === r || Object.prototype.hasOwnProperty.call(e, r) || n(e, t, r)
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    r(o("7GgjK"), t.exports),
    r(o("wmAso"), t.exports),
    r(o("bbF90"), t.exports),
    r(o("44mK7"), t.exports),
    r(o("99h0T"), t.exports),
    r(o("gHOAl"), t.exports),
    r(o("1TGNa"), t.exports),
    r(o("S6Egr"), t.exports),
    r(o("8PAJ0"), t.exports),
    r(o("3A2AA"), t.exports),
    r(o("d8YsU"), t.exports),
    r(o("dtfyi"), t.exports),
    r(o("7XMRi"), t.exports),
    r(o("epq2U"), t.exports),
    r(o("1X08Y"), t.exports),
    r(o("bMpY1"), t.exports)
}
)),
o.register("7GgjK", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createBurnInstruction = t.exports.burnInstructionDiscriminator = t.exports.burnStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    t.exports.burnStruct = new s.BeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)], ["nonce", s.u64], ["index", s.u32]],"BurnInstructionArgs"),
    t.exports.burnInstructionDiscriminator = [116, 110, 29, 56, 107, 219, 42, 93],
    t.exports.createBurnInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.burnStruct.serialize({
            instructionDiscriminator: t.exports.burnInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("wmAso", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createCancelRedeemInstruction = t.exports.cancelRedeemInstructionDiscriminator = t.exports.cancelRedeemStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    t.exports.cancelRedeemStruct = new s.BeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)]],"CancelRedeemInstructionArgs"),
    t.exports.cancelRedeemInstructionDiscriminator = [111, 76, 232, 50, 39, 175, 48, 242],
    t.exports.createCancelRedeemInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.cancelRedeemStruct.serialize({
            instructionDiscriminator: t.exports.cancelRedeemInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !0,
            isSigner: !0
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.voucher,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("bbF90", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createCompressInstruction = t.exports.compressInstructionDiscriminator = t.exports.compressStruct = void 0;
    const s = i(o("dmNue"))
      , a = i(o("1DULh"))
      , l = i(o("gNDby"));
    t.exports.compressStruct = new a.BeetArgsStruct([["instructionDiscriminator", a.uniformFixedSizeArray(a.u8, 8)]],"CompressInstructionArgs"),
    t.exports.compressInstructionDiscriminator = [82, 193, 176, 117, 176, 21, 115, 253],
    t.exports.createCompressInstruction = function(e, n=new l.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var r, i;
        const [o] = t.exports.compressStruct.serialize({
            instructionDiscriminator: t.exports.compressInstructionDiscriminator
        })
          , a = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.tokenAccount,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.mint,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.metadata,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.masterEdition,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.payer,
            isWritable: !0,
            isSigner: !0
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (r = e.tokenProgram) && void 0 !== r ? r : s.TOKEN_PROGRAM_ID,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.tokenMetadataProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : l.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                a.push(t);
        return new l.TransactionInstruction({
            programId: n,
            keys: a,
            data: o
        })
    }
}
)),
o.register("dmNue", (function(r, i) {
    t(r.exports, "TOKEN_PROGRAM_ID", (()=>Xt)),
    t(r.exports, "ASSOCIATED_TOKEN_PROGRAM_ID", (()=>qt)),
    t(r.exports, "u64", (()=>Jt)),
    t(r.exports, "NATIVE_MINT", (()=>ne)),
    t(r.exports, "MintLayout", (()=>re)),
    t(r.exports, "AccountLayout", (()=>ie)),
    t(r.exports, "Token", (()=>oe));
    for (var s = o("g5Zhu"), a = o("dEXSZ"), l = o("gNDby"), c = {}, u = {
        byteLength: function(t) {
            var e = y(t)
              , n = e[0]
              , r = e[1];
            return 3 * (n + r) / 4 - r
        },
        toByteArray: function(t) {
            var e, n, r = y(t), i = r[0], s = r[1], o = new f(function(t, e, n) {
                return 3 * (e + n) / 4 - n
            }(0, i, s)), a = 0, l = s > 0 ? i - 4 : i;
            for (n = 0; n < l; n += 4)
                e = d[t.charCodeAt(n)] << 18 | d[t.charCodeAt(n + 1)] << 12 | d[t.charCodeAt(n + 2)] << 6 | d[t.charCodeAt(n + 3)],
                o[a++] = e >> 16 & 255,
                o[a++] = e >> 8 & 255,
                o[a++] = 255 & e;
            2 === s && (e = d[t.charCodeAt(n)] << 2 | d[t.charCodeAt(n + 1)] >> 4,
            o[a++] = 255 & e);
            1 === s && (e = d[t.charCodeAt(n)] << 10 | d[t.charCodeAt(n + 1)] << 4 | d[t.charCodeAt(n + 2)] >> 2,
            o[a++] = e >> 8 & 255,
            o[a++] = 255 & e);
            return o
        },
        fromByteArray: function(t) {
            for (var e, n = t.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r; o < a; o += s)
                i.push(b(t, o, o + s > a ? a : o + s));
            1 === r ? (e = t[n - 1],
            i.push(h[e >> 2] + h[e << 4 & 63] + "==")) : 2 === r && (e = (t[n - 2] << 8) + t[n - 1],
            i.push(h[e >> 10] + h[e >> 4 & 63] + h[e << 2 & 63] + "="));
            return i.join("")
        }
    }, h = [], d = [], f = "undefined" != typeof Uint8Array ? Uint8Array : Array, p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", m = 0, g = p.length; m < g; ++m)
        h[m] = p[m],
        d[p.charCodeAt(m)] = m;
    function y(t) {
        var e = t.length;
        if (e % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
        var n = t.indexOf("=");
        return -1 === n && (n = e),
        [n, n === e ? 0 : 4 - n % 4]
    }
    function b(t, e, n) {
        for (var r, i, s = [], o = e; o < n; o += 3)
            r = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (255 & t[o + 2]),
            s.push(h[(i = r) >> 18 & 63] + h[i >> 12 & 63] + h[i >> 6 & 63] + h[63 & i]);
        return s.join("")
    }
    d["-".charCodeAt(0)] = 62,
    d["_".charCodeAt(0)] = 63;
    var v = {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        read: function(t, e, n, r, i) {
            var s, o, a = 8 * i - r - 1, l = (1 << a) - 1, c = l >> 1, u = -7, h = n ? i - 1 : 0, d = n ? -1 : 1, f = t[e + h];
            for (h += d,
            s = f & (1 << -u) - 1,
            f >>= -u,
            u += a; u > 0; s = 256 * s + t[e + h],
            h += d,
            u -= 8)
                ;
            for (o = s & (1 << -u) - 1,
            s >>= -u,
            u += r; u > 0; o = 256 * o + t[e + h],
            h += d,
            u -= 8)
                ;
            if (0 === s)
                s = 1 - c;
            else {
                if (s === l)
                    return o ? NaN : 1 / 0 * (f ? -1 : 1);
                o += Math.pow(2, r),
                s -= c
            }
            return (f ? -1 : 1) * o * Math.pow(2, s - r)
        },
        write: function(t, e, n, r, i, s) {
            var o, a, l, c = 8 * s - i - 1, u = (1 << c) - 1, h = u >> 1, d = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : s - 1, p = r ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e),
            isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
            o = u) : (o = Math.floor(Math.log(e) / Math.LN2),
            e * (l = Math.pow(2, -o)) < 1 && (o--,
            l *= 2),
            (e += o + h >= 1 ? d / l : d * Math.pow(2, 1 - h)) * l >= 2 && (o++,
            l /= 2),
            o + h >= u ? (a = 0,
            o = u) : o + h >= 1 ? (a = (e * l - 1) * Math.pow(2, i),
            o += h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i),
            o = 0)); i >= 8; t[n + f] = 255 & a,
            f += p,
            a /= 256,
            i -= 8)
                ;
            for (o = o << i | a,
            c += i; c > 0; t[n + f] = 255 & o,
            f += p,
            o /= 256,
            c -= 8)
                ;
            t[n + f - p] |= 128 * m
        }
    };
    /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
    !function(t) {
        const e = u
          , n = v
          , r = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        t.Buffer = o,
        t.SlowBuffer = function(t) {
            +t != t && (t = 0);
            return o.alloc(+t)
        }
        ,
        t.INSPECT_MAX_BYTES = 50;
        const i = 2147483647;
        function s(t) {
            if (t > i)
                throw new RangeError('The value "' + t + '" is invalid for option "size"');
            const e = new Uint8Array(t);
            return Object.setPrototypeOf(e, o.prototype),
            e
        }
        function o(t, e, n) {
            if ("number" == typeof t) {
                if ("string" == typeof e)
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                return c(t)
            }
            return a(t, e, n)
        }
        function a(t, e, n) {
            if ("string" == typeof t)
                return function(t, e) {
                    "string" == typeof e && "" !== e || (e = "utf8");
                    if (!o.isEncoding(e))
                        throw new TypeError("Unknown encoding: " + e);
                    const n = 0 | p(t, e);
                    let r = s(n);
                    const i = r.write(t, e);
                    i !== n && (r = r.slice(0, i));
                    return r
                }(t, e);
            if (ArrayBuffer.isView(t))
                return function(t) {
                    if (q(t, Uint8Array)) {
                        const e = new Uint8Array(t);
                        return d(e.buffer, e.byteOffset, e.byteLength)
                    }
                    return h(t)
                }(t);
            if (null == t)
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
            if (q(t, ArrayBuffer) || t && q(t.buffer, ArrayBuffer))
                return d(t, e, n);
            if ("undefined" != typeof SharedArrayBuffer && (q(t, SharedArrayBuffer) || t && q(t.buffer, SharedArrayBuffer)))
                return d(t, e, n);
            if ("number" == typeof t)
                throw new TypeError('The "value" argument must not be of type number. Received type number');
            const r = t.valueOf && t.valueOf();
            if (null != r && r !== t)
                return o.from(r, e, n);
            const i = function(t) {
                if (o.isBuffer(t)) {
                    const e = 0 | f(t.length)
                      , n = s(e);
                    return 0 === n.length || t.copy(n, 0, 0, e),
                    n
                }
                if (void 0 !== t.length)
                    return "number" != typeof t.length || K(t.length) ? s(0) : h(t);
                if ("Buffer" === t.type && Array.isArray(t.data))
                    return h(t.data)
            }(t);
            if (i)
                return i;
            if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive])
                return o.from(t[Symbol.toPrimitive]("string"), e, n);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
        }
        function l(t) {
            if ("number" != typeof t)
                throw new TypeError('"size" argument must be of type number');
            if (t < 0)
                throw new RangeError('The value "' + t + '" is invalid for option "size"')
        }
        function c(t) {
            return l(t),
            s(t < 0 ? 0 : 0 | f(t))
        }
        function h(t) {
            const e = t.length < 0 ? 0 : 0 | f(t.length)
              , n = s(e);
            for (let r = 0; r < e; r += 1)
                n[r] = 255 & t[r];
            return n
        }
        function d(t, e, n) {
            if (e < 0 || t.byteLength < e)
                throw new RangeError('"offset" is outside of buffer bounds');
            if (t.byteLength < e + (n || 0))
                throw new RangeError('"length" is outside of buffer bounds');
            let r;
            return r = void 0 === e && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t,e) : new Uint8Array(t,e,n),
            Object.setPrototypeOf(r, o.prototype),
            r
        }
        function f(t) {
            if (t >= i)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
            return 0 | t
        }
        function p(t, e) {
            if (o.isBuffer(t))
                return t.length;
            if (ArrayBuffer.isView(t) || q(t, ArrayBuffer))
                return t.byteLength;
            if ("string" != typeof t)
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
            const n = t.length
              , r = arguments.length > 2 && !0 === arguments[2];
            if (!r && 0 === n)
                return 0;
            let i = !1;
            for (; ; )
                switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                    return n;
                case "utf8":
                case "utf-8":
                    return $(t).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return 2 * n;
                case "hex":
                    return n >>> 1;
                case "base64":
                    return G(t).length;
                default:
                    if (i)
                        return r ? -1 : $(t).length;
                    e = ("" + e).toLowerCase(),
                    i = !0
                }
        }
        function m(t, e, n) {
            let r = !1;
            if ((void 0 === e || e < 0) && (e = 0),
            e > this.length)
                return "";
            if ((void 0 === n || n > this.length) && (n = this.length),
            n <= 0)
                return "";
            if ((n >>>= 0) <= (e >>>= 0))
                return "";
            for (t || (t = "utf8"); ; )
                switch (t) {
                case "hex":
                    return C(this, e, n);
                case "utf8":
                case "utf-8":
                    return T(this, e, n);
                case "ascii":
                    return I(this, e, n);
                case "latin1":
                case "binary":
                    return M(this, e, n);
                case "base64":
                    return S(this, e, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return P(this, e, n);
                default:
                    if (r)
                        throw new TypeError("Unknown encoding: " + t);
                    t = (t + "").toLowerCase(),
                    r = !0
                }
        }
        function g(t, e, n) {
            const r = t[e];
            t[e] = t[n],
            t[n] = r
        }
        function y(t, e, n, r, i) {
            if (0 === t.length)
                return -1;
            if ("string" == typeof n ? (r = n,
            n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648),
            K(n = +n) && (n = i ? 0 : t.length - 1),
            n < 0 && (n = t.length + n),
            n >= t.length) {
                if (i)
                    return -1;
                n = t.length - 1
            } else if (n < 0) {
                if (!i)
                    return -1;
                n = 0
            }
            if ("string" == typeof e && (e = o.from(e, r)),
            o.isBuffer(e))
                return 0 === e.length ? -1 : b(t, e, n, r, i);
            if ("number" == typeof e)
                return e &= 255,
                "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : b(t, [e], n, r, i);
            throw new TypeError("val must be string, number or Buffer")
        }
        function b(t, e, n, r, i) {
            let s, o = 1, a = t.length, l = e.length;
            if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                if (t.length < 2 || e.length < 2)
                    return -1;
                o = 2,
                a /= 2,
                l /= 2,
                n /= 2
            }
            function c(t, e) {
                return 1 === o ? t[e] : t.readUInt16BE(e * o)
            }
            if (i) {
                let r = -1;
                for (s = n; s < a; s++)
                    if (c(t, s) === c(e, -1 === r ? 0 : s - r)) {
                        if (-1 === r && (r = s),
                        s - r + 1 === l)
                            return r * o
                    } else
                        -1 !== r && (s -= s - r),
                        r = -1
            } else
                for (n + l > a && (n = a - l),
                s = n; s >= 0; s--) {
                    let n = !0;
                    for (let r = 0; r < l; r++)
                        if (c(t, s + r) !== c(e, r)) {
                            n = !1;
                            break
                        }
                    if (n)
                        return s
                }
            return -1
        }
        function w(t, e, n, r) {
            n = Number(n) || 0;
            const i = t.length - n;
            r ? (r = Number(r)) > i && (r = i) : r = i;
            const s = e.length;
            let o;
            for (r > s / 2 && (r = s / 2),
            o = 0; o < r; ++o) {
                const r = parseInt(e.substr(2 * o, 2), 16);
                if (K(r))
                    return o;
                t[n + o] = r
            }
            return o
        }
        function x(t, e, n, r) {
            return X($(e, t.length - n), t, n, r)
        }
        function E(t, e, n, r) {
            return X(function(t) {
                const e = [];
                for (let n = 0; n < t.length; ++n)
                    e.push(255 & t.charCodeAt(n));
                return e
            }(e), t, n, r)
        }
        function _(t, e, n, r) {
            return X(G(e), t, n, r)
        }
        function A(t, e, n, r) {
            return X(function(t, e) {
                let n, r, i;
                const s = [];
                for (let o = 0; o < t.length && !((e -= 2) < 0); ++o)
                    n = t.charCodeAt(o),
                    r = n >> 8,
                    i = n % 256,
                    s.push(i),
                    s.push(r);
                return s
            }(e, t.length - n), t, n, r)
        }
        function S(t, n, r) {
            return 0 === n && r === t.length ? e.fromByteArray(t) : e.fromByteArray(t.slice(n, r))
        }
        function T(t, e, n) {
            n = Math.min(t.length, n);
            const r = [];
            let i = e;
            for (; i < n; ) {
                const e = t[i];
                let s = null
                  , o = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
                if (i + o <= n) {
                    let n, r, a, l;
                    switch (o) {
                    case 1:
                        e < 128 && (s = e);
                        break;
                    case 2:
                        n = t[i + 1],
                        128 == (192 & n) && (l = (31 & e) << 6 | 63 & n,
                        l > 127 && (s = l));
                        break;
                    case 3:
                        n = t[i + 1],
                        r = t[i + 2],
                        128 == (192 & n) && 128 == (192 & r) && (l = (15 & e) << 12 | (63 & n) << 6 | 63 & r,
                        l > 2047 && (l < 55296 || l > 57343) && (s = l));
                        break;
                    case 4:
                        n = t[i + 1],
                        r = t[i + 2],
                        a = t[i + 3],
                        128 == (192 & n) && 128 == (192 & r) && 128 == (192 & a) && (l = (15 & e) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & a,
                        l > 65535 && l < 1114112 && (s = l))
                    }
                }
                null === s ? (s = 65533,
                o = 1) : s > 65535 && (s -= 65536,
                r.push(s >>> 10 & 1023 | 55296),
                s = 56320 | 1023 & s),
                r.push(s),
                i += o
            }
            return function(t) {
                const e = t.length;
                if (e <= k)
                    return String.fromCharCode.apply(String, t);
                let n = ""
                  , r = 0;
                for (; r < e; )
                    n += String.fromCharCode.apply(String, t.slice(r, r += k));
                return n
            }(r)
        }
        t.kMaxLength = i,
        o.TYPED_ARRAY_SUPPORT = function() {
            try {
                const t = new Uint8Array(1)
                  , e = {
                    foo: function() {
                        return 42
                    }
                };
                return Object.setPrototypeOf(e, Uint8Array.prototype),
                Object.setPrototypeOf(t, e),
                42 === t.foo()
            } catch (t) {
                return !1
            }
        }(),
        o.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),
        Object.defineProperty(o.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (o.isBuffer(this))
                    return this.buffer
            }
        }),
        Object.defineProperty(o.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (o.isBuffer(this))
                    return this.byteOffset
            }
        }),
        o.poolSize = 8192,
        o.from = function(t, e, n) {
            return a(t, e, n)
        }
        ,
        Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(o, Uint8Array),
        o.alloc = function(t, e, n) {
            return function(t, e, n) {
                return l(t),
                t <= 0 ? s(t) : void 0 !== e ? "string" == typeof n ? s(t).fill(e, n) : s(t).fill(e) : s(t)
            }(t, e, n)
        }
        ,
        o.allocUnsafe = function(t) {
            return c(t)
        }
        ,
        o.allocUnsafeSlow = function(t) {
            return c(t)
        }
        ,
        o.isBuffer = function(t) {
            return null != t && !0 === t._isBuffer && t !== o.prototype
        }
        ,
        o.compare = function(t, e) {
            if (q(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)),
            q(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
            !o.isBuffer(t) || !o.isBuffer(e))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (t === e)
                return 0;
            let n = t.length
              , r = e.length;
            for (let i = 0, s = Math.min(n, r); i < s; ++i)
                if (t[i] !== e[i]) {
                    n = t[i],
                    r = e[i];
                    break
                }
            return n < r ? -1 : r < n ? 1 : 0
        }
        ,
        o.isEncoding = function(t) {
            switch (String(t).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
            }
        }
        ,
        o.concat = function(t, e) {
            if (!Array.isArray(t))
                throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === t.length)
                return o.alloc(0);
            let n;
            if (void 0 === e)
                for (e = 0,
                n = 0; n < t.length; ++n)
                    e += t[n].length;
            const r = o.allocUnsafe(e);
            let i = 0;
            for (n = 0; n < t.length; ++n) {
                let e = t[n];
                if (q(e, Uint8Array))
                    i + e.length > r.length ? (o.isBuffer(e) || (e = o.from(e)),
                    e.copy(r, i)) : Uint8Array.prototype.set.call(r, e, i);
                else {
                    if (!o.isBuffer(e))
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    e.copy(r, i)
                }
                i += e.length
            }
            return r
        }
        ,
        o.byteLength = p,
        o.prototype._isBuffer = !0,
        o.prototype.swap16 = function() {
            const t = this.length;
            if (t % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let e = 0; e < t; e += 2)
                g(this, e, e + 1);
            return this
        }
        ,
        o.prototype.swap32 = function() {
            const t = this.length;
            if (t % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let e = 0; e < t; e += 4)
                g(this, e, e + 3),
                g(this, e + 1, e + 2);
            return this
        }
        ,
        o.prototype.swap64 = function() {
            const t = this.length;
            if (t % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let e = 0; e < t; e += 8)
                g(this, e, e + 7),
                g(this, e + 1, e + 6),
                g(this, e + 2, e + 5),
                g(this, e + 3, e + 4);
            return this
        }
        ,
        o.prototype.toString = function() {
            const t = this.length;
            return 0 === t ? "" : 0 === arguments.length ? T(this, 0, t) : m.apply(this, arguments)
        }
        ,
        o.prototype.toLocaleString = o.prototype.toString,
        o.prototype.equals = function(t) {
            if (!o.isBuffer(t))
                throw new TypeError("Argument must be a Buffer");
            return this === t || 0 === o.compare(this, t)
        }
        ,
        o.prototype.inspect = function() {
            let e = "";
            const n = t.INSPECT_MAX_BYTES;
            return e = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(),
            this.length > n && (e += " ... "),
            "<Buffer " + e + ">"
        }
        ,
        r && (o.prototype[r] = o.prototype.inspect),
        o.prototype.compare = function(t, e, n, r, i) {
            if (q(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)),
            !o.isBuffer(t))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
            if (void 0 === e && (e = 0),
            void 0 === n && (n = t ? t.length : 0),
            void 0 === r && (r = 0),
            void 0 === i && (i = this.length),
            e < 0 || n > t.length || r < 0 || i > this.length)
                throw new RangeError("out of range index");
            if (r >= i && e >= n)
                return 0;
            if (r >= i)
                return -1;
            if (e >= n)
                return 1;
            if (this === t)
                return 0;
            let s = (i >>>= 0) - (r >>>= 0)
              , a = (n >>>= 0) - (e >>>= 0);
            const l = Math.min(s, a)
              , c = this.slice(r, i)
              , u = t.slice(e, n);
            for (let t = 0; t < l; ++t)
                if (c[t] !== u[t]) {
                    s = c[t],
                    a = u[t];
                    break
                }
            return s < a ? -1 : a < s ? 1 : 0
        }
        ,
        o.prototype.includes = function(t, e, n) {
            return -1 !== this.indexOf(t, e, n)
        }
        ,
        o.prototype.indexOf = function(t, e, n) {
            return y(this, t, e, n, !0)
        }
        ,
        o.prototype.lastIndexOf = function(t, e, n) {
            return y(this, t, e, n, !1)
        }
        ,
        o.prototype.write = function(t, e, n, r) {
            if (void 0 === e)
                r = "utf8",
                n = this.length,
                e = 0;
            else if (void 0 === n && "string" == typeof e)
                r = e,
                n = this.length,
                e = 0;
            else {
                if (!isFinite(e))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                e >>>= 0,
                isFinite(n) ? (n >>>= 0,
                void 0 === r && (r = "utf8")) : (r = n,
                n = void 0)
            }
            const i = this.length - e;
            if ((void 0 === n || n > i) && (n = i),
            t.length > 0 && (n < 0 || e < 0) || e > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            r || (r = "utf8");
            let s = !1;
            for (; ; )
                switch (r) {
                case "hex":
                    return w(this, t, e, n);
                case "utf8":
                case "utf-8":
                    return x(this, t, e, n);
                case "ascii":
                case "latin1":
                case "binary":
                    return E(this, t, e, n);
                case "base64":
                    return _(this, t, e, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return A(this, t, e, n);
                default:
                    if (s)
                        throw new TypeError("Unknown encoding: " + r);
                    r = ("" + r).toLowerCase(),
                    s = !0
                }
        }
        ,
        o.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }
        ;
        const k = 4096;
        function I(t, e, n) {
            let r = "";
            n = Math.min(t.length, n);
            for (let i = e; i < n; ++i)
                r += String.fromCharCode(127 & t[i]);
            return r
        }
        function M(t, e, n) {
            let r = "";
            n = Math.min(t.length, n);
            for (let i = e; i < n; ++i)
                r += String.fromCharCode(t[i]);
            return r
        }
        function C(t, e, n) {
            const r = t.length;
            (!e || e < 0) && (e = 0),
            (!n || n < 0 || n > r) && (n = r);
            let i = "";
            for (let r = e; r < n; ++r)
                i += Q[t[r]];
            return i
        }
        function P(t, e, n) {
            const r = t.slice(e, n);
            let i = "";
            for (let t = 0; t < r.length - 1; t += 2)
                i += String.fromCharCode(r[t] + 256 * r[t + 1]);
            return i
        }
        function O(t, e, n) {
            if (t % 1 != 0 || t < 0)
                throw new RangeError("offset is not uint");
            if (t + e > n)
                throw new RangeError("Trying to access beyond buffer length")
        }
        function N(t, e, n, r, i, s) {
            if (!o.isBuffer(t))
                throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > i || e < s)
                throw new RangeError('"value" argument is out of bounds');
            if (n + r > t.length)
                throw new RangeError("Index out of range")
        }
        function R(t, e, n, r, i) {
            V(e, r, i, t, n, 7);
            let s = Number(e & BigInt(4294967295));
            t[n++] = s,
            s >>= 8,
            t[n++] = s,
            s >>= 8,
            t[n++] = s,
            s >>= 8,
            t[n++] = s;
            let o = Number(e >> BigInt(32) & BigInt(4294967295));
            return t[n++] = o,
            o >>= 8,
            t[n++] = o,
            o >>= 8,
            t[n++] = o,
            o >>= 8,
            t[n++] = o,
            n
        }
        function D(t, e, n, r, i) {
            V(e, r, i, t, n, 7);
            let s = Number(e & BigInt(4294967295));
            t[n + 7] = s,
            s >>= 8,
            t[n + 6] = s,
            s >>= 8,
            t[n + 5] = s,
            s >>= 8,
            t[n + 4] = s;
            let o = Number(e >> BigInt(32) & BigInt(4294967295));
            return t[n + 3] = o,
            o >>= 8,
            t[n + 2] = o,
            o >>= 8,
            t[n + 1] = o,
            o >>= 8,
            t[n] = o,
            n + 8
        }
        function B(t, e, n, r, i, s) {
            if (n + r > t.length)
                throw new RangeError("Index out of range");
            if (n < 0)
                throw new RangeError("Index out of range")
        }
        function L(t, e, r, i, s) {
            return e = +e,
            r >>>= 0,
            s || B(t, 0, r, 4),
            n.write(t, e, r, i, 23, 4),
            r + 4
        }
        function F(t, e, r, i, s) {
            return e = +e,
            r >>>= 0,
            s || B(t, 0, r, 8),
            n.write(t, e, r, i, 52, 8),
            r + 8
        }
        o.prototype.slice = function(t, e) {
            const n = this.length;
            (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
            (e = void 0 === e ? n : ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n),
            e < t && (e = t);
            const r = this.subarray(t, e);
            return Object.setPrototypeOf(r, o.prototype),
            r
        }
        ,
        o.prototype.readUintLE = o.prototype.readUIntLE = function(t, e, n) {
            t >>>= 0,
            e >>>= 0,
            n || O(t, e, this.length);
            let r = this[t]
              , i = 1
              , s = 0;
            for (; ++s < e && (i *= 256); )
                r += this[t + s] * i;
            return r
        }
        ,
        o.prototype.readUintBE = o.prototype.readUIntBE = function(t, e, n) {
            t >>>= 0,
            e >>>= 0,
            n || O(t, e, this.length);
            let r = this[t + --e]
              , i = 1;
            for (; e > 0 && (i *= 256); )
                r += this[t + --e] * i;
            return r
        }
        ,
        o.prototype.readUint8 = o.prototype.readUInt8 = function(t, e) {
            return t >>>= 0,
            e || O(t, 1, this.length),
            this[t]
        }
        ,
        o.prototype.readUint16LE = o.prototype.readUInt16LE = function(t, e) {
            return t >>>= 0,
            e || O(t, 2, this.length),
            this[t] | this[t + 1] << 8
        }
        ,
        o.prototype.readUint16BE = o.prototype.readUInt16BE = function(t, e) {
            return t >>>= 0,
            e || O(t, 2, this.length),
            this[t] << 8 | this[t + 1]
        }
        ,
        o.prototype.readUint32LE = o.prototype.readUInt32LE = function(t, e) {
            return t >>>= 0,
            e || O(t, 4, this.length),
            (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
        }
        ,
        o.prototype.readUint32BE = o.prototype.readUInt32BE = function(t, e) {
            return t >>>= 0,
            e || O(t, 4, this.length),
            16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
        }
        ,
        o.prototype.readBigUInt64LE = Z((function(t) {
            W(t >>>= 0, "offset");
            const e = this[t]
              , n = this[t + 7];
            void 0 !== e && void 0 !== n || Y(t, this.length - 8);
            const r = e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24
              , i = this[++t] + 256 * this[++t] + 65536 * this[++t] + n * 2 ** 24;
            return BigInt(r) + (BigInt(i) << BigInt(32))
        }
        )),
        o.prototype.readBigUInt64BE = Z((function(t) {
            W(t >>>= 0, "offset");
            const e = this[t]
              , n = this[t + 7];
            void 0 !== e && void 0 !== n || Y(t, this.length - 8);
            const r = e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t]
              , i = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n;
            return (BigInt(r) << BigInt(32)) + BigInt(i)
        }
        )),
        o.prototype.readIntLE = function(t, e, n) {
            t >>>= 0,
            e >>>= 0,
            n || O(t, e, this.length);
            let r = this[t]
              , i = 1
              , s = 0;
            for (; ++s < e && (i *= 256); )
                r += this[t + s] * i;
            return i *= 128,
            r >= i && (r -= Math.pow(2, 8 * e)),
            r
        }
        ,
        o.prototype.readIntBE = function(t, e, n) {
            t >>>= 0,
            e >>>= 0,
            n || O(t, e, this.length);
            let r = e
              , i = 1
              , s = this[t + --r];
            for (; r > 0 && (i *= 256); )
                s += this[t + --r] * i;
            return i *= 128,
            s >= i && (s -= Math.pow(2, 8 * e)),
            s
        }
        ,
        o.prototype.readInt8 = function(t, e) {
            return t >>>= 0,
            e || O(t, 1, this.length),
            128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        }
        ,
        o.prototype.readInt16LE = function(t, e) {
            t >>>= 0,
            e || O(t, 2, this.length);
            const n = this[t] | this[t + 1] << 8;
            return 32768 & n ? 4294901760 | n : n
        }
        ,
        o.prototype.readInt16BE = function(t, e) {
            t >>>= 0,
            e || O(t, 2, this.length);
            const n = this[t + 1] | this[t] << 8;
            return 32768 & n ? 4294901760 | n : n
        }
        ,
        o.prototype.readInt32LE = function(t, e) {
            return t >>>= 0,
            e || O(t, 4, this.length),
            this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
        }
        ,
        o.prototype.readInt32BE = function(t, e) {
            return t >>>= 0,
            e || O(t, 4, this.length),
            this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
        }
        ,
        o.prototype.readBigInt64LE = Z((function(t) {
            W(t >>>= 0, "offset");
            const e = this[t]
              , n = this[t + 7];
            void 0 !== e && void 0 !== n || Y(t, this.length - 8);
            const r = this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (n << 24);
            return (BigInt(r) << BigInt(32)) + BigInt(e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24)
        }
        )),
        o.prototype.readBigInt64BE = Z((function(t) {
            W(t >>>= 0, "offset");
            const e = this[t]
              , n = this[t + 7];
            void 0 !== e && void 0 !== n || Y(t, this.length - 8);
            const r = (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
            return (BigInt(r) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + n)
        }
        )),
        o.prototype.readFloatLE = function(t, e) {
            return t >>>= 0,
            e || O(t, 4, this.length),
            n.read(this, t, !0, 23, 4)
        }
        ,
        o.prototype.readFloatBE = function(t, e) {
            return t >>>= 0,
            e || O(t, 4, this.length),
            n.read(this, t, !1, 23, 4)
        }
        ,
        o.prototype.readDoubleLE = function(t, e) {
            return t >>>= 0,
            e || O(t, 8, this.length),
            n.read(this, t, !0, 52, 8)
        }
        ,
        o.prototype.readDoubleBE = function(t, e) {
            return t >>>= 0,
            e || O(t, 8, this.length),
            n.read(this, t, !1, 52, 8)
        }
        ,
        o.prototype.writeUintLE = o.prototype.writeUIntLE = function(t, e, n, r) {
            if (t = +t,
            e >>>= 0,
            n >>>= 0,
            !r) {
                N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0)
            }
            let i = 1
              , s = 0;
            for (this[e] = 255 & t; ++s < n && (i *= 256); )
                this[e + s] = t / i & 255;
            return e + n
        }
        ,
        o.prototype.writeUintBE = o.prototype.writeUIntBE = function(t, e, n, r) {
            if (t = +t,
            e >>>= 0,
            n >>>= 0,
            !r) {
                N(this, t, e, n, Math.pow(2, 8 * n) - 1, 0)
            }
            let i = n - 1
              , s = 1;
            for (this[e + i] = 255 & t; --i >= 0 && (s *= 256); )
                this[e + i] = t / s & 255;
            return e + n
        }
        ,
        o.prototype.writeUint8 = o.prototype.writeUInt8 = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 1, 255, 0),
            this[e] = 255 & t,
            e + 1
        }
        ,
        o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 2, 65535, 0),
            this[e] = 255 & t,
            this[e + 1] = t >>> 8,
            e + 2
        }
        ,
        o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 2, 65535, 0),
            this[e] = t >>> 8,
            this[e + 1] = 255 & t,
            e + 2
        }
        ,
        o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 4, 4294967295, 0),
            this[e + 3] = t >>> 24,
            this[e + 2] = t >>> 16,
            this[e + 1] = t >>> 8,
            this[e] = 255 & t,
            e + 4
        }
        ,
        o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 4, 4294967295, 0),
            this[e] = t >>> 24,
            this[e + 1] = t >>> 16,
            this[e + 2] = t >>> 8,
            this[e + 3] = 255 & t,
            e + 4
        }
        ,
        o.prototype.writeBigUInt64LE = Z((function(t, e=0) {
            return R(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"))
        }
        )),
        o.prototype.writeBigUInt64BE = Z((function(t, e=0) {
            return D(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"))
        }
        )),
        o.prototype.writeIntLE = function(t, e, n, r) {
            if (t = +t,
            e >>>= 0,
            !r) {
                const r = Math.pow(2, 8 * n - 1);
                N(this, t, e, n, r - 1, -r)
            }
            let i = 0
              , s = 1
              , o = 0;
            for (this[e] = 255 & t; ++i < n && (s *= 256); )
                t < 0 && 0 === o && 0 !== this[e + i - 1] && (o = 1),
                this[e + i] = (t / s >> 0) - o & 255;
            return e + n
        }
        ,
        o.prototype.writeIntBE = function(t, e, n, r) {
            if (t = +t,
            e >>>= 0,
            !r) {
                const r = Math.pow(2, 8 * n - 1);
                N(this, t, e, n, r - 1, -r)
            }
            let i = n - 1
              , s = 1
              , o = 0;
            for (this[e + i] = 255 & t; --i >= 0 && (s *= 256); )
                t < 0 && 0 === o && 0 !== this[e + i + 1] && (o = 1),
                this[e + i] = (t / s >> 0) - o & 255;
            return e + n
        }
        ,
        o.prototype.writeInt8 = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 1, 127, -128),
            t < 0 && (t = 255 + t + 1),
            this[e] = 255 & t,
            e + 1
        }
        ,
        o.prototype.writeInt16LE = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 2, 32767, -32768),
            this[e] = 255 & t,
            this[e + 1] = t >>> 8,
            e + 2
        }
        ,
        o.prototype.writeInt16BE = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 2, 32767, -32768),
            this[e] = t >>> 8,
            this[e + 1] = 255 & t,
            e + 2
        }
        ,
        o.prototype.writeInt32LE = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 4, 2147483647, -2147483648),
            this[e] = 255 & t,
            this[e + 1] = t >>> 8,
            this[e + 2] = t >>> 16,
            this[e + 3] = t >>> 24,
            e + 4
        }
        ,
        o.prototype.writeInt32BE = function(t, e, n) {
            return t = +t,
            e >>>= 0,
            n || N(this, t, e, 4, 2147483647, -2147483648),
            t < 0 && (t = 4294967295 + t + 1),
            this[e] = t >>> 24,
            this[e + 1] = t >>> 16,
            this[e + 2] = t >>> 8,
            this[e + 3] = 255 & t,
            e + 4
        }
        ,
        o.prototype.writeBigInt64LE = Z((function(t, e=0) {
            return R(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        }
        )),
        o.prototype.writeBigInt64BE = Z((function(t, e=0) {
            return D(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        }
        )),
        o.prototype.writeFloatLE = function(t, e, n) {
            return L(this, t, e, !0, n)
        }
        ,
        o.prototype.writeFloatBE = function(t, e, n) {
            return L(this, t, e, !1, n)
        }
        ,
        o.prototype.writeDoubleLE = function(t, e, n) {
            return F(this, t, e, !0, n)
        }
        ,
        o.prototype.writeDoubleBE = function(t, e, n) {
            return F(this, t, e, !1, n)
        }
        ,
        o.prototype.copy = function(t, e, n, r) {
            if (!o.isBuffer(t))
                throw new TypeError("argument should be a Buffer");
            if (n || (n = 0),
            r || 0 === r || (r = this.length),
            e >= t.length && (e = t.length),
            e || (e = 0),
            r > 0 && r < n && (r = n),
            r === n)
                return 0;
            if (0 === t.length || 0 === this.length)
                return 0;
            if (e < 0)
                throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length)
                throw new RangeError("Index out of range");
            if (r < 0)
                throw new RangeError("sourceEnd out of bounds");
            r > this.length && (r = this.length),
            t.length - e < r - n && (r = t.length - e + n);
            const i = r - n;
            return this === t && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e, n, r) : Uint8Array.prototype.set.call(t, this.subarray(n, r), e),
            i
        }
        ,
        o.prototype.fill = function(t, e, n, r) {
            if ("string" == typeof t) {
                if ("string" == typeof e ? (r = e,
                e = 0,
                n = this.length) : "string" == typeof n && (r = n,
                n = this.length),
                void 0 !== r && "string" != typeof r)
                    throw new TypeError("encoding must be a string");
                if ("string" == typeof r && !o.isEncoding(r))
                    throw new TypeError("Unknown encoding: " + r);
                if (1 === t.length) {
                    const e = t.charCodeAt(0);
                    ("utf8" === r && e < 128 || "latin1" === r) && (t = e)
                }
            } else
                "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t));
            if (e < 0 || this.length < e || this.length < n)
                throw new RangeError("Out of range index");
            if (n <= e)
                return this;
            let i;
            if (e >>>= 0,
            n = void 0 === n ? this.length : n >>> 0,
            t || (t = 0),
            "number" == typeof t)
                for (i = e; i < n; ++i)
                    this[i] = t;
            else {
                const s = o.isBuffer(t) ? t : o.from(t, r)
                  , a = s.length;
                if (0 === a)
                    throw new TypeError('The value "' + t + '" is invalid for argument "value"');
                for (i = 0; i < n - e; ++i)
                    this[i + e] = s[i % a]
            }
            return this
        }
        ;
        const j = {};
        function U(t, e, n) {
            j[t] = class extends n {
                constructor() {
                    super(),
                    Object.defineProperty(this, "message", {
                        value: e.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }),
                    this.name = `${this.name} [${t}]`,
                    this.stack,
                    delete this.name
                }
                get code() {
                    return t
                }
                set code(t) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: t,
                        writable: !0
                    })
                }
                toString() {
                    return `${this.name} [${t}]: ${this.message}`
                }
            }
        }
        function z(t) {
            let e = ""
              , n = t.length;
            const r = "-" === t[0] ? 1 : 0;
            for (; n >= r + 4; n -= 3)
                e = `_${t.slice(n - 3, n)}${e}`;
            return `${t.slice(0, n)}${e}`
        }
        function V(t, e, n, r, i, s) {
            if (t > n || t < e) {
                const r = "bigint" == typeof e ? "n" : "";
                let i;
                throw i = s > 3 ? 0 === e || e === BigInt(0) ? `>= 0${r} and < 2${r} ** ${8 * (s + 1)}${r}` : `>= -(2${r} ** ${8 * (s + 1) - 1}${r}) and < 2 ** ${8 * (s + 1) - 1}${r}` : `>= ${e}${r} and <= ${n}${r}`,
                new j.ERR_OUT_OF_RANGE("value",i,t)
            }
            !function(t, e, n) {
                W(e, "offset"),
                void 0 !== t[e] && void 0 !== t[e + n] || Y(e, t.length - (n + 1))
            }(r, i, s)
        }
        function W(t, e) {
            if ("number" != typeof t)
                throw new j.ERR_INVALID_ARG_TYPE(e,"number",t)
        }
        function Y(t, e, n) {
            if (Math.floor(t) !== t)
                throw W(t, n),
                new j.ERR_OUT_OF_RANGE(n || "offset","an integer",t);
            if (e < 0)
                throw new j.ERR_BUFFER_OUT_OF_BOUNDS;
            throw new j.ERR_OUT_OF_RANGE(n || "offset",`>= ${n ? 1 : 0} and <= ${e}`,t)
        }
        U("ERR_BUFFER_OUT_OF_BOUNDS", (function(t) {
            return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
        }
        ), RangeError),
        U("ERR_INVALID_ARG_TYPE", (function(t, e) {
            return `The "${t}" argument must be of type number. Received type ${typeof e}`
        }
        ), TypeError),
        U("ERR_OUT_OF_RANGE", (function(t, e, n) {
            let r = `The value of "${t}" is out of range.`
              , i = n;
            return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = z(String(n)) : "bigint" == typeof n && (i = String(n),
            (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = z(i)),
            i += "n"),
            r += ` It must be ${e}. Received ${i}`,
            r
        }
        ), RangeError);
        const H = /[^+/0-9A-Za-z-_]/g;
        function $(t, e) {
            let n;
            e = e || 1 / 0;
            const r = t.length;
            let i = null;
            const s = [];
            for (let o = 0; o < r; ++o) {
                if (n = t.charCodeAt(o),
                n > 55295 && n < 57344) {
                    if (!i) {
                        if (n > 56319) {
                            (e -= 3) > -1 && s.push(239, 191, 189);
                            continue
                        }
                        if (o + 1 === r) {
                            (e -= 3) > -1 && s.push(239, 191, 189);
                            continue
                        }
                        i = n;
                        continue
                    }
                    if (n < 56320) {
                        (e -= 3) > -1 && s.push(239, 191, 189),
                        i = n;
                        continue
                    }
                    n = 65536 + (i - 55296 << 10 | n - 56320)
                } else
                    i && (e -= 3) > -1 && s.push(239, 191, 189);
                if (i = null,
                n < 128) {
                    if ((e -= 1) < 0)
                        break;
                    s.push(n)
                } else if (n < 2048) {
                    if ((e -= 2) < 0)
                        break;
                    s.push(n >> 6 | 192, 63 & n | 128)
                } else if (n < 65536) {
                    if ((e -= 3) < 0)
                        break;
                    s.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                } else {
                    if (!(n < 1114112))
                        throw new Error("Invalid code point");
                    if ((e -= 4) < 0)
                        break;
                    s.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                }
            }
            return s
        }
        function G(t) {
            return e.toByteArray(function(t) {
                if ((t = (t = t.split("=")[0]).trim().replace(H, "")).length < 2)
                    return "";
                for (; t.length % 4 != 0; )
                    t += "=";
                return t
            }(t))
        }
        function X(t, e, n, r) {
            let i;
            for (i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)
                e[i + n] = t[i];
            return i
        }
        function q(t, e) {
            return t instanceof e || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === e.name
        }
        function K(t) {
            return t != t
        }
        const Q = function() {
            const t = "0123456789abcdef"
              , e = new Array(256);
            for (let n = 0; n < 16; ++n) {
                const r = 16 * n;
                for (let i = 0; i < 16; ++i)
                    e[r + i] = t[n] + t[i]
            }
            return e
        }();
        function Z(t) {
            return "undefined" == typeof BigInt ? J : t
        }
        function J() {
            throw new Error("BigInt not supported")
        }
    }(c);
    var w = void 0 !== n ? n : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}
      , x = "function" == typeof Object.create ? function(t, e) {
        t.super_ = e,
        t.prototype = Object.create(e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        })
    }
    : function(t, e) {
        t.super_ = e;
        var n = function() {};
        n.prototype = e.prototype,
        t.prototype = new n,
        t.prototype.constructor = t
    }
    ;
    function E(t, e) {
        var n = {
            seen: [],
            stylize: A
        };
        return arguments.length >= 3 && (n.depth = arguments[2]),
        arguments.length >= 4 && (n.colors = arguments[3]),
        I(e) ? n.showHidden = e : e && function(t, e) {
            if (!e || !N(e))
                return t;
            var n = Object.keys(e)
              , r = n.length;
            for (; r--; )
                t[n[r]] = e[n[r]]
        }(n, e),
        P(n.showHidden) && (n.showHidden = !1),
        P(n.depth) && (n.depth = 2),
        P(n.colors) && (n.colors = !1),
        P(n.customInspect) && (n.customInspect = !0),
        n.colors && (n.stylize = _),
        S(n, t, n.depth)
    }
    function _(t, e) {
        var n = E.styles[e];
        return n ? "[" + E.colors[n][0] + "m" + t + "[" + E.colors[n][1] + "m" : t
    }
    function A(t, e) {
        return t
    }
    function S(t, e, n) {
        if (t.customInspect && e && B(e.inspect) && e.inspect !== E && (!e.constructor || e.constructor.prototype !== e)) {
            var r = e.inspect(n, t);
            return C(r) || (r = S(t, r, n)),
            r
        }
        var i = function(t, e) {
            if (P(e))
                return t.stylize("undefined", "undefined");
            if (C(e)) {
                var n = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return t.stylize(n, "string")
            }
            if (r = e,
            "number" == typeof r)
                return t.stylize("" + e, "number");
            var r;
            if (I(e))
                return t.stylize("" + e, "boolean");
            if (M(e))
                return t.stylize("null", "null")
        }(t, e);
        if (i)
            return i;
        var s = Object.keys(e)
          , o = function(t) {
            var e = {};
            return t.forEach((function(t, n) {
                e[t] = !0
            }
            )),
            e
        }(s);
        if (t.showHidden && (s = Object.getOwnPropertyNames(e)),
        D(e) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0))
            return T(e);
        if (0 === s.length) {
            if (B(e)) {
                var a = e.name ? ": " + e.name : "";
                return t.stylize("[Function" + a + "]", "special")
            }
            if (O(e))
                return t.stylize(RegExp.prototype.toString.call(e), "regexp");
            if (R(e))
                return t.stylize(Date.prototype.toString.call(e), "date");
            if (D(e))
                return T(e)
        }
        var l, c, u = "", h = !1, d = ["{", "}"];
        (l = e,
        Array.isArray(l) && (h = !0,
        d = ["[", "]"]),
        B(e)) && (u = " [Function" + (e.name ? ": " + e.name : "") + "]");
        return O(e) && (u = " " + RegExp.prototype.toString.call(e)),
        R(e) && (u = " " + Date.prototype.toUTCString.call(e)),
        D(e) && (u = " " + T(e)),
        0 !== s.length || h && 0 != e.length ? n < 0 ? O(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special") : (t.seen.push(e),
        c = h ? function(t, e, n, r, i) {
            for (var s = [], o = 0, a = e.length; o < a; ++o)
                j(e, String(o)) ? s.push(k(t, e, n, r, String(o), !0)) : s.push("");
            return i.forEach((function(i) {
                i.match(/^\d+$/) || s.push(k(t, e, n, r, i, !0))
            }
            )),
            s
        }(t, e, n, o, s) : s.map((function(r) {
            return k(t, e, n, o, r, h)
        }
        )),
        t.seen.pop(),
        function(t, e, n) {
            var r = t.reduce((function(t, e) {
                return e.indexOf("\n"),
                t + e.replace(/\u001b\[\d\d?m/g, "").length + 1
            }
            ), 0);
            return r > 60 ? n[0] + ("" === e ? "" : e + "\n ") + " " + t.join(",\n  ") + " " + n[1] : n[0] + e + " " + t.join(", ") + " " + n[1]
        }(c, u, d)) : d[0] + u + d[1]
    }
    function T(t) {
        return "[" + Error.prototype.toString.call(t) + "]"
    }
    function k(t, e, n, r, i, s) {
        var o, a, l;
        if ((l = Object.getOwnPropertyDescriptor(e, i) || {
            value: e[i]
        }).get ? a = l.set ? t.stylize("[Getter/Setter]", "special") : t.stylize("[Getter]", "special") : l.set && (a = t.stylize("[Setter]", "special")),
        j(r, i) || (o = "[" + i + "]"),
        a || (t.seen.indexOf(l.value) < 0 ? (a = M(n) ? S(t, l.value, null) : S(t, l.value, n - 1)).indexOf("\n") > -1 && (a = s ? a.split("\n").map((function(t) {
            return "  " + t
        }
        )).join("\n").substr(2) : "\n" + a.split("\n").map((function(t) {
            return "   " + t
        }
        )).join("\n")) : a = t.stylize("[Circular]", "special")),
        P(o)) {
            if (s && i.match(/^\d+$/))
                return a;
            (o = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.substr(1, o.length - 2),
            o = t.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"),
            o = t.stylize(o, "string"))
        }
        return o + ": " + a
    }
    function I(t) {
        return "boolean" == typeof t
    }
    function M(t) {
        return null === t
    }
    function C(t) {
        return "string" == typeof t
    }
    function P(t) {
        return void 0 === t
    }
    function O(t) {
        return N(t) && "[object RegExp]" === F(t)
    }
    function N(t) {
        return "object" == typeof t && null !== t
    }
    function R(t) {
        return N(t) && "[object Date]" === F(t)
    }
    function D(t) {
        return N(t) && ("[object Error]" === F(t) || t instanceof Error)
    }
    function B(t) {
        return "function" == typeof t
    }
    function L(t) {
        return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t
    }
    function F(t) {
        return Object.prototype.toString.call(t)
    }
    function j(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    function U(t, e) {
        if (t === e)
            return 0;
        for (var n = t.length, r = e.length, i = 0, s = Math.min(n, r); i < s; ++i)
            if (t[i] !== e[i]) {
                n = t[i],
                r = e[i];
                break
            }
        return n < r ? -1 : r < n ? 1 : 0
    }
    E.colors = {
        bold: [1, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        white: [37, 39],
        grey: [90, 39],
        black: [30, 39],
        blue: [34, 39],
        cyan: [36, 39],
        green: [32, 39],
        magenta: [35, 39],
        red: [31, 39],
        yellow: [33, 39]
    },
    E.styles = {
        special: "cyan",
        number: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        date: "magenta",
        regexp: "red"
    };
    var z, V = Object.prototype.hasOwnProperty, W = Object.keys || function(t) {
        var e = [];
        for (var n in t)
            V.call(t, n) && e.push(n);
        return e
    }
    , Y = Array.prototype.slice;
    function H() {
        return void 0 !== z ? z : z = "foo" === function() {}
        .name
    }
    function $(t) {
        return Object.prototype.toString.call(t)
    }
    function G(t) {
        return !c.isBuffer(t) && ("function" == typeof w.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : !!t && (t instanceof DataView || !!(t.buffer && t.buffer instanceof ArrayBuffer))))
    }
    function X(t, e) {
        t || tt(t, !0, e, "==", et)
    }
    var q = /\s*function\s+([^\(\s]*)\s*/;
    function K(t) {
        if (B(t)) {
            if (H())
                return t.name;
            var e = t.toString().match(q);
            return e && e[1]
        }
    }
    function Q(t) {
        var e;
        this.name = "AssertionError",
        this.actual = t.actual,
        this.expected = t.expected,
        this.operator = t.operator,
        t.message ? (this.message = t.message,
        this.generatedMessage = !1) : (this.message = Z(J((e = this).actual), 128) + " " + e.operator + " " + Z(J(e.expected), 128),
        this.generatedMessage = !0);
        var n = t.stackStartFunction || tt;
        if (Error.captureStackTrace)
            Error.captureStackTrace(this, n);
        else {
            var r = new Error;
            if (r.stack) {
                var i = r.stack
                  , s = K(n)
                  , o = i.indexOf("\n" + s);
                if (o >= 0) {
                    var a = i.indexOf("\n", o + 1);
                    i = i.substring(a + 1)
                }
                this.stack = i
            }
        }
    }
    function Z(t, e) {
        return "string" == typeof t ? t.length < e ? t : t.slice(0, e) : t
    }
    function J(t) {
        if (H() || !B(t))
            return E(t);
        var e = K(t);
        return "[Function" + (e ? ": " + e : "") + "]"
    }
    function tt(t, e, n, r, i) {
        throw new Q({
            message: n,
            actual: t,
            expected: e,
            operator: r,
            stackStartFunction: i
        })
    }
    function et(t, e) {
        t || tt(t, !0, e, "==", et)
    }
    function nt(t, e, n, r) {
        if (t === e)
            return !0;
        if (c.isBuffer(t) && c.isBuffer(e))
            return 0 === U(t, e);
        if (R(t) && R(e))
            return t.getTime() === e.getTime();
        if (O(t) && O(e))
            return t.source === e.source && t.global === e.global && t.multiline === e.multiline && t.lastIndex === e.lastIndex && t.ignoreCase === e.ignoreCase;
        if (null !== t && "object" == typeof t || null !== e && "object" == typeof e) {
            if (G(t) && G(e) && $(t) === $(e) && !(t instanceof Float32Array || t instanceof Float64Array))
                return 0 === U(new Uint8Array(t.buffer), new Uint8Array(e.buffer));
            if (c.isBuffer(t) !== c.isBuffer(e))
                return !1;
            var i = (r = r || {
                actual: [],
                expected: []
            }).actual.indexOf(t);
            return -1 !== i && i === r.expected.indexOf(e) || (r.actual.push(t),
            r.expected.push(e),
            function(t, e, n, r) {
                if (null == t || null == e)
                    return !1;
                if (L(t) || L(e))
                    return t === e;
                if (n && Object.getPrototypeOf(t) !== Object.getPrototypeOf(e))
                    return !1;
                var i = rt(t)
                  , s = rt(e);
                if (i && !s || !i && s)
                    return !1;
                if (i)
                    return nt(t = Y.call(t), e = Y.call(e), n);
                var o, a, l = W(t), c = W(e);
                if (l.length !== c.length)
                    return !1;
                for (l.sort(),
                c.sort(),
                a = l.length - 1; a >= 0; a--)
                    if (l[a] !== c[a])
                        return !1;
                for (a = l.length - 1; a >= 0; a--)
                    if (!nt(t[o = l[a]], e[o], n, r))
                        return !1;
                return !0
            }(t, e, n, r))
        }
        return n ? t === e : t == e
    }
    function rt(t) {
        return "[object Arguments]" == Object.prototype.toString.call(t)
    }
    function it(t, e) {
        if (!t || !e)
            return !1;
        if ("[object RegExp]" == Object.prototype.toString.call(e))
            return e.test(t);
        try {
            if (t instanceof e)
                return !0
        } catch (t) {}
        return !Error.isPrototypeOf(e) && !0 === e.call({}, t)
    }
    function st(t, e, n, r) {
        var i;
        if ("function" != typeof e)
            throw new TypeError('"block" argument must be a function');
        "string" == typeof n && (r = n,
        n = null),
        i = function(t) {
            var e;
            try {
                t()
            } catch (t) {
                e = t
            }
            return e
        }(e),
        r = (n && n.name ? " (" + n.name + ")." : ".") + (r ? " " + r : "."),
        t && !i && tt(i, n, "Missing expected exception" + r);
        var s = "string" == typeof r
          , o = !t && i && !n;
        if ((!t && D(i) && s && it(i, n) || o) && tt(i, n, "Got unwanted exception" + r),
        t && i && n && !it(i, n) || !t && i)
            throw i
    }
    X.AssertionError = Q,
    x(Q, Error),
    X.fail = tt,
    X.ok = et,
    X.equal = function t(e, n, r) {
        e != n && tt(e, n, r, "==", t)
    }
    ,
    X.notEqual = function t(e, n, r) {
        e == n && tt(e, n, r, "!=", t)
    }
    ,
    X.deepEqual = function t(e, n, r) {
        nt(e, n, !1) || tt(e, n, r, "deepEqual", t)
    }
    ,
    X.deepStrictEqual = function t(e, n, r) {
        nt(e, n, !0) || tt(e, n, r, "deepStrictEqual", t)
    }
    ,
    X.notDeepEqual = function t(e, n, r) {
        nt(e, n, !1) && tt(e, n, r, "notDeepEqual", t)
    }
    ,
    X.notDeepStrictEqual = function t(e, n, r) {
        nt(e, n, !0) && tt(e, n, r, "notDeepStrictEqual", t)
    }
    ,
    X.strictEqual = function t(e, n, r) {
        e !== n && tt(e, n, r, "===", t)
    }
    ,
    X.notStrictEqual = function t(e, n, r) {
        e === n && tt(e, n, r, "!==", t)
    }
    ,
    X.throws = function(t, e, n) {
        st(!0, t, e, n)
    }
    ,
    X.doesNotThrow = function(t, e, n) {
        st(!1, t, e, n)
    }
    ,
    X.ifError = function(t) {
        if (t)
            throw t
    }
    ;
    var ot = {};
    class at {
        constructor(t, e) {
            if (!Number.isInteger(t))
                throw new TypeError("span must be an integer");
            this.span = t,
            this.property = e
        }
        makeDestinationObject() {
            return {}
        }
        decode(t, e) {
            throw new Error("Layout is abstract")
        }
        encode(t, e, n) {
            throw new Error("Layout is abstract")
        }
        getSpan(t, e) {
            if (0 > this.span)
                throw new RangeError("indeterminate span");
            return this.span
        }
        replicate(t) {
            const e = Object.create(this.constructor.prototype);
            return Object.assign(e, this),
            e.property = t,
            e
        }
        fromArray(t) {}
    }
    function lt(t, e) {
        return e.property ? t + "[" + e.property + "]" : t
    }
    ot.Layout = at,
    ot.nameWithProperty = lt,
    ot.bindConstructorLayout = function(t, e) {
        if ("function" != typeof t)
            throw new TypeError("Class must be constructor");
        if (t.hasOwnProperty("layout_"))
            throw new Error("Class is already bound to a layout");
        if (!(e && e instanceof at))
            throw new TypeError("layout must be a Layout");
        if (e.hasOwnProperty("boundConstructor_"))
            throw new Error("layout is already bound to a constructor");
        t.layout_ = e,
        e.boundConstructor_ = t,
        e.makeDestinationObject = ()=>new t,
        Object.defineProperty(t.prototype, "encode", {
            value: function(t, n) {
                return e.encode(this, t, n)
            },
            writable: !0
        }),
        Object.defineProperty(t, "decode", {
            value: function(t, n) {
                return e.decode(t, n)
            },
            writable: !0
        })
    }
    ;
    class ct extends at {
        isCount() {
            throw new Error("ExternalLayout is abstract")
        }
    }
    class ut extends ct {
        constructor(t, e) {
            if (void 0 === t && (t = 1),
            !Number.isInteger(t) || 0 >= t)
                throw new TypeError("elementSpan must be a (positive) integer");
            super(-1, e),
            this.elementSpan = t
        }
        isCount() {
            return !0
        }
        decode(t, e) {
            void 0 === e && (e = 0);
            const n = t.length - e;
            return Math.floor(n / this.elementSpan)
        }
        encode(t, e, n) {
            return 0
        }
    }
    class ht extends ct {
        constructor(t, e, n) {
            if (!(t instanceof at))
                throw new TypeError("layout must be a Layout");
            if (void 0 === e)
                e = 0;
            else if (!Number.isInteger(e))
                throw new TypeError("offset must be integer or undefined");
            super(t.span, n || t.property),
            this.layout = t,
            this.offset = e
        }
        isCount() {
            return this.layout instanceof dt || this.layout instanceof ft
        }
        decode(t, e) {
            return void 0 === e && (e = 0),
            this.layout.decode(t, e + this.offset)
        }
        encode(t, e, n) {
            return void 0 === n && (n = 0),
            this.layout.encode(t, e, n + this.offset)
        }
    }
    class dt extends at {
        constructor(t, e) {
            if (super(t, e),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(t, e) {
            return void 0 === e && (e = 0),
            t.readUIntLE(e, this.span)
        }
        encode(t, e, n) {
            return void 0 === n && (n = 0),
            e.writeUIntLE(t, n, this.span),
            this.span
        }
    }
    class ft extends at {
        constructor(t, e) {
            if (super(t, e),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(t, e) {
            return void 0 === e && (e = 0),
            t.readUIntBE(e, this.span)
        }
        encode(t, e, n) {
            return void 0 === n && (n = 0),
            e.writeUIntBE(t, n, this.span),
            this.span
        }
    }
    class pt extends at {
        constructor(t, e) {
            if (super(t, e),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(t, e) {
            return void 0 === e && (e = 0),
            t.readIntLE(e, this.span)
        }
        encode(t, e, n) {
            return void 0 === n && (n = 0),
            e.writeIntLE(t, n, this.span),
            this.span
        }
    }
    class mt extends at {
        constructor(t, e) {
            if (super(t, e),
            6 < this.span)
                throw new RangeError("span must not exceed 6 bytes")
        }
        decode(t, e) {
            return void 0 === e && (e = 0),
            t.readIntBE(e, this.span)
        }
        encode(t, e, n) {
            return void 0 === n && (n = 0),
            e.writeIntBE(t, n, this.span),
            this.span
        }
    }
    const gt = Math.pow(2, 32);
    function yt(t) {
        const e = Math.floor(t / gt);
        return {
            hi32: e,
            lo32: t - e * gt
        }
    }
    function bt(t, e) {
        return t * gt + e
    }
    class vt extends at {
        constructor(t) {
            super(8, t)
        }
        decode(t, e) {
            void 0 === e && (e = 0);
            const n = t.readUInt32LE(e);
            return bt(t.readUInt32LE(e + 4), n)
        }
        encode(t, e, n) {
            void 0 === n && (n = 0);
            const r = yt(t);
            return e.writeUInt32LE(r.lo32, n),
            e.writeUInt32LE(r.hi32, n + 4),
            8
        }
    }
    class wt extends at {
        constructor(t) {
            super(8, t)
        }
        decode(t, e) {
            void 0 === e && (e = 0);
            return bt(t.readUInt32BE(e), t.readUInt32BE(e + 4))
        }
        encode(t, e, n) {
            void 0 === n && (n = 0);
            const r = yt(t);
            return e.writeUInt32BE(r.hi32, n),
            e.writeUInt32BE(r.lo32, n + 4),
            8
        }
    }
    class xt extends at {
        constructor(t) {
            super(8, t)
        }
        decode(t, e) {
            void 0 === e && (e = 0);
            const n = t.readUInt32LE(e);
            return bt(t.readInt32LE(e + 4), n)
        }
        encode(t, e, n) {
            void 0 === n && (n = 0);
            const r = yt(t);
            return e.writeUInt32LE(r.lo32, n),
            e.writeInt32LE(r.hi32, n + 4),
            8
        }
    }
    class Et extends at {
        constructor(t) {
            super(8, t)
        }
        decode(t, e) {
            void 0 === e && (e = 0);
            return bt(t.readInt32BE(e), t.readUInt32BE(e + 4))
        }
        encode(t, e, n) {
            void 0 === n && (n = 0);
            const r = yt(t);
            return e.writeInt32BE(r.hi32, n),
            e.writeUInt32BE(r.lo32, n + 4),
            8
        }
    }
    class _t extends at {
        constructor(t) {
            super(4, t)
        }
        decode(t, e) {
            return void 0 === e && (e = 0),
            t.readFloatLE(e)
        }
        encode(t, e, n) {
            return void 0 === n && (n = 0),
            e.writeFloatLE(t, n),
            4
        }
    }
    class At extends at {
        constructor(t) {
            super(4, t)
        }
        decode(t, e) {
            return void 0 === e && (e = 0),
            t.readFloatBE(e)
        }
        encode(t, e, n) {
            return void 0 === n && (n = 0),
            e.writeFloatBE(t, n),
            4
        }
    }
    class St extends at {
        constructor(t) {
            super(8, t)
        }
        decode(t, e) {
            return void 0 === e && (e = 0),
            t.readDoubleLE(e)
        }
        encode(t, e, n) {
            return void 0 === n && (n = 0),
            e.writeDoubleLE(t, n),
            8
        }
    }
    class Tt extends at {
        constructor(t) {
            super(8, t)
        }
        decode(t, e) {
            return void 0 === e && (e = 0),
            t.readDoubleBE(e)
        }
        encode(t, e, n) {
            return void 0 === n && (n = 0),
            e.writeDoubleBE(t, n),
            8
        }
    }
    class kt extends at {
        constructor(t, e, n) {
            if (!(t instanceof at))
                throw new TypeError("elementLayout must be a Layout");
            if (!(e instanceof ct && e.isCount() || Number.isInteger(e) && 0 <= e))
                throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
            let r = -1;
            !(e instanceof ct) && 0 < t.span && (r = e * t.span),
            super(r, n),
            this.elementLayout = t,
            this.count = e
        }
        getSpan(t, e) {
            if (0 <= this.span)
                return this.span;
            void 0 === e && (e = 0);
            let n = 0
              , r = this.count;
            if (r instanceof ct && (r = r.decode(t, e)),
            0 < this.elementLayout.span)
                n = r * this.elementLayout.span;
            else {
                let i = 0;
                for (; i < r; )
                    n += this.elementLayout.getSpan(t, e + n),
                    ++i
            }
            return n
        }
        decode(t, e) {
            void 0 === e && (e = 0);
            const n = [];
            let r = 0
              , i = this.count;
            for (i instanceof ct && (i = i.decode(t, e)); r < i; )
                n.push(this.elementLayout.decode(t, e)),
                e += this.elementLayout.getSpan(t, e),
                r += 1;
            return n
        }
        encode(t, e, n) {
            void 0 === n && (n = 0);
            const r = this.elementLayout
              , i = t.reduce(((t,i)=>t + r.encode(i, e, n + t)), 0);
            return this.count instanceof ct && this.count.encode(t.length, e, n),
            i
        }
    }
    class It extends at {
        constructor(t, e, n) {
            if (!Array.isArray(t) || !t.reduce(((t,e)=>t && e instanceof at), !0))
                throw new TypeError("fields must be array of Layout instances");
            "boolean" == typeof e && void 0 === n && (n = e,
            e = void 0);
            for (const e of t)
                if (0 > e.span && void 0 === e.property)
                    throw new Error("fields cannot contain unnamed variable-length layout");
            let r = -1;
            try {
                r = t.reduce(((t,e)=>t + e.getSpan()), 0)
            } catch (t) {}
            super(r, e),
            this.fields = t,
            this.decodePrefixes = !!n
        }
        getSpan(t, e) {
            if (0 <= this.span)
                return this.span;
            void 0 === e && (e = 0);
            let n = 0;
            try {
                n = this.fields.reduce(((n,r)=>{
                    const i = r.getSpan(t, e);
                    return e += i,
                    n + i
                }
                ), 0)
            } catch (t) {
                throw new RangeError("indeterminate span")
            }
            return n
        }
        decode(t, e) {
            void 0 === e && (e = 0);
            const n = this.makeDestinationObject();
            for (const r of this.fields)
                if (void 0 !== r.property && (n[r.property] = r.decode(t, e)),
                e += r.getSpan(t, e),
                this.decodePrefixes && t.length === e)
                    break;
            return n
        }
        encode(t, e, n) {
            void 0 === n && (n = 0);
            const r = n;
            let i = 0
              , s = 0;
            for (const r of this.fields) {
                let o = r.span;
                if (s = 0 < o ? o : 0,
                void 0 !== r.property) {
                    const i = t[r.property];
                    void 0 !== i && (s = r.encode(i, e, n),
                    0 > o && (o = r.getSpan(e, n)))
                }
                i = n,
                n += o
            }
            return i + s - r
        }
        fromArray(t) {
            const e = this.makeDestinationObject();
            for (const n of this.fields)
                void 0 !== n.property && 0 < t.length && (e[n.property] = t.shift());
            return e
        }
        layoutFor(t) {
            if ("string" != typeof t)
                throw new TypeError("property must be string");
            for (const e of this.fields)
                if (e.property === t)
                    return e
        }
        offsetOf(t) {
            if ("string" != typeof t)
                throw new TypeError("property must be string");
            let e = 0;
            for (const n of this.fields) {
                if (n.property === t)
                    return e;
                0 > n.span ? e = -1 : 0 <= e && (e += n.span)
            }
        }
    }
    class Mt {
        constructor(t) {
            this.property = t
        }
        decode() {
            throw new Error("UnionDiscriminator is abstract")
        }
        encode() {
            throw new Error("UnionDiscriminator is abstract")
        }
    }
    class Ct extends Mt {
        constructor(t, e) {
            if (!(t instanceof ct && t.isCount()))
                throw new TypeError("layout must be an unsigned integer ExternalLayout");
            super(e || t.property || "variant"),
            this.layout = t
        }
        decode(t, e) {
            return this.layout.decode(t, e)
        }
        encode(t, e, n) {
            return this.layout.encode(t, e, n)
        }
    }
    class Pt extends at {
        constructor(t, e, n) {
            const r = t instanceof dt || t instanceof ft;
            if (r)
                t = new Ct(new ht(t));
            else if (t instanceof ct && t.isCount())
                t = new Ct(t);
            else if (!(t instanceof Mt))
                throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
            if (void 0 === e && (e = null),
            !(null === e || e instanceof at))
                throw new TypeError("defaultLayout must be null or a Layout");
            if (null !== e) {
                if (0 > e.span)
                    throw new Error("defaultLayout must have constant span");
                void 0 === e.property && (e = e.replicate("content"))
            }
            let i = -1;
            e && (i = e.span,
            0 <= i && r && (i += t.layout.span)),
            super(i, n),
            this.discriminator = t,
            this.usesPrefixDiscriminator = r,
            this.defaultLayout = e,
            this.registry = {};
            let s = this.defaultGetSourceVariant.bind(this);
            this.getSourceVariant = function(t) {
                return s(t)
            }
            ,
            this.configGetSourceVariant = function(t) {
                s = t.bind(this)
            }
        }
        getSpan(t, e) {
            if (0 <= this.span)
                return this.span;
            void 0 === e && (e = 0);
            const n = this.getVariant(t, e);
            if (!n)
                throw new Error("unable to determine span for unrecognized variant");
            return n.getSpan(t, e)
        }
        defaultGetSourceVariant(t) {
            if (t.hasOwnProperty(this.discriminator.property)) {
                if (this.defaultLayout && t.hasOwnProperty(this.defaultLayout.property))
                    return;
                const e = this.registry[t[this.discriminator.property]];
                if (e && (!e.layout || t.hasOwnProperty(e.property)))
                    return e
            } else
                for (const e in this.registry) {
                    const n = this.registry[e];
                    if (t.hasOwnProperty(n.property))
                        return n
                }
            throw new Error("unable to infer src variant")
        }
        decode(t, e) {
            let n;
            void 0 === e && (e = 0);
            const r = this.discriminator
              , i = r.decode(t, e);
            let s = this.registry[i];
            if (void 0 === s) {
                let o = 0;
                s = this.defaultLayout,
                this.usesPrefixDiscriminator && (o = r.layout.span),
                n = this.makeDestinationObject(),
                n[r.property] = i,
                n[s.property] = this.defaultLayout.decode(t, e + o)
            } else
                n = s.decode(t, e);
            return n
        }
        encode(t, e, n) {
            void 0 === n && (n = 0);
            const r = this.getSourceVariant(t);
            if (void 0 === r) {
                const r = this.discriminator
                  , i = this.defaultLayout;
                let s = 0;
                return this.usesPrefixDiscriminator && (s = r.layout.span),
                r.encode(t[r.property], e, n),
                s + i.encode(t[i.property], e, n + s)
            }
            return r.encode(t, e, n)
        }
        addVariant(t, e, n) {
            const r = new Ot(this,t,e,n);
            return this.registry[t] = r,
            r
        }
        getVariant(t, e) {
            let n = t;
            return c.Buffer.isBuffer(t) && (void 0 === e && (e = 0),
            n = this.discriminator.decode(t, e)),
            this.registry[n]
        }
    }
    class Ot extends at {
        constructor(t, e, n, r) {
            if (!(t instanceof Pt))
                throw new TypeError("union must be a Union");
            if (!Number.isInteger(e) || 0 > e)
                throw new TypeError("variant must be a (non-negative) integer");
            if ("string" == typeof n && void 0 === r && (r = n,
            n = null),
            n) {
                if (!(n instanceof at))
                    throw new TypeError("layout must be a Layout");
                if (null !== t.defaultLayout && 0 <= n.span && n.span > t.defaultLayout.span)
                    throw new Error("variant span exceeds span of containing union");
                if ("string" != typeof r)
                    throw new TypeError("variant must have a String property")
            }
            let i = t.span;
            0 > t.span && (i = n ? n.span : 0,
            0 <= i && t.usesPrefixDiscriminator && (i += t.discriminator.layout.span)),
            super(i, r),
            this.union = t,
            this.variant = e,
            this.layout = n || null
        }
        getSpan(t, e) {
            if (0 <= this.span)
                return this.span;
            void 0 === e && (e = 0);
            let n = 0;
            return this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span),
            n + this.layout.getSpan(t, e + n)
        }
        decode(t, e) {
            const n = this.makeDestinationObject();
            if (void 0 === e && (e = 0),
            this !== this.union.getVariant(t, e))
                throw new Error("variant mismatch");
            let r = 0;
            return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span),
            this.layout ? n[this.property] = this.layout.decode(t, e + r) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant),
            n
        }
        encode(t, e, n) {
            void 0 === n && (n = 0);
            let r = 0;
            if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span),
            this.layout && !t.hasOwnProperty(this.property))
                throw new TypeError("variant lacks property " + this.property);
            this.union.discriminator.encode(this.variant, e, n);
            let i = r;
            if (this.layout && (this.layout.encode(t[this.property], e, n + r),
            i += this.layout.getSpan(e, n + r),
            0 <= this.union.span && i > this.union.span))
                throw new Error("encoded variant overruns containing union");
            return i
        }
        fromArray(t) {
            if (this.layout)
                return this.layout.fromArray(t)
        }
    }
    function Nt(t) {
        return 0 > t && (t += 4294967296),
        t
    }
    class Rt extends at {
        constructor(t, e, n) {
            if (!(t instanceof dt || t instanceof ft))
                throw new TypeError("word must be a UInt or UIntBE layout");
            if ("string" == typeof e && void 0 === n && (n = e,
            e = void 0),
            4 < t.span)
                throw new RangeError("word cannot exceed 32 bits");
            super(t.span, n),
            this.word = t,
            this.msb = !!e,
            this.fields = [];
            let r = 0;
            this._packedSetValue = function(t) {
                return r = Nt(t),
                this
            }
            ,
            this._packedGetValue = function() {
                return r
            }
        }
        decode(t, e) {
            const n = this.makeDestinationObject();
            void 0 === e && (e = 0);
            const r = this.word.decode(t, e);
            this._packedSetValue(r);
            for (const t of this.fields)
                void 0 !== t.property && (n[t.property] = t.decode(r));
            return n
        }
        encode(t, e, n) {
            void 0 === n && (n = 0);
            const r = this.word.decode(e, n);
            this._packedSetValue(r);
            for (const e of this.fields)
                if (void 0 !== e.property) {
                    const n = t[e.property];
                    void 0 !== n && e.encode(n)
                }
            return this.word.encode(this._packedGetValue(), e, n)
        }
        addField(t, e) {
            const n = new Dt(this,t,e);
            return this.fields.push(n),
            n
        }
        addBoolean(t) {
            const e = new Bt(this,t);
            return this.fields.push(e),
            e
        }
        fieldFor(t) {
            if ("string" != typeof t)
                throw new TypeError("property must be string");
            for (const e of this.fields)
                if (e.property === t)
                    return e
        }
    }
    class Dt {
        constructor(t, e, n) {
            if (!(t instanceof Rt))
                throw new TypeError("container must be a BitStructure");
            if (!Number.isInteger(e) || 0 >= e)
                throw new TypeError("bits must be positive integer");
            const r = 8 * t.span
              , i = t.fields.reduce(((t,e)=>t + e.bits), 0);
            if (e + i > r)
                throw new Error("bits too long for span remainder (" + (r - i) + " of " + r + " remain)");
            this.container = t,
            this.bits = e,
            this.valueMask = (1 << e) - 1,
            32 === e && (this.valueMask = 4294967295),
            this.start = i,
            this.container.msb && (this.start = r - i - e),
            this.wordMask = Nt(this.valueMask << this.start),
            this.property = n
        }
        decode() {
            return Nt(this.container._packedGetValue() & this.wordMask) >>> this.start
        }
        encode(t) {
            if (!Number.isInteger(t) || t !== Nt(t & this.valueMask))
                throw new TypeError(lt("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
            const e = this.container._packedGetValue()
              , n = Nt(t << this.start);
            this.container._packedSetValue(Nt(e & ~this.wordMask) | n)
        }
    }
    class Bt extends Dt {
        constructor(t, e) {
            super(t, 1, e)
        }
        decode(t, e) {
            return !!Dt.prototype.decode.call(this, t, e)
        }
        encode(t) {
            return "boolean" == typeof t && (t = +t),
            Dt.prototype.encode.call(this, t)
        }
    }
    class Lt extends at {
        constructor(t, e) {
            if (!(t instanceof ct && t.isCount() || Number.isInteger(t) && 0 <= t))
                throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
            let n = -1;
            t instanceof ct || (n = t),
            super(n, e),
            this.length = t
        }
        getSpan(t, e) {
            let n = this.span;
            return 0 > n && (n = this.length.decode(t, e)),
            n
        }
        decode(t, e) {
            void 0 === e && (e = 0);
            let n = this.span;
            return 0 > n && (n = this.length.decode(t, e)),
            t.slice(e, e + n)
        }
        encode(t, e, n) {
            let r = this.length;
            if (this.length instanceof ct && (r = t.length),
            !c.Buffer.isBuffer(t) || r !== t.length)
                throw new TypeError(lt("Blob.encode", this) + " requires (length " + r + ") Buffer as src");
            if (n + r > e.length)
                throw new RangeError("encoding overruns Buffer");
            return e.write(t.toString("hex"), n, r, "hex"),
            this.length instanceof ct && this.length.encode(r, e, n),
            r
        }
    }
    class Ft extends at {
        constructor(t) {
            super(-1, t)
        }
        getSpan(t, e) {
            if (!c.Buffer.isBuffer(t))
                throw new TypeError("b must be a Buffer");
            void 0 === e && (e = 0);
            let n = e;
            for (; n < t.length && 0 !== t[n]; )
                n += 1;
            return 1 + n - e
        }
        decode(t, e, n) {
            void 0 === e && (e = 0);
            let r = this.getSpan(t, e);
            return t.slice(e, e + r - 1).toString("utf-8")
        }
        encode(t, e, n) {
            void 0 === n && (n = 0),
            "string" != typeof t && (t = t.toString());
            const r = new c.Buffer(t,"utf8")
              , i = r.length;
            if (n + i > e.length)
                throw new RangeError("encoding overruns Buffer");
            return r.copy(e, n),
            e[n + i] = 0,
            i + 1
        }
    }
    class jt extends at {
        constructor(t, e) {
            if ("string" == typeof t && void 0 === e && (e = t,
            t = void 0),
            void 0 === t)
                t = -1;
            else if (!Number.isInteger(t))
                throw new TypeError("maxSpan must be an integer");
            super(-1, e),
            this.maxSpan = t
        }
        getSpan(t, e) {
            if (!c.Buffer.isBuffer(t))
                throw new TypeError("b must be a Buffer");
            return void 0 === e && (e = 0),
            t.length - e
        }
        decode(t, e, n) {
            void 0 === e && (e = 0);
            let r = this.getSpan(t, e);
            if (0 <= this.maxSpan && this.maxSpan < r)
                throw new RangeError("text length exceeds maxSpan");
            return t.slice(e, e + r).toString("utf-8")
        }
        encode(t, e, n) {
            void 0 === n && (n = 0),
            "string" != typeof t && (t = t.toString());
            const r = new c.Buffer(t,"utf8")
              , i = r.length;
            if (0 <= this.maxSpan && this.maxSpan < i)
                throw new RangeError("text length exceeds maxSpan");
            if (n + i > e.length)
                throw new RangeError("encoding overruns Buffer");
            return r.copy(e, n),
            i
        }
    }
    class Ut extends at {
        constructor(t, e) {
            super(0, e),
            this.value = t
        }
        decode(t, e, n) {
            return this.value
        }
        encode(t, e, n) {
            return 0
        }
    }
    ot.ExternalLayout = ct,
    ot.GreedyCount = ut,
    ot.OffsetLayout = ht,
    ot.UInt = dt,
    ot.UIntBE = ft,
    ot.Int = pt,
    ot.IntBE = mt,
    ot.Float = _t,
    ot.FloatBE = At,
    ot.Double = St,
    ot.DoubleBE = Tt,
    ot.Sequence = kt,
    ot.Structure = It,
    ot.UnionDiscriminator = Mt,
    ot.UnionLayoutDiscriminator = Ct,
    ot.Union = Pt,
    ot.VariantLayout = Ot,
    ot.BitStructure = Rt,
    ot.BitField = Dt,
    ot.Boolean = Bt,
    ot.Blob = Lt,
    ot.CString = Ft,
    ot.UTF8 = jt,
    ot.Constant = Ut,
    ot.greedy = (t,e)=>new ut(t,e),
    ot.offset = (t,e,n)=>new ht(t,e,n);
    var zt = ot.u8 = t=>new dt(1,t);
    ot.u16 = t=>new dt(2,t),
    ot.u24 = t=>new dt(3,t);
    var Vt = ot.u32 = t=>new dt(4,t);
    ot.u40 = t=>new dt(5,t),
    ot.u48 = t=>new dt(6,t),
    ot.nu64 = t=>new vt(t),
    ot.u16be = t=>new ft(2,t),
    ot.u24be = t=>new ft(3,t),
    ot.u32be = t=>new ft(4,t),
    ot.u40be = t=>new ft(5,t),
    ot.u48be = t=>new ft(6,t),
    ot.nu64be = t=>new wt(t),
    ot.s8 = t=>new pt(1,t),
    ot.s16 = t=>new pt(2,t),
    ot.s24 = t=>new pt(3,t),
    ot.s32 = t=>new pt(4,t),
    ot.s40 = t=>new pt(5,t),
    ot.s48 = t=>new pt(6,t),
    ot.ns64 = t=>new xt(t),
    ot.s16be = t=>new mt(2,t),
    ot.s24be = t=>new mt(3,t),
    ot.s32be = t=>new mt(4,t),
    ot.s40be = t=>new mt(5,t),
    ot.s48be = t=>new mt(6,t),
    ot.ns64be = t=>new Et(t),
    ot.f32 = t=>new _t(t),
    ot.f32be = t=>new At(t),
    ot.f64 = t=>new St(t),
    ot.f64be = t=>new Tt(t);
    var Wt = ot.struct = (t,e,n)=>new It(t,e,n);
    ot.bits = (t,e,n)=>new Rt(t,e,n),
    ot.seq = (t,e,n)=>new kt(t,e,n),
    ot.union = (t,e,n)=>new Pt(t,e,n),
    ot.unionLayoutDiscriminator = (t,e)=>new Ct(t,e);
    var Yt = ot.blob = (t,e)=>new Lt(t,e);
    ot.cstr = t=>new Ft(t),
    ot.utf8 = (t,e)=>new jt(t,e),
    ot.const = (t,e)=>new Ut(t,e);
    const Ht = (t="publicKey")=>Yt(32, t)
      , $t = (t="uint64")=>Yt(8, t);
    function Gt(t, e, n, ...r) {
        return (0,
        l.sendAndConfirmTransaction)(e, n, r, {
            skipPreflight: !1
        })
    }
    const Xt = new (0,
    l.PublicKey)("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
      , qt = new (0,
    l.PublicKey)("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
      , Kt = "Failed to find account"
      , Qt = "Invalid account owner";
    function Zt(t) {
        return c.Buffer.from(t.toBuffer())
    }
    class Jt extends (e(a)) {
        toBuffer() {
            const t = super.toArray().reverse()
              , e = c.Buffer.from(t);
            if (8 === e.length)
                return e;
            X(e.length < 8, "u64 too large");
            const n = c.Buffer.alloc(8);
            return e.copy(n),
            n
        }
        static fromBuffer(t) {
            return X(8 === t.length, `Invalid buffer length: ${t.length}`),
            new Jt([...t].reverse().map((t=>`00${t.toString(16)}`.slice(-2))).join(""),16)
        }
    }
    function te(t) {
        return "publicKey"in t
    }
    const ee = {
        MintTokens: 0,
        FreezeAccount: 1,
        AccountOwner: 2,
        CloseAccount: 3
    }
      , ne = new (0,
    l.PublicKey)("So11111111111111111111111111111111111111112")
      , re = Wt([Vt("mintAuthorityOption"), Ht("mintAuthority"), $t("supply"), zt("decimals"), zt("isInitialized"), Vt("freezeAuthorityOption"), Ht("freezeAuthority")])
      , ie = Wt([Ht("mint"), Ht("owner"), $t("amount"), Vt("delegateOption"), Ht("delegate"), zt("state"), Vt("isNativeOption"), $t("isNative"), $t("delegatedAmount"), Vt("closeAuthorityOption"), Ht("closeAuthority")])
      , se = Wt([zt("m"), zt("n"), zt("is_initialized"), Ht("signer1"), Ht("signer2"), Ht("signer3"), Ht("signer4"), Ht("signer5"), Ht("signer6"), Ht("signer7"), Ht("signer8"), Ht("signer9"), Ht("signer10"), Ht("signer11")]);
    class oe {
        constructor(t, n, r, i) {
            e(s)(this, "connection", void 0),
            e(s)(this, "publicKey", void 0),
            e(s)(this, "programId", void 0),
            e(s)(this, "associatedProgramId", void 0),
            e(s)(this, "payer", void 0),
            Object.assign(this, {
                connection: t,
                publicKey: n,
                programId: r,
                payer: i,
                associatedProgramId: qt
            })
        }
        static async getMinBalanceRentForExemptMint(t) {
            return await t.getMinimumBalanceForRentExemption(re.span)
        }
        static async getMinBalanceRentForExemptAccount(t) {
            return await t.getMinimumBalanceForRentExemption(ie.span)
        }
        static async getMinBalanceRentForExemptMultisig(t) {
            return await t.getMinimumBalanceForRentExemption(se.span)
        }
        static async createMint(t, e, n, r, i, s) {
            const o = l.Keypair.generate()
              , a = new oe(t,o.publicKey,s,e)
              , c = await oe.getMinBalanceRentForExemptMint(t)
              , u = new (0,
            l.Transaction);
            return u.add(l.SystemProgram.createAccount({
                fromPubkey: e.publicKey,
                newAccountPubkey: o.publicKey,
                lamports: c,
                space: re.span,
                programId: s
            })),
            u.add(oe.createInitMintInstruction(s, o.publicKey, i, n, r)),
            await Gt(0, t, u, e, o),
            a
        }
        async createAccount(t) {
            const e = await oe.getMinBalanceRentForExemptAccount(this.connection)
              , n = l.Keypair.generate()
              , r = new (0,
            l.Transaction);
            r.add(l.SystemProgram.createAccount({
                fromPubkey: this.payer.publicKey,
                newAccountPubkey: n.publicKey,
                lamports: e,
                space: ie.span,
                programId: this.programId
            }));
            const i = this.publicKey;
            return r.add(oe.createInitAccountInstruction(this.programId, i, n.publicKey, t)),
            await Gt(0, this.connection, r, this.payer, n),
            n.publicKey
        }
        async createAssociatedTokenAccount(t) {
            const e = await oe.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, t);
            return this.createAssociatedTokenAccountInternal(t, e)
        }
        async createAssociatedTokenAccountInternal(t, e) {
            return await Gt(0, this.connection, (new (0,
            l.Transaction)).add(oe.createAssociatedTokenAccountInstruction(this.associatedProgramId, this.programId, this.publicKey, e, t, this.payer.publicKey)), this.payer),
            e
        }
        async getOrCreateAssociatedAccountInfo(t) {
            const e = await oe.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, t);
            try {
                return await this.getAccountInfo(e)
            } catch (n) {
                if (n.message === Kt || n.message === Qt) {
                    try {
                        await this.createAssociatedTokenAccountInternal(t, e)
                    } catch (t) {}
                    return await this.getAccountInfo(e)
                }
                throw n
            }
        }
        static async createWrappedNativeAccount(t, e, n, r, i) {
            const s = await oe.getMinBalanceRentForExemptAccount(t)
              , o = l.Keypair.generate()
              , a = new (0,
            l.Transaction);
            return a.add(l.SystemProgram.createAccount({
                fromPubkey: r.publicKey,
                newAccountPubkey: o.publicKey,
                lamports: s,
                space: ie.span,
                programId: e
            })),
            a.add(l.SystemProgram.transfer({
                fromPubkey: r.publicKey,
                toPubkey: o.publicKey,
                lamports: i
            })),
            a.add(oe.createInitAccountInstruction(e, ne, o.publicKey, n)),
            await Gt(0, t, a, r, o),
            o.publicKey
        }
        async createMultisig(t, e) {
            const n = l.Keypair.generate()
              , r = await oe.getMinBalanceRentForExemptMultisig(this.connection)
              , i = new (0,
            l.Transaction);
            i.add(l.SystemProgram.createAccount({
                fromPubkey: this.payer.publicKey,
                newAccountPubkey: n.publicKey,
                lamports: r,
                space: se.span,
                programId: this.programId
            }));
            let s = [{
                pubkey: n.publicKey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: l.SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }];
            e.forEach((t=>s.push({
                pubkey: t,
                isSigner: !1,
                isWritable: !1
            })));
            const o = Wt([zt("instruction"), zt("m")])
              , a = c.Buffer.alloc(o.span);
            return o.encode({
                instruction: 2,
                m: t
            }, a),
            i.add({
                keys: s,
                programId: this.programId,
                data: a
            }),
            await Gt(0, this.connection, i, this.payer, n),
            n.publicKey
        }
        async getMintInfo() {
            const t = await this.connection.getAccountInfo(this.publicKey);
            if (null === t)
                throw new Error("Failed to find mint account");
            if (!t.owner.equals(this.programId))
                throw new Error(`Invalid mint owner: ${JSON.stringify(t.owner)}`);
            if (t.data.length != re.span)
                throw new Error("Invalid mint size");
            const e = c.Buffer.from(t.data)
              , n = re.decode(e);
            return 0 === n.mintAuthorityOption ? n.mintAuthority = null : n.mintAuthority = new (0,
            l.PublicKey)(n.mintAuthority),
            n.supply = Jt.fromBuffer(n.supply),
            n.isInitialized = 0 != n.isInitialized,
            0 === n.freezeAuthorityOption ? n.freezeAuthority = null : n.freezeAuthority = new (0,
            l.PublicKey)(n.freezeAuthority),
            n
        }
        async getAccountInfo(t, e) {
            const n = await this.connection.getAccountInfo(t, e);
            if (null === n)
                throw new Error(Kt);
            if (!n.owner.equals(this.programId))
                throw new Error(Qt);
            if (n.data.length != ie.span)
                throw new Error("Invalid account size");
            const r = c.Buffer.from(n.data)
              , i = ie.decode(r);
            if (i.address = t,
            i.mint = new (0,
            l.PublicKey)(i.mint),
            i.owner = new (0,
            l.PublicKey)(i.owner),
            i.amount = Jt.fromBuffer(i.amount),
            0 === i.delegateOption ? (i.delegate = null,
            i.delegatedAmount = new Jt) : (i.delegate = new (0,
            l.PublicKey)(i.delegate),
            i.delegatedAmount = Jt.fromBuffer(i.delegatedAmount)),
            i.isInitialized = 0 !== i.state,
            i.isFrozen = 2 === i.state,
            1 === i.isNativeOption ? (i.rentExemptReserve = Jt.fromBuffer(i.isNative),
            i.isNative = !0) : (i.rentExemptReserve = null,
            i.isNative = !1),
            0 === i.closeAuthorityOption ? i.closeAuthority = null : i.closeAuthority = new (0,
            l.PublicKey)(i.closeAuthority),
            !i.mint.equals(this.publicKey))
                throw new Error(`Invalid account mint: ${JSON.stringify(i.mint)} !== ${JSON.stringify(this.publicKey)}`);
            return i
        }
        async getMultisigInfo(t) {
            const e = await this.connection.getAccountInfo(t);
            if (null === e)
                throw new Error("Failed to find multisig");
            if (!e.owner.equals(this.programId))
                throw new Error("Invalid multisig owner");
            if (e.data.length != se.span)
                throw new Error("Invalid multisig size");
            const n = c.Buffer.from(e.data)
              , r = se.decode(n);
            return r.signer1 = new (0,
            l.PublicKey)(r.signer1),
            r.signer2 = new (0,
            l.PublicKey)(r.signer2),
            r.signer3 = new (0,
            l.PublicKey)(r.signer3),
            r.signer4 = new (0,
            l.PublicKey)(r.signer4),
            r.signer5 = new (0,
            l.PublicKey)(r.signer5),
            r.signer6 = new (0,
            l.PublicKey)(r.signer6),
            r.signer7 = new (0,
            l.PublicKey)(r.signer7),
            r.signer8 = new (0,
            l.PublicKey)(r.signer8),
            r.signer9 = new (0,
            l.PublicKey)(r.signer9),
            r.signer10 = new (0,
            l.PublicKey)(r.signer10),
            r.signer11 = new (0,
            l.PublicKey)(r.signer11),
            r
        }
        async transfer(t, e, n, r, i) {
            let s, o;
            return te(n) ? (s = n.publicKey,
            o = [n]) : (s = n,
            o = r),
            await Gt("Transfer", this.connection, (new (0,
            l.Transaction)).add(oe.createTransferInstruction(this.programId, t, e, s, r, i)), this.payer, ...o)
        }
        async approve(t, e, n, r, i) {
            let s, o;
            te(n) ? (s = n.publicKey,
            o = [n]) : (s = n,
            o = r),
            await Gt("Approve", this.connection, (new (0,
            l.Transaction)).add(oe.createApproveInstruction(this.programId, t, e, s, r, i)), this.payer, ...o)
        }
        async revoke(t, e, n) {
            let r, i;
            te(e) ? (r = e.publicKey,
            i = [e]) : (r = e,
            i = n),
            await Gt("Revoke", this.connection, (new (0,
            l.Transaction)).add(oe.createRevokeInstruction(this.programId, t, r, n)), this.payer, ...i)
        }
        async setAuthority(t, e, n, r, i) {
            let s, o;
            te(r) ? (s = r.publicKey,
            o = [r]) : (s = r,
            o = i),
            await Gt("SetAuthority", this.connection, (new (0,
            l.Transaction)).add(oe.createSetAuthorityInstruction(this.programId, t, e, n, s, i)), this.payer, ...o)
        }
        async mintTo(t, e, n, r) {
            let i, s;
            te(e) ? (i = e.publicKey,
            s = [e]) : (i = e,
            s = n),
            await Gt("MintTo", this.connection, (new (0,
            l.Transaction)).add(oe.createMintToInstruction(this.programId, this.publicKey, t, i, n, r)), this.payer, ...s)
        }
        async burn(t, e, n, r) {
            let i, s;
            te(e) ? (i = e.publicKey,
            s = [e]) : (i = e,
            s = n),
            await Gt("Burn", this.connection, (new (0,
            l.Transaction)).add(oe.createBurnInstruction(this.programId, this.publicKey, t, i, n, r)), this.payer, ...s)
        }
        async closeAccount(t, e, n, r) {
            let i, s;
            te(n) ? (i = n.publicKey,
            s = [n]) : (i = n,
            s = r),
            await Gt("CloseAccount", this.connection, (new (0,
            l.Transaction)).add(oe.createCloseAccountInstruction(this.programId, t, e, i, r)), this.payer, ...s)
        }
        async freezeAccount(t, e, n) {
            let r, i;
            te(e) ? (r = e.publicKey,
            i = [e]) : (r = e,
            i = n),
            await Gt("FreezeAccount", this.connection, (new (0,
            l.Transaction)).add(oe.createFreezeAccountInstruction(this.programId, t, this.publicKey, r, n)), this.payer, ...i)
        }
        async thawAccount(t, e, n) {
            let r, i;
            te(e) ? (r = e.publicKey,
            i = [e]) : (r = e,
            i = n),
            await Gt("ThawAccount", this.connection, (new (0,
            l.Transaction)).add(oe.createThawAccountInstruction(this.programId, t, this.publicKey, r, n)), this.payer, ...i)
        }
        async transferChecked(t, e, n, r, i, s) {
            let o, a;
            return te(n) ? (o = n.publicKey,
            a = [n]) : (o = n,
            a = r),
            await Gt("TransferChecked", this.connection, (new (0,
            l.Transaction)).add(oe.createTransferCheckedInstruction(this.programId, t, this.publicKey, e, o, r, i, s)), this.payer, ...a)
        }
        async approveChecked(t, e, n, r, i, s) {
            let o, a;
            te(n) ? (o = n.publicKey,
            a = [n]) : (o = n,
            a = r),
            await Gt("ApproveChecked", this.connection, (new (0,
            l.Transaction)).add(oe.createApproveCheckedInstruction(this.programId, t, this.publicKey, e, o, r, i, s)), this.payer, ...a)
        }
        async mintToChecked(t, e, n, r, i) {
            let s, o;
            te(e) ? (s = e.publicKey,
            o = [e]) : (s = e,
            o = n),
            await Gt("MintToChecked", this.connection, (new (0,
            l.Transaction)).add(oe.createMintToCheckedInstruction(this.programId, this.publicKey, t, s, n, r, i)), this.payer, ...o)
        }
        async burnChecked(t, e, n, r, i) {
            let s, o;
            te(e) ? (s = e.publicKey,
            o = [e]) : (s = e,
            o = n),
            await Gt("BurnChecked", this.connection, (new (0,
            l.Transaction)).add(oe.createBurnCheckedInstruction(this.programId, this.publicKey, t, s, n, r, i)), this.payer, ...o)
        }
        async syncNative(t) {
            await Gt(0, this.connection, (new (0,
            l.Transaction)).add(oe.createSyncNativeInstruction(this.programId, t)), this.payer)
        }
        static createInitMintInstruction(t, e, n, r, i) {
            let s = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: l.SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }];
            const o = Wt([zt("instruction"), zt("decimals"), Ht("mintAuthority"), zt("option"), Ht("freezeAuthority")]);
            let a = c.Buffer.alloc(1024);
            {
                const t = o.encode({
                    instruction: 0,
                    decimals: n,
                    mintAuthority: Zt(r),
                    option: null === i ? 0 : 1,
                    freezeAuthority: Zt(i || new (0,
                    l.PublicKey)(0))
                }, a);
                a = a.slice(0, t)
            }
            return new (0,
            l.TransactionInstruction)({
                keys: s,
                programId: t,
                data: a
            })
        }
        static createInitAccountInstruction(t, e, n, r) {
            const i = [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: l.SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }]
              , s = Wt([zt("instruction")])
              , o = c.Buffer.alloc(s.span);
            return s.encode({
                instruction: 1
            }, o),
            new (0,
            l.TransactionInstruction)({
                keys: i,
                programId: t,
                data: o
            })
        }
        static createTransferInstruction(t, e, n, r, i, s) {
            const o = Wt([zt("instruction"), $t("amount")])
              , a = c.Buffer.alloc(o.span);
            o.encode({
                instruction: 3,
                amount: new Jt(s).toBuffer()
            }, a);
            let u = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }];
            return 0 === i.length ? u.push({
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }) : (u.push({
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }),
            i.forEach((t=>u.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: u,
                programId: t,
                data: a
            })
        }
        static createApproveInstruction(t, e, n, r, i, s) {
            const o = Wt([zt("instruction"), $t("amount")])
              , a = c.Buffer.alloc(o.span);
            o.encode({
                instruction: 4,
                amount: new Jt(s).toBuffer()
            }, a);
            let u = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !1
            }];
            return 0 === i.length ? u.push({
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }) : (u.push({
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }),
            i.forEach((t=>u.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: u,
                programId: t,
                data: a
            })
        }
        static createRevokeInstruction(t, e, n, r) {
            const i = Wt([zt("instruction")])
              , s = c.Buffer.alloc(i.span);
            i.encode({
                instruction: 5
            }, s);
            let o = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }];
            return 0 === r.length ? o.push({
                pubkey: n,
                isSigner: !0,
                isWritable: !1
            }) : (o.push({
                pubkey: n,
                isSigner: !1,
                isWritable: !1
            }),
            r.forEach((t=>o.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: o,
                programId: t,
                data: s
            })
        }
        static createSetAuthorityInstruction(t, e, n, r, i, s) {
            const o = Wt([zt("instruction"), zt("authorityType"), zt("option"), Ht("newAuthority")]);
            let a = c.Buffer.alloc(1024);
            {
                const t = o.encode({
                    instruction: 6,
                    authorityType: ee[r],
                    option: null === n ? 0 : 1,
                    newAuthority: Zt(n || new (0,
                    l.PublicKey)(0))
                }, a);
                a = a.slice(0, t)
            }
            let u = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }];
            return 0 === s.length ? u.push({
                pubkey: i,
                isSigner: !0,
                isWritable: !1
            }) : (u.push({
                pubkey: i,
                isSigner: !1,
                isWritable: !1
            }),
            s.forEach((t=>u.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: u,
                programId: t,
                data: a
            })
        }
        static createMintToInstruction(t, e, n, r, i, s) {
            const o = Wt([zt("instruction"), $t("amount")])
              , a = c.Buffer.alloc(o.span);
            o.encode({
                instruction: 7,
                amount: new Jt(s).toBuffer()
            }, a);
            let u = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }];
            return 0 === i.length ? u.push({
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }) : (u.push({
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }),
            i.forEach((t=>u.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: u,
                programId: t,
                data: a
            })
        }
        static createBurnInstruction(t, e, n, r, i, s) {
            const o = Wt([zt("instruction"), $t("amount")])
              , a = c.Buffer.alloc(o.span);
            o.encode({
                instruction: 8,
                amount: new Jt(s).toBuffer()
            }, a);
            let u = [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }];
            return 0 === i.length ? u.push({
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }) : (u.push({
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }),
            i.forEach((t=>u.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: u,
                programId: t,
                data: a
            })
        }
        static createCloseAccountInstruction(t, e, n, r, i) {
            const s = Wt([zt("instruction")])
              , o = c.Buffer.alloc(s.span);
            s.encode({
                instruction: 9
            }, o);
            let a = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }];
            return 0 === i.length ? a.push({
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }) : (a.push({
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }),
            i.forEach((t=>a.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: a,
                programId: t,
                data: o
            })
        }
        static createFreezeAccountInstruction(t, e, n, r, i) {
            const s = Wt([zt("instruction")])
              , o = c.Buffer.alloc(s.span);
            s.encode({
                instruction: 10
            }, o);
            let a = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !1
            }];
            return 0 === i.length ? a.push({
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }) : (a.push({
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }),
            i.forEach((t=>a.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: a,
                programId: t,
                data: o
            })
        }
        static createThawAccountInstruction(t, e, n, r, i) {
            const s = Wt([zt("instruction")])
              , o = c.Buffer.alloc(s.span);
            s.encode({
                instruction: 11
            }, o);
            let a = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !1
            }];
            return 0 === i.length ? a.push({
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }) : (a.push({
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }),
            i.forEach((t=>a.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: a,
                programId: t,
                data: o
            })
        }
        static createTransferCheckedInstruction(t, e, n, r, i, s, o, a) {
            const u = Wt([zt("instruction"), $t("amount"), zt("decimals")])
              , h = c.Buffer.alloc(u.span);
            u.encode({
                instruction: 12,
                amount: new Jt(o).toBuffer(),
                decimals: a
            }, h);
            let d = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: r,
                isSigner: !1,
                isWritable: !0
            }];
            return 0 === s.length ? d.push({
                pubkey: i,
                isSigner: !0,
                isWritable: !1
            }) : (d.push({
                pubkey: i,
                isSigner: !1,
                isWritable: !1
            }),
            s.forEach((t=>d.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: d,
                programId: t,
                data: h
            })
        }
        static createApproveCheckedInstruction(t, e, n, r, i, s, o, a) {
            const u = Wt([zt("instruction"), $t("amount"), zt("decimals")])
              , h = c.Buffer.alloc(u.span);
            u.encode({
                instruction: 13,
                amount: new Jt(o).toBuffer(),
                decimals: a
            }, h);
            let d = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }];
            return 0 === s.length ? d.push({
                pubkey: i,
                isSigner: !0,
                isWritable: !1
            }) : (d.push({
                pubkey: i,
                isSigner: !1,
                isWritable: !1
            }),
            s.forEach((t=>d.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: d,
                programId: t,
                data: h
            })
        }
        static createMintToCheckedInstruction(t, e, n, r, i, s, o) {
            const a = Wt([zt("instruction"), $t("amount"), zt("decimals")])
              , u = c.Buffer.alloc(a.span);
            a.encode({
                instruction: 14,
                amount: new Jt(s).toBuffer(),
                decimals: o
            }, u);
            let h = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }];
            return 0 === i.length ? h.push({
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }) : (h.push({
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }),
            i.forEach((t=>h.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: h,
                programId: t,
                data: u
            })
        }
        static createBurnCheckedInstruction(t, e, n, r, i, s, o) {
            const a = Wt([zt("instruction"), $t("amount"), zt("decimals")])
              , u = c.Buffer.alloc(a.span);
            a.encode({
                instruction: 15,
                amount: new Jt(s).toBuffer(),
                decimals: o
            }, u);
            let h = [{
                pubkey: n,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }];
            return 0 === i.length ? h.push({
                pubkey: r,
                isSigner: !0,
                isWritable: !1
            }) : (h.push({
                pubkey: r,
                isSigner: !1,
                isWritable: !1
            }),
            i.forEach((t=>h.push({
                pubkey: t.publicKey,
                isSigner: !0,
                isWritable: !1
            })))),
            new (0,
            l.TransactionInstruction)({
                keys: h,
                programId: t,
                data: u
            })
        }
        static createSyncNativeInstruction(t, e) {
            const n = Wt([zt("instruction")])
              , r = c.Buffer.alloc(n.span);
            n.encode({
                instruction: 17
            }, r);
            let i = [{
                pubkey: e,
                isSigner: !1,
                isWritable: !0
            }];
            return new (0,
            l.TransactionInstruction)({
                keys: i,
                programId: t,
                data: r
            })
        }
        static async getAssociatedTokenAddress(t, e, n, r, i=!1) {
            if (!i && !l.PublicKey.isOnCurve(r.toBuffer()))
                throw new Error(`Owner cannot sign: ${r.toString()}`);
            return (await l.PublicKey.findProgramAddress([r.toBuffer(), e.toBuffer(), n.toBuffer()], t))[0]
        }
        static createAssociatedTokenAccountInstruction(t, e, n, r, i, s) {
            const o = c.Buffer.alloc(0);
            let a = [{
                pubkey: s,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: r,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: i,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: n,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: l.SystemProgram.programId,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: e,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: l.SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }];
            return new (0,
            l.TransactionInstruction)({
                keys: a,
                programId: t,
                data: o
            })
        }
    }
}
)),
o.register("g5Zhu", (function(t, e) {
    var n = o("5DKOa");
    t.exports = function(t, e, r) {
        return (e = n(e))in t ? Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = r,
        t
    }
    ,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)),
o.register("44mK7", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createCreateTreeInstruction = t.exports.createTreeInstructionDiscriminator = t.exports.createTreeStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    t.exports.createTreeStruct = new s.FixableBeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["maxDepth", s.u32], ["maxBufferSize", s.u32], ["public", s.coption(s.bool)]],"CreateTreeInstructionArgs"),
    t.exports.createTreeInstructionDiscriminator = [165, 83, 136, 142, 89, 202, 47, 220],
    t.exports.createCreateTreeInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.createTreeStruct.serialize({
            instructionDiscriminator: t.exports.createTreeInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.payer,
            isWritable: !0,
            isSigner: !0
        }, {
            pubkey: e.treeCreator,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("99h0T", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createDecompressV1Instruction = t.exports.decompressV1InstructionDiscriminator = t.exports.decompressV1Struct = void 0;
    const s = i(o("dmNue"))
      , a = i(o("1DULh"))
      , l = i(o("gNDby"));
    var c = o("k6S43");
    t.exports.decompressV1Struct = new a.FixableBeetArgsStruct([["instructionDiscriminator", a.uniformFixedSizeArray(a.u8, 8)], ["metadata", c.metadataArgsBeet]],"DecompressV1InstructionArgs"),
    t.exports.decompressV1InstructionDiscriminator = [54, 85, 76, 70, 228, 250, 164, 81],
    t.exports.createDecompressV1Instruction = function(e, n, r=new l.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i, o;
        const [a] = t.exports.decompressV1Struct.serialize({
            instructionDiscriminator: t.exports.decompressV1InstructionDiscriminator,
            ...n
        })
          , c = [{
            pubkey: e.voucher,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !0,
            isSigner: !0
        }, {
            pubkey: e.tokenAccount,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.mint,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.mintAuthority,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.metadata,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.masterEdition,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : l.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.sysvarRent,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.tokenMetadataProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (o = e.tokenProgram) && void 0 !== o ? o : s.TOKEN_PROGRAM_ID,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.associatedTokenProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                c.push(t);
        return new l.TransactionInstruction({
            programId: r,
            keys: c,
            data: a
        })
    }
}
)),
o.register("k6S43", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.metadataArgsBeet = void 0;
    const s = i(o("1DULh"));
    var a = o("bon4v")
      , l = o("3PxdX")
      , c = o("hVvqL")
      , u = o("e2KNJ")
      , h = o("awKN7");
    t.exports.metadataArgsBeet = new s.FixableBeetArgsStruct([["name", s.utf8String], ["symbol", s.utf8String], ["uri", s.utf8String], ["sellerFeeBasisPoints", s.u16], ["primarySaleHappened", s.bool], ["isMutable", s.bool], ["editionNonce", s.coption(s.u8)], ["tokenStandard", s.coption(a.tokenStandardBeet)], ["collection", s.coption(l.collectionBeet)], ["uses", s.coption(c.usesBeet)], ["tokenProgramVersion", u.tokenProgramVersionBeet], ["creators", s.array(h.creatorBeet)]],"MetadataArgs")
}
)),
o.register("bon4v", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.tokenStandardBeet = t.exports.TokenStandard = void 0;
    const s = i(o("1DULh"));
    var a, l;
    (l = a = t.exports.TokenStandard || (t.exports.TokenStandard = {}))[l.NonFungible = 0] = "NonFungible",
    l[l.FungibleAsset = 1] = "FungibleAsset",
    l[l.Fungible = 2] = "Fungible",
    l[l.NonFungibleEdition = 3] = "NonFungibleEdition",
    t.exports.tokenStandardBeet = s.fixedScalarEnum(a)
}
)),
o.register("3PxdX", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.collectionBeet = void 0;
    const s = i(o("1DULh"))
      , a = i(o("9dESI"));
    t.exports.collectionBeet = new s.BeetArgsStruct([["verified", s.bool], ["key", a.publicKey]],"Collection")
}
)),
o.register("hVvqL", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.usesBeet = void 0;
    const s = i(o("1DULh"));
    var a = o("3ZGlf");
    t.exports.usesBeet = new s.BeetArgsStruct([["useMethod", a.useMethodBeet], ["remaining", s.u64], ["total", s.u64]],"Uses")
}
)),
o.register("3ZGlf", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.useMethodBeet = t.exports.UseMethod = void 0;
    const s = i(o("1DULh"));
    var a, l;
    (l = a = t.exports.UseMethod || (t.exports.UseMethod = {}))[l.Burn = 0] = "Burn",
    l[l.Multiple = 1] = "Multiple",
    l[l.Single = 2] = "Single",
    t.exports.useMethodBeet = s.fixedScalarEnum(a)
}
)),
o.register("e2KNJ", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.tokenProgramVersionBeet = t.exports.TokenProgramVersion = void 0;
    const s = i(o("1DULh"));
    var a, l;
    (l = a = t.exports.TokenProgramVersion || (t.exports.TokenProgramVersion = {}))[l.Original = 0] = "Original",
    l[l.Token2022 = 1] = "Token2022",
    t.exports.tokenProgramVersionBeet = s.fixedScalarEnum(a)
}
)),
o.register("awKN7", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.creatorBeet = void 0;
    const s = i(o("9dESI"))
      , a = i(o("1DULh"));
    t.exports.creatorBeet = new a.BeetArgsStruct([["address", s.publicKey], ["verified", a.bool], ["share", a.u8]],"Creator")
}
)),
o.register("gHOAl", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createDelegateInstruction = t.exports.delegateInstructionDiscriminator = t.exports.delegateStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    t.exports.delegateStruct = new s.BeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)], ["nonce", s.u64], ["index", s.u32]],"DelegateInstructionArgs"),
    t.exports.delegateInstructionDiscriminator = [90, 147, 75, 178, 85, 88, 4, 137],
    t.exports.createDelegateInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.delegateStruct.serialize({
            instructionDiscriminator: t.exports.delegateInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.previousLeafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.newLeafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("1TGNa", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createMintToCollectionV1Instruction = t.exports.mintToCollectionV1InstructionDiscriminator = t.exports.mintToCollectionV1Struct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    var l = o("k6S43");
    t.exports.mintToCollectionV1Struct = new s.FixableBeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["metadataArgs", l.metadataArgsBeet]],"MintToCollectionV1InstructionArgs"),
    t.exports.mintToCollectionV1InstructionDiscriminator = [153, 18, 178, 47, 197, 158, 86, 15],
    t.exports.createMintToCollectionV1Instruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.mintToCollectionV1Struct.serialize({
            instructionDiscriminator: t.exports.mintToCollectionV1InstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.payer,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.treeDelegate,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.collectionAuthority,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.collectionAuthorityRecordPda,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionMint,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionMetadata,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.editionAccount,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.bubblegumSigner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.tokenMetadataProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("S6Egr", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createMintV1Instruction = t.exports.mintV1InstructionDiscriminator = t.exports.mintV1Struct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    var l = o("k6S43");
    t.exports.mintV1Struct = new s.FixableBeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["message", l.metadataArgsBeet]],"MintV1InstructionArgs"),
    t.exports.mintV1InstructionDiscriminator = [145, 98, 192, 118, 184, 147, 118, 104],
    t.exports.createMintV1Instruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.mintV1Struct.serialize({
            instructionDiscriminator: t.exports.mintV1InstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.payer,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.treeDelegate,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("8PAJ0", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createRedeemInstruction = t.exports.redeemInstructionDiscriminator = t.exports.redeemStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    t.exports.redeemStruct = new s.BeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)], ["nonce", s.u64], ["index", s.u32]],"RedeemInstructionArgs"),
    t.exports.redeemInstructionDiscriminator = [184, 12, 86, 149, 70, 196, 97, 225],
    t.exports.createRedeemInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.redeemStruct.serialize({
            instructionDiscriminator: t.exports.redeemInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !0,
            isSigner: !0
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.voucher,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("3A2AA", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createSetAndVerifyCollectionInstruction = t.exports.setAndVerifyCollectionInstructionDiscriminator = t.exports.setAndVerifyCollectionStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"))
      , l = i(o("9dESI"));
    var c = o("k6S43");
    t.exports.setAndVerifyCollectionStruct = new s.FixableBeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)], ["nonce", s.u64], ["index", s.u32], ["message", c.metadataArgsBeet], ["collection", l.publicKey]],"SetAndVerifyCollectionInstructionArgs"),
    t.exports.setAndVerifyCollectionInstructionDiscriminator = [235, 242, 121, 216, 158, 234, 180, 234],
    t.exports.createSetAndVerifyCollectionInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.setAndVerifyCollectionStruct.serialize({
            instructionDiscriminator: t.exports.setAndVerifyCollectionInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.payer,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.treeDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionAuthority,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.collectionAuthorityRecordPda,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionMint,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionMetadata,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.editionAccount,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.bubblegumSigner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.tokenMetadataProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("d8YsU", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createSetTreeDelegateInstruction = t.exports.setTreeDelegateInstructionDiscriminator = t.exports.setTreeDelegateStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    t.exports.setTreeDelegateStruct = new s.BeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)]],"SetTreeDelegateInstructionArgs"),
    t.exports.setTreeDelegateInstructionDiscriminator = [253, 118, 66, 37, 190, 49, 154, 102],
    t.exports.createSetTreeDelegateInstruction = function(e, n=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var r;
        const [i] = t.exports.setTreeDelegateStruct.serialize({
            instructionDiscriminator: t.exports.setTreeDelegateInstructionDiscriminator
        })
          , s = [{
            pubkey: e.treeAuthority,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.treeCreator,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.newTreeDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (r = e.systemProgram) && void 0 !== r ? r : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                s.push(t);
        return new a.TransactionInstruction({
            programId: n,
            keys: s,
            data: i
        })
    }
}
)),
o.register("dtfyi", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createTransferInstruction = t.exports.transferInstructionDiscriminator = t.exports.transferStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    t.exports.transferStruct = new s.BeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)], ["nonce", s.u64], ["index", s.u32]],"TransferInstructionArgs"),
    t.exports.transferInstructionDiscriminator = [163, 52, 200, 231, 140, 3, 69, 186],
    t.exports.createTransferInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.transferStruct.serialize({
            instructionDiscriminator: t.exports.transferInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.newLeafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("7XMRi", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createUnverifyCollectionInstruction = t.exports.unverifyCollectionInstructionDiscriminator = t.exports.unverifyCollectionStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    var l = o("k6S43");
    t.exports.unverifyCollectionStruct = new s.FixableBeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)], ["nonce", s.u64], ["index", s.u32], ["message", l.metadataArgsBeet]],"UnverifyCollectionInstructionArgs"),
    t.exports.unverifyCollectionInstructionDiscriminator = [250, 251, 42, 106, 41, 137, 186, 168],
    t.exports.createUnverifyCollectionInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.unverifyCollectionStruct.serialize({
            instructionDiscriminator: t.exports.unverifyCollectionInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.payer,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.treeDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionAuthority,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.collectionAuthorityRecordPda,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionMint,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionMetadata,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.editionAccount,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.bubblegumSigner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.tokenMetadataProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("epq2U", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createUnverifyCreatorInstruction = t.exports.unverifyCreatorInstructionDiscriminator = t.exports.unverifyCreatorStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    var l = o("k6S43");
    t.exports.unverifyCreatorStruct = new s.FixableBeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)], ["nonce", s.u64], ["index", s.u32], ["message", l.metadataArgsBeet]],"UnverifyCreatorInstructionArgs"),
    t.exports.unverifyCreatorInstructionDiscriminator = [107, 178, 57, 39, 105, 115, 112, 152],
    t.exports.createUnverifyCreatorInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.unverifyCreatorStruct.serialize({
            instructionDiscriminator: t.exports.unverifyCreatorInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.payer,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.creator,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("1X08Y", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createVerifyCollectionInstruction = t.exports.verifyCollectionInstructionDiscriminator = t.exports.verifyCollectionStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    var l = o("k6S43");
    t.exports.verifyCollectionStruct = new s.FixableBeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)], ["nonce", s.u64], ["index", s.u32], ["message", l.metadataArgsBeet]],"VerifyCollectionInstructionArgs"),
    t.exports.verifyCollectionInstructionDiscriminator = [56, 113, 101, 253, 79, 55, 122, 169],
    t.exports.createVerifyCollectionInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.verifyCollectionStruct.serialize({
            instructionDiscriminator: t.exports.verifyCollectionInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.payer,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.treeDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionAuthority,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.collectionAuthorityRecordPda,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionMint,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.collectionMetadata,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.editionAccount,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.bubblegumSigner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.tokenMetadataProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("bMpY1", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.createVerifyCreatorInstruction = t.exports.verifyCreatorInstructionDiscriminator = t.exports.verifyCreatorStruct = void 0;
    const s = i(o("1DULh"))
      , a = i(o("gNDby"));
    var l = o("k6S43");
    t.exports.verifyCreatorStruct = new s.FixableBeetArgsStruct([["instructionDiscriminator", s.uniformFixedSizeArray(s.u8, 8)], ["root", s.uniformFixedSizeArray(s.u8, 32)], ["dataHash", s.uniformFixedSizeArray(s.u8, 32)], ["creatorHash", s.uniformFixedSizeArray(s.u8, 32)], ["nonce", s.u64], ["index", s.u32], ["message", l.metadataArgsBeet]],"VerifyCreatorInstructionArgs"),
    t.exports.verifyCreatorInstructionDiscriminator = [52, 17, 96, 132, 71, 4, 85, 194],
    t.exports.createVerifyCreatorInstruction = function(e, n, r=new a.PublicKey("BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY")) {
        var i;
        const [s] = t.exports.verifyCreatorStruct.serialize({
            instructionDiscriminator: t.exports.verifyCreatorInstructionDiscriminator,
            ...n
        })
          , o = [{
            pubkey: e.treeAuthority,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafOwner,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.leafDelegate,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.merkleTree,
            isWritable: !0,
            isSigner: !1
        }, {
            pubkey: e.payer,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.creator,
            isWritable: !1,
            isSigner: !0
        }, {
            pubkey: e.logWrapper,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: e.compressionProgram,
            isWritable: !1,
            isSigner: !1
        }, {
            pubkey: null !== (i = e.systemProgram) && void 0 !== i ? i : a.SystemProgram.programId,
            isWritable: !1,
            isSigner: !1
        }];
        if (null != e.anchorRemainingAccounts)
            for (const t of e.anchorRemainingAccounts)
                o.push(t);
        return new a.TransactionInstruction({
            programId: r,
            keys: o,
            data: s
        })
    }
}
)),
o.register("dtie9", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__exportStar || function(t, e) {
        for (var r in t)
            "default" === r || Object.prototype.hasOwnProperty.call(e, r) || n(e, t, r)
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    r(o("brd7C"), t.exports),
    r(o("3PxdX"), t.exports),
    r(o("awKN7"), t.exports),
    r(o("6IP7q"), t.exports),
    r(o("fwbNs"), t.exports),
    r(o("k6S43"), t.exports),
    r(o("e2KNJ"), t.exports),
    r(o("bon4v"), t.exports),
    r(o("3ZGlf"), t.exports),
    r(o("hVvqL"), t.exports),
    r(o("9LOhz"), t.exports)
}
)),
o.register("brd7C", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.bubblegumEventTypeBeet = t.exports.BubblegumEventType = void 0;
    const s = i(o("1DULh"));
    var a, l;
    (l = a = t.exports.BubblegumEventType || (t.exports.BubblegumEventType = {}))[l.Uninitialized = 0] = "Uninitialized",
    l[l.LeafSchemaEvent = 1] = "LeafSchemaEvent",
    t.exports.bubblegumEventTypeBeet = s.fixedScalarEnum(a)
}
)),
o.register("6IP7q", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.instructionNameBeet = t.exports.InstructionName = void 0;
    const s = i(o("1DULh"));
    var a, l;
    (l = a = t.exports.InstructionName || (t.exports.InstructionName = {}))[l.Unknown = 0] = "Unknown",
    l[l.MintV1 = 1] = "MintV1",
    l[l.Redeem = 2] = "Redeem",
    l[l.CancelRedeem = 3] = "CancelRedeem",
    l[l.Transfer = 4] = "Transfer",
    l[l.Delegate = 5] = "Delegate",
    l[l.DecompressV1 = 6] = "DecompressV1",
    l[l.Compress = 7] = "Compress",
    l[l.Burn = 8] = "Burn",
    l[l.CreateTree = 9] = "CreateTree",
    l[l.VerifyCreator = 10] = "VerifyCreator",
    l[l.UnverifyCreator = 11] = "UnverifyCreator",
    l[l.VerifyCollection = 12] = "VerifyCollection",
    l[l.UnverifyCollection = 13] = "UnverifyCollection",
    l[l.SetAndVerifyCollection = 14] = "SetAndVerifyCollection",
    l[l.MintToCollectionV1 = 15] = "MintToCollectionV1",
    t.exports.instructionNameBeet = s.fixedScalarEnum(a)
}
)),
o.register("9LOhz", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.versionBeet = t.exports.Version = void 0;
    const s = i(o("1DULh"));
    var a, l;
    (l = a = t.exports.Version || (t.exports.Version = {}))[l.V1 = 0] = "V1",
    t.exports.versionBeet = s.fixedScalarEnum(a)
}
)),
o.register("l0Lrl", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.cusper = void 0;
    var n = o("f22Bo")
      , r = o("5dlKa");
    t.exports.cusper = (0,
    n.initCusper)(r.errorFromCode)
}
)),
o.register("f22Bo", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n),
        Object.defineProperty(t, r, {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        })
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__exportStar || function(t, e) {
        for (var r in t)
            "default" === r || Object.prototype.hasOwnProperty.call(e, r) || n(e, t, r)
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    r(o("fi5RY"), t.exports),
    r(o("4fRY0"), t.exports)
}
)),
o.register("fi5RY", (function(t, e) {
    var n = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n),
        Object.defineProperty(t, r, {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        })
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , r = t.exports && t.exports.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    }
    : function(t, e) {
        t.default = e
    }
    )
      , i = t.exports && t.exports.__importStar || function(t) {
        if (t && t.__esModule)
            return t;
        var e = {};
        if (null != t)
            for (var i in t)
                "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
        return r(e, t),
        e
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.TokenLendingError = t.exports.AnchorError = t.exports.CustomProgramError = t.exports.CusperUnknownError = t.exports.initCusper = t.exports.ErrorResolver = void 0;
    var s = o("bET1B");
    const a = i(o("fbyRT"));
    var l = o("85ebB");
    class c {
        constructor(t) {
            this.resolveErrorFromCode = t
        }
        errorFromCode(t, e, n=!0) {
            let r = null != this.resolveErrorFromCode ? this.resolveErrorFromCode(t) : null;
            return null != r ? this.passPreparedError(r, null != e ? e : this.errorFromCode) : (r = d.fromCode(t),
            null != r ? this.passPreparedError(r, null != e ? e : this.errorFromCode) : (r = f.fromCode(t),
            null != r ? this.passPreparedError(r, null != e ? e : this.errorFromCode) : n ? (r = new u(t,"CusperUnknownError","cusper does not know this error"),
            this.passPreparedError(r, null != e ? e : this.errorFromCode)) : void 0))
        }
        errorFromProgramLogs(t, e=!0) {
            const n = (0,
            s.errorCodeFromLogs)(t);
            return null == n ? null : this.errorFromCode(n, this.errorFromProgramLogs, e)
        }
        throwError(t) {
            const e = null != t.logs && this.errorFromProgramLogs(t.logs, !0) || new u(-1,"Error created without logs and thus without error code");
            throw this.passPreparedError(e, this.throwError)
        }
        passPreparedError(t, e) {
            return null == t ? null : ("function" == typeof Error.captureStackTrace && Error.captureStackTrace(t, e),
            t)
        }
    }
    t.exports.ErrorResolver = c,
    t.exports.initCusper = function(t) {
        return new c(t)
    }
    ;
    class u extends Error {
        constructor(t, ...e) {
            super(...e),
            this.code = t,
            this.name = "CusperUnknownError"
        }
    }
    t.exports.CusperUnknownError = u;
    class h extends Error {
        constructor(t, e, ...n) {
            super(...n),
            this.code = t,
            this.name = `CustomProgramError#${e}`
        }
    }
    t.exports.CustomProgramError = h;
    class d extends Error {
        constructor(t, e, ...n) {
            super(...n),
            this.code = t,
            this.name = `AnchorError#${e}`
        }
        static fromCode(t) {
            const e = d.errorMap.get(t);
            return null != e ? new d(e.code,e.name,e.message) : null
        }
        toString() {
            return `${this.name}: ${this.message}`
        }
    }
    t.exports.AnchorError = d,
    d.errorMap = Object.entries(a.LangErrorCode).reduce(((t,[e,n])=>(t.set(n, {
        code: n,
        name: e,
        message: a.LangErrorMessage.get(n)
    }),
    t)), new Map);
    class f extends Error {
        constructor(t, e, ...n) {
            super(...n),
            this.code = t,
            this.name = `TokenLendingError#${e}`
        }
        static fromCode(t) {
            const e = f.errorMap.get(t);
            return null != e ? new f(e.code,e.name,e.message) : null
        }
        toString() {
            return `${this.name}: ${this.message}`
        }
    }
    t.exports.TokenLendingError = f,
    f.errorMap = l.tokenLendingErrors
}
)),
o.register("bET1B", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.errorCodeFromLogs = void 0;
    const n = /Custom program error: (0x[a-f0-9]+)/i;
    t.exports.errorCodeFromLogs = function(t) {
        for (const e of t) {
            const t = e.match(n);
            if (null == t)
                continue;
            const r = t[1];
            try {
                return parseInt(r)
            } catch (t) {}
        }
        return null
    }
}
)),
o.register("fbyRT", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.LangErrorMessage = t.exports.LangErrorCode = void 0,
    t.exports.LangErrorCode = {
        InstructionMissing: 100,
        InstructionFallbackNotFound: 101,
        InstructionDidNotDeserialize: 102,
        InstructionDidNotSerialize: 103,
        IdlInstructionStub: 1e3,
        IdlInstructionInvalidProgram: 1001,
        ConstraintMut: 2e3,
        ConstraintHasOne: 2001,
        ConstraintSigner: 2002,
        ConstraintRaw: 2003,
        ConstraintOwner: 2004,
        ConstraintRentExempt: 2005,
        ConstraintSeeds: 2006,
        ConstraintExecutable: 2007,
        ConstraintState: 2008,
        ConstraintAssociated: 2009,
        ConstraintAssociatedInit: 2010,
        ConstraintClose: 2011,
        ConstraintAddress: 2012,
        ConstraintZero: 2013,
        ConstraintTokenMint: 2014,
        ConstraintTokenOwner: 2015,
        ConstraintMintMintAuthority: 2016,
        ConstraintMintFreezeAuthority: 2017,
        ConstraintMintDecimals: 2018,
        ConstraintSpace: 2019,
        AccountDiscriminatorAlreadySet: 3e3,
        AccountDiscriminatorNotFound: 3001,
        AccountDiscriminatorMismatch: 3002,
        AccountDidNotDeserialize: 3003,
        AccountDidNotSerialize: 3004,
        AccountNotEnoughKeys: 3005,
        AccountNotMutable: 3006,
        AccountOwnedByWrongProgram: 3007,
        InvalidProgramId: 3008,
        InvalidProgramExecutable: 3009,
        AccountNotSigner: 3010,
        AccountNotSystemOwned: 3011,
        AccountNotInitialized: 3012,
        AccountNotProgramData: 3013,
        StateInvalidAddress: 4e3,
        Deprecated: 5e3
    },
    t.exports.LangErrorMessage = new Map([[t.exports.LangErrorCode.InstructionMissing, "8 byte instruction identifier not provided"], [t.exports.LangErrorCode.InstructionFallbackNotFound, "Fallback functions are not supported"], [t.exports.LangErrorCode.InstructionDidNotDeserialize, "The program could not deserialize the given instruction"], [t.exports.LangErrorCode.InstructionDidNotSerialize, "The program could not serialize the given instruction"], [t.exports.LangErrorCode.IdlInstructionStub, "The program was compiled without idl instructions"], [t.exports.LangErrorCode.IdlInstructionInvalidProgram, "The transaction was given an invalid program for the IDL instruction"], [t.exports.LangErrorCode.ConstraintMut, "A mut constraint was violated"], [t.exports.LangErrorCode.ConstraintHasOne, "A has_one constraint was violated"], [t.exports.LangErrorCode.ConstraintSigner, "A signer constraint was violated"], [t.exports.LangErrorCode.ConstraintRaw, "A raw constraint was violated"], [t.exports.LangErrorCode.ConstraintOwner, "An owner constraint was violated"], [t.exports.LangErrorCode.ConstraintRentExempt, "A rent exempt constraint was violated"], [t.exports.LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"], [t.exports.LangErrorCode.ConstraintExecutable, "An executable constraint was violated"], [t.exports.LangErrorCode.ConstraintState, "A state constraint was violated"], [t.exports.LangErrorCode.ConstraintAssociated, "An associated constraint was violated"], [t.exports.LangErrorCode.ConstraintAssociatedInit, "An associated init constraint was violated"], [t.exports.LangErrorCode.ConstraintClose, "A close constraint was violated"], [t.exports.LangErrorCode.ConstraintAddress, "An address constraint was violated"], [t.exports.LangErrorCode.ConstraintZero, "Expected zero account discriminant"], [t.exports.LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"], [t.exports.LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"], [t.exports.LangErrorCode.ConstraintMintMintAuthority, "A mint mint authority constraint was violated"], [t.exports.LangErrorCode.ConstraintMintFreezeAuthority, "A mint freeze authority constraint was violated"], [t.exports.LangErrorCode.ConstraintMintDecimals, "A mint decimals constraint was violated"], [t.exports.LangErrorCode.ConstraintSpace, "A space constraint was violated"], [t.exports.LangErrorCode.AccountDiscriminatorAlreadySet, "The account discriminator was already set on this account"], [t.exports.LangErrorCode.AccountDiscriminatorNotFound, "No 8 byte discriminator was found on the account"], [t.exports.LangErrorCode.AccountDiscriminatorMismatch, "8 byte discriminator did not match what was expected"], [t.exports.LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"], [t.exports.LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"], [t.exports.LangErrorCode.AccountNotEnoughKeys, "Not enough account keys given to the instruction"], [t.exports.LangErrorCode.AccountNotMutable, "The given account is not mutable"], [t.exports.LangErrorCode.AccountOwnedByWrongProgram, "The given account is owned by a different program than expected"], [t.exports.LangErrorCode.InvalidProgramId, "Program ID was not as expected"], [t.exports.LangErrorCode.InvalidProgramExecutable, "Program account is not executable"], [t.exports.LangErrorCode.AccountNotSigner, "The given account did not sign"], [t.exports.LangErrorCode.AccountNotSystemOwned, "The given account is not owned by the system program"], [t.exports.LangErrorCode.AccountNotInitialized, "The program expected this account to be already initialized"], [t.exports.LangErrorCode.AccountNotProgramData, "The given account is not a program data account"], [t.exports.LangErrorCode.StateInvalidAddress, "The given state account does not have the correct address"], [t.exports.LangErrorCode.Deprecated, "The API being used is deprecated and should no longer be used"]])
}
)),
o.register("85ebB", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.tokenLendingErrors = void 0,
    t.exports.tokenLendingErrors = new Map([[0, {
        code: 0,
        message: 'Failed to unpack instruction data"',
        name: "InstructionUnpackError"
    }], [1, {
        code: 1,
        message: 'Account is already initialized"',
        name: "AlreadyInitialized"
    }], [2, {
        code: 2,
        message: 'Lamport balance below rent-exempt threshold"',
        name: "NotRentExempt"
    }], [3, {
        code: 3,
        message: 'Market authority is invalid"',
        name: "InvalidMarketAuthority"
    }], [4, {
        code: 4,
        message: 'Market owner is invalid"',
        name: "InvalidMarketOwner"
    }], [5, {
        code: 5,
        message: 'Input account owner is not the program address"',
        name: "InvalidAccountOwner"
    }], [6, {
        code: 6,
        message: 'Input token account is not owned by the correct token program id"',
        name: "InvalidTokenOwner"
    }], [7, {
        code: 7,
        message: 'Input token account is not valid"',
        name: "InvalidTokenAccount"
    }], [8, {
        code: 8,
        message: 'Input token mint account is not valid"',
        name: "InvalidTokenMint"
    }], [9, {
        code: 9,
        message: 'Input token program account is not valid"',
        name: "InvalidTokenProgram"
    }], [10, {
        code: 10,
        message: 'Input amount is invalid"',
        name: "InvalidAmount"
    }], [11, {
        code: 11,
        message: 'Input config value is invalid"',
        name: "InvalidConfig"
    }], [12, {
        code: 12,
        message: 'Input account must be a signer"',
        name: "InvalidSigner"
    }], [13, {
        code: 13,
        message: 'Invalid account input"',
        name: "InvalidAccountInput"
    }], [14, {
        code: 14,
        message: 'Math operation overflow"',
        name: "MathOverflow"
    }], [15, {
        code: 15,
        message: 'Token initialize mint failed"',
        name: "TokenInitializeMintFailed"
    }], [16, {
        code: 16,
        message: 'Token initialize account failed"',
        name: "TokenInitializeAccountFailed"
    }], [17, {
        code: 17,
        message: 'Token transfer failed"',
        name: "TokenTransferFailed"
    }], [18, {
        code: 18,
        message: 'Token mint to failed"',
        name: "TokenMintToFailed"
    }], [19, {
        code: 19,
        message: 'Token burn failed"',
        name: "TokenBurnFailed"
    }], [20, {
        code: 20,
        message: 'Insufficient liquidity available"',
        name: "InsufficientLiquidity"
    }], [21, {
        code: 21,
        message: 'Input reserve has collateral disabled"',
        name: "ReserveCollateralDisabled"
    }], [22, {
        code: 22,
        message: 'Reserve state needs to be refreshed"',
        name: "ReserveStale"
    }], [23, {
        code: 23,
        message: 'Withdraw amount too small"',
        name: "WithdrawTooSmall"
    }], [24, {
        code: 24,
        message: 'Withdraw amount too large"',
        name: "WithdrawTooLarge"
    }], [25, {
        code: 25,
        message: 'Borrow amount too small to receive liquidity after fees"',
        name: "BorrowTooSmall"
    }], [26, {
        code: 26,
        message: 'Borrow amount too large for deposited collateral"',
        name: "BorrowTooLarge"
    }], [27, {
        code: 27,
        message: 'Repay amount too small to transfer liquidity"',
        name: "RepayTooSmall"
    }], [28, {
        code: 28,
        message: 'Liquidation amount too small to receive collateral"',
        name: "LiquidationTooSmall"
    }], [29, {
        code: 29,
        message: 'Cannot liquidate healthy obligations"',
        name: "ObligationHealthy"
    }], [30, {
        code: 30,
        message: 'Obligation state needs to be refreshed"',
        name: "ObligationStale"
    }], [31, {
        code: 31,
        message: 'Obligation reserve limit exceeded"',
        name: "ObligationReserveLimit"
    }], [32, {
        code: 32,
        message: 'Obligation owner is invalid"',
        name: "InvalidObligationOwner"
    }], [33, {
        code: 33,
        message: 'Obligation deposits are empty"',
        name: "ObligationDepositsEmpty"
    }], [34, {
        code: 34,
        message: 'Obligation borrows are empty"',
        name: "ObligationBorrowsEmpty"
    }], [35, {
        code: 35,
        message: 'Obligation deposits have zero value"',
        name: "ObligationDepositsZero"
    }], [36, {
        code: 36,
        message: 'Obligation borrows have zero value"',
        name: "ObligationBorrowsZero"
    }], [37, {
        code: 37,
        message: 'Invalid obligation collateral"',
        name: "InvalidObligationCollateral"
    }], [38, {
        code: 38,
        message: 'Invalid obligation liquidity"',
        name: "InvalidObligationLiquidity"
    }], [39, {
        code: 39,
        message: 'Obligation collateral is empty"',
        name: "ObligationCollateralEmpty"
    }], [40, {
        code: 40,
        message: 'Obligation liquidity is empty"',
        name: "ObligationLiquidityEmpty"
    }], [41, {
        code: 41,
        message: 'Interest rate is negative"',
        name: "NegativeInterestRate"
    }], [42, {
        code: 42,
        message: 'Input oracle config is invalid"',
        name: "InvalidOracleConfig"
    }], [43, {
        code: 43,
        message: 'Input flash loan receiver program account is not valid"',
        name: "InvalidFlashLoanReceiverProgram"
    }], [44, {
        code: 44,
        message: 'Not enough liquidity after flash loan"',
        name: "NotEnoughLiquidityAfterFlashLoan"
    }]])
}
)),
o.register("4fRY0", (function(t, e) {
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    })
}
)),
o.register("3JSSJ", (function(t, e) {
    var n = o("6ZWSX").Buffer
      , r = t.exports && t.exports.__createBinding || (Object.create ? function(t, e, n, r) {
        void 0 === r && (r = n);
        var i = Object.getOwnPropertyDescriptor(e, n);
        i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
            enumerable: !0,
            get: function() {
                return e[n]
            }
        }),
        Object.defineProperty(t, r, i)
    }
    : function(t, e, n, r) {
        void 0 === r && (r = n),
        t[r] = e[n]
    }
    )
      , i = t.exports && t.exports.__exportStar || function(t, e) {
        for (var n in t)
            "default" === n || Object.prototype.hasOwnProperty.call(e, n) || r(e, t, n)
    }
      , s = t.exports && t.exports.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(t.exports, "__esModule", {
        value: !0
    }),
    t.exports.computeCompressedNFTHash = t.exports.computeCreatorHash = t.exports.computeDataHash = t.exports.getLeafAssetId = void 0;
    var a = o("1IGmO")
      , l = o("gNDby");
    const c = s(o("dEXSZ"));
    function u(t) {
        const [e] = o("5dlKa").metadataArgsBeet.serialize(t)
          , r = n.from(a.keccak_256.digest(e))
          , i = new c.default(t.sellerFeeBasisPoints).toBuffer("le", 2);
        return n.from(a.keccak_256.digest(n.concat([r, i])))
    }
    function h(t) {
        let e = n.from([]);
        for (const r of t)
            e = n.concat([r.address.toBuffer(), n.from([r.verified ? 1 : 0]), n.from([r.share])]);
        return n.from(a.keccak_256.digest(e))
    }
    i(o("5dlKa"), t.exports),
    t.exports.getLeafAssetId = async function(t, e) {
        const [r] = await l.PublicKey.findProgramAddress([n.from("asset", "utf8"), t.toBuffer(), Uint8Array.from(e.toArray("le", 8))], o("5dlKa").PROGRAM_ID);
        return r
    }
    ,
    t.exports.computeDataHash = u,
    t.exports.computeCreatorHash = h,
    t.exports.computeCompressedNFTHash = function(t, e, r, i, s) {
        const o = n.concat([n.from([1]), t.toBuffer(), e.toBuffer(), r.toBuffer(), i.toBuffer("le", 8), u(s), h(s.creators)]);
        return n.from(a.keccak_256.digest(o))
    }
}
)),
o.register("1IGmO", (function(t, e) {
    var r = o("hPtJY");
    /**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
    !function() {
        var e = "input is invalid type"
          , i = "object" == typeof window
          , s = i ? window : {};
        s.JS_SHA3_NO_WINDOW && (i = !1);
        var o = !i && "object" == typeof self;
        !s.JS_SHA3_NO_NODE_JS && "object" == typeof r && r.versions && r.versions.node ? s = n : o && (s = self);
        var a = !s.JS_SHA3_NO_COMMON_JS && t.exports
          , l = "function" == typeof define && define.amd
          , c = !s.JS_SHA3_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer
          , u = "0123456789abcdef".split("")
          , h = [4, 1024, 262144, 67108864]
          , d = [0, 8, 16, 24]
          , f = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]
          , p = [224, 256, 384, 512]
          , m = [128, 256]
          , g = ["hex", "buffer", "arrayBuffer", "array", "digest"]
          , y = {
            128: 168,
            256: 136
        };
        !s.JS_SHA3_NO_NODE_JS && Array.isArray || (Array.isArray = function(t) {
            return "[object Array]" === Object.prototype.toString.call(t)
        }
        ),
        !c || !s.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(t) {
            return "object" == typeof t && t.buffer && t.buffer.constructor === ArrayBuffer
        }
        );
        for (var b = function(t, e, n) {
            return function(r) {
                return new N(t,e,t).update(r)[n]()
            }
        }, v = function(t, e, n) {
            return function(r, i) {
                return new N(t,e,i).update(r)[n]()
            }
        }, w = function(t, e, n) {
            return function(e, r, i, s) {
                return S["cshake" + t].update(e, r, i, s)[n]()
            }
        }, x = function(t, e, n) {
            return function(e, r, i, s) {
                return S["kmac" + t].update(e, r, i, s)[n]()
            }
        }, E = function(t, e, n, r) {
            for (var i = 0; i < g.length; ++i) {
                var s = g[i];
                t[s] = e(n, r, s)
            }
            return t
        }, _ = function(t, e) {
            var n = b(t, e, "hex");
            return n.create = function() {
                return new N(t,e,t)
            }
            ,
            n.update = function(t) {
                return n.create().update(t)
            }
            ,
            E(n, b, t, e)
        }, A = [{
            name: "keccak",
            padding: [1, 256, 65536, 16777216],
            bits: p,
            createMethod: _
        }, {
            name: "sha3",
            padding: [6, 1536, 393216, 100663296],
            bits: p,
            createMethod: _
        }, {
            name: "shake",
            padding: [31, 7936, 2031616, 520093696],
            bits: m,
            createMethod: function(t, e) {
                var n = v(t, e, "hex");
                return n.create = function(n) {
                    return new N(t,e,n)
                }
                ,
                n.update = function(t, e) {
                    return n.create(e).update(t)
                }
                ,
                E(n, v, t, e)
            }
        }, {
            name: "cshake",
            padding: h,
            bits: m,
            createMethod: function(t, e) {
                var n = y[t]
                  , r = w(t, 0, "hex");
                return r.create = function(r, i, s) {
                    return i || s ? new N(t,e,r).bytepad([i, s], n) : S["shake" + t].create(r)
                }
                ,
                r.update = function(t, e, n, i) {
                    return r.create(e, n, i).update(t)
                }
                ,
                E(r, w, t, e)
            }
        }, {
            name: "kmac",
            padding: h,
            bits: m,
            createMethod: function(t, e) {
                var n = y[t]
                  , r = x(t, 0, "hex");
                return r.create = function(r, i, s) {
                    return new R(t,e,i).bytepad(["KMAC", s], n).bytepad([r], n)
                }
                ,
                r.update = function(t, e, n, i) {
                    return r.create(t, n, i).update(e)
                }
                ,
                E(r, x, t, e)
            }
        }], S = {}, T = [], k = 0; k < A.length; ++k)
            for (var I = A[k], M = I.bits, C = 0; C < M.length; ++C) {
                var P = I.name + "_" + M[C];
                if (T.push(P),
                S[P] = I.createMethod(M[C], I.padding),
                "sha3" !== I.name) {
                    var O = I.name + M[C];
                    T.push(O),
                    S[O] = S[P]
                }
            }
        function N(t, e, n) {
            this.blocks = [],
            this.s = [],
            this.padding = e,
            this.outputBits = n,
            this.reset = !0,
            this.finalized = !1,
            this.block = 0,
            this.start = 0,
            this.blockCount = 1600 - (t << 1) >> 5,
            this.byteCount = this.blockCount << 2,
            this.outputBlocks = n >> 5,
            this.extraBytes = (31 & n) >> 3;
            for (var r = 0; r < 50; ++r)
                this.s[r] = 0
        }
        function R(t, e, n) {
            N.call(this, t, e, n)
        }
        N.prototype.update = function(t) {
            if (this.finalized)
                throw new Error("finalize already called");
            var n, r = typeof t;
            if ("string" !== r) {
                if ("object" !== r)
                    throw new Error(e);
                if (null === t)
                    throw new Error(e);
                if (c && t.constructor === ArrayBuffer)
                    t = new Uint8Array(t);
                else if (!(Array.isArray(t) || c && ArrayBuffer.isView(t)))
                    throw new Error(e);
                n = !0
            }
            for (var i, s, o = this.blocks, a = this.byteCount, l = t.length, u = this.blockCount, h = 0, f = this.s; h < l; ) {
                if (this.reset)
                    for (this.reset = !1,
                    o[0] = this.block,
                    i = 1; i < u + 1; ++i)
                        o[i] = 0;
                if (n)
                    for (i = this.start; h < l && i < a; ++h)
                        o[i >> 2] |= t[h] << d[3 & i++];
                else
                    for (i = this.start; h < l && i < a; ++h)
                        (s = t.charCodeAt(h)) < 128 ? o[i >> 2] |= s << d[3 & i++] : s < 2048 ? (o[i >> 2] |= (192 | s >> 6) << d[3 & i++],
                        o[i >> 2] |= (128 | 63 & s) << d[3 & i++]) : s < 55296 || s >= 57344 ? (o[i >> 2] |= (224 | s >> 12) << d[3 & i++],
                        o[i >> 2] |= (128 | s >> 6 & 63) << d[3 & i++],
                        o[i >> 2] |= (128 | 63 & s) << d[3 & i++]) : (s = 65536 + ((1023 & s) << 10 | 1023 & t.charCodeAt(++h)),
                        o[i >> 2] |= (240 | s >> 18) << d[3 & i++],
                        o[i >> 2] |= (128 | s >> 12 & 63) << d[3 & i++],
                        o[i >> 2] |= (128 | s >> 6 & 63) << d[3 & i++],
                        o[i >> 2] |= (128 | 63 & s) << d[3 & i++]);
                if (this.lastByteIndex = i,
                i >= a) {
                    for (this.start = i - a,
                    this.block = o[u],
                    i = 0; i < u; ++i)
                        f[i] ^= o[i];
                    D(f),
                    this.reset = !0
                } else
                    this.start = i
            }
            return this
        }
        ,
        N.prototype.encode = function(t, e) {
            var n = 255 & t
              , r = 1
              , i = [n];
            for (n = 255 & (t >>= 8); n > 0; )
                i.unshift(n),
                n = 255 & (t >>= 8),
                ++r;
            return e ? i.push(r) : i.unshift(r),
            this.update(i),
            i.length
        }
        ,
        N.prototype.encodeString = function(t) {
            var n, r = typeof t;
            if ("string" !== r) {
                if ("object" !== r)
                    throw new Error(e);
                if (null === t)
                    throw new Error(e);
                if (c && t.constructor === ArrayBuffer)
                    t = new Uint8Array(t);
                else if (!(Array.isArray(t) || c && ArrayBuffer.isView(t)))
                    throw new Error(e);
                n = !0
            }
            var i = 0
              , s = t.length;
            if (n)
                i = s;
            else
                for (var o = 0; o < t.length; ++o) {
                    var a = t.charCodeAt(o);
                    a < 128 ? i += 1 : a < 2048 ? i += 2 : a < 55296 || a >= 57344 ? i += 3 : (a = 65536 + ((1023 & a) << 10 | 1023 & t.charCodeAt(++o)),
                    i += 4)
                }
            return i += this.encode(8 * i),
            this.update(t),
            i
        }
        ,
        N.prototype.bytepad = function(t, e) {
            for (var n = this.encode(e), r = 0; r < t.length; ++r)
                n += this.encodeString(t[r]);
            var i = e - n % e
              , s = [];
            return s.length = i,
            this.update(s),
            this
        }
        ,
        N.prototype.finalize = function() {
            if (!this.finalized) {
                this.finalized = !0;
                var t = this.blocks
                  , e = this.lastByteIndex
                  , n = this.blockCount
                  , r = this.s;
                if (t[e >> 2] |= this.padding[3 & e],
                this.lastByteIndex === this.byteCount)
                    for (t[0] = t[n],
                    e = 1; e < n + 1; ++e)
                        t[e] = 0;
                for (t[n - 1] |= 2147483648,
                e = 0; e < n; ++e)
                    r[e] ^= t[e];
                D(r)
            }
        }
        ,
        N.prototype.toString = N.prototype.hex = function() {
            this.finalize();
            for (var t, e = this.blockCount, n = this.s, r = this.outputBlocks, i = this.extraBytes, s = 0, o = 0, a = ""; o < r; ) {
                for (s = 0; s < e && o < r; ++s,
                ++o)
                    t = n[s],
                    a += u[t >> 4 & 15] + u[15 & t] + u[t >> 12 & 15] + u[t >> 8 & 15] + u[t >> 20 & 15] + u[t >> 16 & 15] + u[t >> 28 & 15] + u[t >> 24 & 15];
                o % e == 0 && (D(n),
                s = 0)
            }
            return i && (t = n[s],
            a += u[t >> 4 & 15] + u[15 & t],
            i > 1 && (a += u[t >> 12 & 15] + u[t >> 8 & 15]),
            i > 2 && (a += u[t >> 20 & 15] + u[t >> 16 & 15])),
            a
        }
        ,
        N.prototype.arrayBuffer = function() {
            this.finalize();
            var t, e = this.blockCount, n = this.s, r = this.outputBlocks, i = this.extraBytes, s = 0, o = 0, a = this.outputBits >> 3;
            t = i ? new ArrayBuffer(r + 1 << 2) : new ArrayBuffer(a);
            for (var l = new Uint32Array(t); o < r; ) {
                for (s = 0; s < e && o < r; ++s,
                ++o)
                    l[o] = n[s];
                o % e == 0 && D(n)
            }
            return i && (l[s] = n[s],
            t = t.slice(0, a)),
            t
        }
        ,
        N.prototype.buffer = N.prototype.arrayBuffer,
        N.prototype.digest = N.prototype.array = function() {
            this.finalize();
            for (var t, e, n = this.blockCount, r = this.s, i = this.outputBlocks, s = this.extraBytes, o = 0, a = 0, l = []; a < i; ) {
                for (o = 0; o < n && a < i; ++o,
                ++a)
                    t = a << 2,
                    e = r[o],
                    l[t] = 255 & e,
                    l[t + 1] = e >> 8 & 255,
                    l[t + 2] = e >> 16 & 255,
                    l[t + 3] = e >> 24 & 255;
                a % n == 0 && D(r)
            }
            return s && (t = a << 2,
            e = r[o],
            l[t] = 255 & e,
            s > 1 && (l[t + 1] = e >> 8 & 255),
            s > 2 && (l[t + 2] = e >> 16 & 255)),
            l
        }
        ,
        R.prototype = new N,
        R.prototype.finalize = function() {
            return this.encode(this.outputBits, !0),
            N.prototype.finalize.call(this)
        }
        ;
        var D = function(t) {
            var e, n, r, i, s, o, a, l, c, u, h, d, p, m, g, y, b, v, w, x, E, _, A, S, T, k, I, M, C, P, O, N, R, D, B, L, F, j, U, z, V, W, Y, H, $, G, X, q, K, Q, Z, J, tt, et, nt, rt, it, st, ot, at, lt, ct, ut;
            for (r = 0; r < 48; r += 2)
                i = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40],
                s = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41],
                o = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42],
                a = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43],
                l = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44],
                c = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45],
                u = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46],
                h = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47],
                e = (d = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48]) ^ (o << 1 | a >>> 31),
                n = (p = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49]) ^ (a << 1 | o >>> 31),
                t[0] ^= e,
                t[1] ^= n,
                t[10] ^= e,
                t[11] ^= n,
                t[20] ^= e,
                t[21] ^= n,
                t[30] ^= e,
                t[31] ^= n,
                t[40] ^= e,
                t[41] ^= n,
                e = i ^ (l << 1 | c >>> 31),
                n = s ^ (c << 1 | l >>> 31),
                t[2] ^= e,
                t[3] ^= n,
                t[12] ^= e,
                t[13] ^= n,
                t[22] ^= e,
                t[23] ^= n,
                t[32] ^= e,
                t[33] ^= n,
                t[42] ^= e,
                t[43] ^= n,
                e = o ^ (u << 1 | h >>> 31),
                n = a ^ (h << 1 | u >>> 31),
                t[4] ^= e,
                t[5] ^= n,
                t[14] ^= e,
                t[15] ^= n,
                t[24] ^= e,
                t[25] ^= n,
                t[34] ^= e,
                t[35] ^= n,
                t[44] ^= e,
                t[45] ^= n,
                e = l ^ (d << 1 | p >>> 31),
                n = c ^ (p << 1 | d >>> 31),
                t[6] ^= e,
                t[7] ^= n,
                t[16] ^= e,
                t[17] ^= n,
                t[26] ^= e,
                t[27] ^= n,
                t[36] ^= e,
                t[37] ^= n,
                t[46] ^= e,
                t[47] ^= n,
                e = u ^ (i << 1 | s >>> 31),
                n = h ^ (s << 1 | i >>> 31),
                t[8] ^= e,
                t[9] ^= n,
                t[18] ^= e,
                t[19] ^= n,
                t[28] ^= e,
                t[29] ^= n,
                t[38] ^= e,
                t[39] ^= n,
                t[48] ^= e,
                t[49] ^= n,
                m = t[0],
                g = t[1],
                G = t[11] << 4 | t[10] >>> 28,
                X = t[10] << 4 | t[11] >>> 28,
                M = t[20] << 3 | t[21] >>> 29,
                C = t[21] << 3 | t[20] >>> 29,
                at = t[31] << 9 | t[30] >>> 23,
                lt = t[30] << 9 | t[31] >>> 23,
                W = t[40] << 18 | t[41] >>> 14,
                Y = t[41] << 18 | t[40] >>> 14,
                D = t[2] << 1 | t[3] >>> 31,
                B = t[3] << 1 | t[2] >>> 31,
                y = t[13] << 12 | t[12] >>> 20,
                b = t[12] << 12 | t[13] >>> 20,
                q = t[22] << 10 | t[23] >>> 22,
                K = t[23] << 10 | t[22] >>> 22,
                P = t[33] << 13 | t[32] >>> 19,
                O = t[32] << 13 | t[33] >>> 19,
                ct = t[42] << 2 | t[43] >>> 30,
                ut = t[43] << 2 | t[42] >>> 30,
                et = t[5] << 30 | t[4] >>> 2,
                nt = t[4] << 30 | t[5] >>> 2,
                L = t[14] << 6 | t[15] >>> 26,
                F = t[15] << 6 | t[14] >>> 26,
                v = t[25] << 11 | t[24] >>> 21,
                w = t[24] << 11 | t[25] >>> 21,
                Q = t[34] << 15 | t[35] >>> 17,
                Z = t[35] << 15 | t[34] >>> 17,
                N = t[45] << 29 | t[44] >>> 3,
                R = t[44] << 29 | t[45] >>> 3,
                S = t[6] << 28 | t[7] >>> 4,
                T = t[7] << 28 | t[6] >>> 4,
                rt = t[17] << 23 | t[16] >>> 9,
                it = t[16] << 23 | t[17] >>> 9,
                j = t[26] << 25 | t[27] >>> 7,
                U = t[27] << 25 | t[26] >>> 7,
                x = t[36] << 21 | t[37] >>> 11,
                E = t[37] << 21 | t[36] >>> 11,
                J = t[47] << 24 | t[46] >>> 8,
                tt = t[46] << 24 | t[47] >>> 8,
                H = t[8] << 27 | t[9] >>> 5,
                $ = t[9] << 27 | t[8] >>> 5,
                k = t[18] << 20 | t[19] >>> 12,
                I = t[19] << 20 | t[18] >>> 12,
                st = t[29] << 7 | t[28] >>> 25,
                ot = t[28] << 7 | t[29] >>> 25,
                z = t[38] << 8 | t[39] >>> 24,
                V = t[39] << 8 | t[38] >>> 24,
                _ = t[48] << 14 | t[49] >>> 18,
                A = t[49] << 14 | t[48] >>> 18,
                t[0] = m ^ ~y & v,
                t[1] = g ^ ~b & w,
                t[10] = S ^ ~k & M,
                t[11] = T ^ ~I & C,
                t[20] = D ^ ~L & j,
                t[21] = B ^ ~F & U,
                t[30] = H ^ ~G & q,
                t[31] = $ ^ ~X & K,
                t[40] = et ^ ~rt & st,
                t[41] = nt ^ ~it & ot,
                t[2] = y ^ ~v & x,
                t[3] = b ^ ~w & E,
                t[12] = k ^ ~M & P,
                t[13] = I ^ ~C & O,
                t[22] = L ^ ~j & z,
                t[23] = F ^ ~U & V,
                t[32] = G ^ ~q & Q,
                t[33] = X ^ ~K & Z,
                t[42] = rt ^ ~st & at,
                t[43] = it ^ ~ot & lt,
                t[4] = v ^ ~x & _,
                t[5] = w ^ ~E & A,
                t[14] = M ^ ~P & N,
                t[15] = C ^ ~O & R,
                t[24] = j ^ ~z & W,
                t[25] = U ^ ~V & Y,
                t[34] = q ^ ~Q & J,
                t[35] = K ^ ~Z & tt,
                t[44] = st ^ ~at & ct,
                t[45] = ot ^ ~lt & ut,
                t[6] = x ^ ~_ & m,
                t[7] = E ^ ~A & g,
                t[16] = P ^ ~N & S,
                t[17] = O ^ ~R & T,
                t[26] = z ^ ~W & D,
                t[27] = V ^ ~Y & B,
                t[36] = Q ^ ~J & H,
                t[37] = Z ^ ~tt & $,
                t[46] = at ^ ~ct & et,
                t[47] = lt ^ ~ut & nt,
                t[8] = _ ^ ~m & y,
                t[9] = A ^ ~g & b,
                t[18] = N ^ ~S & k,
                t[19] = R ^ ~T & I,
                t[28] = W ^ ~D & L,
                t[29] = Y ^ ~B & F,
                t[38] = J ^ ~H & G,
                t[39] = tt ^ ~$ & X,
                t[48] = ct ^ ~et & rt,
                t[49] = ut ^ ~nt & it,
                t[0] ^= f[r],
                t[1] ^= f[r + 1]
        };
        if (a)
            t.exports = S;
        else {
            for (k = 0; k < T.length; ++k)
                s[T[k]] = S[T[k]];
            l && define((function() {
                return S
            }
            ))
        }
    }()
}
)),
o("27Lyk").register(JSON.parse('{"h00hi":"index.2b7070b3.js","bSJWN":"TransportWebHID.4e265b2d.js","2Wmvo":"esm.123e1b5d.js","avSDn":"solanaEmbed.esm.59ed5123.js","hIE2C":"index.140e1820.css"}'));
var a, l;
a = o("1b2ls"),
o("acw62");
var c;
!function t() {
    if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)
        } catch (t) {
            console.error(t)
        }
}(),
l = (c = o("Xw6Mv")).createRoot,
c.hydrateRoot,
o("acw62");
/**
 * React Router DOM v6.9.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var u, h, d = o("acw62");
/**
 * @remix-run/router v1.4.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function f() {
    return f = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
                Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }
    ,
    f.apply(this, arguments)
}
(h = u || (u = {})).Pop = "POP",
h.Push = "PUSH",
h.Replace = "REPLACE";
const p = "popstate";
function m(t) {
    return void 0 === t && (t = {}),
    E((function(t, e) {
        let {pathname: n, search: r, hash: i} = t.location;
        return v("", {
            pathname: n,
            search: r,
            hash: i
        }, e.state && e.state.usr || null, e.state && e.state.key || "default")
    }
    ), (function(t, e) {
        return "string" == typeof e ? e : w(e)
    }
    ), null, t)
}
function g(t, e) {
    if (!1 === t || null == t)
        throw new Error(e)
}
function y(t, e) {
    if (!t) {
        "undefined" != typeof console && console.warn(e);
        try {
            throw new Error(e)
        } catch (t) {}
    }
}
function b(t, e) {
    return {
        usr: t.state,
        key: t.key,
        idx: e
    }
}
function v(t, e, n, r) {
    return void 0 === n && (n = null),
    f({
        pathname: "string" == typeof t ? t : t.pathname,
        search: "",
        hash: ""
    }, "string" == typeof e ? x(e) : e, {
        state: n,
        key: e && e.key || r || Math.random().toString(36).substr(2, 8)
    })
}
function w(t) {
    let {pathname: e="/", search: n="", hash: r=""} = t;
    return n && "?" !== n && (e += "?" === n.charAt(0) ? n : "?" + n),
    r && "#" !== r && (e += "#" === r.charAt(0) ? r : "#" + r),
    e
}
function x(t) {
    let e = {};
    if (t) {
        let n = t.indexOf("#");
        n >= 0 && (e.hash = t.substr(n),
        t = t.substr(0, n));
        let r = t.indexOf("?");
        r >= 0 && (e.search = t.substr(r),
        t = t.substr(0, r)),
        t && (e.pathname = t)
    }
    return e
}
function E(t, e, n, r) {
    void 0 === r && (r = {});
    let {window: i=document.defaultView, v5Compat: s=!1} = r
      , o = i.history
      , a = u.Pop
      , l = null
      , c = h();
    function h() {
        return (o.state || {
            idx: null
        }).idx
    }
    function d() {
        a = u.Pop;
        let t = h()
          , e = null == t ? null : t - c;
        c = t,
        l && l({
            action: a,
            location: y.location,
            delta: e
        })
    }
    function m(t) {
        let e = "null" !== i.location.origin ? i.location.origin : i.location.href
          , n = "string" == typeof t ? t : w(t);
        return g(e, "No window.location.(origin|href) available to create URL for href: " + n),
        new URL(n,e)
    }
    null == c && (c = 0,
    o.replaceState(f({}, o.state, {
        idx: c
    }), ""));
    let y = {
        get action() {
            return a
        },
        get location() {
            return t(i, o)
        },
        listen(t) {
            if (l)
                throw new Error("A history only accepts one active listener");
            return i.addEventListener(p, d),
            l = t,
            ()=>{
                i.removeEventListener(p, d),
                l = null
            }
        },
        createHref: t=>e(i, t),
        createURL: m,
        encodeLocation(t) {
            let e = m(t);
            return {
                pathname: e.pathname,
                search: e.search,
                hash: e.hash
            }
        },
        push: function(t, e) {
            a = u.Push;
            let r = v(y.location, t, e);
            n && n(r, t),
            c = h() + 1;
            let d = b(r, c)
              , f = y.createHref(r);
            try {
                o.pushState(d, "", f)
            } catch (t) {
                i.location.assign(f)
            }
            s && l && l({
                action: a,
                location: y.location,
                delta: 1
            })
        },
        replace: function(t, e) {
            a = u.Replace;
            let r = v(y.location, t, e);
            n && n(r, t),
            c = h();
            let i = b(r, c)
              , d = y.createHref(r);
            o.replaceState(i, "", d),
            s && l && l({
                action: a,
                location: y.location,
                delta: 0
            })
        },
        go: t=>o.go(t)
    };
    return y
}
var _, A;
(A = _ || (_ = {})).data = "data",
A.deferred = "deferred",
A.redirect = "redirect",
A.error = "error";
new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function S(t, e, n) {
    void 0 === n && (n = "/");
    let r = j(("string" == typeof e ? x(e) : e).pathname || "/", n);
    if (null == r)
        return null;
    let i = T(t);
    !function(t) {
        t.sort(((t,e)=>t.score !== e.score ? e.score - t.score : function(t, e) {
            let n = t.length === e.length && t.slice(0, -1).every(((t,n)=>t === e[n]));
            return n ? t[t.length - 1] - e[e.length - 1] : 0
        }(t.routesMeta.map((t=>t.childrenIndex)), e.routesMeta.map((t=>t.childrenIndex)))))
    }(i);
    let s = null;
    for (let t = 0; null == s && t < i.length; ++t)
        s = B(i[t], F(r));
    return s
}
function T(t, e, n, r) {
    void 0 === e && (e = []),
    void 0 === n && (n = []),
    void 0 === r && (r = "");
    let i = (t,i,s)=>{
        let o = {
            relativePath: void 0 === s ? t.path || "" : s,
            caseSensitive: !0 === t.caseSensitive,
            childrenIndex: i,
            route: t
        };
        o.relativePath.startsWith("/") && (g(o.relativePath.startsWith(r), 'Absolute route path "' + o.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),
        o.relativePath = o.relativePath.slice(r.length));
        let a = W([r, o.relativePath])
          , l = n.concat(o);
        t.children && t.children.length > 0 && (g(!0 !== t.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + a + '".'),
        T(t.children, e, l, a)),
        (null != t.path || t.index) && e.push({
            path: a,
            score: D(a, t.index),
            routesMeta: l
        })
    }
    ;
    return t.forEach(((t,e)=>{
        var n;
        if ("" !== t.path && null != (n = t.path) && n.includes("?"))
            for (let n of k(t.path))
                i(t, e, n);
        else
            i(t, e)
    }
    )),
    e
}
function k(t) {
    let e = t.split("/");
    if (0 === e.length)
        return [];
    let[n,...r] = e
      , i = n.endsWith("?")
      , s = n.replace(/\?$/, "");
    if (0 === r.length)
        return i ? [s, ""] : [s];
    let o = k(r.join("/"))
      , a = [];
    return a.push(...o.map((t=>"" === t ? s : [s, t].join("/")))),
    i && a.push(...o),
    a.map((e=>t.startsWith("/") && "" === e ? "/" : e))
}
const I = /^:\w+$/
  , M = 3
  , C = 2
  , P = 1
  , O = 10
  , N = -2
  , R = t=>"*" === t;
function D(t, e) {
    let n = t.split("/")
      , r = n.length;
    return n.some(R) && (r += N),
    e && (r += C),
    n.filter((t=>!R(t))).reduce(((t,e)=>t + (I.test(e) ? M : "" === e ? P : O)), r)
}
function B(t, e) {
    let {routesMeta: n} = t
      , r = {}
      , i = "/"
      , s = [];
    for (let t = 0; t < n.length; ++t) {
        let o = n[t]
          , a = t === n.length - 1
          , l = "/" === i ? e : e.slice(i.length) || "/"
          , c = L({
            path: o.relativePath,
            caseSensitive: o.caseSensitive,
            end: a
        }, l);
        if (!c)
            return null;
        Object.assign(r, c.params);
        let u = o.route;
        s.push({
            params: r,
            pathname: W([i, c.pathname]),
            pathnameBase: Y(W([i, c.pathnameBase])),
            route: u
        }),
        "/" !== c.pathnameBase && (i = W([i, c.pathnameBase]))
    }
    return s
}
function L(t, e) {
    "string" == typeof t && (t = {
        path: t,
        caseSensitive: !1,
        end: !0
    });
    let[n,r] = function(t, e, n) {
        void 0 === e && (e = !1);
        void 0 === n && (n = !0);
        y("*" === t || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were "' + t.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + t.replace(/\*$/, "/*") + '".');
        let r = []
          , i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, ((t,e)=>(r.push(e),
        "/([^\\/]+)")));
        t.endsWith("*") ? (r.push("*"),
        i += "*" === t || "/*" === t ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : "" !== t && "/" !== t && (i += "(?:(?=\\/|$))");
        let s = new RegExp(i,e ? void 0 : "i");
        return [s, r]
    }(t.path, t.caseSensitive, t.end)
      , i = e.match(n);
    if (!i)
        return null;
    let s = i[0]
      , o = s.replace(/(.)\/+$/, "$1")
      , a = i.slice(1);
    return {
        params: r.reduce(((t,e,n)=>{
            if ("*" === e) {
                let t = a[n] || "";
                o = s.slice(0, s.length - t.length).replace(/(.)\/+$/, "$1")
            }
            return t[e] = function(t, e) {
                try {
                    return decodeURIComponent(t)
                } catch (n) {
                    return y(!1, 'The value for the URL param "' + e + '" will not be decoded because the string "' + t + '" is a malformed URL segment. This is probably due to a bad percent encoding (' + n + ")."),
                    t
                }
            }(a[n] || "", e),
            t
        }
        ), {}),
        pathname: s,
        pathnameBase: o,
        pattern: t
    }
}
function F(t) {
    try {
        return decodeURI(t)
    } catch (e) {
        return y(!1, 'The URL path "' + t + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + e + ")."),
        t
    }
}
function j(t, e) {
    if ("/" === e)
        return t;
    if (!t.toLowerCase().startsWith(e.toLowerCase()))
        return null;
    let n = e.endsWith("/") ? e.length - 1 : e.length
      , r = t.charAt(n);
    return r && "/" !== r ? null : t.slice(n) || "/"
}
function U(t, e, n, r) {
    return "Cannot include a '" + t + "' character in a manually specified `to." + e + "` field [" + JSON.stringify(r) + "].  Please separate it out to the `to." + n + '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'
}
function z(t) {
    return t.filter(((t,e)=>0 === e || t.route.path && t.route.path.length > 0))
}
function V(t, e, n, r) {
    let i;
    void 0 === r && (r = !1),
    "string" == typeof t ? i = x(t) : (i = f({}, t),
    g(!i.pathname || !i.pathname.includes("?"), U("?", "pathname", "search", i)),
    g(!i.pathname || !i.pathname.includes("#"), U("#", "pathname", "hash", i)),
    g(!i.search || !i.search.includes("#"), U("#", "search", "hash", i)));
    let s, o = "" === t || "" === i.pathname, a = o ? "/" : i.pathname;
    if (r || null == a)
        s = n;
    else {
        let t = e.length - 1;
        if (a.startsWith("..")) {
            let e = a.split("/");
            for (; ".." === e[0]; )
                e.shift(),
                t -= 1;
            i.pathname = e.join("/")
        }
        s = t >= 0 ? e[t] : "/"
    }
    let l = function(t, e) {
        void 0 === e && (e = "/");
        let {pathname: n, search: r="", hash: i=""} = "string" == typeof t ? x(t) : t
          , s = n ? n.startsWith("/") ? n : function(t, e) {
            let n = e.replace(/\/+$/, "").split("/");
            return t.split("/").forEach((t=>{
                ".." === t ? n.length > 1 && n.pop() : "." !== t && n.push(t)
            }
            )),
            n.length > 1 ? n.join("/") : "/"
        }(n, e) : e;
        return {
            pathname: s,
            search: H(r),
            hash: $(i)
        }
    }(i, s)
      , c = a && "/" !== a && a.endsWith("/")
      , u = (o || "." === a) && n.endsWith("/");
    return l.pathname.endsWith("/") || !c && !u || (l.pathname += "/"),
    l
}
const W = t=>t.join("/").replace(/\/\/+/g, "/")
  , Y = t=>t.replace(/\/+$/, "").replace(/^\/*/, "/")
  , H = t=>t && "?" !== t ? t.startsWith("?") ? t : "?" + t : ""
  , $ = t=>t && "#" !== t ? t.startsWith("#") ? t : "#" + t : "";
class G extends Error {
}
function X(t) {
    return null != t && "number" == typeof t.status && "string" == typeof t.statusText && "boolean" == typeof t.internal && "data"in t
}
const q = ["post", "put", "patch", "delete"]
  , K = (new Set(q),
["get", ...q]);
new Set(K),
new Set([301, 302, 303, 307, 308]),
new Set([307, 308]),
"undefined" != typeof window && void 0 !== window.document && window.document.createElement;
Symbol("deferred");
/**
 * React Router v6.9.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
d = o("acw62");
const Q = "function" == typeof Object.is ? Object.is : function(t, e) {
    return t === e && (0 !== t || 1 / t == 1 / e) || t != t && e != e
}
  , {useState: Z, useEffect: J, useLayoutEffect: tt, useDebugValue: et} = d;
function nt(t) {
    const e = t.getSnapshot
      , n = t.value;
    try {
        const t = e();
        return !Q(n, t)
    } catch (t) {
        return !0
    }
}
const rt = !!("undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement) ? function(t, e, n) {
    return e()
}
: function(t, e, n) {
    const r = e()
      , [{inst: i},s] = Z({
        inst: {
            value: r,
            getSnapshot: e
        }
    });
    return tt((()=>{
        i.value = r,
        i.getSnapshot = e,
        nt(i) && s({
            inst: i
        })
    }
    ), [t, r, e]),
    J((()=>{
        nt(i) && s({
            inst: i
        });
        return t((()=>{
            nt(i) && s({
                inst: i
            })
        }
        ))
    }
    ), [t]),
    et(r),
    r
}
  , it = ("useSyncExternalStore"in d && d.useSyncExternalStore,
d.createContext(null))
  , st = d.createContext(null)
  , ot = d.createContext(null)
  , at = d.createContext(null)
  , lt = d.createContext({
    outlet: null,
    matches: []
})
  , ct = d.createContext(null);
function ut() {
    return ut = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
                Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }
    ,
    ut.apply(this, arguments)
}
function ht() {
    return null != d.useContext(at)
}
function dt() {
    return !ht() && g(!1),
    d.useContext(at).location
}
function ft() {
    !ht() && g(!1);
    let {basename: t, navigator: e} = d.useContext(ot)
      , {matches: n} = d.useContext(lt)
      , {pathname: r} = dt()
      , i = JSON.stringify(z(n).map((t=>t.pathnameBase)))
      , s = d.useRef(!1);
    return d.useEffect((()=>{
        s.current = !0
    }
    )),
    d.useCallback((function(n, o) {
        if (void 0 === o && (o = {}),
        !s.current)
            return;
        if ("number" == typeof n)
            return void e.go(n);
        let a = V(n, JSON.parse(i), r, "path" === o.relative);
        "/" !== t && (a.pathname = "/" === a.pathname ? t : W([t, a.pathname])),
        (o.replace ? e.replace : e.push)(a, o.state, o)
    }
    ), [t, e, i, r])
}
const pt = d.createContext(null);
function mt() {
    let {matches: t} = d.useContext(lt)
      , e = t[t.length - 1];
    return e ? e.params : {}
}
function gt() {
    let t = function() {
        var t;
        let e = d.useContext(ct)
          , n = At(Et.UseRouteError)
          , r = St(Et.UseRouteError);
        return e || (null == (t = n.errors) ? void 0 : t[r])
    }()
      , e = X(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t)
      , n = t instanceof Error ? t.stack : null
      , r = "rgba(200,200,200, 0.5)"
      , i = {
        padding: "0.5rem",
        backgroundColor: r
    };
    return d.createElement(d.Fragment, null, d.createElement("h2", null, "Unexpected Application Error!"), d.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, e), n ? d.createElement("pre", {
        style: i
    }, n) : null, null)
}
class yt extends d.Component {
    constructor(t) {
        super(t),
        this.state = {
            location: t.location,
            error: t.error
        }
    }
    static getDerivedStateFromError(t) {
        return {
            error: t
        }
    }
    static getDerivedStateFromProps(t, e) {
        return e.location !== t.location ? {
            error: t.error,
            location: t.location
        } : {
            error: t.error || e.error,
            location: e.location
        }
    }
    componentDidCatch(t, e) {
        console.error("React Router caught the following error during render", t, e)
    }
    render() {
        return this.state.error ? d.createElement(lt.Provider, {
            value: this.props.routeContext
        }, d.createElement(ct.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function bt(t) {
    let {routeContext: e, match: n, children: r} = t
      , i = d.useContext(it);
    return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id),
    d.createElement(lt.Provider, {
        value: e
    }, r)
}
function vt(t, e, n) {
    if (void 0 === e && (e = []),
    null == t) {
        if (null == n || !n.errors)
            return null;
        t = n.matches
    }
    let r = t
      , i = null == n ? void 0 : n.errors;
    if (null != i) {
        let t = r.findIndex((t=>t.route.id && (null == i ? void 0 : i[t.route.id])));
        !(t >= 0) && g(!1),
        r = r.slice(0, Math.min(r.length, t + 1))
    }
    return r.reduceRight(((t,s,o)=>{
        let a = s.route.id ? null == i ? void 0 : i[s.route.id] : null
          , l = null;
        n && (l = s.route.ErrorBoundary ? d.createElement(s.route.ErrorBoundary, null) : s.route.errorElement ? s.route.errorElement : d.createElement(gt, null));
        let c = e.concat(r.slice(0, o + 1))
          , u = ()=>{
            let e = t;
            return a ? e = l : s.route.Component ? e = d.createElement(s.route.Component, null) : s.route.element && (e = s.route.element),
            d.createElement(bt, {
                match: s,
                routeContext: {
                    outlet: t,
                    matches: c
                },
                children: e
            })
        }
        ;
        return n && (s.route.ErrorBoundary || s.route.errorElement || 0 === o) ? d.createElement(yt, {
            location: n.location,
            component: l,
            error: a,
            children: u(),
            routeContext: {
                outlet: null,
                matches: c
            }
        }) : u()
    }
    ), null)
}
var wt, xt, Et, _t;
function At(t) {
    let e = d.useContext(st);
    return !e && g(!1),
    e
}
function St(t) {
    let e = function(t) {
        let e = d.useContext(lt);
        return !e && g(!1),
        e
    }()
      , n = e.matches[e.matches.length - 1];
    return !n.route.id && g(!1),
    n.route.id
}
(xt = wt || (wt = {})).UseBlocker = "useBlocker",
xt.UseRevalidator = "useRevalidator",
(_t = Et || (Et = {})).UseBlocker = "useBlocker",
_t.UseLoaderData = "useLoaderData",
_t.UseActionData = "useActionData",
_t.UseRouteError = "useRouteError",
_t.UseNavigation = "useNavigation",
_t.UseRouteLoaderData = "useRouteLoaderData",
_t.UseMatches = "useMatches",
_t.UseRevalidator = "useRevalidator";
function Tt(t) {
    let {to: e, replace: n, state: r, relative: i} = t;
    !ht() && g(!1);
    let s = d.useContext(st)
      , o = ft();
    return d.useEffect((()=>{
        s && "idle" !== s.navigation.state || o(e, {
            replace: n,
            state: r,
            relative: i
        })
    }
    )),
    null
}
function kt(t) {
    return function(t) {
        let e = d.useContext(lt).outlet;
        return e ? d.createElement(pt.Provider, {
            value: t
        }, e) : e
    }(t.context)
}
function It(t) {
    g(!1)
}
function Mt(t) {
    let {basename: e="/", children: n=null, location: r, navigationType: i=u.Pop, navigator: s, static: o=!1} = t;
    ht() && g(!1);
    let a = e.replace(/^\/*/, "/")
      , l = d.useMemo((()=>({
        basename: a,
        navigator: s,
        static: o
    })), [a, s, o]);
    "string" == typeof r && (r = x(r));
    let {pathname: c="/", search: h="", hash: f="", state: p=null, key: m="default"} = r
      , y = d.useMemo((()=>{
        let t = j(c, a);
        return null == t ? null : {
            location: {
                pathname: t,
                search: h,
                hash: f,
                state: p,
                key: m
            },
            navigationType: i
        }
    }
    ), [a, c, h, f, p, m, i]);
    return null == y ? null : d.createElement(ot.Provider, {
        value: l
    }, d.createElement(at.Provider, {
        children: n,
        value: y
    }))
}
function Ct(t) {
    let {children: e, location: n} = t
      , r = d.useContext(it);
    return function(t, e) {
        !ht() && g(!1);
        let n, {navigator: r} = d.useContext(ot), i = d.useContext(st), {matches: s} = d.useContext(lt), o = s[s.length - 1], a = o ? o.params : {}, l = (o && o.pathname,
        o ? o.pathnameBase : "/"), c = (o && o.route,
        dt());
        if (e) {
            var h;
            let t = "string" == typeof e ? x(e) : e;
            "/" !== l && !(null == (h = t.pathname) ? void 0 : h.startsWith(l)) && g(!1),
            n = t
        } else
            n = c;
        let f = n.pathname || "/"
          , p = S(t, {
            pathname: "/" === l ? f : f.slice(l.length) || "/"
        })
          , m = vt(p && p.map((t=>Object.assign({}, t, {
            params: Object.assign({}, a, t.params),
            pathname: W([l, r.encodeLocation ? r.encodeLocation(t.pathname).pathname : t.pathname]),
            pathnameBase: "/" === t.pathnameBase ? l : W([l, r.encodeLocation ? r.encodeLocation(t.pathnameBase).pathname : t.pathnameBase])
        }))), s, i || void 0);
        return e && m ? d.createElement(at.Provider, {
            value: {
                location: ut({
                    pathname: "/",
                    search: "",
                    hash: "",
                    state: null,
                    key: "default"
                }, n),
                navigationType: u.Pop
            }
        }, m) : m
    }(r && !e ? r.router.routes : Rt(e), n)
}
var Pt, Ot;
(Ot = Pt || (Pt = {}))[Ot.pending = 0] = "pending",
Ot[Ot.success = 1] = "success",
Ot[Ot.error = 2] = "error";
new Promise((()=>{}
));
class Nt extends d.Component {
    constructor(t) {
        super(t),
        this.state = {
            error: null
        }
    }
    static getDerivedStateFromError(t) {
        return {
            error: t
        }
    }
    componentDidCatch(t, e) {
        console.error("<Await> caught the following error during render", t, e)
    }
    render() {
        let {children: t, errorElement: e, resolve: n} = this.props
          , r = null
          , i = Pt.pending;
        if (n instanceof Promise)
            if (this.state.error) {
                Pt.error;
                let t = this.state.error;
                Promise.reject().catch((()=>{}
                )),
                Object.defineProperty(r, "_tracked", {
                    get: ()=>!0
                }),
                Object.defineProperty(r, "_error", {
                    get: ()=>t
                })
            } else
                n._tracked ? (n,
                void 0 !== r._error ? Pt.error : void 0 !== r._data ? Pt.success : Pt.pending) : (Pt.pending,
                Object.defineProperty(n, "_tracked", {
                    get: ()=>!0
                }),
                n.then((t=>Object.defineProperty(n, "_data", {
                    get: ()=>t
                })), (t=>Object.defineProperty(n, "_error", {
                    get: ()=>t
                }))));
        else
            Pt.success,
            Promise.resolve(),
            Object.defineProperty(r, "_tracked", {
                get: ()=>!0
            }),
            Object.defineProperty(r, "_data", {
                get: ()=>n
            });
        if (i === Pt.error && r._error instanceof G)
            throw $7939e29d663dd3ed$var$neverSettledPromise;
        if (i === Pt.error && !e)
            throw r._error;
        if (i === Pt.error)
            return d.createElement($7939e29d663dd3ed$var$AwaitContext.Provider, {
                value: r,
                children: e
            });
        if (i === Pt.success)
            return d.createElement($7939e29d663dd3ed$var$AwaitContext.Provider, {
                value: r,
                children: t
            });
        throw r
    }
}
function Rt(t, e) {
    void 0 === e && (e = []);
    let n = [];
    return d.Children.forEach(t, ((t,r)=>{
        if (!d.isValidElement(t))
            return;
        if (t.type === d.Fragment)
            return void n.push.apply(n, Rt(t.props.children, e));
        t.type !== It && g(!1),
        t.props.index && t.props.children && g(!1);
        let i = [...e, r]
          , s = {
            id: t.props.id || i.join("-"),
            caseSensitive: t.props.caseSensitive,
            element: t.props.element,
            Component: t.props.Component,
            index: t.props.index,
            path: t.props.path,
            loader: t.props.loader,
            action: t.props.action,
            errorElement: t.props.errorElement,
            ErrorBoundary: t.props.ErrorBoundary,
            hasErrorBoundary: null != t.props.ErrorBoundary || null != t.props.errorElement,
            shouldRevalidate: t.props.shouldRevalidate,
            handle: t.props.handle,
            lazy: t.props.lazy
        };
        t.props.children && (s.children = Rt(t.props.children, i)),
        n.push(s)
    }
    )),
    n
}
function Dt(t) {
    let {basename: e, children: n, window: r} = t
      , i = d.useRef();
    null == i.current && (i.current = m({
        window: r,
        v5Compat: !0
    }));
    let s = i.current
      , [o,a] = d.useState({
        action: s.action,
        location: s.location
    });
    return d.useLayoutEffect((()=>s.listen(a)), [s]),
    d.createElement(Mt, {
        basename: e,
        children: n,
        location: o.location,
        navigationType: o.action,
        navigator: s
    })
}
"undefined" != typeof window && void 0 !== window.document && window.document.createElement;
var Bt, Lt;
!function(t) {
    t.UseScrollRestoration = "useScrollRestoration",
    t.UseSubmitImpl = "useSubmitImpl",
    t.UseFetcher = "useFetcher"
}(Bt || (Bt = {})),
function(t) {
    t.UseFetchers = "useFetchers",
    t.UseScrollRestoration = "useScrollRestoration"
}(Lt || (Lt = {}));
d = o("acw62"),
d = o("acw62");
function Ft(t) {
    var e, n, r = "";
    if ("string" == typeof t || "number" == typeof t)
        r += t;
    else if ("object" == typeof t)
        if (Array.isArray(t))
            for (e = 0; e < t.length; e++)
                t[e] && (n = Ft(t[e])) && (r && (r += " "),
                r += n);
        else
            for (e in t)
                t[e] && (r && (r += " "),
                r += e);
    return r
}
var jt = function() {
    for (var t, e, n = 0, r = ""; n < arguments.length; )
        (t = arguments[n++]) && (e = Ft(t)) && (r && (r += " "),
        r += e);
    return r
};
const Ut = t=>"number" == typeof t && !isNaN(t)
  , zt = t=>"string" == typeof t
  , Vt = t=>"function" == typeof t
  , Wt = t=>zt(t) || Vt(t) ? t : null
  , Yt = t=>(0,
d.isValidElement)(t) || zt(t) || Vt(t) || Ut(t);
function Ht(t) {
    let {enter: n, exit: r, appendPosition: i=!1, collapse: s=!0, collapseDuration: o=300} = t;
    return function(t) {
        let {children: a, position: l, preventExitTransition: c, done: u, nodeRef: h, isIn: f} = t;
        const p = i ? `${n}--${l}` : n
          , m = i ? `${r}--${l}` : r
          , g = (0,
        d.useRef)(0);
        return (0,
        d.useLayoutEffect)((()=>{
            const t = h.current
              , e = p.split(" ")
              , n = r=>{
                r.target === h.current && (t.dispatchEvent(new Event("d")),
                t.removeEventListener("animationend", n),
                t.removeEventListener("animationcancel", n),
                0 === g.current && "animationcancel" !== r.type && t.classList.remove(...e))
            }
            ;
            t.classList.add(...e),
            t.addEventListener("animationend", n),
            t.addEventListener("animationcancel", n)
        }
        ), []),
        (0,
        d.useEffect)((()=>{
            const t = h.current
              , e = ()=>{
                t.removeEventListener("animationend", e),
                s ? function(t, e, n) {
                    void 0 === n && (n = 300);
                    const {scrollHeight: r, style: i} = t;
                    requestAnimationFrame((()=>{
                        i.minHeight = "initial",
                        i.height = r + "px",
                        i.transition = `all ${n}ms`,
                        requestAnimationFrame((()=>{
                            i.height = "0",
                            i.padding = "0",
                            i.margin = "0",
                            setTimeout(e, n)
                        }
                        ))
                    }
                    ))
                }(t, u, o) : u()
            }
            ;
            f || (c ? e() : (g.current = 1,
            t.className += ` ${m}`,
            t.addEventListener("animationend", e)))
        }
        ), [f]),
        e(d).createElement(e(d).Fragment, null, a)
    }
}
function $t(t, e) {
    return {
        content: t.content,
        containerId: t.props.containerId,
        id: t.props.toastId,
        theme: t.props.theme,
        type: t.props.type,
        data: t.props.data || {},
        isLoading: t.props.isLoading,
        icon: t.props.icon,
        status: e
    }
}
const Gt = {
    list: new Map,
    emitQueue: new Map,
    on(t, e) {
        return this.list.has(t) || this.list.set(t, []),
        this.list.get(t).push(e),
        this
    },
    off(t, e) {
        if (e) {
            const n = this.list.get(t).filter((t=>t !== e));
            return this.list.set(t, n),
            this
        }
        return this.list.delete(t),
        this
    },
    cancelEmit(t) {
        const e = this.emitQueue.get(t);
        return e && (e.forEach(clearTimeout),
        this.emitQueue.delete(t)),
        this
    },
    emit(t) {
        this.list.has(t) && this.list.get(t).forEach((e=>{
            const n = setTimeout((()=>{
                e(...[].slice.call(arguments, 1))
            }
            ), 0);
            this.emitQueue.has(t) || this.emitQueue.set(t, []),
            this.emitQueue.get(t).push(n)
        }
        ))
    }
}
  , Xt = t=>{
    let {theme: n, type: r, ...i} = t;
    return e(d).createElement("svg", {
        viewBox: "0 0 24 24",
        width: "100%",
        height: "100%",
        fill: "colored" === n ? "currentColor" : `var(--toastify-icon-color-${r})`,
        ...i
    })
}
  , qt = {
    info: function(t) {
        return e(d).createElement(Xt, {
            ...t
        }, e(d).createElement("path", {
            d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
        }))
    },
    warning: function(t) {
        return e(d).createElement(Xt, {
            ...t
        }, e(d).createElement("path", {
            d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
        }))
    },
    success: function(t) {
        return e(d).createElement(Xt, {
            ...t
        }, e(d).createElement("path", {
            d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
        }))
    },
    error: function(t) {
        return e(d).createElement(Xt, {
            ...t
        }, e(d).createElement("path", {
            d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
        }))
    },
    spinner: function() {
        return e(d).createElement("div", {
            className: "Toastify__spinner"
        })
    }
};
function Kt(t) {
    return t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientX : t.clientX
}
function Qt(t) {
    return t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientY : t.clientY
}
function Zt(t) {
    let {closeToast: n, theme: r, ariaLabel: i="close"} = t;
    return e(d).createElement("button", {
        className: `Toastify__close-button Toastify__close-button--${r}`,
        type: "button",
        onClick: t=>{
            t.stopPropagation(),
            n(t)
        }
        ,
        "aria-label": i
    }, e(d).createElement("svg", {
        "aria-hidden": "true",
        viewBox: "0 0 14 16"
    }, e(d).createElement("path", {
        fillRule: "evenodd",
        d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
    })))
}
function Jt(t) {
    let {delay: n, isRunning: r, closeToast: i, type: s="default", hide: o, className: a, style: l, controlledProgress: c, progress: u, rtl: h, isIn: f, theme: p} = t;
    const m = o || c && 0 === u
      , g = {
        ...l,
        animationDuration: `${n}ms`,
        animationPlayState: r ? "running" : "paused",
        opacity: m ? 0 : 1
    };
    c && (g.transform = `scaleX(${u})`);
    const y = jt("Toastify__progress-bar", c ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${p}`, `Toastify__progress-bar--${s}`, {
        "Toastify__progress-bar--rtl": h
    })
      , b = Vt(a) ? a({
        rtl: h,
        type: s,
        defaultClassName: y
    }) : jt(y, a);
    return e(d).createElement("div", {
        role: "progressbar",
        "aria-hidden": m ? "true" : "false",
        "aria-label": "notification timer",
        className: b,
        style: g,
        [c && u >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: c && u < 1 ? null : ()=>{
            f && i()
        }
    })
}
const te = t=>{
    const {isRunning: n, preventExitTransition: r, toastRef: i, eventHandlers: s} = function(t) {
        const [e,n] = (0,
        d.useState)(!1)
          , [r,i] = (0,
        d.useState)(!1)
          , s = (0,
        d.useRef)(null)
          , o = (0,
        d.useRef)({
            start: 0,
            x: 0,
            y: 0,
            delta: 0,
            removalDistance: 0,
            canCloseOnClick: !0,
            canDrag: !1,
            boundingRect: null,
            didMove: !1
        }).current
          , a = (0,
        d.useRef)(t)
          , {autoClose: l, pauseOnHover: c, closeToast: u, onClick: h, closeOnClick: f} = t;
        function p(e) {
            if (t.draggable) {
                "touchstart" === e.nativeEvent.type && e.nativeEvent.preventDefault(),
                o.didMove = !1,
                document.addEventListener("mousemove", b),
                document.addEventListener("mouseup", v),
                document.addEventListener("touchmove", b),
                document.addEventListener("touchend", v);
                const n = s.current;
                o.canCloseOnClick = !0,
                o.canDrag = !0,
                o.boundingRect = n.getBoundingClientRect(),
                n.style.transition = "",
                o.x = Kt(e.nativeEvent),
                o.y = Qt(e.nativeEvent),
                "x" === t.draggableDirection ? (o.start = o.x,
                o.removalDistance = n.offsetWidth * (t.draggablePercent / 100)) : (o.start = o.y,
                o.removalDistance = n.offsetHeight * (80 === t.draggablePercent ? 1.5 * t.draggablePercent : t.draggablePercent / 100))
            }
        }
        function m(e) {
            if (o.boundingRect) {
                const {top: n, bottom: r, left: i, right: s} = o.boundingRect;
                "touchend" !== e.nativeEvent.type && t.pauseOnHover && o.x >= i && o.x <= s && o.y >= n && o.y <= r ? y() : g()
            }
        }
        function g() {
            n(!0)
        }
        function y() {
            n(!1)
        }
        function b(n) {
            const r = s.current;
            o.canDrag && r && (o.didMove = !0,
            e && y(),
            o.x = Kt(n),
            o.y = Qt(n),
            o.delta = "x" === t.draggableDirection ? o.x - o.start : o.y - o.start,
            o.start !== o.x && (o.canCloseOnClick = !1),
            r.style.transform = `translate${t.draggableDirection}(${o.delta}px)`,
            r.style.opacity = "" + (1 - Math.abs(o.delta / o.removalDistance)))
        }
        function v() {
            document.removeEventListener("mousemove", b),
            document.removeEventListener("mouseup", v),
            document.removeEventListener("touchmove", b),
            document.removeEventListener("touchend", v);
            const e = s.current;
            if (o.canDrag && o.didMove && e) {
                if (o.canDrag = !1,
                Math.abs(o.delta) > o.removalDistance)
                    return i(!0),
                    void t.closeToast();
                e.style.transition = "transform 0.2s, opacity 0.2s",
                e.style.transform = `translate${t.draggableDirection}(0)`,
                e.style.opacity = "1"
            }
        }
        (0,
        d.useEffect)((()=>{
            a.current = t
        }
        )),
        (0,
        d.useEffect)((()=>(s.current && s.current.addEventListener("d", g, {
            once: !0
        }),
        Vt(t.onOpen) && t.onOpen((0,
        d.isValidElement)(t.children) && t.children.props),
        ()=>{
            const t = a.current;
            Vt(t.onClose) && t.onClose((0,
            d.isValidElement)(t.children) && t.children.props)
        }
        )), []),
        (0,
        d.useEffect)((()=>(t.pauseOnFocusLoss && (document.hasFocus() || y(),
        window.addEventListener("focus", g),
        window.addEventListener("blur", y)),
        ()=>{
            t.pauseOnFocusLoss && (window.removeEventListener("focus", g),
            window.removeEventListener("blur", y))
        }
        )), [t.pauseOnFocusLoss]);
        const w = {
            onMouseDown: p,
            onTouchStart: p,
            onMouseUp: m,
            onTouchEnd: m
        };
        return l && c && (w.onMouseEnter = y,
        w.onMouseLeave = g),
        f && (w.onClick = t=>{
            h && h(t),
            o.canCloseOnClick && u()
        }
        ),
        {
            playToast: g,
            pauseToast: y,
            isRunning: e,
            preventExitTransition: r,
            toastRef: s,
            eventHandlers: w
        }
    }(t)
      , {closeButton: o, children: a, autoClose: l, onClick: c, type: u, hideProgressBar: h, closeToast: f, transition: p, position: m, className: g, style: y, bodyClassName: b, bodyStyle: v, progressClassName: w, progressStyle: x, updateId: E, role: _, progress: A, rtl: S, toastId: T, deleteToast: k, isIn: I, isLoading: M, iconOut: C, closeOnClick: P, theme: O} = t
      , N = jt("Toastify__toast", `Toastify__toast-theme--${O}`, `Toastify__toast--${u}`, {
        "Toastify__toast--rtl": S
    }, {
        "Toastify__toast--close-on-click": P
    })
      , R = Vt(g) ? g({
        rtl: S,
        position: m,
        type: u,
        defaultClassName: N
    }) : jt(N, g)
      , D = !!A || !l
      , B = {
        closeToast: f,
        type: u,
        theme: O
    };
    let L = null;
    return !1 === o || (L = Vt(o) ? o(B) : (0,
    d.isValidElement)(o) ? (0,
    d.cloneElement)(o, B) : Zt(B)),
    e(d).createElement(p, {
        isIn: I,
        done: k,
        position: m,
        preventExitTransition: r,
        nodeRef: i
    }, e(d).createElement("div", {
        id: T,
        onClick: c,
        className: R,
        ...s,
        style: y,
        ref: i
    }, e(d).createElement("div", {
        ...I && {
            role: _
        },
        className: Vt(b) ? b({
            type: u
        }) : jt("Toastify__toast-body", b),
        style: v
    }, null != C && e(d).createElement("div", {
        className: jt("Toastify__toast-icon", {
            "Toastify--animate-icon Toastify__zoom-enter": !M
        })
    }, C), e(d).createElement("div", null, a)), L, e(d).createElement(Jt, {
        ...E && !D ? {
            key: `pb-${E}`
        } : {},
        rtl: S,
        theme: O,
        delay: l,
        isRunning: n,
        isIn: I,
        closeToast: f,
        hide: h,
        type: u,
        style: x,
        className: w,
        controlledProgress: D,
        progress: A || 0
    })))
}
  , ee = function(t, e) {
    return void 0 === e && (e = !1),
    {
        enter: `Toastify--animate Toastify__${t}-enter`,
        exit: `Toastify--animate Toastify__${t}-exit`,
        appendPosition: e
    }
}
  , ne = Ht(ee("bounce", !0))
  , re = (Ht(ee("slide", !0)),
Ht(ee("zoom")),
Ht(ee("flip")))
  , ie = (0,
d.forwardRef)(((t,n)=>{
    const {getToastToRender: r, containerRef: i, isToastActive: s} = function(t) {
        const [,e] = (0,
        d.useReducer)((t=>t + 1), 0)
          , [n,r] = (0,
        d.useState)([])
          , i = (0,
        d.useRef)(null)
          , s = (0,
        d.useRef)(new Map).current
          , o = t=>-1 !== n.indexOf(t)
          , a = (0,
        d.useRef)({
            toastKey: 1,
            displayedToast: 0,
            count: 0,
            queue: [],
            props: t,
            containerId: null,
            isToastActive: o,
            getToast: t=>s.get(t)
        }).current;
        function l(t) {
            let {containerId: e} = t;
            const {limit: n} = a.props;
            !n || e && a.containerId !== e || (a.count -= a.queue.length,
            a.queue = [])
        }
        function c(t) {
            r((e=>null == t ? [] : e.filter((e=>e !== t))))
        }
        function u() {
            const {toastContent: t, toastProps: e, staleId: n} = a.queue.shift();
            f(t, e, n)
        }
        function h(t, n) {
            let {delay: r, staleId: o, ...l} = n;
            if (!Yt(t) || function(t) {
                return !i.current || a.props.enableMultiContainer && t.containerId !== a.props.containerId || s.has(t.toastId) && null == t.updateId
            }(l))
                return;
            const {toastId: h, updateId: p, data: m} = l
              , {props: g} = a
              , y = ()=>c(h)
              , b = null == p;
            b && a.count++;
            const v = {
                ...g,
                style: g.toastStyle,
                key: a.toastKey++,
                ...l,
                toastId: h,
                updateId: p,
                data: m,
                closeToast: y,
                isIn: !1,
                className: Wt(l.className || g.toastClassName),
                bodyClassName: Wt(l.bodyClassName || g.bodyClassName),
                progressClassName: Wt(l.progressClassName || g.progressClassName),
                autoClose: !l.isLoading && (w = l.autoClose,
                x = g.autoClose,
                !1 === w || Ut(w) && w > 0 ? w : x),
                deleteToast() {
                    const t = $t(s.get(h), "removed");
                    s.delete(h),
                    Gt.emit(4, t);
                    const n = a.queue.length;
                    if (a.count = null == h ? a.count - a.displayedToast : a.count - 1,
                    a.count < 0 && (a.count = 0),
                    n > 0) {
                        const t = null == h ? a.props.limit : 1;
                        if (1 === n || 1 === t)
                            a.displayedToast++,
                            u();
                        else {
                            const e = t > n ? n : t;
                            a.displayedToast = e;
                            for (let t = 0; t < e; t++)
                                u()
                        }
                    } else
                        e()
                }
            };
            var w, x;
            v.iconOut = function(t) {
                let {theme: e, type: n, isLoading: r, icon: i} = t
                  , s = null;
                const o = {
                    theme: e,
                    type: n
                };
                return !1 === i || (Vt(i) ? s = i(o) : (0,
                d.isValidElement)(i) ? s = (0,
                d.cloneElement)(i, o) : zt(i) || Ut(i) ? s = i : r ? s = qt.spinner() : (t=>t in qt)(n) && (s = qt[n](o))),
                s
            }(v),
            Vt(l.onOpen) && (v.onOpen = l.onOpen),
            Vt(l.onClose) && (v.onClose = l.onClose),
            v.closeButton = g.closeButton,
            !1 === l.closeButton || Yt(l.closeButton) ? v.closeButton = l.closeButton : !0 === l.closeButton && (v.closeButton = !Yt(g.closeButton) || g.closeButton);
            let E = t;
            (0,
            d.isValidElement)(t) && !zt(t.type) ? E = (0,
            d.cloneElement)(t, {
                closeToast: y,
                toastProps: v,
                data: m
            }) : Vt(t) && (E = t({
                closeToast: y,
                toastProps: v,
                data: m
            })),
            g.limit && g.limit > 0 && a.count > g.limit && b ? a.queue.push({
                toastContent: E,
                toastProps: v,
                staleId: o
            }) : Ut(r) ? setTimeout((()=>{
                f(E, v, o)
            }
            ), r) : f(E, v, o)
        }
        function f(t, e, n) {
            const {toastId: i} = e;
            n && s.delete(n);
            const o = {
                content: t,
                props: e
            };
            s.set(i, o),
            r((t=>[...t, i].filter((t=>t !== n)))),
            Gt.emit(4, $t(o, null == o.props.updateId ? "added" : "updated"))
        }
        return (0,
        d.useEffect)((()=>(a.containerId = t.containerId,
        Gt.cancelEmit(3).on(0, h).on(1, (t=>i.current && c(t))).on(5, l).emit(2, a),
        ()=>{
            s.clear(),
            Gt.emit(3, a)
        }
        )), []),
        (0,
        d.useEffect)((()=>{
            a.props = t,
            a.isToastActive = o,
            a.displayedToast = n.length
        }
        )),
        {
            getToastToRender: function(e) {
                const n = new Map
                  , r = Array.from(s.values());
                return t.newestOnTop && r.reverse(),
                r.forEach((t=>{
                    const {position: e} = t.props;
                    n.has(e) || n.set(e, []),
                    n.get(e).push(t)
                }
                )),
                Array.from(n, (t=>e(t[0], t[1])))
            },
            containerRef: i,
            isToastActive: o
        }
    }(t)
      , {className: o, style: a, rtl: l, containerId: c} = t;
    function u(t) {
        const e = jt("Toastify__toast-container", `Toastify__toast-container--${t}`, {
            "Toastify__toast-container--rtl": l
        });
        return Vt(o) ? o({
            position: t,
            rtl: l,
            defaultClassName: e
        }) : jt(e, Wt(o))
    }
    return (0,
    d.useEffect)((()=>{
        n && (n.current = i.current)
    }
    ), []),
    e(d).createElement("div", {
        ref: i,
        className: "Toastify",
        id: c
    }, r(((t,n)=>{
        const r = n.length ? {
            ...a
        } : {
            ...a,
            pointerEvents: "none"
        };
        return e(d).createElement("div", {
            className: u(t),
            style: r,
            key: `container-${t}`
        }, n.map(((t,r)=>{
            let {content: i, props: o} = t;
            return e(d).createElement(te, {
                ...o,
                isIn: s(o.toastId),
                style: {
                    ...o.style,
                    "--nth": r + 1,
                    "--len": n.length
                },
                key: `toast-${o.key}`
            }, i)
        }
        )))
    }
    )))
}
));
ie.displayName = "ToastContainer",
ie.defaultProps = {
    position: "top-right",
    transition: ne,
    autoClose: 5e3,
    closeButton: Zt,
    pauseOnHover: !0,
    pauseOnFocusLoss: !0,
    closeOnClick: !0,
    draggable: !0,
    draggablePercent: 80,
    draggableDirection: "x",
    role: "alert",
    theme: "light"
};
let se, oe = new Map, ae = [], le = 1;
function ce() {
    return "" + le++
}
function ue(t) {
    return t && (zt(t.toastId) || Ut(t.toastId)) ? t.toastId : ce()
}
function he(t, e) {
    return oe.size > 0 ? Gt.emit(0, t, e) : ae.push({
        content: t,
        options: e
    }),
    e.toastId
}
function de(t, e) {
    return {
        ...e,
        type: e && e.type || t,
        toastId: ue(e)
    }
}
function fe(t) {
    return (e,n)=>he(e, de(t, n))
}
function pe(t, e) {
    return he(t, de("default", e))
}
function me(t, e) {
    return function() {
        return t.apply(e, arguments)
    }
}
pe.loading = (t,e)=>he(t, de("default", {
    isLoading: !0,
    autoClose: !1,
    closeOnClick: !1,
    closeButton: !1,
    draggable: !1,
    ...e
})),
pe.promise = function(t, e, n) {
    let r, {pending: i, error: s, success: o} = e;
    i && (r = zt(i) ? pe.loading(i, n) : pe.loading(i.render, {
        ...n,
        ...i
    }));
    const a = {
        isLoading: null,
        autoClose: null,
        closeOnClick: null,
        closeButton: null,
        draggable: null,
        delay: 100
    }
      , l = (t,e,i)=>{
        if (null == e)
            return void pe.dismiss(r);
        const s = {
            type: t,
            ...a,
            ...n,
            data: i
        }
          , o = zt(e) ? {
            render: e
        } : e;
        return r ? pe.update(r, {
            ...s,
            ...o
        }) : pe(o.render, {
            ...s,
            ...o
        }),
        i
    }
      , c = Vt(t) ? t() : t;
    return c.then((t=>l("success", o, t))).catch((t=>l("error", s, t))),
    c
}
,
pe.success = fe("success"),
pe.info = fe("info"),
pe.error = fe("error"),
pe.warning = fe("warning"),
pe.warn = pe.warning,
pe.dark = (t,e)=>he(t, de("default", {
    theme: "dark",
    ...e
})),
pe.dismiss = t=>{
    oe.size > 0 ? Gt.emit(1, t) : ae = ae.filter((e=>null != t && e.options.toastId !== t))
}
,
pe.clearWaitingQueue = function(t) {
    return void 0 === t && (t = {}),
    Gt.emit(5, t)
}
,
pe.isActive = t=>{
    let e = !1;
    return oe.forEach((n=>{
        n.isToastActive && n.isToastActive(t) && (e = !0)
    }
    )),
    e
}
,
pe.update = function(t, e) {
    void 0 === e && (e = {}),
    setTimeout((()=>{
        const n = function(t, e) {
            let {containerId: n} = e;
            const r = oe.get(n || se);
            return r && r.getToast(t)
        }(t, e);
        if (n) {
            const {props: r, content: i} = n
              , s = {
                ...r,
                ...e,
                toastId: e.toastId || t,
                updateId: ce()
            };
            s.toastId !== t && (s.staleId = t);
            const o = s.render || i;
            delete s.render,
            he(o, s)
        }
    }
    ), 0)
}
,
pe.done = t=>{
    pe.update(t, {
        progress: 1
    })
}
,
pe.onChange = t=>(Gt.on(4, t),
()=>{
    Gt.off(4, t)
}
),
pe.POSITION = {
    TOP_LEFT: "top-left",
    TOP_RIGHT: "top-right",
    TOP_CENTER: "top-center",
    BOTTOM_LEFT: "bottom-left",
    BOTTOM_RIGHT: "bottom-right",
    BOTTOM_CENTER: "bottom-center"
},
pe.TYPE = {
    INFO: "info",
    SUCCESS: "success",
    WARNING: "warning",
    ERROR: "error",
    DEFAULT: "default"
},
Gt.on(2, (t=>{
    se = t.containerId || t,
    oe.set(se, t),
    ae.forEach((t=>{
        Gt.emit(0, t.content, t.options)
    }
    )),
    ae = []
}
)).on(3, (t=>{
    oe.delete(t.containerId || t),
    0 === oe.size && Gt.off(0).off(1).off(5)
}
));
const {toString: ge} = Object.prototype
  , {getPrototypeOf: ye} = Object
  , be = (ve = Object.create(null),
t=>{
    const e = ge.call(t);
    return ve[e] || (ve[e] = e.slice(8, -1).toLowerCase())
}
);
var ve;
const we = t=>(t = t.toLowerCase(),
e=>be(e) === t)
  , xe = t=>e=>typeof e === t
  , {isArray: Ee} = Array
  , _e = xe("undefined");
const Ae = we("ArrayBuffer");
const Se = xe("string")
  , Te = xe("function")
  , ke = xe("number")
  , Ie = t=>null !== t && "object" == typeof t
  , Me = t=>{
    if ("object" !== be(t))
        return !1;
    const e = ye(t);
    return !(null !== e && e !== Object.prototype && null !== Object.getPrototypeOf(e) || Symbol.toStringTag in t || Symbol.iterator in t)
}
  , Ce = we("Date")
  , Pe = we("File")
  , Oe = we("Blob")
  , Ne = we("FileList")
  , Re = we("URLSearchParams");
function De(t, e, {allOwnKeys: n=!1}={}) {
    if (null == t)
        return;
    let r, i;
    if ("object" != typeof t && (t = [t]),
    Ee(t))
        for (r = 0,
        i = t.length; r < i; r++)
            e.call(null, t[r], r, t);
    else {
        const i = n ? Object.getOwnPropertyNames(t) : Object.keys(t)
          , s = i.length;
        let o;
        for (r = 0; r < s; r++)
            o = i[r],
            e.call(null, t[o], o, t)
    }
}
function Be(t, e) {
    e = e.toLowerCase();
    const n = Object.keys(t);
    let r, i = n.length;
    for (; i-- > 0; )
        if (r = n[i],
        e === r.toLowerCase())
            return r;
    return null
}
const Le = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : n
  , Fe = t=>!_e(t) && t !== Le;
const je = (Ue = "undefined" != typeof Uint8Array && ye(Uint8Array),
t=>Ue && t instanceof Ue);
var Ue;
const ze = we("HTMLFormElement")
  , Ve = (({hasOwnProperty: t})=>(e,n)=>t.call(e, n))(Object.prototype)
  , We = we("RegExp")
  , Ye = (t,e)=>{
    const n = Object.getOwnPropertyDescriptors(t)
      , r = {};
    De(n, ((n,i)=>{
        !1 !== e(n, i, t) && (r[i] = n)
    }
    )),
    Object.defineProperties(t, r)
}
  , He = "abcdefghijklmnopqrstuvwxyz"
  , $e = "0123456789"
  , Ge = {
    DIGIT: $e,
    ALPHA: He,
    ALPHA_DIGIT: He + He.toUpperCase() + $e
};
var Xe = {
    isArray: Ee,
    isArrayBuffer: Ae,
    isBuffer: function(t) {
        return null !== t && !_e(t) && null !== t.constructor && !_e(t.constructor) && Te(t.constructor.isBuffer) && t.constructor.isBuffer(t)
    },
    isFormData: t=>{
        const e = "[object FormData]";
        return t && ("function" == typeof FormData && t instanceof FormData || ge.call(t) === e || Te(t.toString) && t.toString() === e)
    }
    ,
    isArrayBufferView: function(t) {
        let e;
        return e = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && Ae(t.buffer),
        e
    },
    isString: Se,
    isNumber: ke,
    isBoolean: t=>!0 === t || !1 === t,
    isObject: Ie,
    isPlainObject: Me,
    isUndefined: _e,
    isDate: Ce,
    isFile: Pe,
    isBlob: Oe,
    isRegExp: We,
    isFunction: Te,
    isStream: t=>Ie(t) && Te(t.pipe),
    isURLSearchParams: Re,
    isTypedArray: je,
    isFileList: Ne,
    forEach: De,
    merge: function t() {
        const {caseless: e} = Fe(this) && this || {}
          , n = {}
          , r = (r,i)=>{
            const s = e && Be(n, i) || i;
            Me(n[s]) && Me(r) ? n[s] = t(n[s], r) : Me(r) ? n[s] = t({}, r) : Ee(r) ? n[s] = r.slice() : n[s] = r
        }
        ;
        for (let t = 0, e = arguments.length; t < e; t++)
            arguments[t] && De(arguments[t], r);
        return n
    },
    extend: (t,e,n,{allOwnKeys: r}={})=>(De(e, ((e,r)=>{
        n && Te(e) ? t[r] = me(e, n) : t[r] = e
    }
    ), {
        allOwnKeys: r
    }),
    t),
    trim: t=>t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
    stripBOM: t=>(65279 === t.charCodeAt(0) && (t = t.slice(1)),
    t),
    inherits: (t,e,n,r)=>{
        t.prototype = Object.create(e.prototype, r),
        t.prototype.constructor = t,
        Object.defineProperty(t, "super", {
            value: e.prototype
        }),
        n && Object.assign(t.prototype, n)
    }
    ,
    toFlatObject: (t,e,n,r)=>{
        let i, s, o;
        const a = {};
        if (e = e || {},
        null == t)
            return e;
        do {
            for (i = Object.getOwnPropertyNames(t),
            s = i.length; s-- > 0; )
                o = i[s],
                r && !r(o, t, e) || a[o] || (e[o] = t[o],
                a[o] = !0);
            t = !1 !== n && ye(t)
        } while (t && (!n || n(t, e)) && t !== Object.prototype);
        return e
    }
    ,
    kindOf: be,
    kindOfTest: we,
    endsWith: (t,e,n)=>{
        t = String(t),
        (void 0 === n || n > t.length) && (n = t.length),
        n -= e.length;
        const r = t.indexOf(e, n);
        return -1 !== r && r === n
    }
    ,
    toArray: t=>{
        if (!t)
            return null;
        if (Ee(t))
            return t;
        let e = t.length;
        if (!ke(e))
            return null;
        const n = new Array(e);
        for (; e-- > 0; )
            n[e] = t[e];
        return n
    }
    ,
    forEachEntry: (t,e)=>{
        const n = (t && t[Symbol.iterator]).call(t);
        let r;
        for (; (r = n.next()) && !r.done; ) {
            const n = r.value;
            e.call(t, n[0], n[1])
        }
    }
    ,
    matchAll: (t,e)=>{
        let n;
        const r = [];
        for (; null !== (n = t.exec(e)); )
            r.push(n);
        return r
    }
    ,
    isHTMLForm: ze,
    hasOwnProperty: Ve,
    hasOwnProp: Ve,
    reduceDescriptors: Ye,
    freezeMethods: t=>{
        Ye(t, ((e,n)=>{
            if (Te(t) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
                return !1;
            const r = t[n];
            Te(r) && (e.enumerable = !1,
            "writable"in e ? e.writable = !1 : e.set || (e.set = ()=>{
                throw Error("Can not rewrite read-only method '" + n + "'")
            }
            ))
        }
        ))
    }
    ,
    toObjectSet: (t,e)=>{
        const n = {}
          , r = t=>{
            t.forEach((t=>{
                n[t] = !0
            }
            ))
        }
        ;
        return Ee(t) ? r(t) : r(String(t).split(e)),
        n
    }
    ,
    toCamelCase: t=>t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(t, e, n) {
        return e.toUpperCase() + n
    }
    )),
    noop: ()=>{}
    ,
    toFiniteNumber: (t,e)=>(t = +t,
    Number.isFinite(t) ? t : e),
    findKey: Be,
    global: Le,
    isContextDefined: Fe,
    ALPHABET: Ge,
    generateString: (t=16,e=Ge.ALPHA_DIGIT)=>{
        let n = "";
        const {length: r} = e;
        for (; t--; )
            n += e[Math.random() * r | 0];
        return n
    }
    ,
    isSpecCompliantForm: function(t) {
        return !!(t && Te(t.append) && "FormData" === t[Symbol.toStringTag] && t[Symbol.iterator])
    },
    toJSONObject: t=>{
        const e = new Array(10)
          , n = (t,r)=>{
            if (Ie(t)) {
                if (e.indexOf(t) >= 0)
                    return;
                if (!("toJSON"in t)) {
                    e[r] = t;
                    const i = Ee(t) ? [] : {};
                    return De(t, ((t,e)=>{
                        const s = n(t, r + 1);
                        !_e(s) && (i[e] = s)
                    }
                    )),
                    e[r] = void 0,
                    i
                }
            }
            return t
        }
        ;
        return n(t, 0)
    }
};
function qe(t, e, n, r, i) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
    this.message = t,
    this.name = "AxiosError",
    e && (this.code = e),
    n && (this.config = n),
    r && (this.request = r),
    i && (this.response = i)
}
Xe.inherits(qe, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: Xe.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        }
    }
});
const Ke = qe.prototype
  , Qe = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((t=>{
    Qe[t] = {
        value: t
    }
}
)),
Object.defineProperties(qe, Qe),
Object.defineProperty(Ke, "isAxiosError", {
    value: !0
}),
qe.from = (t,e,n,r,i,s)=>{
    const o = Object.create(Ke);
    return Xe.toFlatObject(t, o, (function(t) {
        return t !== Error.prototype
    }
    ), (t=>"isAxiosError" !== t)),
    qe.call(o, t.message, e, n, r, i),
    o.cause = t,
    o.name = t.name,
    s && Object.assign(o, s),
    o
}
;
var Ze = qe
  , Je = null
  , tn = o("6ZWSX").Buffer;
function en(t) {
    return Xe.isPlainObject(t) || Xe.isArray(t)
}
function nn(t) {
    return Xe.endsWith(t, "[]") ? t.slice(0, -2) : t
}
function rn(t, e, n) {
    return t ? t.concat(e).map((function(t, e) {
        return t = nn(t),
        !n && e ? "[" + t + "]" : t
    }
    )).join(n ? "." : "") : e
}
const sn = Xe.toFlatObject(Xe, {}, null, (function(t) {
    return /^is[A-Z]/.test(t)
}
));
var on = function(t, e, n) {
    if (!Xe.isObject(t))
        throw new TypeError("target must be an object");
    e = e || new (Je || FormData);
    const r = (n = Xe.toFlatObject(n, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, (function(t, e) {
        return !Xe.isUndefined(e[t])
    }
    ))).metaTokens
      , i = n.visitor || c
      , s = n.dots
      , o = n.indexes
      , a = (n.Blob || "undefined" != typeof Blob && Blob) && Xe.isSpecCompliantForm(e);
    if (!Xe.isFunction(i))
        throw new TypeError("visitor must be a function");
    function l(t) {
        if (null === t)
            return "";
        if (Xe.isDate(t))
            return t.toISOString();
        if (!a && Xe.isBlob(t))
            throw new Ze("Blob is not supported. Use a Buffer instead.");
        return Xe.isArrayBuffer(t) || Xe.isTypedArray(t) ? a && "function" == typeof Blob ? new Blob([t]) : tn.from(t) : t
    }
    function c(t, n, i) {
        let a = t;
        if (t && !i && "object" == typeof t)
            if (Xe.endsWith(n, "{}"))
                n = r ? n : n.slice(0, -2),
                t = JSON.stringify(t);
            else if (Xe.isArray(t) && function(t) {
                return Xe.isArray(t) && !t.some(en)
            }(t) || (Xe.isFileList(t) || Xe.endsWith(n, "[]")) && (a = Xe.toArray(t)))
                return n = nn(n),
                a.forEach((function(t, r) {
                    !Xe.isUndefined(t) && null !== t && e.append(!0 === o ? rn([n], r, s) : null === o ? n : n + "[]", l(t))
                }
                )),
                !1;
        return !!en(t) || (e.append(rn(i, n, s), l(t)),
        !1)
    }
    const u = []
      , h = Object.assign(sn, {
        defaultVisitor: c,
        convertValue: l,
        isVisitable: en
    });
    if (!Xe.isObject(t))
        throw new TypeError("data must be an object");
    return function t(n, r) {
        if (!Xe.isUndefined(n)) {
            if (-1 !== u.indexOf(n))
                throw Error("Circular reference detected in " + r.join("."));
            u.push(n),
            Xe.forEach(n, (function(n, s) {
                !0 === (!(Xe.isUndefined(n) || null === n) && i.call(e, n, Xe.isString(s) ? s.trim() : s, r, h)) && t(n, r ? r.concat(s) : [s])
            }
            )),
            u.pop()
        }
    }(t),
    e
};
function an(t) {
    const e = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, (function(t) {
        return e[t]
    }
    ))
}
function ln(t, e) {
    this._pairs = [],
    t && on(t, this, e)
}
const cn = ln.prototype;
cn.append = function(t, e) {
    this._pairs.push([t, e])
}
,
cn.toString = function(t) {
    const e = t ? function(e) {
        return t.call(this, e, an)
    }
    : an;
    return this._pairs.map((function(t) {
        return e(t[0]) + "=" + e(t[1])
    }
    ), "").join("&")
}
;
var un = ln;
function hn(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function dn(t, e, n) {
    if (!e)
        return t;
    const r = n && n.encode || hn
      , i = n && n.serialize;
    let s;
    if (s = i ? i(e, n) : Xe.isURLSearchParams(e) ? e.toString() : new un(e,n).toString(r),
    s) {
        const e = t.indexOf("#");
        -1 !== e && (t = t.slice(0, e)),
        t += (-1 === t.indexOf("?") ? "?" : "&") + s
    }
    return t
}
var fn = class {
    constructor() {
        this.handlers = []
    }
    use(t, e, n) {
        return this.handlers.push({
            fulfilled: t,
            rejected: e,
            synchronous: !!n && n.synchronous,
            runWhen: n ? n.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(t) {
        this.handlers[t] && (this.handlers[t] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(t) {
        Xe.forEach(this.handlers, (function(e) {
            null !== e && t(e)
        }
        ))
    }
}
  , pn = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
};
var mn = {
    isBrowser: !0,
    classes: {
        URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : un,
        FormData: "undefined" != typeof FormData ? FormData : null,
        Blob: "undefined" != typeof Blob ? Blob : null
    },
    isStandardBrowserEnv: (()=>{
        let t;
        return ("undefined" == typeof navigator || "ReactNative" !== (t = navigator.product) && "NativeScript" !== t && "NS" !== t) && ("undefined" != typeof window && "undefined" != typeof document)
    }
    )(),
    isStandardBrowserWebWorkerEnv: "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
    protocols: ["http", "https", "file", "blob", "url", "data"]
};
function gn(t, e) {
    return on(t, new mn.classes.URLSearchParams, Object.assign({
        visitor: function(t, e, n, r) {
            return mn.isNode && Xe.isBuffer(t) ? (this.append(e, t.toString("base64")),
            !1) : r.defaultVisitor.apply(this, arguments)
        }
    }, e))
}
var yn = function(t) {
    function e(t, n, r, i) {
        let s = t[i++];
        const o = Number.isFinite(+s)
          , a = i >= t.length;
        if (s = !s && Xe.isArray(r) ? r.length : s,
        a)
            return Xe.hasOwnProp(r, s) ? r[s] = [r[s], n] : r[s] = n,
            !o;
        r[s] && Xe.isObject(r[s]) || (r[s] = []);
        return e(t, n, r[s], i) && Xe.isArray(r[s]) && (r[s] = function(t) {
            const e = {}
              , n = Object.keys(t);
            let r;
            const i = n.length;
            let s;
            for (r = 0; r < i; r++)
                s = n[r],
                e[s] = t[s];
            return e
        }(r[s])),
        !o
    }
    if (Xe.isFormData(t) && Xe.isFunction(t.entries)) {
        const n = {};
        return Xe.forEachEntry(t, ((t,r)=>{
            e(function(t) {
                return Xe.matchAll(/\w+|\[(\w*)]/g, t).map((t=>"[]" === t[0] ? "" : t[1] || t[0]))
            }(t), r, n, 0)
        }
        )),
        n
    }
    return null
};
const bn = {
    "Content-Type": void 0
};
const vn = {
    transitional: pn,
    adapter: ["xhr", "http"],
    transformRequest: [function(t, e) {
        const n = e.getContentType() || ""
          , r = n.indexOf("application/json") > -1
          , i = Xe.isObject(t);
        i && Xe.isHTMLForm(t) && (t = new FormData(t));
        if (Xe.isFormData(t))
            return r && r ? JSON.stringify(yn(t)) : t;
        if (Xe.isArrayBuffer(t) || Xe.isBuffer(t) || Xe.isStream(t) || Xe.isFile(t) || Xe.isBlob(t))
            return t;
        if (Xe.isArrayBufferView(t))
            return t.buffer;
        if (Xe.isURLSearchParams(t))
            return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            t.toString();
        let s;
        if (i) {
            if (n.indexOf("application/x-www-form-urlencoded") > -1)
                return gn(t, this.formSerializer).toString();
            if ((s = Xe.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
                const e = this.env && this.env.FormData;
                return on(s ? {
                    "files[]": t
                } : t, e && new e, this.formSerializer)
            }
        }
        return i || r ? (e.setContentType("application/json", !1),
        function(t, e, n) {
            if (Xe.isString(t))
                try {
                    return (e || JSON.parse)(t),
                    Xe.trim(t)
                } catch (t) {
                    if ("SyntaxError" !== t.name)
                        throw t
                }
            return (n || JSON.stringify)(t)
        }(t)) : t
    }
    ],
    transformResponse: [function(t) {
        const e = this.transitional || vn.transitional
          , n = e && e.forcedJSONParsing
          , r = "json" === this.responseType;
        if (t && Xe.isString(t) && (n && !this.responseType || r)) {
            const n = !(e && e.silentJSONParsing) && r;
            try {
                return JSON.parse(t)
            } catch (t) {
                if (n) {
                    if ("SyntaxError" === t.name)
                        throw Ze.from(t, Ze.ERR_BAD_RESPONSE, this, null, this.response);
                    throw t
                }
            }
        }
        return t
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: mn.classes.FormData,
        Blob: mn.classes.Blob
    },
    validateStatus: function(t) {
        return t >= 200 && t < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*"
        }
    }
};
Xe.forEach(["delete", "get", "head"], (function(t) {
    vn.headers[t] = {}
}
)),
Xe.forEach(["post", "put", "patch"], (function(t) {
    vn.headers[t] = Xe.merge(bn)
}
));
var wn = vn;
const xn = Xe.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
var En = t=>{
    const e = {};
    let n, r, i;
    return t && t.split("\n").forEach((function(t) {
        i = t.indexOf(":"),
        n = t.substring(0, i).trim().toLowerCase(),
        r = t.substring(i + 1).trim(),
        !n || e[n] && xn[n] || ("set-cookie" === n ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r)
    }
    )),
    e
}
;
const _n = Symbol("internals");
function An(t) {
    return t && String(t).trim().toLowerCase()
}
function Sn(t) {
    return !1 === t || null == t ? t : Xe.isArray(t) ? t.map(Sn) : String(t)
}
function Tn(t, e, n, r, i) {
    return Xe.isFunction(r) ? r.call(this, e, n) : (i && (e = n),
    Xe.isString(e) ? Xe.isString(r) ? -1 !== e.indexOf(r) : Xe.isRegExp(r) ? r.test(e) : void 0 : void 0)
}
class kn {
    constructor(t) {
        t && this.set(t)
    }
    set(t, e, n) {
        const r = this;
        function i(t, e, n) {
            const i = An(e);
            if (!i)
                throw new Error("header name must be a non-empty string");
            const s = Xe.findKey(r, i);
            (!s || void 0 === r[s] || !0 === n || void 0 === n && !1 !== r[s]) && (r[s || e] = Sn(t))
        }
        const s = (t,e)=>Xe.forEach(t, ((t,n)=>i(t, n, e)));
        return Xe.isPlainObject(t) || t instanceof this.constructor ? s(t, e) : Xe.isString(t) && (t = t.trim()) && !/^[-_a-zA-Z]+$/.test(t.trim()) ? s(En(t), e) : null != t && i(e, t, n),
        this
    }
    get(t, e) {
        if (t = An(t)) {
            const n = Xe.findKey(this, t);
            if (n) {
                const t = this[n];
                if (!e)
                    return t;
                if (!0 === e)
                    return function(t) {
                        const e = Object.create(null)
                          , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                        let r;
                        for (; r = n.exec(t); )
                            e[r[1]] = r[2];
                        return e
                    }(t);
                if (Xe.isFunction(e))
                    return e.call(this, t, n);
                if (Xe.isRegExp(e))
                    return e.exec(t);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(t, e) {
        if (t = An(t)) {
            const n = Xe.findKey(this, t);
            return !(!n || void 0 === this[n] || e && !Tn(0, this[n], n, e))
        }
        return !1
    }
    delete(t, e) {
        const n = this;
        let r = !1;
        function i(t) {
            if (t = An(t)) {
                const i = Xe.findKey(n, t);
                !i || e && !Tn(0, n[i], i, e) || (delete n[i],
                r = !0)
            }
        }
        return Xe.isArray(t) ? t.forEach(i) : i(t),
        r
    }
    clear(t) {
        const e = Object.keys(this);
        let n = e.length
          , r = !1;
        for (; n--; ) {
            const i = e[n];
            t && !Tn(0, this[i], i, t, !0) || (delete this[i],
            r = !0)
        }
        return r
    }
    normalize(t) {
        const e = this
          , n = {};
        return Xe.forEach(this, ((r,i)=>{
            const s = Xe.findKey(n, i);
            if (s)
                return e[s] = Sn(r),
                void delete e[i];
            const o = t ? function(t) {
                return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((t,e,n)=>e.toUpperCase() + n))
            }(i) : String(i).trim();
            o !== i && delete e[i],
            e[o] = Sn(r),
            n[o] = !0
        }
        )),
        this
    }
    concat(...t) {
        return this.constructor.concat(this, ...t)
    }
    toJSON(t) {
        const e = Object.create(null);
        return Xe.forEach(this, ((n,r)=>{
            null != n && !1 !== n && (e[r] = t && Xe.isArray(n) ? n.join(", ") : n)
        }
        )),
        e
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map((([t,e])=>t + ": " + e)).join("\n")
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(t) {
        return t instanceof this ? t : new this(t)
    }
    static concat(t, ...e) {
        const n = new this(t);
        return e.forEach((t=>n.set(t))),
        n
    }
    static accessor(t) {
        const e = (this[_n] = this[_n] = {
            accessors: {}
        }).accessors
          , n = this.prototype;
        function r(t) {
            const r = An(t);
            e[r] || (!function(t, e) {
                const n = Xe.toCamelCase(" " + e);
                ["get", "set", "has"].forEach((r=>{
                    Object.defineProperty(t, r + n, {
                        value: function(t, n, i) {
                            return this[r].call(this, e, t, n, i)
                        },
                        configurable: !0
                    })
                }
                ))
            }(n, t),
            e[r] = !0)
        }
        return Xe.isArray(t) ? t.forEach(r) : r(t),
        this
    }
}
kn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
Xe.freezeMethods(kn.prototype),
Xe.freezeMethods(kn);
var In = kn;
function Mn(t, e) {
    const n = this || wn
      , r = e || n
      , i = In.from(r.headers);
    let s = r.data;
    return Xe.forEach(t, (function(t) {
        s = t.call(n, s, i.normalize(), e ? e.status : void 0)
    }
    )),
    i.normalize(),
    s
}
function Cn(t) {
    return !(!t || !t.__CANCEL__)
}
function Pn(t, e, n) {
    Ze.call(this, null == t ? "canceled" : t, Ze.ERR_CANCELED, e, n),
    this.name = "CanceledError"
}
Xe.inherits(Pn, Ze, {
    __CANCEL__: !0
});
var On = Pn;
function Nn(t, e, n) {
    const r = n.config.validateStatus;
    n.status && r && !r(n.status) ? e(new Ze("Request failed with status code " + n.status,[Ze.ERR_BAD_REQUEST, Ze.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n)) : t(n)
}
var Rn = mn.isStandardBrowserEnv ? {
    write: function(t, e, n, r, i, s) {
        const o = [];
        o.push(t + "=" + encodeURIComponent(e)),
        Xe.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()),
        Xe.isString(r) && o.push("path=" + r),
        Xe.isString(i) && o.push("domain=" + i),
        !0 === s && o.push("secure"),
        document.cookie = o.join("; ")
    },
    read: function(t) {
        const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
        return e ? decodeURIComponent(e[3]) : null
    },
    remove: function(t) {
        this.write(t, "", Date.now() - 864e5)
    }
} : {
    write: function() {},
    read: function() {
        return null
    },
    remove: function() {}
};
function Dn(t, e) {
    return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t
}
function Bn(t, e) {
    return t && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) ? Dn(t, e) : e
}
var Ln = mn.isStandardBrowserEnv ? function() {
    const t = /(msie|trident)/i.test(navigator.userAgent)
      , e = document.createElement("a");
    let n;
    function r(n) {
        let r = n;
        return t && (e.setAttribute("href", r),
        r = e.href),
        e.setAttribute("href", r),
        {
            href: e.href,
            protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
            host: e.host,
            search: e.search ? e.search.replace(/^\?/, "") : "",
            hash: e.hash ? e.hash.replace(/^#/, "") : "",
            hostname: e.hostname,
            port: e.port,
            pathname: "/" === e.pathname.charAt(0) ? e.pathname : "/" + e.pathname
        }
    }
    return n = r(window.location.href),
    function(t) {
        const e = Xe.isString(t) ? r(t) : t;
        return e.protocol === n.protocol && e.host === n.host
    }
}() : function() {
    return !0
}
;
function Fn(t) {
    const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
    return e && e[1] || ""
}
var jn = function(t, e) {
    t = t || 10;
    const n = new Array(t)
      , r = new Array(t);
    let i, s = 0, o = 0;
    return e = void 0 !== e ? e : 1e3,
    function(a) {
        const l = Date.now()
          , c = r[o];
        i || (i = l),
        n[s] = a,
        r[s] = l;
        let u = o
          , h = 0;
        for (; u !== s; )
            h += n[u++],
            u %= t;
        if (s = (s + 1) % t,
        s === o && (o = (o + 1) % t),
        l - i < e)
            return;
        const d = c && l - c;
        return d ? Math.round(1e3 * h / d) : void 0
    }
};
function Un(t, e) {
    let n = 0;
    const r = jn(50, 250);
    return i=>{
        const s = i.loaded
          , o = i.lengthComputable ? i.total : void 0
          , a = s - n
          , l = r(a);
        n = s;
        const c = {
            loaded: s,
            total: o,
            progress: o ? s / o : void 0,
            bytes: a,
            rate: l || void 0,
            estimated: l && o && s <= o ? (o - s) / l : void 0,
            event: i
        };
        c[e ? "download" : "upload"] = !0,
        t(c)
    }
}
const zn = "undefined" != typeof XMLHttpRequest;
const Vn = {
    http: Je,
    xhr: zn && function(t) {
        return new Promise((function(e, n) {
            let r = t.data;
            const i = In.from(t.headers).normalize()
              , s = t.responseType;
            let o;
            function a() {
                t.cancelToken && t.cancelToken.unsubscribe(o),
                t.signal && t.signal.removeEventListener("abort", o)
            }
            Xe.isFormData(r) && (mn.isStandardBrowserEnv || mn.isStandardBrowserWebWorkerEnv) && i.setContentType(!1);
            let l = new XMLHttpRequest;
            if (t.auth) {
                const e = t.auth.username || ""
                  , n = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : "";
                i.set("Authorization", "Basic " + btoa(e + ":" + n))
            }
            const c = Bn(t.baseURL, t.url);
            function u() {
                if (!l)
                    return;
                const r = In.from("getAllResponseHeaders"in l && l.getAllResponseHeaders());
                Nn((function(t) {
                    e(t),
                    a()
                }
                ), (function(t) {
                    n(t),
                    a()
                }
                ), {
                    data: s && "text" !== s && "json" !== s ? l.response : l.responseText,
                    status: l.status,
                    statusText: l.statusText,
                    headers: r,
                    config: t,
                    request: l
                }),
                l = null
            }
            if (l.open(t.method.toUpperCase(), dn(c, t.params, t.paramsSerializer), !0),
            l.timeout = t.timeout,
            "onloadend"in l ? l.onloadend = u : l.onreadystatechange = function() {
                l && 4 === l.readyState && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf("file:")) && setTimeout(u)
            }
            ,
            l.onabort = function() {
                l && (n(new Ze("Request aborted",Ze.ECONNABORTED,t,l)),
                l = null)
            }
            ,
            l.onerror = function() {
                n(new Ze("Network Error",Ze.ERR_NETWORK,t,l)),
                l = null
            }
            ,
            l.ontimeout = function() {
                let e = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
                const r = t.transitional || pn;
                t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                n(new Ze(e,r.clarifyTimeoutError ? Ze.ETIMEDOUT : Ze.ECONNABORTED,t,l)),
                l = null
            }
            ,
            mn.isStandardBrowserEnv) {
                const e = (t.withCredentials || Ln(c)) && t.xsrfCookieName && Rn.read(t.xsrfCookieName);
                e && i.set(t.xsrfHeaderName, e)
            }
            void 0 === r && i.setContentType(null),
            "setRequestHeader"in l && Xe.forEach(i.toJSON(), (function(t, e) {
                l.setRequestHeader(e, t)
            }
            )),
            Xe.isUndefined(t.withCredentials) || (l.withCredentials = !!t.withCredentials),
            s && "json" !== s && (l.responseType = t.responseType),
            "function" == typeof t.onDownloadProgress && l.addEventListener("progress", Un(t.onDownloadProgress, !0)),
            "function" == typeof t.onUploadProgress && l.upload && l.upload.addEventListener("progress", Un(t.onUploadProgress)),
            (t.cancelToken || t.signal) && (o = e=>{
                l && (n(!e || e.type ? new On(null,t,l) : e),
                l.abort(),
                l = null)
            }
            ,
            t.cancelToken && t.cancelToken.subscribe(o),
            t.signal && (t.signal.aborted ? o() : t.signal.addEventListener("abort", o)));
            const h = Fn(c);
            h && -1 === mn.protocols.indexOf(h) ? n(new Ze("Unsupported protocol " + h + ":",Ze.ERR_BAD_REQUEST,t)) : l.send(r || null)
        }
        ))
    }
};
Xe.forEach(Vn, ((t,e)=>{
    if (t) {
        try {
            Object.defineProperty(t, "name", {
                value: e
            })
        } catch (t) {}
        Object.defineProperty(t, "adapterName", {
            value: e
        })
    }
}
));
var Wn = {
    getAdapter: t=>{
        t = Xe.isArray(t) ? t : [t];
        const {length: e} = t;
        let n, r;
        for (let i = 0; i < e && (n = t[i],
        !(r = Xe.isString(n) ? Vn[n.toLowerCase()] : n)); i++)
            ;
        if (!r) {
            if (!1 === r)
                throw new Ze(`Adapter ${n} is not supported by the environment`,"ERR_NOT_SUPPORT");
            throw new Error(Xe.hasOwnProp(Vn, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`)
        }
        if (!Xe.isFunction(r))
            throw new TypeError("adapter is not a function");
        return r
    }
    ,
    adapters: Vn
};
function Yn(t) {
    if (t.cancelToken && t.cancelToken.throwIfRequested(),
    t.signal && t.signal.aborted)
        throw new On(null,t)
}
function Hn(t) {
    Yn(t),
    t.headers = In.from(t.headers),
    t.data = Mn.call(t, t.transformRequest),
    -1 !== ["post", "put", "patch"].indexOf(t.method) && t.headers.setContentType("application/x-www-form-urlencoded", !1);
    return Wn.getAdapter(t.adapter || wn.adapter)(t).then((function(e) {
        return Yn(t),
        e.data = Mn.call(t, t.transformResponse, e),
        e.headers = In.from(e.headers),
        e
    }
    ), (function(e) {
        return Cn(e) || (Yn(t),
        e && e.response && (e.response.data = Mn.call(t, t.transformResponse, e.response),
        e.response.headers = In.from(e.response.headers))),
        Promise.reject(e)
    }
    ))
}
const $n = t=>t instanceof In ? t.toJSON() : t;
function Gn(t, e) {
    e = e || {};
    const n = {};
    function r(t, e, n) {
        return Xe.isPlainObject(t) && Xe.isPlainObject(e) ? Xe.merge.call({
            caseless: n
        }, t, e) : Xe.isPlainObject(e) ? Xe.merge({}, e) : Xe.isArray(e) ? e.slice() : e
    }
    function i(t, e, n) {
        return Xe.isUndefined(e) ? Xe.isUndefined(t) ? void 0 : r(void 0, t, n) : r(t, e, n)
    }
    function s(t, e) {
        if (!Xe.isUndefined(e))
            return r(void 0, e)
    }
    function o(t, e) {
        return Xe.isUndefined(e) ? Xe.isUndefined(t) ? void 0 : r(void 0, t) : r(void 0, e)
    }
    function a(n, i, s) {
        return s in e ? r(n, i) : s in t ? r(void 0, n) : void 0
    }
    const l = {
        url: s,
        method: s,
        data: s,
        baseURL: o,
        transformRequest: o,
        transformResponse: o,
        paramsSerializer: o,
        timeout: o,
        timeoutMessage: o,
        withCredentials: o,
        adapter: o,
        responseType: o,
        xsrfCookieName: o,
        xsrfHeaderName: o,
        onUploadProgress: o,
        onDownloadProgress: o,
        decompress: o,
        maxContentLength: o,
        maxBodyLength: o,
        beforeRedirect: o,
        transport: o,
        httpAgent: o,
        httpsAgent: o,
        cancelToken: o,
        socketPath: o,
        responseEncoding: o,
        validateStatus: a,
        headers: (t,e)=>i($n(t), $n(e), !0)
    };
    return Xe.forEach(Object.keys(t).concat(Object.keys(e)), (function(r) {
        const s = l[r] || i
          , o = s(t[r], e[r], r);
        Xe.isUndefined(o) && s !== a || (n[r] = o)
    }
    )),
    n
}
const Xn = "1.3.4"
  , qn = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(((t,e)=>{
    qn[t] = function(n) {
        return typeof n === t || "a" + (e < 1 ? "n " : " ") + t
    }
}
));
const Kn = {};
qn.transitional = function(t, e, n) {
    function r(t, e) {
        return "[Axios v1.3.4] Transitional option '" + t + "'" + e + (n ? ". " + n : "")
    }
    return (n,i,s)=>{
        if (!1 === t)
            throw new Ze(r(i, " has been removed" + (e ? " in " + e : "")),Ze.ERR_DEPRECATED);
        return e && !Kn[i] && (Kn[i] = !0,
        console.warn(r(i, " has been deprecated since v" + e + " and will be removed in the near future"))),
        !t || t(n, i, s)
    }
}
;
var Qn = {
    assertOptions: function(t, e, n) {
        if ("object" != typeof t)
            throw new Ze("options must be an object",Ze.ERR_BAD_OPTION_VALUE);
        const r = Object.keys(t);
        let i = r.length;
        for (; i-- > 0; ) {
            const s = r[i]
              , o = e[s];
            if (o) {
                const e = t[s]
                  , n = void 0 === e || o(e, s, t);
                if (!0 !== n)
                    throw new Ze("option " + s + " must be " + n,Ze.ERR_BAD_OPTION_VALUE)
            } else if (!0 !== n)
                throw new Ze("Unknown option " + s,Ze.ERR_BAD_OPTION)
        }
    },
    validators: qn
};
const Zn = Qn.validators;
class Jn {
    constructor(t) {
        this.defaults = t,
        this.interceptors = {
            request: new fn,
            response: new fn
        }
    }
    request(t, e) {
        "string" == typeof t ? (e = e || {}).url = t : e = t || {},
        e = Gn(this.defaults, e);
        const {transitional: n, paramsSerializer: r, headers: i} = e;
        let s;
        void 0 !== n && Qn.assertOptions(n, {
            silentJSONParsing: Zn.transitional(Zn.boolean),
            forcedJSONParsing: Zn.transitional(Zn.boolean),
            clarifyTimeoutError: Zn.transitional(Zn.boolean)
        }, !1),
        void 0 !== r && Qn.assertOptions(r, {
            encode: Zn.function,
            serialize: Zn.function
        }, !0),
        e.method = (e.method || this.defaults.method || "get").toLowerCase(),
        s = i && Xe.merge(i.common, i[e.method]),
        s && Xe.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (t=>{
            delete i[t]
        }
        )),
        e.headers = In.concat(s, i);
        const o = [];
        let a = !0;
        this.interceptors.request.forEach((function(t) {
            "function" == typeof t.runWhen && !1 === t.runWhen(e) || (a = a && t.synchronous,
            o.unshift(t.fulfilled, t.rejected))
        }
        ));
        const l = [];
        let c;
        this.interceptors.response.forEach((function(t) {
            l.push(t.fulfilled, t.rejected)
        }
        ));
        let u, h = 0;
        if (!a) {
            const t = [Hn.bind(this), void 0];
            for (t.unshift.apply(t, o),
            t.push.apply(t, l),
            u = t.length,
            c = Promise.resolve(e); h < u; )
                c = c.then(t[h++], t[h++]);
            return c
        }
        u = o.length;
        let d = e;
        for (h = 0; h < u; ) {
            const t = o[h++]
              , e = o[h++];
            try {
                d = t(d)
            } catch (t) {
                e.call(this, t);
                break
            }
        }
        try {
            c = Hn.call(this, d)
        } catch (t) {
            return Promise.reject(t)
        }
        for (h = 0,
        u = l.length; h < u; )
            c = c.then(l[h++], l[h++]);
        return c
    }
    getUri(t) {
        return dn(Bn((t = Gn(this.defaults, t)).baseURL, t.url), t.params, t.paramsSerializer)
    }
}
Xe.forEach(["delete", "get", "head", "options"], (function(t) {
    Jn.prototype[t] = function(e, n) {
        return this.request(Gn(n || {}, {
            method: t,
            url: e,
            data: (n || {}).data
        }))
    }
}
)),
Xe.forEach(["post", "put", "patch"], (function(t) {
    function e(e) {
        return function(n, r, i) {
            return this.request(Gn(i || {}, {
                method: t,
                headers: e ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: n,
                data: r
            }))
        }
    }
    Jn.prototype[t] = e(),
    Jn.prototype[t + "Form"] = e(!0)
}
));
var tr = Jn;
class er {
    constructor(t) {
        if ("function" != typeof t)
            throw new TypeError("executor must be a function.");
        let e;
        this.promise = new Promise((function(t) {
            e = t
        }
        ));
        const n = this;
        this.promise.then((t=>{
            if (!n._listeners)
                return;
            let e = n._listeners.length;
            for (; e-- > 0; )
                n._listeners[e](t);
            n._listeners = null
        }
        )),
        this.promise.then = t=>{
            let e;
            const r = new Promise((t=>{
                n.subscribe(t),
                e = t
            }
            )).then(t);
            return r.cancel = function() {
                n.unsubscribe(e)
            }
            ,
            r
        }
        ,
        t((function(t, r, i) {
            n.reason || (n.reason = new On(t,r,i),
            e(n.reason))
        }
        ))
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(t) {
        this.reason ? t(this.reason) : this._listeners ? this._listeners.push(t) : this._listeners = [t]
    }
    unsubscribe(t) {
        if (!this._listeners)
            return;
        const e = this._listeners.indexOf(t);
        -1 !== e && this._listeners.splice(e, 1)
    }
    static source() {
        let t;
        return {
            token: new er((function(e) {
                t = e
            }
            )),
            cancel: t
        }
    }
}
var nr = er;
const rr = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(rr).forEach((([t,e])=>{
    rr[e] = t
}
));
var ir = rr;
const sr = function t(e) {
    const n = new tr(e)
      , r = me(tr.prototype.request, n);
    return Xe.extend(r, tr.prototype, n, {
        allOwnKeys: !0
    }),
    Xe.extend(r, n, null, {
        allOwnKeys: !0
    }),
    r.create = function(n) {
        return t(Gn(e, n))
    }
    ,
    r
}(wn);
sr.Axios = tr,
sr.CanceledError = On,
sr.CancelToken = nr,
sr.isCancel = Cn,
sr.VERSION = Xn,
sr.toFormData = on,
sr.AxiosError = Ze,
sr.Cancel = sr.CanceledError,
sr.all = function(t) {
    return Promise.all(t)
}
,
sr.spread = function(t) {
    return function(e) {
        return t.apply(null, e)
    }
}
,
sr.isAxiosError = function(t) {
    return Xe.isObject(t) && !0 === t.isAxiosError
}
,
sr.mergeConfig = Gn,
sr.AxiosHeaders = In,
sr.formToJSON = t=>yn(Xe.isHTMLForm(t) ? new FormData(t) : t),
sr.HttpStatusCode = ir,
sr.default = sr;
var or = sr;
const {Axios: ar, AxiosError: lr, CanceledError: cr, isCancel: ur, CancelToken: hr, VERSION: dr, all: fr, Cancel: pr, isAxiosError: mr, spread: gr, toFormData: yr, AxiosHeaders: br, HttpStatusCode: vr, formToJSON: wr, mergeConfig: xr} = or;
var Er = o("gNDby");
new (0,
Er.PublicKey)("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
const _r = async()=>{
    const t = await or.get("https://cdn.piratesquadnft.com/clients/meegos/maintenance/status.json");
    if (200 === t.status)
        return t.data
}
  , Ar = window.phantom?.solana?.isPhantom
  , Sr = /(undefined|false)/g
  , Tr = (t,e)=>e.replaceAll(Sr, "").trim().split(/\s+/).reduce(((e,n)=>`${e ? `${e} ` : ""}${t[n] ?? n}`), "")
  , kr = ()=>{
    const t = localStorage.getItem("sessionInfo") ?? void 0;
    if (!t)
        return;
    const e = JSON.parse(t);
    return {
        ...e,
        discordServerJoined: Boolean(e.discordServerJoined)
    }
}
  , Ir = t=>localStorage.setItem("sessionInfo", JSON.stringify(t))
  , Mr = (t,e)=>{
    const n = kr();
    n && e && (n[t] = e,
    Ir(n))
}
  , Cr = t=>{
    const e = kr();
    e && e[t] && (delete e[t],
    Ir(e))
}
  , Pr = (t,e)=>!localStorage.getItem(`maintenance-${t}-${e}`)
  , Or = (t,e)=>{
    localStorage.setItem(`maintenance-${t}-${e}`, "hidden")
}
;
var Nr, Rr = {};
Rr = function() {
    var t = document.getSelection();
    if (!t.rangeCount)
        return function() {}
        ;
    for (var e = document.activeElement, n = [], r = 0; r < t.rangeCount; r++)
        n.push(t.getRangeAt(r));
    switch (e.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
        e.blur();
        break;
    default:
        e = null
    }
    return t.removeAllRanges(),
    function() {
        "Caret" === t.type && t.removeAllRanges(),
        t.rangeCount || n.forEach((function(e) {
            t.addRange(e)
        }
        )),
        e && e.focus()
    }
}
;
var Dr = {
    "text/plain": "Text",
    "text/html": "Url",
    default: "Text"
}
  , Br = "Copy to clipboard: #{key}, Enter";
Nr = function(t, e) {
    var n, r, i, s, o, a, l = !1;
    e || (e = {}),
    n = e.debug || !1;
    try {
        if (i = Rr(),
        s = document.createRange(),
        o = document.getSelection(),
        (a = document.createElement("span")).textContent = t,
        a.ariaHidden = "true",
        a.style.all = "unset",
        a.style.position = "fixed",
        a.style.top = 0,
        a.style.clip = "rect(0, 0, 0, 0)",
        a.style.whiteSpace = "pre",
        a.style.webkitUserSelect = "text",
        a.style.MozUserSelect = "text",
        a.style.msUserSelect = "text",
        a.style.userSelect = "text",
        a.addEventListener("copy", (function(r) {
            if (r.stopPropagation(),
            e.format)
                if (r.preventDefault(),
                void 0 === r.clipboardData) {
                    n && console.warn("unable to use e.clipboardData"),
                    n && console.warn("trying IE specific stuff"),
                    window.clipboardData.clearData();
                    var i = Dr[e.format] || Dr.default;
                    window.clipboardData.setData(i, t)
                } else
                    r.clipboardData.clearData(),
                    r.clipboardData.setData(e.format, t);
            e.onCopy && (r.preventDefault(),
            e.onCopy(r.clipboardData))
        }
        )),
        document.body.appendChild(a),
        s.selectNodeContents(a),
        o.addRange(s),
        !document.execCommand("copy"))
            throw new Error("copy command was unsuccessful");
        l = !0
    } catch (i) {
        n && console.error("unable to copy using execCommand: ", i),
        n && console.warn("trying IE specific stuff");
        try {
            window.clipboardData.setData(e.format || "text", t),
            e.onCopy && e.onCopy(window.clipboardData),
            l = !0
        } catch (i) {
            n && console.error("unable to copy using clipboardData: ", i),
            n && console.error("falling back to prompt"),
            r = function(t) {
                var e = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
                return t.replace(/#{\s*key\s*}/g, e)
            }("message"in e ? e.message : Br),
            window.prompt(r, t)
        }
    } finally {
        o && ("function" == typeof o.removeRange ? o.removeRange(s) : o.removeAllRanges()),
        a && document.body.removeChild(a),
        i()
    }
    return l
}
;
d = o("acw62");
function Lr() {
    return Lr = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
                Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }
    ,
    Lr.apply(this, arguments)
}
function Fr(t, e) {
    if (null == t)
        return {};
    var n, r, i = {}, s = Object.keys(t);
    for (r = 0; r < s.length; r++)
        n = s[r],
        e.indexOf(n) >= 0 || (i[n] = t[n]);
    return i
}
function jr(t, e) {
    return jr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e,
        t
    }
    ,
    jr(t, e)
}
function Ur(t, e) {
    t.prototype = Object.create(e.prototype),
    t.prototype.constructor = t,
    jr(t, e)
}
function zr(t, e) {
    return t.replace(new RegExp("(^|\\s)" + e + "(?:\\s|$)","g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "")
}
d = o("acw62"),
d = o("acw62");
var Vr = {
    disabled: !1
}
  , Wr = e(d = o("acw62")).createContext(null)
  , Yr = function(t) {
    return t.scrollTop
}
  , Hr = "unmounted"
  , $r = "exited"
  , Gr = "entering"
  , Xr = "entered"
  , qr = "exiting"
  , Kr = function(t) {
    function n(e, n) {
        var r;
        r = t.call(this, e, n) || this;
        var i, s = n && !n.isMounting ? e.enter : e.appear;
        return r.appearStatus = null,
        e.in ? s ? (i = $r,
        r.appearStatus = Gr) : i = Xr : i = e.unmountOnExit || e.mountOnEnter ? Hr : $r,
        r.state = {
            status: i
        },
        r.nextCallback = null,
        r
    }
    Ur(n, t),
    n.getDerivedStateFromProps = function(t, e) {
        return t.in && e.status === Hr ? {
            status: $r
        } : null
    }
    ;
    var r = n.prototype;
    return r.componentDidMount = function() {
        this.updateStatus(!0, this.appearStatus)
    }
    ,
    r.componentDidUpdate = function(t) {
        var e = null;
        if (t !== this.props) {
            var n = this.state.status;
            this.props.in ? n !== Gr && n !== Xr && (e = Gr) : n !== Gr && n !== Xr || (e = qr)
        }
        this.updateStatus(!1, e)
    }
    ,
    r.componentWillUnmount = function() {
        this.cancelNextCallback()
    }
    ,
    r.getTimeouts = function() {
        var t, e, n, r = this.props.timeout;
        return t = e = n = r,
        null != r && "number" != typeof r && (t = r.exit,
        e = r.enter,
        n = void 0 !== r.appear ? r.appear : e),
        {
            exit: t,
            enter: e,
            appear: n
        }
    }
    ,
    r.updateStatus = function(t, n) {
        if (void 0 === t && (t = !1),
        null !== n)
            if (this.cancelNextCallback(),
            n === Gr) {
                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                    var r = this.props.nodeRef ? this.props.nodeRef.current : e(c).findDOMNode(this);
                    r && Yr(r)
                }
                this.performEnter(t)
            } else
                this.performExit();
        else
            this.props.unmountOnExit && this.state.status === $r && this.setState({
                status: Hr
            })
    }
    ,
    r.performEnter = function(t) {
        var n = this
          , r = this.props.enter
          , i = this.context ? this.context.isMounting : t
          , s = this.props.nodeRef ? [i] : [e(c).findDOMNode(this), i]
          , o = s[0]
          , a = s[1]
          , l = this.getTimeouts()
          , u = i ? l.appear : l.enter;
        !t && !r || Vr.disabled ? this.safeSetState({
            status: Xr
        }, (function() {
            n.props.onEntered(o)
        }
        )) : (this.props.onEnter(o, a),
        this.safeSetState({
            status: Gr
        }, (function() {
            n.props.onEntering(o, a),
            n.onTransitionEnd(u, (function() {
                n.safeSetState({
                    status: Xr
                }, (function() {
                    n.props.onEntered(o, a)
                }
                ))
            }
            ))
        }
        )))
    }
    ,
    r.performExit = function() {
        var t = this
          , n = this.props.exit
          , r = this.getTimeouts()
          , i = this.props.nodeRef ? void 0 : e(c).findDOMNode(this);
        n && !Vr.disabled ? (this.props.onExit(i),
        this.safeSetState({
            status: qr
        }, (function() {
            t.props.onExiting(i),
            t.onTransitionEnd(r.exit, (function() {
                t.safeSetState({
                    status: $r
                }, (function() {
                    t.props.onExited(i)
                }
                ))
            }
            ))
        }
        ))) : this.safeSetState({
            status: $r
        }, (function() {
            t.props.onExited(i)
        }
        ))
    }
    ,
    r.cancelNextCallback = function() {
        null !== this.nextCallback && (this.nextCallback.cancel(),
        this.nextCallback = null)
    }
    ,
    r.safeSetState = function(t, e) {
        e = this.setNextCallback(e),
        this.setState(t, e)
    }
    ,
    r.setNextCallback = function(t) {
        var e = this
          , n = !0;
        return this.nextCallback = function(r) {
            n && (n = !1,
            e.nextCallback = null,
            t(r))
        }
        ,
        this.nextCallback.cancel = function() {
            n = !1
        }
        ,
        this.nextCallback
    }
    ,
    r.onTransitionEnd = function(t, n) {
        this.setNextCallback(n);
        var r = this.props.nodeRef ? this.props.nodeRef.current : e(c).findDOMNode(this)
          , i = null == t && !this.props.addEndListener;
        if (r && !i) {
            if (this.props.addEndListener) {
                var s = this.props.nodeRef ? [this.nextCallback] : [r, this.nextCallback]
                  , o = s[0]
                  , a = s[1];
                this.props.addEndListener(o, a)
            }
            null != t && setTimeout(this.nextCallback, t)
        } else
            setTimeout(this.nextCallback, 0)
    }
    ,
    r.render = function() {
        var t = this.state.status;
        if (t === Hr)
            return null;
        var n = this.props
          , r = n.children
          , i = (n.in,
        n.mountOnEnter,
        n.unmountOnExit,
        n.appear,
        n.enter,
        n.exit,
        n.timeout,
        n.addEndListener,
        n.onEnter,
        n.onEntering,
        n.onEntered,
        n.onExit,
        n.onExiting,
        n.onExited,
        n.nodeRef,
        Fr(n, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]));
        return e(d).createElement(Wr.Provider, {
            value: null
        }, "function" == typeof r ? r(t, i) : e(d).cloneElement(e(d).Children.only(r), i))
    }
    ,
    n
}(e(d).Component);
function Qr() {}
Kr.contextType = Wr,
Kr.propTypes = {},
Kr.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: Qr,
    onEntering: Qr,
    onEntered: Qr,
    onExit: Qr,
    onExiting: Qr,
    onExited: Qr
},
Kr.UNMOUNTED = Hr,
Kr.EXITED = $r,
Kr.ENTERING = Gr,
Kr.ENTERED = Xr,
Kr.EXITING = qr;
var Zr = Kr
  , Jr = function(t, e) {
    return t && e && e.split(" ").forEach((function(e) {
        return r = e,
        void ((n = t).classList ? n.classList.add(r) : function(t, e) {
            return t.classList ? !!e && t.classList.contains(e) : -1 !== (" " + (t.className.baseVal || t.className) + " ").indexOf(" " + e + " ")
        }(n, r) || ("string" == typeof n.className ? n.className = n.className + " " + r : n.setAttribute("class", (n.className && n.className.baseVal || "") + " " + r)));
        var n, r
    }
    ))
}
  , ti = function(t, e) {
    return t && e && e.split(" ").forEach((function(e) {
        return r = e,
        void ((n = t).classList ? n.classList.remove(r) : "string" == typeof n.className ? n.className = zr(n.className, r) : n.setAttribute("class", zr(n.className && n.className.baseVal || "", r)));
        var n, r
    }
    ))
}
  , ei = function(t) {
    function n() {
        for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++)
            r[i] = arguments[i];
        return (e = t.call.apply(t, [this].concat(r)) || this).appliedClasses = {
            appear: {},
            enter: {},
            exit: {}
        },
        e.onEnter = function(t, n) {
            var r = e.resolveArguments(t, n)
              , i = r[0]
              , s = r[1];
            e.removeClasses(i, "exit"),
            e.addClass(i, s ? "appear" : "enter", "base"),
            e.props.onEnter && e.props.onEnter(t, n)
        }
        ,
        e.onEntering = function(t, n) {
            var r = e.resolveArguments(t, n)
              , i = r[0]
              , s = r[1] ? "appear" : "enter";
            e.addClass(i, s, "active"),
            e.props.onEntering && e.props.onEntering(t, n)
        }
        ,
        e.onEntered = function(t, n) {
            var r = e.resolveArguments(t, n)
              , i = r[0]
              , s = r[1] ? "appear" : "enter";
            e.removeClasses(i, s),
            e.addClass(i, s, "done"),
            e.props.onEntered && e.props.onEntered(t, n)
        }
        ,
        e.onExit = function(t) {
            var n = e.resolveArguments(t)[0];
            e.removeClasses(n, "appear"),
            e.removeClasses(n, "enter"),
            e.addClass(n, "exit", "base"),
            e.props.onExit && e.props.onExit(t)
        }
        ,
        e.onExiting = function(t) {
            var n = e.resolveArguments(t)[0];
            e.addClass(n, "exit", "active"),
            e.props.onExiting && e.props.onExiting(t)
        }
        ,
        e.onExited = function(t) {
            var n = e.resolveArguments(t)[0];
            e.removeClasses(n, "exit"),
            e.addClass(n, "exit", "done"),
            e.props.onExited && e.props.onExited(t)
        }
        ,
        e.resolveArguments = function(t, n) {
            return e.props.nodeRef ? [e.props.nodeRef.current, t] : [t, n]
        }
        ,
        e.getClassNames = function(t) {
            var n = e.props.classNames
              , r = "string" == typeof n
              , i = r ? "" + (r && n ? n + "-" : "") + t : n[t];
            return {
                baseClassName: i,
                activeClassName: r ? i + "-active" : n[t + "Active"],
                doneClassName: r ? i + "-done" : n[t + "Done"]
            }
        }
        ,
        e
    }
    Ur(n, t);
    var r = n.prototype;
    return r.addClass = function(t, e, n) {
        var r = this.getClassNames(e)[n + "ClassName"]
          , i = this.getClassNames("enter").doneClassName;
        "appear" === e && "done" === n && i && (r += " " + i),
        "active" === n && t && Yr(t),
        r && (this.appliedClasses[e][n] = r,
        Jr(t, r))
    }
    ,
    r.removeClasses = function(t, e) {
        var n = this.appliedClasses[e]
          , r = n.base
          , i = n.active
          , s = n.done;
        this.appliedClasses[e] = {},
        r && ti(t, r),
        i && ti(t, i),
        s && ti(t, s)
    }
    ,
    r.render = function() {
        var t = this.props
          , n = (t.classNames,
        Fr(t, ["classNames"]));
        return e(d).createElement(Zr, Lr({}, n, {
            onEnter: this.onEnter,
            onEntered: this.onEntered,
            onEntering: this.onEntering,
            onExit: this.onExit,
            onExiting: this.onExiting,
            onExited: this.onExited
        }))
    }
    ,
    n
}(e(d).Component);
ei.defaultProps = {
    classNames: ""
},
ei.propTypes = {};
var ni = ei;
function ri(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter((function(e) {
            return Object.getOwnPropertyDescriptor(t, e).enumerable
        }
        ))),
        n.push.apply(n, r)
    }
    return n
}
function ii(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = null != arguments[e] ? arguments[e] : {};
        e % 2 ? ri(Object(n), !0).forEach((function(e) {
            ai(t, e, n[e])
        }
        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ri(Object(n)).forEach((function(e) {
            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
        }
        ))
    }
    return t
}
function si(t) {
    return si = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    si(t)
}
function oi(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(t, r.key, r)
    }
}
function ai(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n,
    t
}
function li(t, e) {
    return function(t) {
        if (Array.isArray(t))
            return t
    }(t) || function(t, e) {
        var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
        if (null == n)
            return;
        var r, i, s = [], o = !0, a = !1;
        try {
            for (n = n.call(t); !(o = (r = n.next()).done) && (s.push(r.value),
            !e || s.length !== e); o = !0)
                ;
        } catch (t) {
            a = !0,
            i = t
        } finally {
            try {
                o || null == n.return || n.return()
            } finally {
                if (a)
                    throw i
            }
        }
        return s
    }(t, e) || ui(t, e) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }()
}
function ci(t) {
    return function(t) {
        if (Array.isArray(t))
            return hi(t)
    }(t) || function(t) {
        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"])
            return Array.from(t)
    }(t) || ui(t) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }()
}
function ui(t, e) {
    if (t) {
        if ("string" == typeof t)
            return hi(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        return "Object" === n && t.constructor && (n = t.constructor.name),
        "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? hi(t, e) : void 0
    }
}
function hi(t, e) {
    (null == e || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++)
        r[n] = t[n];
    return r
}
var di = function() {}
  , fi = {}
  , pi = {}
  , mi = null
  , gi = {
    mark: di,
    measure: di
};
try {
    "undefined" != typeof window && (fi = window),
    "undefined" != typeof document && (pi = document),
    "undefined" != typeof MutationObserver && (mi = MutationObserver),
    "undefined" != typeof performance && (gi = performance)
} catch (t) {}
var yi, bi, vi, wi, xi, Ei = (fi.navigator || {}).userAgent, _i = void 0 === Ei ? "" : Ei, Ai = fi, Si = pi, Ti = mi, ki = gi, Ii = (Ai.document,
!!Si.documentElement && !!Si.head && "function" == typeof Si.addEventListener && "function" == typeof Si.createElement), Mi = ~_i.indexOf("MSIE") || ~_i.indexOf("Trident/"), Ci = "___FONT_AWESOME___", Pi = 16, Oi = "fa", Ni = "svg-inline--fa", Ri = "data-fa-i2svg", Di = "data-fa-pseudo-element", Bi = "data-fa-pseudo-element-pending", Li = "data-prefix", Fi = "data-icon", ji = "fontawesome-i2svg", Ui = "async", zi = ["HTML", "HEAD", "STYLE", "SCRIPT"], Vi = function() {
    try {
        return !0
    } catch (t) {
        return !1
    }
}(), Wi = "classic", Yi = "sharp", Hi = [Wi, Yi];
function $i(t) {
    return new Proxy(t,{
        get: function(t, e) {
            return e in t ? t[e] : t[Wi]
        }
    })
}
var Gi = $i((ai(yi = {}, Wi, {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fad: "duotone",
    "fa-duotone": "duotone",
    fab: "brands",
    "fa-brands": "brands",
    fak: "kit",
    "fa-kit": "kit"
}),
ai(yi, Yi, {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular"
}),
yi))
  , Xi = $i((ai(bi = {}, Wi, {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    duotone: "fad",
    brands: "fab",
    kit: "fak"
}),
ai(bi, Yi, {
    solid: "fass",
    regular: "fasr"
}),
bi))
  , qi = $i((ai(vi = {}, Wi, {
    fab: "fa-brands",
    fad: "fa-duotone",
    fak: "fa-kit",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
}),
ai(vi, Yi, {
    fass: "fa-solid",
    fasr: "fa-regular"
}),
vi))
  , Ki = $i((ai(wi = {}, Wi, {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-kit": "fak",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
}),
ai(wi, Yi, {
    "fa-solid": "fass",
    "fa-regular": "fasr"
}),
wi))
  , Qi = /fa(s|r|l|t|d|b|k|ss|sr)?[\-\ ]/
  , Zi = "fa-layers-text"
  , Ji = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i
  , ts = $i((ai(xi = {}, Wi, {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
}),
ai(xi, Yi, {
    900: "fass",
    400: "fasr"
}),
xi))
  , es = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  , ns = es.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20])
  , rs = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"]
  , is = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
}
  , ss = new Set;
Object.keys(Xi[Wi]).map(ss.add.bind(ss)),
Object.keys(Xi[Yi]).map(ss.add.bind(ss));
var os = [].concat(Hi, ci(ss), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", is.GROUP, is.SWAP_OPACITY, is.PRIMARY, is.SECONDARY]).concat(es.map((function(t) {
    return "".concat(t, "x")
}
))).concat(ns.map((function(t) {
    return "w-".concat(t)
}
)))
  , as = Ai.FontAwesomeConfig || {};
if (Si && "function" == typeof Si.querySelector) {
    [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((function(t) {
        var e = li(t, 2)
          , n = e[0]
          , r = e[1]
          , i = function(t) {
            return "" === t || "false" !== t && ("true" === t || t)
        }(function(t) {
            var e = Si.querySelector("script[" + t + "]");
            if (e)
                return e.getAttribute(t)
        }(n));
        null != i && (as[r] = i)
    }
    ))
}
var ls = {
    styleDefault: "solid",
    familyDefault: "classic",
    cssPrefix: Oi,
    replacementClass: Ni,
    autoReplaceSvg: !0,
    autoAddCss: !0,
    autoA11y: !0,
    searchPseudoElements: !1,
    observeMutations: !0,
    mutateApproach: "async",
    keepOriginalSource: !0,
    measurePerformance: !1,
    showMissingIcons: !0
};
as.familyPrefix && (as.cssPrefix = as.familyPrefix);
var cs = ii(ii({}, ls), as);
cs.autoReplaceSvg || (cs.observeMutations = !1);
var us = {};
Object.keys(ls).forEach((function(t) {
    Object.defineProperty(us, t, {
        enumerable: !0,
        set: function(e) {
            cs[t] = e,
            hs.forEach((function(t) {
                return t(us)
            }
            ))
        },
        get: function() {
            return cs[t]
        }
    })
}
)),
Object.defineProperty(us, "familyPrefix", {
    enumerable: !0,
    set: function(t) {
        cs.cssPrefix = t,
        hs.forEach((function(t) {
            return t(us)
        }
        ))
    },
    get: function() {
        return cs.cssPrefix
    }
}),
Ai.FontAwesomeConfig = us;
var hs = [];
var ds = Pi
  , fs = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: !1,
    flipY: !1
};
var ps = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function ms() {
    for (var t = 12, e = ""; t-- > 0; )
        e += ps[62 * Math.random() | 0];
    return e
}
function gs(t) {
    for (var e = [], n = (t || []).length >>> 0; n--; )
        e[n] = t[n];
    return e
}
function ys(t) {
    return t.classList ? gs(t.classList) : (t.getAttribute("class") || "").split(" ").filter((function(t) {
        return t
    }
    ))
}
function bs(t) {
    return "".concat(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
}
function vs(t) {
    return Object.keys(t || {}).reduce((function(e, n) {
        return e + "".concat(n, ": ").concat(t[n].trim(), ";")
    }
    ), "")
}
function ws(t) {
    return t.size !== fs.size || t.x !== fs.x || t.y !== fs.y || t.rotate !== fs.rotate || t.flipX || t.flipY
}
var xs = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-counter-scale, 0.25));\n          transform: scale(var(--fa-counter-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(var(--fa-li-width, 2em) * -1);\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  -webkit-animation-name: fa-beat;\n          animation-name: fa-beat;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  -webkit-animation-name: fa-bounce;\n          animation-name: fa-bounce;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  -webkit-animation-name: fa-fade;\n          animation-name: fa-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  -webkit-animation-name: fa-beat-fade;\n          animation-name: fa-beat-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  -webkit-animation-name: fa-flip;\n          animation-name: fa-flip;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  -webkit-animation-name: fa-shake;\n          animation-name: fa-shake;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 2s);\n          animation-duration: var(--fa-animation-duration, 2s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));\n          animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    -webkit-animation-delay: -1ms;\n            animation-delay: -1ms;\n    -webkit-animation-duration: 1ms;\n            animation-duration: 1ms;\n    -webkit-animation-iteration-count: 1;\n            animation-iteration-count: 1;\n    -webkit-transition-delay: 0s;\n            transition-delay: 0s;\n    -webkit-transition-duration: 0s;\n            transition-duration: 0s;\n  }\n}\n@-webkit-keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@-webkit-keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@-webkit-keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@-webkit-keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@-webkit-keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@-webkit-keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  -webkit-transform: rotate(var(--fa-rotate-angle, none));\n          transform: rotate(var(--fa-rotate-angle, none));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}';
function Es() {
    var t = Oi
      , e = Ni
      , n = us.cssPrefix
      , r = us.replacementClass
      , i = xs;
    if (n !== t || r !== e) {
        var s = new RegExp("\\.".concat(t, "\\-"),"g")
          , o = new RegExp("\\--".concat(t, "\\-"),"g")
          , a = new RegExp("\\.".concat(e),"g");
        i = i.replace(s, ".".concat(n, "-")).replace(o, "--".concat(n, "-")).replace(a, ".".concat(r))
    }
    return i
}
var _s = !1;
function As() {
    us.autoAddCss && !_s && (!function(t) {
        if (t && Ii) {
            var e = Si.createElement("style");
            e.setAttribute("type", "text/css"),
            e.innerHTML = t;
            for (var n = Si.head.childNodes, r = null, i = n.length - 1; i > -1; i--) {
                var s = n[i]
                  , o = (s.tagName || "").toUpperCase();
                ["STYLE", "LINK"].indexOf(o) > -1 && (r = s)
            }
            Si.head.insertBefore(e, r)
        }
    }(Es()),
    _s = !0)
}
var Ss = {
    mixout: function() {
        return {
            dom: {
                css: Es,
                insertCss: As
            }
        }
    },
    hooks: function() {
        return {
            beforeDOMElementCreation: function() {
                As()
            },
            beforeI2svg: function() {
                As()
            }
        }
    }
}
  , Ts = Ai || {};
Ts[Ci] || (Ts[Ci] = {}),
Ts[Ci].styles || (Ts[Ci].styles = {}),
Ts[Ci].hooks || (Ts[Ci].hooks = {}),
Ts[Ci].shims || (Ts[Ci].shims = []);
var ks = Ts[Ci]
  , Is = []
  , Ms = !1;
function Cs(t) {
    var e = t.tag
      , n = t.attributes
      , r = void 0 === n ? {} : n
      , i = t.children
      , s = void 0 === i ? [] : i;
    return "string" == typeof t ? bs(t) : "<".concat(e, " ").concat(function(t) {
        return Object.keys(t || {}).reduce((function(e, n) {
            return e + "".concat(n, '="').concat(bs(t[n]), '" ')
        }
        ), "").trim()
    }(r), ">").concat(s.map(Cs).join(""), "</").concat(e, ">")
}
function Ps(t, e, n) {
    if (t && t[e] && t[e][n])
        return {
            prefix: e,
            iconName: n,
            icon: t[e][n]
        }
}
Ii && ((Ms = (Si.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(Si.readyState)) || Si.addEventListener("DOMContentLoaded", (function t() {
    Si.removeEventListener("DOMContentLoaded", t),
    Ms = 1,
    Is.map((function(t) {
        return t()
    }
    ))
}
)));
var Os = function(t, e, n, r) {
    var i, s, o, a = Object.keys(t), l = a.length, c = void 0 !== r ? function(t, e) {
        return function(n, r, i, s) {
            return t.call(e, n, r, i, s)
        }
    }(e, r) : e;
    for (void 0 === n ? (i = 1,
    o = t[a[0]]) : (i = 0,
    o = n); i < l; i++)
        o = c(o, t[s = a[i]], s, t);
    return o
};
function Ns(t) {
    var e = function(t) {
        for (var e = [], n = 0, r = t.length; n < r; ) {
            var i = t.charCodeAt(n++);
            if (i >= 55296 && i <= 56319 && n < r) {
                var s = t.charCodeAt(n++);
                56320 == (64512 & s) ? e.push(((1023 & i) << 10) + (1023 & s) + 65536) : (e.push(i),
                n--)
            } else
                e.push(i)
        }
        return e
    }(t);
    return 1 === e.length ? e[0].toString(16) : null
}
function Rs(t) {
    return Object.keys(t).reduce((function(e, n) {
        var r = t[n];
        return !!r.icon ? e[r.iconName] = r.icon : e[n] = r,
        e
    }
    ), {})
}
function Ds(t, e) {
    var n = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).skipHooks
      , r = void 0 !== n && n
      , i = Rs(e);
    "function" != typeof ks.hooks.addPack || r ? ks.styles[t] = ii(ii({}, ks.styles[t] || {}), i) : ks.hooks.addPack(t, Rs(e)),
    "fas" === t && Ds("fa", e)
}
var Bs, Ls, Fs, js = ks.styles, Us = ks.shims, zs = (ai(Bs = {}, Wi, Object.values(qi[Wi])),
ai(Bs, Yi, Object.values(qi[Yi])),
Bs), Vs = null, Ws = {}, Ys = {}, Hs = {}, $s = {}, Gs = {}, Xs = (ai(Ls = {}, Wi, Object.keys(Gi[Wi])),
ai(Ls, Yi, Object.keys(Gi[Yi])),
Ls);
function qs(t, e) {
    var n, r = e.split("-"), i = r[0], s = r.slice(1).join("-");
    return i !== t || "" === s || (n = s,
    ~os.indexOf(n)) ? null : s
}
var Ks, Qs = function() {
    var t = function(t) {
        return Os(js, (function(e, n, r) {
            return e[r] = Os(n, t, {}),
            e
        }
        ), {})
    };
    Ws = t((function(t, e, n) {
        (e[3] && (t[e[3]] = n),
        e[2]) && e[2].filter((function(t) {
            return "number" == typeof t
        }
        )).forEach((function(e) {
            t[e.toString(16)] = n
        }
        ));
        return t
    }
    )),
    Ys = t((function(t, e, n) {
        (t[n] = n,
        e[2]) && e[2].filter((function(t) {
            return "string" == typeof t
        }
        )).forEach((function(e) {
            t[e] = n
        }
        ));
        return t
    }
    )),
    Gs = t((function(t, e, n) {
        var r = e[2];
        return t[n] = n,
        r.forEach((function(e) {
            t[e] = n
        }
        )),
        t
    }
    ));
    var e = "far"in js || us.autoFetchSvg
      , n = Os(Us, (function(t, n) {
        var r = n[0]
          , i = n[1]
          , s = n[2];
        return "far" !== i || e || (i = "fas"),
        "string" == typeof r && (t.names[r] = {
            prefix: i,
            iconName: s
        }),
        "number" == typeof r && (t.unicodes[r.toString(16)] = {
            prefix: i,
            iconName: s
        }),
        t
    }
    ), {
        names: {},
        unicodes: {}
    });
    Hs = n.names,
    $s = n.unicodes,
    Vs = ro(us.styleDefault, {
        family: us.familyDefault
    })
};
function Zs(t, e) {
    return (Ws[t] || {})[e]
}
function Js(t, e) {
    return (Gs[t] || {})[e]
}
function to(t) {
    return Hs[t] || {
        prefix: null,
        iconName: null
    }
}
function eo() {
    return Vs
}
Ks = function(t) {
    Vs = ro(t.styleDefault, {
        family: us.familyDefault
    })
}
,
hs.push(Ks),
Qs();
var no = function() {
    return {
        prefix: null,
        iconName: null,
        rest: []
    }
};
function ro(t) {
    var e = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).family
      , n = void 0 === e ? Wi : e
      , r = Gi[n][t]
      , i = Xi[n][t] || Xi[n][r]
      , s = t in ks.styles ? t : null;
    return i || s || null
}
var io = (ai(Fs = {}, Wi, Object.keys(qi[Wi])),
ai(Fs, Yi, Object.keys(qi[Yi])),
Fs);
function so(t) {
    var e, n = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).skipLookups, r = void 0 !== n && n, i = (ai(e = {}, Wi, "".concat(us.cssPrefix, "-").concat(Wi)),
    ai(e, Yi, "".concat(us.cssPrefix, "-").concat(Yi)),
    e), s = null, o = Wi;
    (t.includes(i[Wi]) || t.some((function(t) {
        return io[Wi].includes(t)
    }
    ))) && (o = Wi),
    (t.includes(i[Yi]) || t.some((function(t) {
        return io[Yi].includes(t)
    }
    ))) && (o = Yi);
    var a = t.reduce((function(t, e) {
        var n = qs(us.cssPrefix, e);
        if (js[e] ? (e = zs[o].includes(e) ? Ki[o][e] : e,
        s = e,
        t.prefix = e) : Xs[o].indexOf(e) > -1 ? (s = e,
        t.prefix = ro(e, {
            family: o
        })) : n ? t.iconName = n : e !== us.replacementClass && e !== i[Wi] && e !== i[Yi] && t.rest.push(e),
        !r && t.prefix && t.iconName) {
            var a = "fa" === s ? to(t.iconName) : {}
              , l = Js(t.prefix, t.iconName);
            a.prefix && (s = null),
            t.iconName = a.iconName || l || t.iconName,
            t.prefix = a.prefix || t.prefix,
            "far" !== t.prefix || js.far || !js.fas || us.autoFetchSvg || (t.prefix = "fas")
        }
        return t
    }
    ), no());
    return (t.includes("fa-brands") || t.includes("fab")) && (a.prefix = "fab"),
    (t.includes("fa-duotone") || t.includes("fad")) && (a.prefix = "fad"),
    a.prefix || o !== Yi || !js.fass && !us.autoFetchSvg || (a.prefix = "fass",
    a.iconName = Js(a.prefix, a.iconName) || a.iconName),
    "fa" !== a.prefix && "fa" !== s || (a.prefix = eo() || "fas"),
    a
}
var oo = function() {
    function t() {
        !function(t, e) {
            if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function")
        }(this, t),
        this.definitions = {}
    }
    var e, n, r;
    return e = t,
    n = [{
        key: "add",
        value: function() {
            for (var t = this, e = arguments.length, n = new Array(e), r = 0; r < e; r++)
                n[r] = arguments[r];
            var i = n.reduce(this._pullDefinitions, {});
            Object.keys(i).forEach((function(e) {
                t.definitions[e] = ii(ii({}, t.definitions[e] || {}), i[e]),
                Ds(e, i[e]);
                var n = qi[Wi][e];
                n && Ds(n, i[e]),
                Qs()
            }
            ))
        }
    }, {
        key: "reset",
        value: function() {
            this.definitions = {}
        }
    }, {
        key: "_pullDefinitions",
        value: function(t, e) {
            var n = e.prefix && e.iconName && e.icon ? {
                0: e
            } : e;
            return Object.keys(n).map((function(e) {
                var r = n[e]
                  , i = r.prefix
                  , s = r.iconName
                  , o = r.icon
                  , a = o[2];
                t[i] || (t[i] = {}),
                a.length > 0 && a.forEach((function(e) {
                    "string" == typeof e && (t[i][e] = o)
                }
                )),
                t[i][s] = o
            }
            )),
            t
        }
    }],
    n && oi(e.prototype, n),
    r && oi(e, r),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    t
}()
  , ao = []
  , lo = {}
  , co = {}
  , uo = Object.keys(co);
function ho(t, e) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
        r[i - 2] = arguments[i];
    return (lo[t] || []).forEach((function(t) {
        e = t.apply(null, [e].concat(r))
    }
    )),
    e
}
function fo(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
        n[r - 1] = arguments[r];
    (lo[t] || []).forEach((function(t) {
        t.apply(null, n)
    }
    ))
}
function po() {
    var t = arguments[0]
      , e = Array.prototype.slice.call(arguments, 1);
    return co[t] ? co[t].apply(null, e) : void 0
}
function mo(t) {
    "fa" === t.prefix && (t.prefix = "fas");
    var e = t.iconName
      , n = t.prefix || eo();
    if (e)
        return e = Js(n, e) || e,
        Ps(go.definitions, n, e) || Ps(ks.styles, n, e)
}
var go = new oo
  , yo = {
    i2svg: function() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return Ii ? (fo("beforeI2svg", t),
        po("pseudoElements2svg", t),
        po("i2svg", t)) : Promise.reject("Operation requires a DOM of some kind.")
    },
    watch: function() {
        var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = e.autoReplaceSvgRoot;
        !1 === us.autoReplaceSvg && (us.autoReplaceSvg = !0),
        us.observeMutations = !0,
        t = function() {
            vo({
                autoReplaceSvgRoot: n
            }),
            fo("watch", e)
        }
        ,
        Ii && (Ms ? setTimeout(t, 0) : Is.push(t))
    }
}
  , bo = {
    noAuto: function() {
        us.autoReplaceSvg = !1,
        us.observeMutations = !1,
        fo("noAuto")
    },
    config: us,
    dom: yo,
    parse: {
        icon: function(t) {
            if (null === t)
                return null;
            if ("object" === si(t) && t.prefix && t.iconName)
                return {
                    prefix: t.prefix,
                    iconName: Js(t.prefix, t.iconName) || t.iconName
                };
            if (Array.isArray(t) && 2 === t.length) {
                var e = 0 === t[1].indexOf("fa-") ? t[1].slice(3) : t[1]
                  , n = ro(t[0]);
                return {
                    prefix: n,
                    iconName: Js(n, e) || e
                }
            }
            if ("string" == typeof t && (t.indexOf("".concat(us.cssPrefix, "-")) > -1 || t.match(Qi))) {
                var r = so(t.split(" "), {
                    skipLookups: !0
                });
                return {
                    prefix: r.prefix || eo(),
                    iconName: Js(r.prefix, r.iconName) || r.iconName
                }
            }
            if ("string" == typeof t) {
                var i = eo();
                return {
                    prefix: i,
                    iconName: Js(i, t) || t
                }
            }
        }
    },
    library: go,
    findIconDefinition: mo,
    toHtml: Cs
}
  , vo = function() {
    var t = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).autoReplaceSvgRoot
      , e = void 0 === t ? Si : t;
    (Object.keys(ks.styles).length > 0 || us.autoFetchSvg) && Ii && us.autoReplaceSvg && bo.dom.i2svg({
        node: e
    })
};
function wo(t, e) {
    return Object.defineProperty(t, "abstract", {
        get: e
    }),
    Object.defineProperty(t, "html", {
        get: function() {
            return t.abstract.map((function(t) {
                return Cs(t)
            }
            ))
        }
    }),
    Object.defineProperty(t, "node", {
        get: function() {
            if (Ii) {
                var e = Si.createElement("div");
                return e.innerHTML = t.html,
                e.children
            }
        }
    }),
    t
}
function xo(t) {
    var e = t.icons
      , n = e.main
      , r = e.mask
      , i = t.prefix
      , s = t.iconName
      , o = t.transform
      , a = t.symbol
      , l = t.title
      , c = t.maskId
      , u = t.titleId
      , h = t.extra
      , d = t.watchable
      , f = void 0 !== d && d
      , p = r.found ? r : n
      , m = p.width
      , g = p.height
      , y = "fak" === i
      , b = [us.replacementClass, s ? "".concat(us.cssPrefix, "-").concat(s) : ""].filter((function(t) {
        return -1 === h.classes.indexOf(t)
    }
    )).filter((function(t) {
        return "" !== t || !!t
    }
    )).concat(h.classes).join(" ")
      , v = {
        children: [],
        attributes: ii(ii({}, h.attributes), {}, {
            "data-prefix": i,
            "data-icon": s,
            class: b,
            role: h.attributes.role || "img",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 ".concat(m, " ").concat(g)
        })
    }
      , w = y && !~h.classes.indexOf("fa-fw") ? {
        width: "".concat(m / g * 1, "em")
    } : {};
    f && (v.attributes[Ri] = ""),
    l && (v.children.push({
        tag: "title",
        attributes: {
            id: v.attributes["aria-labelledby"] || "title-".concat(u || ms())
        },
        children: [l]
    }),
    delete v.attributes.title);
    var x = ii(ii({}, v), {}, {
        prefix: i,
        iconName: s,
        main: n,
        mask: r,
        maskId: c,
        transform: o,
        symbol: a,
        styles: ii(ii({}, w), h.styles)
    })
      , E = r.found && n.found ? po("generateAbstractMask", x) || {
        children: [],
        attributes: {}
    } : po("generateAbstractIcon", x) || {
        children: [],
        attributes: {}
    }
      , _ = E.children
      , A = E.attributes;
    return x.children = _,
    x.attributes = A,
    a ? function(t) {
        var e = t.prefix
          , n = t.iconName
          , r = t.children
          , i = t.attributes
          , s = t.symbol
          , o = !0 === s ? "".concat(e, "-").concat(us.cssPrefix, "-").concat(n) : s;
        return [{
            tag: "svg",
            attributes: {
                style: "display: none;"
            },
            children: [{
                tag: "symbol",
                attributes: ii(ii({}, i), {}, {
                    id: o
                }),
                children: r
            }]
        }]
    }(x) : function(t) {
        var e = t.children
          , n = t.main
          , r = t.mask
          , i = t.attributes
          , s = t.styles
          , o = t.transform;
        if (ws(o) && n.found && !r.found) {
            var a = {
                x: n.width / n.height / 2,
                y: .5
            };
            i.style = vs(ii(ii({}, s), {}, {
                "transform-origin": "".concat(a.x + o.x / 16, "em ").concat(a.y + o.y / 16, "em")
            }))
        }
        return [{
            tag: "svg",
            attributes: i,
            children: e
        }]
    }(x)
}
function Eo(t) {
    var e = t.content
      , n = t.width
      , r = t.height
      , i = t.transform
      , s = t.title
      , o = t.extra
      , a = t.watchable
      , l = void 0 !== a && a
      , c = ii(ii(ii({}, o.attributes), s ? {
        title: s
    } : {}), {}, {
        class: o.classes.join(" ")
    });
    l && (c[Ri] = "");
    var u = ii({}, o.styles);
    ws(i) && (u.transform = function(t) {
        var e = t.transform
          , n = t.width
          , r = void 0 === n ? Pi : n
          , i = t.height
          , s = void 0 === i ? Pi : i
          , o = t.startCentered
          , a = void 0 !== o && o
          , l = "";
        return l += a && Mi ? "translate(".concat(e.x / ds - r / 2, "em, ").concat(e.y / ds - s / 2, "em) ") : a ? "translate(calc(-50% + ".concat(e.x / ds, "em), calc(-50% + ").concat(e.y / ds, "em)) ") : "translate(".concat(e.x / ds, "em, ").concat(e.y / ds, "em) "),
        l += "scale(".concat(e.size / ds * (e.flipX ? -1 : 1), ", ").concat(e.size / ds * (e.flipY ? -1 : 1), ") "),
        l + "rotate(".concat(e.rotate, "deg) ")
    }({
        transform: i,
        startCentered: !0,
        width: n,
        height: r
    }),
    u["-webkit-transform"] = u.transform);
    var h = vs(u);
    h.length > 0 && (c.style = h);
    var d = [];
    return d.push({
        tag: "span",
        attributes: c,
        children: [e]
    }),
    s && d.push({
        tag: "span",
        attributes: {
            class: "sr-only"
        },
        children: [s]
    }),
    d
}
var _o = ks.styles;
function Ao(t) {
    var e = t[0]
      , n = t[1]
      , r = li(t.slice(4), 1)[0];
    return {
        found: !0,
        width: e,
        height: n,
        icon: Array.isArray(r) ? {
            tag: "g",
            attributes: {
                class: "".concat(us.cssPrefix, "-").concat(is.GROUP)
            },
            children: [{
                tag: "path",
                attributes: {
                    class: "".concat(us.cssPrefix, "-").concat(is.SECONDARY),
                    fill: "currentColor",
                    d: r[0]
                }
            }, {
                tag: "path",
                attributes: {
                    class: "".concat(us.cssPrefix, "-").concat(is.PRIMARY),
                    fill: "currentColor",
                    d: r[1]
                }
            }]
        } : {
            tag: "path",
            attributes: {
                fill: "currentColor",
                d: r
            }
        }
    }
}
var So = {
    found: !1,
    width: 512,
    height: 512
};
function To(t, e) {
    var n = e;
    return "fa" === e && null !== us.styleDefault && (e = eo()),
    new Promise((function(r, i) {
        po("missingIconAbstract");
        if ("fa" === n) {
            var s = to(t) || {};
            t = s.iconName || t,
            e = s.prefix || e
        }
        if (t && e && _o[e] && _o[e][t])
            return r(Ao(_o[e][t]));
        !function(t, e) {
            Vi || us.showMissingIcons || !t || console.error('Icon with name "'.concat(t, '" and prefix "').concat(e, '" is missing.'))
        }(t, e),
        r(ii(ii({}, So), {}, {
            icon: us.showMissingIcons && t && po("missingIconAbstract") || {}
        }))
    }
    ))
}
var ko = function() {}
  , Io = us.measurePerformance && ki && ki.mark && ki.measure ? ki : {
    mark: ko,
    measure: ko
}
  , Mo = 'FA "6.3.0"'
  , Co = function(t) {
    Io.mark("".concat(Mo, " ").concat(t, " ends")),
    Io.measure("".concat(Mo, " ").concat(t), "".concat(Mo, " ").concat(t, " begins"), "".concat(Mo, " ").concat(t, " ends"))
}
  , Po = {
    begin: function(t) {
        return Io.mark("".concat(Mo, " ").concat(t, " begins")),
        function() {
            return Co(t)
        }
    },
    end: Co
}
  , Oo = function() {};
function No(t) {
    return "string" == typeof (t.getAttribute ? t.getAttribute(Ri) : null)
}
function Ro(t) {
    return Si.createElementNS("http://www.w3.org/2000/svg", t)
}
function Do(t) {
    return Si.createElement(t)
}
function Bo(t) {
    var e = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).ceFn
      , n = void 0 === e ? "svg" === t.tag ? Ro : Do : e;
    if ("string" == typeof t)
        return Si.createTextNode(t);
    var r = n(t.tag);
    return Object.keys(t.attributes || []).forEach((function(e) {
        r.setAttribute(e, t.attributes[e])
    }
    )),
    (t.children || []).forEach((function(t) {
        r.appendChild(Bo(t, {
            ceFn: n
        }))
    }
    )),
    r
}
var Lo = {
    replace: function(t) {
        var e = t[0];
        if (e.parentNode)
            if (t[1].forEach((function(t) {
                e.parentNode.insertBefore(Bo(t), e)
            }
            )),
            null === e.getAttribute(Ri) && us.keepOriginalSource) {
                var n = Si.createComment(function(t) {
                    var e = " ".concat(t.outerHTML, " ");
                    return "".concat(e, "Font Awesome fontawesome.com ")
                }(e));
                e.parentNode.replaceChild(n, e)
            } else
                e.remove()
    },
    nest: function(t) {
        var e = t[0]
          , n = t[1];
        if (~ys(e).indexOf(us.replacementClass))
            return Lo.replace(t);
        var r = new RegExp("".concat(us.cssPrefix, "-.*"));
        if (delete n[0].attributes.id,
        n[0].attributes.class) {
            var i = n[0].attributes.class.split(" ").reduce((function(t, e) {
                return e === us.replacementClass || e.match(r) ? t.toSvg.push(e) : t.toNode.push(e),
                t
            }
            ), {
                toNode: [],
                toSvg: []
            });
            n[0].attributes.class = i.toSvg.join(" "),
            0 === i.toNode.length ? e.removeAttribute("class") : e.setAttribute("class", i.toNode.join(" "))
        }
        var s = n.map((function(t) {
            return Cs(t)
        }
        )).join("\n");
        e.setAttribute(Ri, ""),
        e.innerHTML = s
    }
};
function Fo(t) {
    t()
}
function jo(t, e) {
    var n = "function" == typeof e ? e : Oo;
    if (0 === t.length)
        n();
    else {
        var r = Fo;
        us.mutateApproach === Ui && (r = Ai.requestAnimationFrame || Fo),
        r((function() {
            var e = !0 === us.autoReplaceSvg ? Lo.replace : Lo[us.autoReplaceSvg] || Lo.replace
              , r = Po.begin("mutate");
            t.map(e),
            r(),
            n()
        }
        ))
    }
}
var Uo = !1;
function zo() {
    Uo = !0
}
function Vo() {
    Uo = !1
}
var Wo = null;
function Yo(t) {
    if (Ti && us.observeMutations) {
        var e = t.treeCallback
          , n = void 0 === e ? Oo : e
          , r = t.nodeCallback
          , i = void 0 === r ? Oo : r
          , s = t.pseudoElementsCallback
          , o = void 0 === s ? Oo : s
          , a = t.observeMutationsRoot
          , l = void 0 === a ? Si : a;
        Wo = new Ti((function(t) {
            if (!Uo) {
                var e = eo();
                gs(t).forEach((function(t) {
                    if ("childList" === t.type && t.addedNodes.length > 0 && !No(t.addedNodes[0]) && (us.searchPseudoElements && o(t.target),
                    n(t.target)),
                    "attributes" === t.type && t.target.parentNode && us.searchPseudoElements && o(t.target.parentNode),
                    "attributes" === t.type && No(t.target) && ~rs.indexOf(t.attributeName))
                        if ("class" === t.attributeName && function(t) {
                            var e = t.getAttribute ? t.getAttribute(Li) : null
                              , n = t.getAttribute ? t.getAttribute(Fi) : null;
                            return e && n
                        }(t.target)) {
                            var r = so(ys(t.target))
                              , s = r.prefix
                              , a = r.iconName;
                            t.target.setAttribute(Li, s || e),
                            a && t.target.setAttribute(Fi, a)
                        } else
                            (l = t.target) && l.classList && l.classList.contains && l.classList.contains(us.replacementClass) && i(t.target);
                    var l
                }
                ))
            }
        }
        )),
        Ii && Wo.observe(l, {
            childList: !0,
            attributes: !0,
            characterData: !0,
            subtree: !0
        })
    }
}
function Ho(t) {
    var e, n, r = t.getAttribute("data-prefix"), i = t.getAttribute("data-icon"), s = void 0 !== t.innerText ? t.innerText.trim() : "", o = so(ys(t));
    return o.prefix || (o.prefix = eo()),
    r && i && (o.prefix = r,
    o.iconName = i),
    o.iconName && o.prefix || (o.prefix && s.length > 0 && (o.iconName = (e = o.prefix,
    n = t.innerText,
    (Ys[e] || {})[n] || Zs(o.prefix, Ns(t.innerText)))),
    !o.iconName && us.autoFetchSvg && t.firstChild && t.firstChild.nodeType === Node.TEXT_NODE && (o.iconName = t.firstChild.data)),
    o
}
function $o(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
        styleParser: !0
    }
      , n = Ho(t)
      , r = n.iconName
      , i = n.prefix
      , s = n.rest
      , o = function(t) {
        var e = gs(t.attributes).reduce((function(t, e) {
            return "class" !== t.name && "style" !== t.name && (t[e.name] = e.value),
            t
        }
        ), {})
          , n = t.getAttribute("title")
          , r = t.getAttribute("data-fa-title-id");
        return us.autoA11y && (n ? e["aria-labelledby"] = "".concat(us.replacementClass, "-title-").concat(r || ms()) : (e["aria-hidden"] = "true",
        e.focusable = "false")),
        e
    }(t)
      , a = ho("parseNodeAttributes", {}, t)
      , l = e.styleParser ? function(t) {
        var e = t.getAttribute("style")
          , n = [];
        return e && (n = e.split(";").reduce((function(t, e) {
            var n = e.split(":")
              , r = n[0]
              , i = n.slice(1);
            return r && i.length > 0 && (t[r] = i.join(":").trim()),
            t
        }
        ), {})),
        n
    }(t) : [];
    return ii({
        iconName: r,
        title: t.getAttribute("title"),
        titleId: t.getAttribute("data-fa-title-id"),
        prefix: i,
        transform: fs,
        mask: {
            iconName: null,
            prefix: null,
            rest: []
        },
        maskId: null,
        symbol: !1,
        extra: {
            classes: s,
            styles: l,
            attributes: o
        }
    }, a)
}
var Go = ks.styles;
function Xo(t) {
    var e = "nest" === us.autoReplaceSvg ? $o(t, {
        styleParser: !1
    }) : $o(t);
    return ~e.extra.classes.indexOf(Zi) ? po("generateLayersText", t, e) : po("generateSvgReplacementMutation", t, e)
}
var qo = new Set;
function Ko(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    if (!Ii)
        return Promise.resolve();
    var n = Si.documentElement.classList
      , r = function(t) {
        return n.add("".concat(ji, "-").concat(t))
    }
      , i = function(t) {
        return n.remove("".concat(ji, "-").concat(t))
    }
      , s = us.autoFetchSvg ? qo : Hi.map((function(t) {
        return "fa-".concat(t)
    }
    )).concat(Object.keys(Go));
    s.includes("fa") || s.push("fa");
    var o = [".".concat(Zi, ":not([").concat(Ri, "])")].concat(s.map((function(t) {
        return ".".concat(t, ":not([").concat(Ri, "])")
    }
    ))).join(", ");
    if (0 === o.length)
        return Promise.resolve();
    var a = [];
    try {
        a = gs(t.querySelectorAll(o))
    } catch (t) {}
    if (!(a.length > 0))
        return Promise.resolve();
    r("pending"),
    i("complete");
    var l = Po.begin("onTree")
      , c = a.reduce((function(t, e) {
        try {
            var n = Xo(e);
            n && t.push(n)
        } catch (t) {
            Vi || "MissingIcon" === t.name && console.error(t)
        }
        return t
    }
    ), []);
    return new Promise((function(t, n) {
        Promise.all(c).then((function(n) {
            jo(n, (function() {
                r("active"),
                r("complete"),
                i("pending"),
                "function" == typeof e && e(),
                l(),
                t()
            }
            ))
        }
        )).catch((function(t) {
            l(),
            n(t)
        }
        ))
    }
    ))
}
function Qo(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    Xo(t).then((function(t) {
        t && jo([t], e)
    }
    ))
}
Hi.map((function(t) {
    qo.add("fa-".concat(t))
}
)),
Object.keys(Gi[Wi]).map(qo.add.bind(qo)),
Object.keys(Gi[Yi]).map(qo.add.bind(qo)),
qo = ci(qo);
var Zo = function(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , n = e.transform
      , r = void 0 === n ? fs : n
      , i = e.symbol
      , s = void 0 !== i && i
      , o = e.mask
      , a = void 0 === o ? null : o
      , l = e.maskId
      , c = void 0 === l ? null : l
      , u = e.title
      , h = void 0 === u ? null : u
      , d = e.titleId
      , f = void 0 === d ? null : d
      , p = e.classes
      , m = void 0 === p ? [] : p
      , g = e.attributes
      , y = void 0 === g ? {} : g
      , b = e.styles
      , v = void 0 === b ? {} : b;
    if (t) {
        var w = t.prefix
          , x = t.iconName
          , E = t.icon;
        return wo(ii({
            type: "icon"
        }, t), (function() {
            return fo("beforeDOMElementCreation", {
                iconDefinition: t,
                params: e
            }),
            us.autoA11y && (h ? y["aria-labelledby"] = "".concat(us.replacementClass, "-title-").concat(f || ms()) : (y["aria-hidden"] = "true",
            y.focusable = "false")),
            xo({
                icons: {
                    main: Ao(E),
                    mask: a ? Ao(a.icon) : {
                        found: !1,
                        width: null,
                        height: null,
                        icon: {}
                    }
                },
                prefix: w,
                iconName: x,
                transform: ii(ii({}, fs), r),
                symbol: s,
                title: h,
                maskId: c,
                titleId: f,
                extra: {
                    attributes: y,
                    styles: v,
                    classes: m
                }
            })
        }
        ))
    }
}
  , Jo = {
    mixout: function() {
        return {
            icon: (t = Zo,
            function(e) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , r = (e || {}).icon ? e : mo(e || {})
                  , i = n.mask;
                return i && (i = (i || {}).icon ? i : mo(i || {})),
                t(r, ii(ii({}, n), {}, {
                    mask: i
                }))
            }
            )
        };
        var t
    },
    hooks: function() {
        return {
            mutationObserverCallbacks: function(t) {
                return t.treeCallback = Ko,
                t.nodeCallback = Qo,
                t
            }
        }
    },
    provides: function(t) {
        t.i2svg = function(t) {
            var e = t.node
              , n = void 0 === e ? Si : e
              , r = t.callback;
            return Ko(n, void 0 === r ? function() {}
            : r)
        }
        ,
        t.generateSvgReplacementMutation = function(t, e) {
            var n = e.iconName
              , r = e.title
              , i = e.titleId
              , s = e.prefix
              , o = e.transform
              , a = e.symbol
              , l = e.mask
              , c = e.maskId
              , u = e.extra;
            return new Promise((function(e, h) {
                Promise.all([To(n, s), l.iconName ? To(l.iconName, l.prefix) : Promise.resolve({
                    found: !1,
                    width: 512,
                    height: 512,
                    icon: {}
                })]).then((function(l) {
                    var h = li(l, 2)
                      , d = h[0]
                      , f = h[1];
                    e([t, xo({
                        icons: {
                            main: d,
                            mask: f
                        },
                        prefix: s,
                        iconName: n,
                        transform: o,
                        symbol: a,
                        maskId: c,
                        title: r,
                        titleId: i,
                        extra: u,
                        watchable: !0
                    })])
                }
                )).catch(h)
            }
            ))
        }
        ,
        t.generateAbstractIcon = function(t) {
            var e, n = t.children, r = t.attributes, i = t.main, s = t.transform, o = vs(t.styles);
            return o.length > 0 && (r.style = o),
            ws(s) && (e = po("generateAbstractTransformGrouping", {
                main: i,
                transform: s,
                containerWidth: i.width,
                iconWidth: i.width
            })),
            n.push(e || i.icon),
            {
                children: n,
                attributes: r
            }
        }
    }
}
  , ta = {
    mixout: function() {
        return {
            layer: function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , n = e.classes
                  , r = void 0 === n ? [] : n;
                return wo({
                    type: "layer"
                }, (function() {
                    fo("beforeDOMElementCreation", {
                        assembler: t,
                        params: e
                    });
                    var n = [];
                    return t((function(t) {
                        Array.isArray(t) ? t.map((function(t) {
                            n = n.concat(t.abstract)
                        }
                        )) : n = n.concat(t.abstract)
                    }
                    )),
                    [{
                        tag: "span",
                        attributes: {
                            class: ["".concat(us.cssPrefix, "-layers")].concat(ci(r)).join(" ")
                        },
                        children: n
                    }]
                }
                ))
            }
        }
    }
}
  , ea = {
    mixout: function() {
        return {
            counter: function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , n = e.title
                  , r = void 0 === n ? null : n
                  , i = e.classes
                  , s = void 0 === i ? [] : i
                  , o = e.attributes
                  , a = void 0 === o ? {} : o
                  , l = e.styles
                  , c = void 0 === l ? {} : l;
                return wo({
                    type: "counter",
                    content: t
                }, (function() {
                    return fo("beforeDOMElementCreation", {
                        content: t,
                        params: e
                    }),
                    function(t) {
                        var e = t.content
                          , n = t.title
                          , r = t.extra
                          , i = ii(ii(ii({}, r.attributes), n ? {
                            title: n
                        } : {}), {}, {
                            class: r.classes.join(" ")
                        })
                          , s = vs(r.styles);
                        s.length > 0 && (i.style = s);
                        var o = [];
                        return o.push({
                            tag: "span",
                            attributes: i,
                            children: [e]
                        }),
                        n && o.push({
                            tag: "span",
                            attributes: {
                                class: "sr-only"
                            },
                            children: [n]
                        }),
                        o
                    }({
                        content: t.toString(),
                        title: r,
                        extra: {
                            attributes: a,
                            styles: c,
                            classes: ["".concat(us.cssPrefix, "-layers-counter")].concat(ci(s))
                        }
                    })
                }
                ))
            }
        }
    }
}
  , na = {
    mixout: function() {
        return {
            text: function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , n = e.transform
                  , r = void 0 === n ? fs : n
                  , i = e.title
                  , s = void 0 === i ? null : i
                  , o = e.classes
                  , a = void 0 === o ? [] : o
                  , l = e.attributes
                  , c = void 0 === l ? {} : l
                  , u = e.styles
                  , h = void 0 === u ? {} : u;
                return wo({
                    type: "text",
                    content: t
                }, (function() {
                    return fo("beforeDOMElementCreation", {
                        content: t,
                        params: e
                    }),
                    Eo({
                        content: t,
                        transform: ii(ii({}, fs), r),
                        title: s,
                        extra: {
                            attributes: c,
                            styles: h,
                            classes: ["".concat(us.cssPrefix, "-layers-text")].concat(ci(a))
                        }
                    })
                }
                ))
            }
        }
    },
    provides: function(t) {
        t.generateLayersText = function(t, e) {
            var n = e.title
              , r = e.transform
              , i = e.extra
              , s = null
              , o = null;
            if (Mi) {
                var a = parseInt(getComputedStyle(t).fontSize, 10)
                  , l = t.getBoundingClientRect();
                s = l.width / a,
                o = l.height / a
            }
            return us.autoA11y && !n && (i.attributes["aria-hidden"] = "true"),
            Promise.resolve([t, Eo({
                content: t.innerHTML,
                width: s,
                height: o,
                transform: r,
                title: n,
                extra: i,
                watchable: !0
            })])
        }
    }
}
  , ra = new RegExp('"',"ug")
  , ia = [1105920, 1112319];
function sa(t, e) {
    var n = "".concat(Bi).concat(e.replace(":", "-"));
    return new Promise((function(r, i) {
        if (null !== t.getAttribute(n))
            return r();
        var s, o, a, l = gs(t.children).filter((function(t) {
            return t.getAttribute(Di) === e
        }
        ))[0], c = Ai.getComputedStyle(t, e), u = c.getPropertyValue("font-family").match(Ji), h = c.getPropertyValue("font-weight"), d = c.getPropertyValue("content");
        if (l && !u)
            return t.removeChild(l),
            r();
        if (u && "none" !== d && "" !== d) {
            var f = c.getPropertyValue("content")
              , p = ~["Sharp"].indexOf(u[2]) ? Yi : Wi
              , m = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(u[2]) ? Xi[p][u[2].toLowerCase()] : ts[p][h]
              , g = function(t) {
                var e, n, r, i, s, o = t.replace(ra, ""), a = (n = 0,
                i = (e = o).length,
                (s = e.charCodeAt(n)) >= 55296 && s <= 56319 && i > n + 1 && (r = e.charCodeAt(n + 1)) >= 56320 && r <= 57343 ? 1024 * (s - 55296) + r - 56320 + 65536 : s), l = a >= ia[0] && a <= ia[1], c = 2 === o.length && o[0] === o[1];
                return {
                    value: Ns(c ? o[0] : o),
                    isSecondary: l || c
                }
            }(f)
              , y = g.value
              , b = g.isSecondary
              , v = u[0].startsWith("FontAwesome")
              , w = Zs(m, y)
              , x = w;
            if (v) {
                var E = (o = $s[s = y],
                a = Zs("fas", s),
                o || (a ? {
                    prefix: "fas",
                    iconName: a
                } : null) || {
                    prefix: null,
                    iconName: null
                });
                E.iconName && E.prefix && (w = E.iconName,
                m = E.prefix)
            }
            if (!w || b || l && l.getAttribute(Li) === m && l.getAttribute(Fi) === x)
                r();
            else {
                t.setAttribute(n, x),
                l && t.removeChild(l);
                var _ = {
                    iconName: null,
                    title: null,
                    titleId: null,
                    prefix: null,
                    transform: fs,
                    symbol: !1,
                    mask: {
                        iconName: null,
                        prefix: null,
                        rest: []
                    },
                    maskId: null,
                    extra: {
                        classes: [],
                        styles: {},
                        attributes: {}
                    }
                }
                  , A = _.extra;
                A.attributes[Di] = e,
                To(w, m).then((function(i) {
                    var s = xo(ii(ii({}, _), {}, {
                        icons: {
                            main: i,
                            mask: no()
                        },
                        prefix: m,
                        iconName: x,
                        extra: A,
                        watchable: !0
                    }))
                      , o = Si.createElement("svg");
                    "::before" === e ? t.insertBefore(o, t.firstChild) : t.appendChild(o),
                    o.outerHTML = s.map((function(t) {
                        return Cs(t)
                    }
                    )).join("\n"),
                    t.removeAttribute(n),
                    r()
                }
                )).catch(i)
            }
        } else
            r()
    }
    ))
}
function oa(t) {
    return Promise.all([sa(t, "::before"), sa(t, "::after")])
}
function aa(t) {
    return !(t.parentNode === document.head || ~zi.indexOf(t.tagName.toUpperCase()) || t.getAttribute(Di) || t.parentNode && "svg" === t.parentNode.tagName)
}
function la(t) {
    if (Ii)
        return new Promise((function(e, n) {
            var r = gs(t.querySelectorAll("*")).filter(aa).map(oa)
              , i = Po.begin("searchPseudoElements");
            zo(),
            Promise.all(r).then((function() {
                i(),
                Vo(),
                e()
            }
            )).catch((function() {
                i(),
                Vo(),
                n()
            }
            ))
        }
        ))
}
var ca = !1
  , ua = function(t) {
    return t.toLowerCase().split(" ").reduce((function(t, e) {
        var n = e.toLowerCase().split("-")
          , r = n[0]
          , i = n.slice(1).join("-");
        if (r && "h" === i)
            return t.flipX = !0,
            t;
        if (r && "v" === i)
            return t.flipY = !0,
            t;
        if (i = parseFloat(i),
        isNaN(i))
            return t;
        switch (r) {
        case "grow":
            t.size = t.size + i;
            break;
        case "shrink":
            t.size = t.size - i;
            break;
        case "left":
            t.x = t.x - i;
            break;
        case "right":
            t.x = t.x + i;
            break;
        case "up":
            t.y = t.y - i;
            break;
        case "down":
            t.y = t.y + i;
            break;
        case "rotate":
            t.rotate = t.rotate + i
        }
        return t
    }
    ), {
        size: 16,
        x: 0,
        y: 0,
        flipX: !1,
        flipY: !1,
        rotate: 0
    })
}
  , ha = {
    mixout: function() {
        return {
            parse: {
                transform: function(t) {
                    return ua(t)
                }
            }
        }
    },
    hooks: function() {
        return {
            parseNodeAttributes: function(t, e) {
                var n = e.getAttribute("data-fa-transform");
                return n && (t.transform = ua(n)),
                t
            }
        }
    },
    provides: function(t) {
        t.generateAbstractTransformGrouping = function(t) {
            var e = t.main
              , n = t.transform
              , r = t.containerWidth
              , i = t.iconWidth
              , s = {
                transform: "translate(".concat(r / 2, " 256)")
            }
              , o = "translate(".concat(32 * n.x, ", ").concat(32 * n.y, ") ")
              , a = "scale(".concat(n.size / 16 * (n.flipX ? -1 : 1), ", ").concat(n.size / 16 * (n.flipY ? -1 : 1), ") ")
              , l = "rotate(".concat(n.rotate, " 0 0)")
              , c = {
                outer: s,
                inner: {
                    transform: "".concat(o, " ").concat(a, " ").concat(l)
                },
                path: {
                    transform: "translate(".concat(i / 2 * -1, " -256)")
                }
            };
            return {
                tag: "g",
                attributes: ii({}, c.outer),
                children: [{
                    tag: "g",
                    attributes: ii({}, c.inner),
                    children: [{
                        tag: e.icon.tag,
                        children: e.icon.children,
                        attributes: ii(ii({}, e.icon.attributes), c.path)
                    }]
                }]
            }
        }
    }
}
  , da = {
    x: 0,
    y: 0,
    width: "100%",
    height: "100%"
};
function fa(t) {
    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    return t.attributes && (t.attributes.fill || e) && (t.attributes.fill = "black"),
    t
}
var pa, ma = {
    hooks: function() {
        return {
            parseNodeAttributes: function(t, e) {
                var n = e.getAttribute("data-fa-mask")
                  , r = n ? so(n.split(" ").map((function(t) {
                    return t.trim()
                }
                ))) : no();
                return r.prefix || (r.prefix = eo()),
                t.mask = r,
                t.maskId = e.getAttribute("data-fa-mask-id"),
                t
            }
        }
    },
    provides: function(t) {
        t.generateAbstractMask = function(t) {
            var e, n = t.children, r = t.attributes, i = t.main, s = t.mask, o = t.maskId, a = t.transform, l = i.width, c = i.icon, u = s.width, h = s.icon, d = function(t) {
                var e = t.transform
                  , n = t.containerWidth
                  , r = t.iconWidth
                  , i = {
                    transform: "translate(".concat(n / 2, " 256)")
                }
                  , s = "translate(".concat(32 * e.x, ", ").concat(32 * e.y, ") ")
                  , o = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") ")
                  , a = "rotate(".concat(e.rotate, " 0 0)");
                return {
                    outer: i,
                    inner: {
                        transform: "".concat(s, " ").concat(o, " ").concat(a)
                    },
                    path: {
                        transform: "translate(".concat(r / 2 * -1, " -256)")
                    }
                }
            }({
                transform: a,
                containerWidth: u,
                iconWidth: l
            }), f = {
                tag: "rect",
                attributes: ii(ii({}, da), {}, {
                    fill: "white"
                })
            }, p = c.children ? {
                children: c.children.map(fa)
            } : {}, m = {
                tag: "g",
                attributes: ii({}, d.inner),
                children: [fa(ii({
                    tag: c.tag,
                    attributes: ii(ii({}, c.attributes), d.path)
                }, p))]
            }, g = {
                tag: "g",
                attributes: ii({}, d.outer),
                children: [m]
            }, y = "mask-".concat(o || ms()), b = "clip-".concat(o || ms()), v = {
                tag: "mask",
                attributes: ii(ii({}, da), {}, {
                    id: y,
                    maskUnits: "userSpaceOnUse",
                    maskContentUnits: "userSpaceOnUse"
                }),
                children: [f, g]
            }, w = {
                tag: "defs",
                children: [{
                    tag: "clipPath",
                    attributes: {
                        id: b
                    },
                    children: (e = h,
                    "g" === e.tag ? e.children : [e])
                }, v]
            };
            return n.push(w, {
                tag: "rect",
                attributes: ii({
                    fill: "currentColor",
                    "clip-path": "url(#".concat(b, ")"),
                    mask: "url(#".concat(y, ")")
                }, da)
            }),
            {
                children: n,
                attributes: r
            }
        }
    }
};
pa = {
    mixoutsTo: bo
}.mixoutsTo,
ao = [Ss, Jo, ta, ea, na, {
    hooks: function() {
        return {
            mutationObserverCallbacks: function(t) {
                return t.pseudoElementsCallback = la,
                t
            }
        }
    },
    provides: function(t) {
        t.pseudoElements2svg = function(t) {
            var e = t.node
              , n = void 0 === e ? Si : e;
            us.searchPseudoElements && la(n)
        }
    }
}, {
    mixout: function() {
        return {
            dom: {
                unwatch: function() {
                    zo(),
                    ca = !0
                }
            }
        }
    },
    hooks: function() {
        return {
            bootstrap: function() {
                Yo(ho("mutationObserverCallbacks", {}))
            },
            noAuto: function() {
                Wo && Wo.disconnect()
            },
            watch: function(t) {
                var e = t.observeMutationsRoot;
                ca ? Vo() : Yo(ho("mutationObserverCallbacks", {
                    observeMutationsRoot: e
                }))
            }
        }
    }
}, ha, ma, {
    provides: function(t) {
        var e = !1;
        Ai.matchMedia && (e = Ai.matchMedia("(prefers-reduced-motion: reduce)").matches),
        t.missingIconAbstract = function() {
            var t = []
              , n = {
                fill: "currentColor"
            }
              , r = {
                attributeType: "XML",
                repeatCount: "indefinite",
                dur: "2s"
            };
            t.push({
                tag: "path",
                attributes: ii(ii({}, n), {}, {
                    d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
                })
            });
            var i = ii(ii({}, r), {}, {
                attributeName: "opacity"
            })
              , s = {
                tag: "circle",
                attributes: ii(ii({}, n), {}, {
                    cx: "256",
                    cy: "364",
                    r: "28"
                }),
                children: []
            };
            return e || s.children.push({
                tag: "animate",
                attributes: ii(ii({}, r), {}, {
                    attributeName: "r",
                    values: "28;14;28;28;14;28;"
                })
            }, {
                tag: "animate",
                attributes: ii(ii({}, i), {}, {
                    values: "1;0;1;1;0;1;"
                })
            }),
            t.push(s),
            t.push({
                tag: "path",
                attributes: ii(ii({}, n), {}, {
                    opacity: "1",
                    d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
                }),
                children: e ? [] : [{
                    tag: "animate",
                    attributes: ii(ii({}, i), {}, {
                        values: "1;0;0;0;0;1;"
                    })
                }]
            }),
            e || t.push({
                tag: "path",
                attributes: ii(ii({}, n), {}, {
                    opacity: "0",
                    d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
                }),
                children: [{
                    tag: "animate",
                    attributes: ii(ii({}, i), {}, {
                        values: "0;0;1;1;0;0;"
                    })
                }]
            }),
            {
                tag: "g",
                attributes: {
                    class: "missing"
                },
                children: t
            }
        }
    }
}, {
    hooks: function() {
        return {
            parseNodeAttributes: function(t, e) {
                var n = e.getAttribute("data-fa-symbol")
                  , r = null !== n && ("" === n || n);
                return t.symbol = r,
                t
            }
        }
    }
}],
lo = {},
Object.keys(co).forEach((function(t) {
    -1 === uo.indexOf(t) && delete co[t]
}
)),
ao.forEach((function(t) {
    var e = t.mixout ? t.mixout() : {};
    if (Object.keys(e).forEach((function(t) {
        "function" == typeof e[t] && (pa[t] = e[t]),
        "object" === si(e[t]) && Object.keys(e[t]).forEach((function(n) {
            pa[t] || (pa[t] = {}),
            pa[t][n] = e[t][n]
        }
        ))
    }
    )),
    t.hooks) {
        var n = t.hooks();
        Object.keys(n).forEach((function(t) {
            lo[t] || (lo[t] = []),
            lo[t].push(n[t])
        }
        ))
    }
    t.provides && t.provides(co)
}
));
var ga, ya = bo.library, ba = bo.parse, va = bo.icon;
ga = o("hOzOt")();
d = o("acw62");
function wa(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter((function(e) {
            return Object.getOwnPropertyDescriptor(t, e).enumerable
        }
        ))),
        n.push.apply(n, r)
    }
    return n
}
function xa(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = null != arguments[e] ? arguments[e] : {};
        e % 2 ? wa(Object(n), !0).forEach((function(e) {
            _a(t, e, n[e])
        }
        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : wa(Object(n)).forEach((function(e) {
            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
        }
        ))
    }
    return t
}
function Ea(t) {
    return Ea = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    Ea(t)
}
function _a(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n,
    t
}
function Aa(t, e) {
    if (null == t)
        return {};
    var n, r, i = function(t, e) {
        if (null == t)
            return {};
        var n, r, i = {}, s = Object.keys(t);
        for (r = 0; r < s.length; r++)
            n = s[r],
            e.indexOf(n) >= 0 || (i[n] = t[n]);
        return i
    }(t, e);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(t);
        for (r = 0; r < s.length; r++)
            n = s[r],
            e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
    }
    return i
}
function Sa(t) {
    return function(t) {
        if (Array.isArray(t))
            return Ta(t)
    }(t) || function(t) {
        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"])
            return Array.from(t)
    }(t) || function(t, e) {
        if (!t)
            return;
        if ("string" == typeof t)
            return Ta(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        "Object" === n && t.constructor && (n = t.constructor.name);
        if ("Map" === n || "Set" === n)
            return Array.from(t);
        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return Ta(t, e)
    }(t) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }()
}
function Ta(t, e) {
    (null == e || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++)
        r[n] = t[n];
    return r
}
function ka(t) {
    return function(t) {
        return (t -= 0) == t
    }(t) ? t : (t = t.replace(/[\-_\s]+(.)?/g, (function(t, e) {
        return e ? e.toUpperCase() : ""
    }
    ))).substr(0, 1).toLowerCase() + t.substr(1)
}
var Ia = ["style"];
var Ma = !1;
try {
    Ma = !0
} catch (t) {}
function Ca(t) {
    return t && "object" === Ea(t) && t.prefix && t.iconName && t.icon ? t : ba.icon ? ba.icon(t) : null === t ? null : t && "object" === Ea(t) && t.prefix && t.iconName ? t : Array.isArray(t) && 2 === t.length ? {
        prefix: t[0],
        iconName: t[1]
    } : "string" == typeof t ? {
        prefix: "fas",
        iconName: t
    } : void 0
}
function Pa(t, e) {
    return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? _a({}, t, e) : {}
}
var Oa = e(d).forwardRef((function(t, e) {
    var n = t.icon
      , r = t.mask
      , i = t.symbol
      , s = t.className
      , o = t.title
      , a = t.titleId
      , l = t.maskId
      , c = Ca(n)
      , u = Pa("classes", [].concat(Sa(function(t) {
        var e, n = t.beat, r = t.fade, i = t.beatFade, s = t.bounce, o = t.shake, a = t.flash, l = t.spin, c = t.spinPulse, u = t.spinReverse, h = t.pulse, d = t.fixedWidth, f = t.inverse, p = t.border, m = t.listItem, g = t.flip, y = t.size, b = t.rotation, v = t.pull, w = (_a(e = {
            "fa-beat": n,
            "fa-fade": r,
            "fa-beat-fade": i,
            "fa-bounce": s,
            "fa-shake": o,
            "fa-flash": a,
            "fa-spin": l,
            "fa-spin-reverse": u,
            "fa-spin-pulse": c,
            "fa-pulse": h,
            "fa-fw": d,
            "fa-inverse": f,
            "fa-border": p,
            "fa-li": m,
            "fa-flip": !0 === g,
            "fa-flip-horizontal": "horizontal" === g || "both" === g,
            "fa-flip-vertical": "vertical" === g || "both" === g
        }, "fa-".concat(y), null != y),
        _a(e, "fa-rotate-".concat(b), null != b && 0 !== b),
        _a(e, "fa-pull-".concat(v), null != v),
        _a(e, "fa-swap-opacity", t.swapOpacity),
        e);
        return Object.keys(w).map((function(t) {
            return w[t] ? t : null
        }
        )).filter((function(t) {
            return t
        }
        ))
    }(t)), Sa(s.split(" "))))
      , h = Pa("transform", "string" == typeof t.transform ? ba.transform(t.transform) : t.transform)
      , d = Pa("mask", Ca(r))
      , f = va(c, xa(xa(xa(xa({}, u), h), d), {}, {
        symbol: i,
        title: o,
        titleId: a,
        maskId: l
    }));
    if (!f)
        return function() {
            var t;
            !Ma && console && "function" == typeof console.error && (t = console).error.apply(t, arguments)
        }("Could not find icon", c),
        null;
    var p = f.abstract
      , m = {
        ref: e
    };
    return Object.keys(t).forEach((function(e) {
        Oa.defaultProps.hasOwnProperty(e) || (m[e] = t[e])
    }
    )),
    Na(p[0], m)
}
));
Oa.displayName = "FontAwesomeIcon",
Oa.propTypes = {
    beat: e(ga).bool,
    border: e(ga).bool,
    beatFade: e(ga).bool,
    bounce: e(ga).bool,
    className: e(ga).string,
    fade: e(ga).bool,
    flash: e(ga).bool,
    mask: e(ga).oneOfType([e(ga).object, e(ga).array, e(ga).string]),
    maskId: e(ga).string,
    fixedWidth: e(ga).bool,
    inverse: e(ga).bool,
    flip: e(ga).oneOf([!0, !1, "horizontal", "vertical", "both"]),
    icon: e(ga).oneOfType([e(ga).object, e(ga).array, e(ga).string]),
    listItem: e(ga).bool,
    pull: e(ga).oneOf(["right", "left"]),
    pulse: e(ga).bool,
    rotation: e(ga).oneOf([0, 90, 180, 270]),
    shake: e(ga).bool,
    size: e(ga).oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
    spin: e(ga).bool,
    spinPulse: e(ga).bool,
    spinReverse: e(ga).bool,
    symbol: e(ga).oneOfType([e(ga).bool, e(ga).string]),
    title: e(ga).string,
    titleId: e(ga).string,
    transform: e(ga).oneOfType([e(ga).string, e(ga).object]),
    swapOpacity: e(ga).bool
},
Oa.defaultProps = {
    border: !1,
    className: "",
    mask: null,
    maskId: null,
    fixedWidth: !1,
    inverse: !1,
    flip: !1,
    icon: null,
    listItem: !1,
    pull: null,
    pulse: !1,
    rotation: null,
    size: null,
    spin: !1,
    spinPulse: !1,
    spinReverse: !1,
    beat: !1,
    fade: !1,
    beatFade: !1,
    bounce: !1,
    shake: !1,
    symbol: !1,
    title: "",
    titleId: null,
    transform: null,
    swapOpacity: !1
};
var Na = function t(e, n) {
    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if ("string" == typeof n)
        return n;
    var i = (n.children || []).map((function(n) {
        return t(e, n)
    }
    ))
      , s = Object.keys(n.attributes || {}).reduce((function(t, e) {
        var r = n.attributes[e];
        switch (e) {
        case "class":
            t.attrs.className = r,
            delete n.attributes.class;
            break;
        case "style":
            t.attrs.style = r.split(";").map((function(t) {
                return t.trim()
            }
            )).filter((function(t) {
                return t
            }
            )).reduce((function(t, e) {
                var n, r = e.indexOf(":"), i = ka(e.slice(0, r)), s = e.slice(r + 1).trim();
                return i.startsWith("webkit") ? t[(n = i,
                n.charAt(0).toUpperCase() + n.slice(1))] = s : t[i] = s,
                t
            }
            ), {});
            break;
        default:
            0 === e.indexOf("aria-") || 0 === e.indexOf("data-") ? t.attrs[e.toLowerCase()] = r : t.attrs[ka(e)] = r
        }
        return t
    }
    ), {
        attrs: {}
    })
      , o = r.style
      , a = void 0 === o ? {} : o
      , l = Aa(r, Ia);
    return s.attrs.style = xa(xa({}, s.attrs.style), a),
    e.apply(void 0, [n.tag, xa(xa({}, s.attrs), l)].concat(Sa(i)))
}
.bind(null, e(d).createElement);
o("acw62");
var Ra, Da, Ba, La, Fa, ja, Ua, za, Va, Wa, Ya, Ha, $a = {};
t($a, "no-padding", (()=>Ra), (t=>Ra = t)),
t($a, "warning", (()=>Da), (t=>Da = t)),
t($a, "content", (()=>Ba), (t=>Ba = t)),
t($a, "loading", (()=>La), (t=>La = t)),
t($a, "success", (()=>Fa), (t=>Fa = t)),
t($a, "no-color", (()=>ja), (t=>ja = t)),
t($a, "selected", (()=>Ua), (t=>Ua = t)),
t($a, "button", (()=>za), (t=>za = t)),
t($a, "gray", (()=>Va), (t=>Va = t)),
t($a, "icon", (()=>Wa), (t=>Wa = t)),
t($a, "floating", (()=>Ya), (t=>Ya = t)),
t($a, "children", (()=>Ha), (t=>Ha = t)),
Ra = "FtH_eW_no-padding",
Da = "FtH_eW_warning",
Ba = "FtH_eW_content",
La = "FtH_eW_loading",
Fa = "FtH_eW_success",
ja = "FtH_eW_no-color",
Ua = "FtH_eW_selected",
za = "FtH_eW_button",
Va = "FtH_eW_gray",
Wa = "FtH_eW_icon",
Ya = "FtH_eW_floating",
Ha = "FtH_eW_children";
const Ga = ({children: t, loading: n, loadingWithChildren: r=!1, className: i, disabled: s, ...o})=>(0,
a.jsx)("button", {
    className: Tr(e($a), `button ${n ? "loading" : ""} ${i ?? ""}`),
    disabled: s,
    ...o,
    children: n ? (0,
    a.jsxs)("div", {
        className: Tr(e($a), "content " + (r ? "" : "floating")),
        children: [(0,
        a.jsx)(Oa, {
            spin: !0,
            icon: "circle-notch"
        }), (0,
        a.jsx)("div", {
            className: Tr(e($a), "children"),
            children: t
        })]
    }) : t
})
  , Xa = ({icon: t, flip: n, size: r="1x", className: i, loadingWithChildren: s, children: o, loading: l, iconProps: c, ...u})=>(0,
a.jsxs)(Ga, {
    className: Tr(e($a), `icon ${i}`),
    loading: l,
    loadingWithChildren: s,
    ...u,
    children: [!l && (0,
    a.jsx)(Oa, {
        flip: n,
        icon: t,
        size: r,
        ...c
    }), o]
});
d = o("acw62");
var qa, Ka = {};
t(Ka, "input", (()=>qa), (t=>qa = t)),
qa = "Cqapla_input";
const Qa = e(d).forwardRef((({className: t, ...n},r)=>(0,
a.jsx)("input", {
    ref: r,
    className: Tr(e(Ka), `input ${t}`),
    ...n
})));
var Za, Ja, tl, el, nl, rl, il, sl, ol, al, ll, cl, ul, hl = {};
t(hl, "loading-content", (()=>Za), (t=>Za = t)),
t(hl, "content", (()=>Ja), (t=>Ja = t)),
t(hl, "background", (()=>tl), (t=>tl = t)),
t(hl, "modal", (()=>el), (t=>el = t)),
t(hl, "input", (()=>nl), (t=>nl = t)),
t(hl, "loading-modal", (()=>rl), (t=>rl = t)),
t(hl, "text", (()=>il), (t=>il = t)),
t(hl, "footer", (()=>sl), (t=>sl = t)),
t(hl, "no-blur", (()=>ol), (t=>ol = t)),
t(hl, "full-size", (()=>al), (t=>al = t)),
t(hl, "title", (()=>ll), (t=>ll = t)),
t(hl, "container", (()=>cl), (t=>cl = t)),
t(hl, "image", (()=>ul), (t=>ul = t)),
Za = "B9uqDG_loading-content",
Ja = "B9uqDG_content",
tl = "B9uqDG_background",
el = "B9uqDG_modal",
nl = "B9uqDG_input",
rl = "B9uqDG_loading-modal",
il = "B9uqDG_text",
sl = "B9uqDG_footer",
ol = "B9uqDG_no-blur",
al = "B9uqDG_full-size",
ll = "B9uqDG_title",
cl = "B9uqDG_container",
ul = "B9uqDG_image";
const dl = ({show: t, children: n, zIndex: r, className: i, onClickBackground: s, containerClassName: o, ...l})=>{
    const c = (0,
    d.useRef)(null);
    return (0,
    a.jsx)(ni, {
        in: t,
        nodeRef: c,
        timeout: 150,
        classNames: {
            enter: "transition-enter",
            enterActive: "transition-enter-active",
            exit: "transition-exit",
            exitActive: "transition-exit-active"
        },
        unmountOnExit: !0,
        ...l,
        children: (0,
        a.jsxs)("div", {
            ref: c,
            className: Tr(e(hl), `modal ${i || ""}`),
            style: {
                zIndex: r
            },
            children: [(0,
            a.jsx)("div", {
                className: Tr(e(hl), "background"),
                onClick: s
            }), (0,
            a.jsx)("div", {
                className: Tr(e(hl), `container ${o || ""}`),
                children: n
            })]
        })
    })
}
  , fl = ({image: t, title: n, text: r, input: i, footer: s, ...o})=>(0,
a.jsx)(dl, {
    containerClassName: "full-size " + (t ? "image" : ""),
    ...o,
    children: (0,
    a.jsxs)(a.Fragment, {
        children: [t && (0,
        a.jsx)("img", {
            src: t
        }), (0,
        a.jsxs)("div", {
            className: Tr(e(hl), "content"),
            children: [(0,
            a.jsx)("div", {
                className: Tr(e(hl), "title"),
                children: n
            }), (0,
            a.jsxs)("div", {
                className: Tr(e(hl), "text"),
                children: [r, i && (0,
                a.jsx)("div", {
                    className: Tr(e(hl), "input"),
                    children: i
                })]
            }), (0,
            a.jsx)("div", {
                className: Tr(e(hl), "footer"),
                children: s
            })]
        })]
    })
})
  , pl = ({progress: t, loadingText: n="Loading...", className: r, ...i})=>(0,
a.jsx)(dl, {
    ...i,
    children: (0,
    a.jsx)("div", {
        className: Tr(e(hl), `modal loading-modal ${r ?? ""}`),
        children: (0,
        a.jsxs)("div", {
            className: Tr(e(hl), "loading-content"),
            children: [n, void 0 !== t ? (0,
            a.jsxs)(a.Fragment, {
                children: [(0,
                a.jsx)("br", {}), `${t}%`]
            }) : ""]
        })
    })
})
  , ml = ({closeText: t="close", onClose: n, copyText: r, ...i})=>{
    const s = (0,
    a.jsxs)(a.Fragment, {
        children: [r && (0,
        a.jsx)(Ga, {
            onClick: ()=>{
                e(Nr)(r) ? pe.success("Text copied!", {
                    pauseOnFocusLoss: !1
                }) : pe.warn("Impossible to copy the text! Copy manually :-)", {
                    pauseOnFocusLoss: !1
                })
            }
            ,
            children: "copy"
        }), (0,
        a.jsx)(Ga, {
            className: Tr(e(hl), "gray"),
            onClick: n,
            children: t
        })]
    });
    return (0,
    a.jsx)(fl, {
        footer: s,
        ...i
    })
}
  , gl = ({acceptText: t="ok", refuseText: n, onAccept: r, onRefuse: i, ...s})=>{
    const o = (0,
    a.jsxs)(a.Fragment, {
        children: [n && (0,
        a.jsx)(Ga, {
            className: Tr(e(hl), "gray"),
            onClick: i,
            children: n
        }), (0,
        a.jsx)(Ga, {
            onClick: r,
            children: t
        })]
    });
    return (0,
    a.jsx)(fl, {
        footer: o,
        ...s
    })
}
  , yl = ({inputProps: t, acceptText: n="ok", refuseText: r, onAccept: i, onRefuse: s, ...o})=>{
    const [l,c] = (0,
    d.useState)("")
      , u = (0,
    a.jsxs)(a.Fragment, {
        children: [r && (0,
        a.jsx)(Ga, {
            className: Tr(e(hl), "gray"),
            onClick: s,
            children: r
        }), (0,
        a.jsx)(Ga, {
            onClick: ()=>i(l),
            children: n
        })]
    })
      , h = (0,
    a.jsx)(Qa, {
        ...t,
        className: Tr(e(hl), `${t?.className} input`),
        value: l,
        onChange: t=>{
            c(t.target.value)
        }
        ,
        autoFocus: !0
    });
    return (0,
    a.jsx)(fl, {
        footer: u,
        input: h,
        ...o
    })
}
;
d = o("acw62");
const bl = {}
  , vl = (t,e)=>{
    switch (e.type) {
    case "SET_IS_LEDGER":
        return e.isLedger ? Mr("isLedger", e.isLedger) : Cr("isLedger"),
        {
            ...t,
            isLedger: e.isLedger
        };
    case "SET_TWITTER_USERNAME":
        return e.twitterUsername ? Mr("twitterUsername", e.twitterUsername) : Cr("twitterUsername"),
        {
            ...t,
            twitterUsername: e.twitterUsername
        };
    case "SET_DISCORD_USERNAME":
        return e.discordUsername ? Mr("discordUsername", e.discordUsername) : Cr("discordUsername"),
        {
            ...t,
            discordUsername: e.discordUsername
        };
    case "SET_DISCORD_SERVER_JOINED":
        return e.discordServerJoined ? Mr("discordServerJoined", e.discordServerJoined) : Cr("discordServerJoined"),
        {
            ...t,
            discordServerJoined: e.discordServerJoined
        };
    case "SET_USERNAME":
        return e.username ? Mr("username", e.username) : Cr("username"),
        {
            ...t,
            username: e.username
        };
    case "SET_SESSION_TOKEN":
        return e.sessionToken ? Mr("sessionToken", e.sessionToken) : Cr("sessionToken"),
        {
            ...t,
            sessionToken: e.sessionToken
        };
    case "SET_PUBLIC_KEY":
        return void 0 === e.publicKey ? Cr("publicKey") : Mr("publicKey", e.publicKey),
        {
            ...t,
            publicKey: e.publicKey
        };
    case "SET_DISCONNECT_WALLET":
        return {
            ...t,
            disconnectWallet: e.disconnectWallet
        };
    case "SET_SHOW_CONNECT_MODAL":
        return {
            ...t,
            showConnectModal: e.showConnectModal
        };
    case "SET_USER_UUID":
        return void 0 === e.userUuid ? Cr("userUuid") : Mr("userUuid", e.userUuid),
        {
            ...t,
            userUuid: e.userUuid
        };
    default:
        return t
    }
}
;
let wl = {};
const xl = kr();
xl && (wl = {
    ...wl,
    ...xl
},
bl.sessionToken = xl.sessionToken);
const El = (0,
d.createContext)({
    state: wl,
    dispatch: ()=>null
})
  , _l = ({children: t})=>{
    const [e,n] = (0,
    d.useReducer)(vl, wl);
    return (0,
    a.jsx)(El.Provider, {
        value: {
            state: e,
            dispatch: n
        },
        children: t
    })
}
  , Al = ()=>(0,
d.useContext)(El)
  , Sl = ()=>{
    const {dispatch: t, state: {disconnectWallet: e}} = Al()
      , n = ft();
    return {
        disconnect: ()=>{
            t({
                type: "SET_SESSION_TOKEN",
                sessionToken: void 0
            }),
            t({
                type: "SET_PUBLIC_KEY",
                publicKey: void 0
            }),
            t({
                type: "SET_TWITTER_USERNAME",
                twitterUsername: void 0
            }),
            t({
                type: "SET_DISCORD_USERNAME",
                discordUsername: void 0
            }),
            e && e(),
            localStorage.removeItem("sessionInfo"),
            n("/")
        }
    }
}
;
var Tl, kl, Il, Ml, Cl, Pl = {};
t(Pl, "custom-toast", (()=>Tl), (t=>Tl = t)),
t(Pl, "buttons", (()=>kl), (t=>kl = t)),
t(Pl, "hub-layout", (()=>Il), (t=>Il = t)),
t(Pl, "container", (()=>Ml), (t=>Ml = t)),
t(Pl, "purple", (()=>Cl), (t=>Cl = t)),
Tl = "_2K0JEG_custom-toast",
kl = "_2K0JEG_buttons",
Il = "_2K0JEG_hub-layout",
Ml = "_2K0JEG_container",
Cl = "_2K0JEG_purple";
const Ol = ()=>{
    const {disconnect: t} = Sl()
      , {dispatch: n} = Al()
      , [r,i] = (0,
    d.useState)(!1)
      , [s,o] = (0,
    d.useState)()
      , [l,c] = (0,
    d.useState)({
        show: !1
    })
      , [u,h] = (0,
    d.useState)({
        show: !1
    })
      , [f,p] = (0,
    d.useState)({
        show: !1
    })
      , [m,g] = (0,
    d.useState)(!1)
      , [y,b] = (0,
    d.useState)(0)
      , [v,w] = (0,
    d.useState)();
    return (0,
    d.useEffect)((()=>{
        bl.disconnect = t,
        bl.showModal = ({title: t, text: e, copyText: n, image: r, closeText: i, onClose: s})=>{
            g(!1),
            h({
                show: !1
            }),
            p({
                show: !1
            }),
            c({
                show: !0,
                title: t,
                text: e,
                closeText: i,
                copyText: n,
                image: r,
                onClose: s
            })
        }
        ,
        bl.showConfirm = ({title: t, text: e, image: n, acceptText: r, refuseText: i, onAccept: s, onRefuse: o})=>{
            g(!1),
            c({
                show: !1
            }),
            p({
                show: !1
            }),
            h({
                show: !0,
                title: t,
                text: e,
                image: n,
                acceptText: r,
                refuseText: i,
                onAccept: s,
                onRefuse: o
            })
        }
        ,
        bl.showInputModal = ({title: t, text: e, image: n, inputProps: r, acceptText: i, refuseText: s, onAccept: o, onRefuse: a})=>{
            g(!1),
            c({
                show: !1
            }),
            h({
                show: !1
            }),
            p({
                show: !0,
                title: t,
                text: e,
                image: n,
                inputProps: r,
                acceptText: i,
                refuseText: s,
                onAccept: o,
                onRefuse: a
            })
        }
        ,
        bl.showLoading = (t,e,n)=>{
            g(t),
            b(e),
            w(n)
        }
        ,
        bl.setSessionToken = t=>{
            n({
                type: "SET_SESSION_TOKEN",
                sessionToken: t
            })
        }
    }
    ), []),
    (0,
    d.useEffect)((()=>{
        const t = async()=>{
            let t;
            try {
                t = await _r()
            } catch (t) {
                return !1
            }
            if (!t)
                return !1;
            const e = "hub"
              , n = t[e]
              , {fromDate: r, toDate: i, id: s, message: a} = n;
            return !!(r && i && a) && (Date.now() >= new Date(r).getTime() && Date.now() <= new Date(i).getTime() && bl.showConfirm ? (o(t.hub),
            bl.showConfirm({
                title: "Website under maintenance",
                text: a.replace("${fromDate}", new Date(r).toLocaleString()).replace("${toDate}", new Date(i).toLocaleString()),
                acceptText: "go to website",
                onAccept() {
                    window.location.href = "https://meegos.io"
                }
            }),
            !0) : !!(Pr(e, s) && Date.now() < new Date(r).getTime() && bl.showConfirm) && (o(void 0),
            bl.showConfirm({
                title: "Maintenance coming",
                text: a.replace("${fromDate}", new Date(r).toLocaleString()).replace("${toDate}", new Date(i).toLocaleString()),
                acceptText: "understood",
                onAccept() {
                    Or(e, s)
                }
            }),
            !1))
        }
          , e = setInterval(t, 6e4);
        return t().then((t=>{
            i(!t)
        }
        )),
        ()=>{
            clearInterval(e)
        }
    }
    ), []),
    (0,
    a.jsxs)("div", {
        className: Tr(e(Pl), "hub-layout"),
        children: [r && !s && (0,
        a.jsx)(kt, {}), (0,
        a.jsx)(ml, {
            ...l,
            onClose: ()=>{
                l.onClose && l.onClose(),
                c({
                    show: !1
                })
            }
        }), (0,
        a.jsx)(gl, {
            ...u,
            onAccept: ()=>{
                u.onAccept && u.onAccept(),
                h({
                    show: !1
                })
            }
            ,
            onRefuse: ()=>{
                u.onRefuse && u.onRefuse(),
                h({
                    show: !1
                })
            }
        }), (0,
        a.jsx)(yl, {
            ...f,
            onAccept: t=>{
                f.onAccept && f.onAccept(t),
                p({
                    show: !1
                })
            }
            ,
            onRefuse: ()=>{
                f.onRefuse && f.onRefuse(),
                p({
                    show: !1
                })
            }
        }), (0,
        a.jsx)(pl, {
            show: m,
            progress: y,
            loadingText: v
        }), (0,
        a.jsx)(ie, {
            toastClassName: Tr(e(Pl), "custom-toast"),
            theme: "dark",
            transition: re,
            autoClose: 3e3
        })]
    })
}
;
o("acw62");
Er = o("gNDby"),
d = o("acw62");
const Nl = (0,
(d = o("acw62")).createContext)({});
function Rl() {
    return (0,
    d.useContext)(Nl)
}
const Dl = ({children: t, endpoint: n, config: r={
    commitment: "confirmed"
}})=>{
    const i = (0,
    d.useMemo)((()=>new (0,
    Er.Connection)(n,r)), [n, r]);
    return e(d).createElement(Nl.Provider, {
        value: {
            connection: i
        }
    }, t)
}
;
var Bl, Ll, Fl = o("3vRz3");
class jl extends Error {
    constructor(t, e) {
        super(t),
        this.error = e
    }
}
class Ul extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletNotReadyError"
    }
}
class zl extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletLoadError"
    }
}
class Vl extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletConfigError"
    }
}
class Wl extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletConnectionError"
    }
}
class Yl extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectedError"
    }
}
class Hl extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectionError"
    }
}
class $l extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletAccountError"
    }
}
class Gl extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletPublicKeyError"
    }
}
class Xl extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletNotConnectedError"
    }
}
class ql extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletSendTransactionError"
    }
}
class Kl extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletSignMessageError"
    }
}
class Ql extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletSignTransactionError"
    }
}
(Ll = Bl || (Bl = {})).Installed = "Installed",
Ll.NotDetected = "NotDetected",
Ll.Loadable = "Loadable",
Ll.Unsupported = "Unsupported";
class Zl extends (e(Fl)) {
    get connected() {
        return !!this.publicKey
    }
    async autoConnect() {
        await this.connect()
    }
    async prepareTransaction(t, e, n={}) {
        const r = this.publicKey;
        if (!r)
            throw new Xl;
        return t.feePayer = t.feePayer || r,
        t.recentBlockhash = t.recentBlockhash || (await e.getLatestBlockhash({
            commitment: n.preflightCommitment,
            minContextSlot: n.minContextSlot
        })).blockhash,
        t
    }
}
function Jl(t) {
    if ("undefined" == typeof window || "undefined" == typeof document)
        return;
    const e = [];
    function n() {
        if (t())
            for (const t of e)
                t()
    }
    const r = setInterval(n, 1e3);
    e.push((()=>clearInterval(r))),
    "loading" === document.readyState && (document.addEventListener("DOMContentLoaded", n, {
        once: !0
    }),
    e.push((()=>document.removeEventListener("DOMContentLoaded", n)))),
    "complete" !== document.readyState && (window.addEventListener("load", n, {
        once: !0
    }),
    e.push((()=>window.removeEventListener("load", n)))),
    n()
}
function tc() {
    if (!navigator)
        return !1;
    const t = navigator.userAgent.toLowerCase()
      , e = t.includes("iphone") || t.includes("ipad")
      , n = t.includes("safari");
    return e && n
}
function ec(t) {
    return "version"in t
}
class nc extends Zl {
    async sendTransaction(t, e, n={}) {
        let r = !0;
        try {
            if (ec(t)) {
                if (!this.supportedTransactionVersions)
                    throw new ql("Sending versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has(t.version))
                    throw new ql(`Sending transaction version ${t.version} isn't supported by this wallet`);
                try {
                    const r = (t = await this.signTransaction(t)).serialize();
                    return await e.sendRawTransaction(r, n)
                } catch (t) {
                    if (t instanceof Ql)
                        throw r = !1,
                        t;
                    throw new ql(t?.message,t)
                }
            } else
                try {
                    const {signers: r, ...i} = n;
                    t = await this.prepareTransaction(t, e, i),
                    r?.length && t.partialSign(...r);
                    const s = (t = await this.signTransaction(t)).serialize();
                    return await e.sendRawTransaction(s, i)
                } catch (t) {
                    if (t instanceof Ql)
                        throw r = !1,
                        t;
                    throw new ql(t?.message,t)
                }
        } catch (t) {
            throw r && this.emit("error", t),
            t
        }
    }
    async signAllTransactions(t) {
        for (const e of t)
            if (ec(e)) {
                if (!this.supportedTransactionVersions)
                    throw new Ql("Signing versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has(e.version))
                    throw new Ql(`Signing transaction version ${e.version} isn't supported by this wallet`)
            }
        const e = [];
        for (const n of t)
            e.push(await this.signTransaction(n));
        return e
    }
}
class rc extends nc {
}
Er = o("gNDby"),
Er = o("gNDby");
const ic = {
    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
    ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
    ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
    ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
    ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
    ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND"
};
class sc extends Error {
    constructor(...t) {
        const [e,n,r] = t;
        super(n),
        this.code = e,
        this.data = r,
        this.name = "SolanaMobileWalletAdapterError"
    }
}
class oc extends Error {
    constructor(...t) {
        const [e,n,r,i] = t;
        super(r),
        this.code = n,
        this.data = i,
        this.jsonRpcMessageId = e,
        this.name = "SolanaMobileWalletAdapterProtocolError"
    }
}
function ac(t, e, n, r) {
    return new (n || (n = Promise))((function(i, s) {
        function o(t) {
            try {
                l(r.next(t))
            } catch (t) {
                s(t)
            }
        }
        function a(t) {
            try {
                l(r.throw(t))
            } catch (t) {
                s(t)
            }
        }
        function l(t) {
            var e;
            t.done ? i(t.value) : (e = t.value,
            e instanceof n ? e : new n((function(t) {
                t(e)
            }
            ))).then(o, a)
        }
        l((r = r.apply(t, e || [])).next())
    }
    ))
}
const lc = 4;
const uc = 12;
function hc(t, e) {
    return ac(this, void 0, void 0, (function*() {
        const n = JSON.stringify(t)
          , r = function(t) {
            if (t >= 4294967296)
                throw new Error("Outbound sequence number overflow. The maximum sequence number is 32-bytes.");
            const e = new ArrayBuffer(lc);
            return new DataView(e).setUint32(0, t, !1),
            new Uint8Array(e)
        }(t.id)
          , i = new Uint8Array(uc);
        crypto.getRandomValues(i);
        const s = yield crypto.subtle.encrypt(fc(r, i), e, (new TextEncoder).encode(n))
          , o = new Uint8Array(r.byteLength + i.byteLength + s.byteLength);
        return o.set(new Uint8Array(r), 0),
        o.set(new Uint8Array(i), r.byteLength),
        o.set(new Uint8Array(s), r.byteLength + i.byteLength),
        o
    }
    ))
}
function dc(t, e) {
    return ac(this, void 0, void 0, (function*() {
        const n = t.slice(0, lc)
          , r = t.slice(lc, lc + uc)
          , i = t.slice(lc + uc)
          , s = yield crypto.subtle.decrypt(fc(n, r), e, i)
          , o = function() {
            void 0 === pc && (pc = new TextDecoder("utf-8"));
            return pc
        }().decode(s)
          , a = JSON.parse(o);
        if (Object.hasOwnProperty.call(a, "error"))
            throw new oc(a.id,a.error.code,a.error.message);
        return a
    }
    ))
}
function fc(t, e) {
    return {
        additionalData: t,
        iv: e,
        name: "AES-GCM",
        tagLength: 128
    }
}
let pc;
function mc(t) {
    if (t < 49152 || t > 65535)
        throw new sc(ic.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE,`Association port number must be between 49152 and 65535. ${t} given.`,{
            port: t
        });
    return t
}
const gc = "solana-wallet";
function yc(t) {
    return t.replace(/(^\/+|\/+$)/g, "").split("/")
}
function bc(t, e, n) {
    return ac(this, void 0, void 0, (function*() {
        const r = mc(e)
          , i = function(t) {
            let e = "";
            const n = new Uint8Array(t)
              , r = n.byteLength;
            for (let t = 0; t < r; t++)
                e += String.fromCharCode(n[t]);
            return window.btoa(e)
        }(yield crypto.subtle.exportKey("raw", t))
          , s = function(t, e) {
            let n = null;
            if (e) {
                try {
                    n = new URL(e)
                } catch (t) {}
                if ("https:" !== (null == n ? void 0 : n.protocol))
                    throw new sc(ic.ERROR_FORBIDDEN_WALLET_BASE_URL,"Base URLs supplied by wallets must be valid `https` URLs")
            }
            n || (n = new URL(`${gc}:/`));
            const r = t.startsWith("/") ? t : [...yc(n.pathname), ...yc(t)].join("/");
            return new URL(r,n)
        }("v1/associate/local", n);
        return s.searchParams.set("association", i.replace(/[/+=]/g, (t=>({
            "/": "_",
            "+": "-",
            "=": "."
        }[t])))),
        s.searchParams.set("port", `${r}`),
        s
    }
    ))
}
const vc = {
    Firefox: 0,
    Other: 1
};
let wc = null;
function xc(t, e) {
    return ac(this, void 0, void 0, (function*() {
        const n = mc(49152 + Math.floor(16384 * Math.random()))
          , r = yield bc(t, n, e);
        if ("https:" === r.protocol)
            window.location.assign(r);
        else
            try {
                const t = -1 !== navigator.userAgent.indexOf("Firefox/") ? vc.Firefox : vc.Other;
                switch (t) {
                case vc.Firefox:
                    i = r,
                    null == wc && (wc = document.createElement("iframe"),
                    wc.style.display = "none",
                    document.body.appendChild(wc)),
                    wc.contentWindow.location.href = i.toString();
                    break;
                case vc.Other:
                    {
                        const t = new Promise(((t,e)=>{
                            function n() {
                                clearTimeout(i),
                                window.removeEventListener("blur", r)
                            }
                            function r() {
                                n(),
                                t()
                            }
                            window.addEventListener("blur", r);
                            const i = setTimeout((()=>{
                                n(),
                                e()
                            }
                            ), 2e3)
                        }
                        ));
                        window.location.assign(r),
                        yield t;
                        break
                    }
                }
            } catch (t) {
                throw new sc(ic.ERROR_WALLET_NOT_FOUND,"Found no installed wallet that supports the mobile wallet protocol.")
            }
        var i;
        return n
    }
    ))
}
const Ec = {
    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
    timeoutMs: 3e4
}
  , _c = "com.solana.mobilewalletadapter.v1";
function Ac(t, e) {
    return ac(this, void 0, void 0, (function*() {
        !function() {
            if ("undefined" == typeof window || !0 !== window.isSecureContext)
                throw new sc(ic.ERROR_SECURE_CONTEXT_REQUIRED,"The mobile wallet adapter protocol must be used in a secure context (`https`).")
        }();
        const n = yield function() {
            return ac(this, void 0, void 0, (function*() {
                return yield crypto.subtle.generateKey({
                    name: "ECDSA",
                    namedCurve: "P-256"
                }, !1, ["sign"])
            }
            ))
        }()
          , r = yield xc(n.publicKey, null == e ? void 0 : e.baseUri)
          , i = `ws://localhost:${r}/solana-wallet`;
        let s;
        const o = (()=>{
            const t = [...Ec.retryDelayScheduleMs];
            return ()=>t.length > 1 ? t.shift() : t[0]
        }
        )();
        let a = 1
          , l = 0
          , c = {
            __type: "disconnected"
        };
        return new Promise(((e,u)=>{
            let h;
            const d = {}
              , f = ()=>ac(this, void 0, void 0, (function*() {
                if ("connecting" !== c.__type)
                    return void console.warn(`Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${c.__type}\`.`);
                const {associationKeypair: t} = c;
                h.removeEventListener("open", f);
                const e = yield function() {
                    return ac(this, void 0, void 0, (function*() {
                        return yield crypto.subtle.generateKey({
                            name: "ECDH",
                            namedCurve: "P-256"
                        }, !1, ["deriveKey", "deriveBits"])
                    }
                    ))
                }();
                h.send(yield function(t, e) {
                    return ac(this, void 0, void 0, (function*() {
                        const n = yield crypto.subtle.exportKey("raw", t)
                          , r = yield crypto.subtle.sign({
                            hash: "SHA-256",
                            name: "ECDSA"
                        }, e, n)
                          , i = new Uint8Array(n.byteLength + r.byteLength);
                        return i.set(new Uint8Array(n), 0),
                        i.set(new Uint8Array(r), n.byteLength),
                        i
                    }
                    ))
                }(e.publicKey, t.privateKey)),
                c = {
                    __type: "hello_req_sent",
                    associationPublicKey: t.publicKey,
                    ecdhPrivateKey: e.privateKey
                }
            }
            ))
              , p = t=>{
                t.wasClean ? c = {
                    __type: "disconnected"
                } : u(new sc(ic.ERROR_SESSION_CLOSED,`The wallet session dropped unexpectedly (${t.code}: ${t.reason}).`,{
                    closeEvent: t
                })),
                y()
            }
              , m = t=>ac(this, void 0, void 0, (function*() {
                y(),
                Date.now() - s >= Ec.timeoutMs ? u(new sc(ic.ERROR_SESSION_TIMEOUT,`Failed to connect to the wallet websocket on port ${r}.`)) : (yield new Promise((t=>{
                    const e = o();
                    b = window.setTimeout(t, e)
                }
                )),
                v())
            }
            ))
              , g = n=>ac(this, void 0, void 0, (function*() {
                const r = yield n.data.arrayBuffer();
                switch (c.__type) {
                case "connected":
                    try {
                        const t = r.slice(0, lc)
                          , e = new DataView(t).getUint32(0, !1);
                        if (e !== l + 1)
                            throw new Error("Encrypted message has invalid sequence number");
                        l = e;
                        const n = yield dc(r, c.sharedSecret)
                          , i = d[n.id];
                        delete d[n.id],
                        i.resolve(n.result)
                    } catch (t) {
                        if (!(t instanceof oc))
                            throw t;
                        {
                            const e = d[t.jsonRpcMessageId];
                            delete d[t.jsonRpcMessageId],
                            e.reject(t)
                        }
                    }
                    break;
                case "hello_req_sent":
                    {
                        const n = yield function(t, e, n) {
                            return ac(this, void 0, void 0, (function*() {
                                const [r,i] = yield Promise.all([crypto.subtle.exportKey("raw", e), crypto.subtle.importKey("raw", t, {
                                    name: "ECDH",
                                    namedCurve: "P-256"
                                }, !1, [])])
                                  , s = yield crypto.subtle.deriveBits({
                                    name: "ECDH",
                                    public: i
                                }, n, 256)
                                  , o = yield crypto.subtle.importKey("raw", s, "HKDF", !1, ["deriveKey"]);
                                return yield crypto.subtle.deriveKey({
                                    name: "HKDF",
                                    hash: "SHA-256",
                                    salt: new Uint8Array(r),
                                    info: new Uint8Array
                                }, o, {
                                    name: "AES-GCM",
                                    length: 128
                                }, !1, ["encrypt", "decrypt"])
                            }
                            ))
                        }(r, c.associationPublicKey, c.ecdhPrivateKey);
                        c = {
                            __type: "connected",
                            sharedSecret: n
                        };
                        const i = new Proxy({},{
                            get(t, e) {
                                if (null == t[e]) {
                                    const r = e.toString().replace(/[A-Z]/g, (t=>`_${t.toLowerCase()}`)).toLowerCase();
                                    t[e] = function(t) {
                                        return ac(this, void 0, void 0, (function*() {
                                            const i = a++;
                                            return h.send(yield hc({
                                                id: i,
                                                jsonrpc: "2.0",
                                                method: r,
                                                params: null != t ? t : {}
                                            }, n)),
                                            new Promise(((t,n)=>{
                                                d[i] = {
                                                    resolve(r) {
                                                        switch (e) {
                                                        case "authorize":
                                                        case "reauthorize":
                                                            {
                                                                const {wallet_uri_base: t} = r;
                                                                if (null != t)
                                                                    try {
                                                                        !function(t) {
                                                                            let e;
                                                                            try {
                                                                                e = new URL(t)
                                                                            } catch (t) {
                                                                                throw new sc(ic.ERROR_FORBIDDEN_WALLET_BASE_URL,"Invalid base URL supplied by wallet")
                                                                            }
                                                                            if ("https:" !== e.protocol)
                                                                                throw new sc(ic.ERROR_FORBIDDEN_WALLET_BASE_URL,"Base URLs supplied by wallets must be valid `https` URLs")
                                                                        }(t)
                                                                    } catch (t) {
                                                                        return void n(t)
                                                                    }
                                                                break
                                                            }
                                                        }
                                                        t(r)
                                                    },
                                                    reject: n
                                                }
                                            }
                                            ))
                                        }
                                        ))
                                    }
                                }
                                return t[e]
                            },
                            defineProperty: ()=>!1,
                            deleteProperty: ()=>!1
                        });
                        try {
                            e(yield t(i))
                        } catch (t) {
                            u(t)
                        } finally {
                            y(),
                            h.close()
                        }
                        break
                    }
                }
            }
            ));
            let y, b;
            const v = ()=>{
                y && y(),
                c = {
                    __type: "connecting",
                    associationKeypair: n
                },
                void 0 === s && (s = Date.now()),
                h = new WebSocket(i,[_c]),
                h.addEventListener("open", f),
                h.addEventListener("close", p),
                h.addEventListener("error", m),
                h.addEventListener("message", g),
                y = ()=>{
                    window.clearTimeout(b),
                    h.removeEventListener("open", f),
                    h.removeEventListener("close", p),
                    h.removeEventListener("error", m),
                    h.removeEventListener("message", g)
                }
            }
            ;
            v()
        }
        ))
    }
    ))
}
var Sc = o("bYkMz");
function Tc(t, e) {
    var n = {};
    for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]])
    }
    return n
}
function kc(t, e, n, r) {
    return new (n || (n = Promise))((function(i, s) {
        function o(t) {
            try {
                l(r.next(t))
            } catch (t) {
                s(t)
            }
        }
        function a(t) {
            try {
                l(r.throw(t))
            } catch (t) {
                s(t)
            }
        }
        function l(t) {
            var e;
            t.done ? i(t.value) : (e = t.value,
            e instanceof n ? e : new n((function(t) {
                t(e)
            }
            ))).then(o, a)
        }
        l((r = r.apply(t, e || [])).next())
    }
    ))
}
function Ic(t) {
    return window.btoa(String.fromCharCode.call(null, ...t))
}
function Mc(t) {
    return new Uint8Array(window.atob(t).split("").map((t=>t.charCodeAt(0))))
}
function Cc(t) {
    return Ic("version"in t ? t.serialize() : t.serialize({
        requireAllSignatures: !1,
        verifySignatures: !1
    }))
}
function Pc(t) {
    return "legacy" === Er.VersionedMessage.deserializeMessageVersion(t) ? Er.Transaction.from(t) : Er.VersionedTransaction.deserialize(t)
}
function Oc(t, n) {
    return kc(this, void 0, void 0, (function*() {
        return yield Ac((n=>{
            const r = new Proxy({},{
                get(t, r) {
                    if (null == t[r])
                        switch (r) {
                        case "signAndSendTransactions":
                            t[r] = function(t) {
                                var {minContextSlot: r, transactions: i} = t
                                  , s = Tc(t, ["minContextSlot", "transactions"]);
                                return kc(this, void 0, void 0, (function*() {
                                    const t = i.map(Cc)
                                      , {signatures: o} = yield n.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, s), null != r ? {
                                        options: {
                                            min_context_slot: r
                                        }
                                    } : null), {
                                        payloads: t
                                    }));
                                    return o.map(Mc).map(e(Sc).encode)
                                }
                                ))
                            }
                            ;
                            break;
                        case "signMessages":
                            t[r] = function(t) {
                                var {payloads: e} = t
                                  , r = Tc(t, ["payloads"]);
                                return kc(this, void 0, void 0, (function*() {
                                    const t = e.map(Ic)
                                      , {signed_payloads: i} = yield n.signMessages(Object.assign(Object.assign({}, r), {
                                        payloads: t
                                    }));
                                    return i.map(Mc)
                                }
                                ))
                            }
                            ;
                            break;
                        case "signTransactions":
                            t[r] = function(t) {
                                var {transactions: e} = t
                                  , r = Tc(t, ["transactions"]);
                                return kc(this, void 0, void 0, (function*() {
                                    const t = e.map(Cc)
                                      , {signed_payloads: i} = yield n.signTransactions(Object.assign(Object.assign({}, r), {
                                        payloads: t
                                    }));
                                    return i.map(Mc).map(Pc)
                                }
                                ))
                            }
                            ;
                            break;
                        default:
                            t[r] = n[r]
                        }
                    return t[r]
                },
                defineProperty: ()=>!1,
                deleteProperty: ()=>!1
            });
            return t(r)
        }
        ), n)
    }
    ))
}
function Nc(t, e, n, r) {
    return new (n || (n = Promise))((function(i, s) {
        function o(t) {
            try {
                l(r.next(t))
            } catch (t) {
                s(t)
            }
        }
        function a(t) {
            try {
                l(r.throw(t))
            } catch (t) {
                s(t)
            }
        }
        function l(t) {
            var e;
            t.done ? i(t.value) : (e = t.value,
            e instanceof n ? e : new n((function(t) {
                t(e)
            }
            ))).then(o, a)
        }
        l((r = r.apply(t, e || [])).next())
    }
    ))
}
const Rc = "Mobile Wallet Adapter";
function Dc(t) {
    const e = (n = t,
    new Uint8Array(window.atob(n).split("").map((t=>t.charCodeAt(0)))));
    var n;
    return new (0,
    Er.PublicKey)(e)
}
function Bc(t) {
    return "version"in t
}
class Lc extends rc {
    constructor(t) {
        super(),
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this.name = Rc,
        this.url = "https://solanamobile.com/wallets",
        this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==",
        this._connecting = !1,
        this._connectionGeneration = 0,
        this._readyState = "undefined" != typeof window && window.isSecureContext && "undefined" != typeof document && /android/i.test(navigator.userAgent) ? Bl.Loadable : Bl.Unsupported,
        this._authorizationResultCache = t.authorizationResultCache,
        this._addressSelector = t.addressSelector,
        this._appIdentity = t.appIdentity,
        this._cluster = t.cluster,
        this._onWalletNotFound = t.onWalletNotFound,
        this._readyState !== Bl.Unsupported && this._authorizationResultCache.get().then((t=>{
            t && this.declareWalletAsInstalled()
        }
        ))
    }
    get publicKey() {
        if (null == this._publicKey && null != this._selectedAddress)
            try {
                this._publicKey = Dc(this._selectedAddress)
            } catch (t) {
                throw new Gl(t instanceof Error && (null == t ? void 0 : t.message) || "Unknown error",t)
            }
        return this._publicKey ? this._publicKey : null
    }
    get connected() {
        return !!this._authorizationResult
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    declareWalletAsInstalled() {
        this._readyState !== Bl.Installed && this.emit("readyStateChange", this._readyState = Bl.Installed)
    }
    runWithGuard(t) {
        return Nc(this, void 0, void 0, (function*() {
            try {
                return yield t()
            } catch (t) {
                throw this.emit("error", t),
                t
            }
        }
        ))
    }
    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
        return Nc(this, void 0, void 0, (function*() {
            return yield this.autoConnect()
        }
        ))
    }
    autoConnect() {
        return Nc(this, void 0, void 0, (function*() {
            if (!this.connecting && !this.connected)
                return yield this.runWithGuard((()=>Nc(this, void 0, void 0, (function*() {
                    if (this._readyState !== Bl.Installed && this._readyState !== Bl.Loadable)
                        throw new Ul;
                    this._connecting = !0;
                    try {
                        const t = yield this._authorizationResultCache.get();
                        t && this.handleAuthorizationResult(t)
                    } catch (t) {
                        throw new Wl(t instanceof Error && t.message || "Unknown error",t)
                    } finally {
                        this._connecting = !1
                    }
                }
                ))))
        }
        ))
    }
    connect() {
        return Nc(this, void 0, void 0, (function*() {
            if (!this.connecting && !this.connected)
                return yield this.runWithGuard((()=>Nc(this, void 0, void 0, (function*() {
                    if (this._readyState !== Bl.Installed && this._readyState !== Bl.Loadable)
                        throw new Ul;
                    this._connecting = !0;
                    try {
                        const t = yield this._authorizationResultCache.get();
                        if (t)
                            return void this.handleAuthorizationResult(t);
                        yield this.transact((t=>Nc(this, void 0, void 0, (function*() {
                            const e = yield t.authorize({
                                cluster: this._cluster,
                                identity: this._appIdentity
                            });
                            Promise.all([this._authorizationResultCache.set(e), this.handleAuthorizationResult(e)])
                        }
                        ))))
                    } catch (t) {
                        throw new Wl(t instanceof Error && t.message || "Unknown error",t)
                    } finally {
                        this._connecting = !1
                    }
                }
                ))))
        }
        ))
    }
    handleAuthorizationResult(t) {
        var e;
        return Nc(this, void 0, void 0, (function*() {
            const n = null == this._authorizationResult || (null === (e = this._authorizationResult) || void 0 === e ? void 0 : e.accounts.length) !== t.accounts.length || this._authorizationResult.accounts.some(((e,n)=>e.address !== t.accounts[n].address));
            if (this._authorizationResult = t,
            this.declareWalletAsInstalled(),
            n) {
                const e = yield this._addressSelector.select(t.accounts.map((({address: t})=>t)));
                e !== this._selectedAddress && (this._selectedAddress = e,
                delete this._publicKey,
                this.emit("connect", this.publicKey))
            }
        }
        ))
    }
    performReauthorization(t, e) {
        return Nc(this, void 0, void 0, (function*() {
            try {
                const n = yield t.reauthorize({
                    auth_token: e
                });
                Promise.all([this._authorizationResultCache.set(n), this.handleAuthorizationResult(n)])
            } catch (t) {
                throw this.disconnect(),
                new Yl(t instanceof Error && (null == t ? void 0 : t.message) || "Unknown error",t)
            }
        }
        ))
    }
    disconnect() {
        return Nc(this, void 0, void 0, (function*() {
            this._authorizationResultCache.clear(),
            this._connecting = !1,
            this._connectionGeneration++,
            delete this._authorizationResult,
            delete this._publicKey,
            delete this._selectedAddress,
            this.emit("disconnect")
        }
        ))
    }
    transact(t) {
        var e;
        return Nc(this, void 0, void 0, (function*() {
            const n = null === (e = this._authorizationResult) || void 0 === e ? void 0 : e.wallet_uri_base
              , r = n ? {
                baseUri: n
            } : void 0
              , i = this._connectionGeneration;
            try {
                return yield Oc(t, r)
            } catch (t) {
                throw this._connectionGeneration !== i && (yield new Promise((()=>{}
                ))),
                t instanceof Error && "SolanaMobileWalletAdapterError" === t.name && "ERROR_WALLET_NOT_FOUND" === t.code && (yield this._onWalletNotFound(this)),
                t
            }
        }
        ))
    }
    assertIsAuthorized() {
        if (!this._authorizationResult || !this._selectedAddress)
            throw new Xl;
        return {
            authToken: this._authorizationResult.auth_token,
            selectedAddress: this._selectedAddress
        }
    }
    performSignTransactions(t) {
        return Nc(this, void 0, void 0, (function*() {
            const {authToken: e} = this.assertIsAuthorized();
            try {
                return yield this.transact((n=>Nc(this, void 0, void 0, (function*() {
                    yield this.performReauthorization(n, e);
                    return yield n.signTransactions({
                        transactions: t
                    })
                }
                ))))
            } catch (t) {
                throw new Ql(null == t ? void 0 : t.message,t)
            }
        }
        ))
    }
    sendTransaction(t, e, n) {
        return Nc(this, void 0, void 0, (function*() {
            return yield this.runWithGuard((()=>Nc(this, void 0, void 0, (function*() {
                const {authToken: r} = this.assertIsAuthorized()
                  , i = null == n ? void 0 : n.minContextSlot;
                try {
                    return yield this.transact((s=>Nc(this, void 0, void 0, (function*() {
                        function o() {
                            let t, r;
                            switch (e.commitment) {
                            case "confirmed":
                            case "finalized":
                            case "processed":
                                t = e.commitment;
                                break;
                            default:
                                t = "finalized"
                            }
                            switch (null == n ? void 0 : n.preflightCommitment) {
                            case "confirmed":
                            case "finalized":
                            case "processed":
                                r = n.preflightCommitment;
                                break;
                            case void 0:
                                r = t;
                            default:
                                r = "finalized"
                            }
                            return ("finalized" === r ? 2 : "confirmed" === r ? 1 : 0) < ("finalized" === t ? 2 : "confirmed" === t ? 1 : 0) ? r : t
                        }
                        const [a,l,c] = yield Promise.all([s.getCapabilities(), this.performReauthorization(s, r), Bc(t) ? null : (()=>Nc(this, void 0, void 0, (function*() {
                            var n;
                            if (t.feePayer || (t.feePayer = null !== (n = this.publicKey) && void 0 !== n ? n : void 0),
                            null == t.recentBlockhash) {
                                const {blockhash: n} = yield e.getLatestBlockhash({
                                    commitment: o()
                                });
                                t.recentBlockhash = n
                            }
                        }
                        )))()]);
                        if (a.supports_sign_and_send_transactions) {
                            return (yield s.signAndSendTransactions({
                                minContextSlot: i,
                                transactions: [t]
                            }))[0]
                        }
                        {
                            const [r] = yield s.signTransactions({
                                transactions: [t]
                            });
                            if (Bc(r))
                                return yield e.sendTransaction(r);
                            {
                                const t = r.serialize();
                                return yield e.sendRawTransaction(t, Object.assign(Object.assign({}, n), {
                                    preflightCommitment: o()
                                }))
                            }
                        }
                    }
                    ))))
                } catch (t) {
                    throw new ql(null == t ? void 0 : t.message,t)
                }
            }
            ))))
        }
        ))
    }
    signTransaction(t) {
        return Nc(this, void 0, void 0, (function*() {
            return yield this.runWithGuard((()=>Nc(this, void 0, void 0, (function*() {
                const [e] = yield this.performSignTransactions([t]);
                return e
            }
            ))))
        }
        ))
    }
    signAllTransactions(t) {
        return Nc(this, void 0, void 0, (function*() {
            return yield this.runWithGuard((()=>Nc(this, void 0, void 0, (function*() {
                return yield this.performSignTransactions(t)
            }
            ))))
        }
        ))
    }
    signMessage(t) {
        return Nc(this, void 0, void 0, (function*() {
            return yield this.runWithGuard((()=>Nc(this, void 0, void 0, (function*() {
                const {authToken: e, selectedAddress: n} = this.assertIsAuthorized();
                try {
                    return yield this.transact((r=>Nc(this, void 0, void 0, (function*() {
                        yield this.performReauthorization(r, e);
                        const [i] = yield r.signMessages({
                            addresses: [n],
                            payloads: [t]
                        });
                        return i.slice(-64)
                    }
                    ))))
                } catch (t) {
                    throw new Kl(null == t ? void 0 : t.message,t)
                }
            }
            ))))
        }
        ))
    }
}
const Fc = "SolanaMobileWalletAdapterDefaultAuthorizationCache";
function jc() {
    let t;
    try {
        t = window.localStorage
    } catch (t) {}
    return {
        clear() {
            return Nc(this, void 0, void 0, (function*() {
                if (t)
                    try {
                        t.removeItem(Fc)
                    } catch (t) {}
            }
            ))
        },
        get() {
            return Nc(this, void 0, void 0, (function*() {
                if (t)
                    try {
                        return JSON.parse(t.getItem(Fc)) || void 0
                    } catch (t) {}
            }
            ))
        },
        set(e) {
            return Nc(this, void 0, void 0, (function*() {
                if (t)
                    try {
                        t.setItem(Fc, JSON.stringify(e))
                    } catch (t) {}
            }
            ))
        }
    }
}
function Uc(t) {
    return Nc(this, void 0, void 0, (function*() {
        "undefined" != typeof window && window.location.assign(t.url)
    }
    ))
}
var zc = {};
t(zc, "isWalletAdapterCompatibleWallet", (()=>Ru));
var Vc = {};
t(Vc, "StandardWalletAdapter", (()=>Nu), (t=>Nu = t));
const Wc = "solana:signAndSendTransaction"
  , Yc = "solana:signMessage"
  , Hc = "solana:signTransaction"
  , $c = "solana:mainnet"
  , Gc = "solana:devnet"
  , Xc = "solana:testnet"
  , qc = "solana:localnet";
const Kc = "https://api.mainnet-beta.solana.com";
function Qc(t) {
    switch (t) {
    case "processed":
    case "confirmed":
    case "finalized":
    case void 0:
        return t;
    case "recent":
        return "processed";
    case "single":
    case "singleGossip":
        return "confirmed";
    case "max":
    case "root":
        return "finalized";
    default:
        return
    }
}
Er = o("gNDby");
const Zc = "standard:connect"
  , Jc = "standard:disconnect"
  , tu = "standard:events";
var eu = {};
class nu extends Event {
    constructor(t) {
        super("wallet-standard:register-wallet", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }),
        $aff560f1983590b4$var$_RegisterWalletEvent_detail.set(this, void 0),
        $aff560f1983590b4$var$__classPrivateFieldSet(this, $aff560f1983590b4$var$_RegisterWalletEvent_detail, t, "f")
    }
    get detail() {
        return $aff560f1983590b4$var$__classPrivateFieldGet(this, $aff560f1983590b4$var$_RegisterWalletEvent_detail, "f")
    }
    get type() {
        return "wallet-standard:register-wallet"
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
new WeakMap;
var ru = {};
t(ru, "ReadonlyWalletAccount", (()=>du), (t=>du = t)),
t(ru, "arraysEqual", (()=>fu), (t=>fu = t)),
t(ru, "bytesEqual", (()=>pu), (t=>pu = t));
var iu, su, ou, au, lu, cu, uu = function(t, e, n, r, i) {
    if ("m" === r)
        throw new TypeError("Private method is not writable");
    if ("a" === r && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if ("function" == typeof e ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return "a" === r ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}, hu = function(t, e, n, r) {
    if ("a" === n && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if ("function" == typeof e ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return "m" === n ? r : "a" === n ? r.call(t) : r ? r.value : e.get(t)
};
class du {
    constructor(t) {
        iu.set(this, void 0),
        su.set(this, void 0),
        ou.set(this, void 0),
        au.set(this, void 0),
        lu.set(this, void 0),
        cu.set(this, void 0),
        new.target === du && Object.freeze(this),
        uu(this, iu, t.address, "f"),
        uu(this, su, t.publicKey.slice(), "f"),
        uu(this, ou, t.chains.slice(), "f"),
        uu(this, au, t.features.slice(), "f"),
        uu(this, lu, t.label, "f"),
        uu(this, cu, t.icon, "f")
    }
    get address() {
        return hu(this, iu, "f")
    }
    get publicKey() {
        return hu(this, su, "f").slice()
    }
    get chains() {
        return hu(this, ou, "f").slice()
    }
    get features() {
        return hu(this, au, "f").slice()
    }
    get label() {
        return hu(this, lu, "f")
    }
    get icon() {
        return hu(this, cu, "f")
    }
}
function fu(t, e) {
    if (t === e)
        return !0;
    const n = t.length;
    if (n !== e.length)
        return !1;
    for (let r = 0; r < n; r++)
        if (t[r] !== e[r])
            return !1;
    return !0
}
function pu(t, e) {
    return fu(t, e)
}
iu = new WeakMap,
su = new WeakMap,
ou = new WeakMap,
au = new WeakMap,
lu = new WeakMap,
cu = new WeakMap,
r(eu, {}),
r(eu, ru);
var mu, gu = o("0DhcF");
mu = gu("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var yu, bu, vu, wu, xu, Eu, _u, Au, Su, Tu, ku, Iu, Mu, Cu, Pu = function(t, e, n, r, i) {
    if ("m" === r)
        throw new TypeError("Private method is not writable");
    if ("a" === r && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if ("function" == typeof e ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return "a" === r ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}, Ou = function(t, e, n, r) {
    if ("a" === n && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if ("function" == typeof e ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return "m" === n ? r : "a" === n ? r.call(t) : r ? r.value : e.get(t)
};
class Nu extends Zl {
    constructor({wallet: t}) {
        super(),
        yu.add(this),
        bu.set(this, void 0),
        vu.set(this, void 0),
        wu.set(this, void 0),
        xu.set(this, void 0),
        Eu.set(this, void 0),
        _u.set(this, void 0),
        Au.set(this, "undefined" == typeof window || "undefined" == typeof document ? Bl.Unsupported : Bl.Installed),
        ku.set(this, (t=>{
            if (!Ou(this, bu, "f") || !Ou(this, vu, "f") || !("accounts"in t))
                return;
            const e = Ou(this, Eu, "f").accounts[0];
            if (!e)
                return Ou(this, yu, "m", Tu).call(this),
                this.emit("error", new Yl),
                void this.emit("disconnect");
            if (e === Ou(this, bu, "f"))
                return;
            let n;
            try {
                n = new (0,
                Er.PublicKey)(e.publicKey)
            } catch (t) {
                return Ou(this, yu, "m", Tu).call(this),
                this.emit("error", new Gl(t?.message)),
                void this.emit("disconnect")
            }
            Ou(this, yu, "m", Su).call(this, e, n),
            this.emit("connect", n)
        }
        )),
        Pu(this, Eu, t, "f");
        const e = Wc in t.features ? t.features[Wc].supportedTransactionVersions : t.features[Hc].supportedTransactionVersions;
        Pu(this, _u, (0,
        ru.arraysEqual)(e, ["legacy"]) ? null : new Set(e), "f"),
        Pu(this, bu, null, "f"),
        Pu(this, vu, null, "f"),
        Pu(this, wu, !1, "f")
    }
    get supportedTransactionVersions() {
        return Ou(this, _u, "f")
    }
    get name() {
        return Ou(this, Eu, "f").name
    }
    get icon() {
        return Ou(this, Eu, "f").icon
    }
    get url() {
        return "https://github.com/solana-labs/wallet-standard"
    }
    get publicKey() {
        return Ou(this, vu, "f")
    }
    get connecting() {
        return Ou(this, wu, "f")
    }
    get readyState() {
        return Ou(this, Au, "f")
    }
    get wallet() {
        return Ou(this, Eu, "f")
    }
    get standard() {
        return !0
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (Ou(this, Au, "f") !== Bl.Installed)
                throw new Ul;
            if (Pu(this, wu, !0, "f"),
            !Ou(this, Eu, "f").accounts.length)
                try {
                    await Ou(this, Eu, "f").features[Zc].connect()
                } catch (t) {
                    throw new Wl(t?.message,t)
                }
            if (!Ou(this, Eu, "f").accounts.length)
                throw new $l;
            const t = Ou(this, Eu, "f").accounts[0];
            let e;
            try {
                e = new (0,
                Er.PublicKey)(t.publicKey)
            } catch (t) {
                throw new Gl(t?.message,t)
            }
            Pu(this, xu, Ou(this, Eu, "f").features[tu].on("change", Ou(this, ku, "f")), "f"),
            Ou(this, yu, "m", Su).call(this, t, e),
            this.emit("connect", e)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            Pu(this, wu, !1, "f")
        }
    }
    async disconnect() {
        if (Jc in Ou(this, Eu, "f").features)
            try {
                await Ou(this, Eu, "f").features[Jc].disconnect()
            } catch (t) {
                this.emit("error", new Hl(t?.message,t))
            }
        Ou(this, yu, "m", Tu).call(this),
        this.emit("disconnect")
    }
    async sendTransaction(t, n, r={}) {
        try {
            const s = Ou(this, bu, "f");
            if (!s)
                throw new Xl;
            let o;
            if (Wc in Ou(this, Eu, "f").features)
                if (s.features.includes(Wc))
                    o = Wc;
                else {
                    if (!(Hc in Ou(this, Eu, "f").features) || !s.features.includes(Hc))
                        throw new $l;
                    o = Hc
                }
            else {
                if (!(Hc in Ou(this, Eu, "f").features))
                    throw new Vl;
                if (!s.features.includes(Hc))
                    throw new $l;
                o = Hc
            }
            const a = (i = n.rpcEndpoint).includes(Kc) ? $c : /\bdevnet\b/i.test(i) ? Gc : /\btestnet\b/i.test(i) ? Xc : /\blocalhost\b/i.test(i) || /\b127\.0\.0\.1\b/.test(i) ? qc : $c;
            if (!s.chains.includes(a))
                throw new ql;
            try {
                const {signers: i, ...l} = r;
                let c;
                if (ec(t) ? (i?.length && t.sign(i),
                c = t.serialize()) : (t = await this.prepareTransaction(t, n, l),
                i?.length && t.partialSign(...i),
                c = new Uint8Array(t.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))),
                o === Wc) {
                    const [t] = await Ou(this, Eu, "f").features[Wc].signAndSendTransaction({
                        account: s,
                        chain: a,
                        transaction: c,
                        options: {
                            preflightCommitment: Qc(l.preflightCommitment || n.commitment),
                            skipPreflight: l.skipPreflight,
                            maxRetries: l.maxRetries,
                            minContextSlot: l.minContextSlot
                        }
                    });
                    return e(mu).encode(t.signature)
                }
                {
                    const [t] = await Ou(this, Eu, "f").features[Hc].signTransaction({
                        account: s,
                        chain: a,
                        transaction: c,
                        options: {
                            preflightCommitment: Qc(l.preflightCommitment || n.commitment),
                            minContextSlot: l.minContextSlot
                        }
                    });
                    return await n.sendRawTransaction(t.signedTransaction, {
                        ...l,
                        preflightCommitment: Qc(l.preflightCommitment || n.commitment)
                    })
                }
            } catch (t) {
                if (t instanceof jl)
                    throw t;
                throw new ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
        var i
    }
}
bu = new WeakMap,
vu = new WeakMap,
wu = new WeakMap,
xu = new WeakMap,
Eu = new WeakMap,
_u = new WeakMap,
Au = new WeakMap,
ku = new WeakMap,
yu = new WeakSet,
Su = function(t, e) {
    Pu(this, bu, t, "f"),
    Pu(this, vu, e, "f"),
    t?.features.includes(Hc) ? (this.signTransaction = Ou(this, yu, "m", Iu),
    this.signAllTransactions = Ou(this, yu, "m", Mu)) : (delete this.signTransaction,
    delete this.signAllTransactions),
    t?.features.includes(Yc) ? this.signMessage = Ou(this, yu, "m", Cu) : delete this.signMessage
}
,
Tu = function() {
    const t = Ou(this, xu, "f");
    t && (Pu(this, xu, void 0, "f"),
    t()),
    Ou(this, yu, "m", Su).call(this, null, null)
}
,
Iu = async function(t) {
    try {
        const e = Ou(this, bu, "f");
        if (!e)
            throw new Xl;
        if (!(Hc in Ou(this, Eu, "f").features))
            throw new Vl;
        if (!e.features.includes(Hc))
            throw new $l;
        try {
            const n = (await Ou(this, Eu, "f").features[Hc].signTransaction({
                account: e,
                transaction: ec(t) ? t.serialize() : new Uint8Array(t.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            }))[0].signedTransaction;
            return ec(t) ? Er.VersionedTransaction.deserialize(n) : Er.Transaction.from(n)
        } catch (t) {
            if (t instanceof jl)
                throw t;
            throw new Ql(t?.message,t)
        }
    } catch (t) {
        throw this.emit("error", t),
        t
    }
}
,
Mu = async function(t) {
    try {
        const e = Ou(this, bu, "f");
        if (!e)
            throw new Xl;
        if (!(Hc in Ou(this, Eu, "f").features))
            throw new Vl;
        if (!e.features.includes(Hc))
            throw new Ql;
        try {
            const n = await Ou(this, Eu, "f").features[Hc].signTransaction(...t.map((t=>({
                account: e,
                transaction: ec(t) ? t.serialize() : new Uint8Array(t.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            }))));
            return t.map(((t,e)=>{
                const r = n[e].signedTransaction;
                return ec(t) ? Er.VersionedTransaction.deserialize(r) : Er.Transaction.from(r)
            }
            ))
        } catch (t) {
            throw new Ql(t?.message,t)
        }
    } catch (t) {
        throw this.emit("error", t),
        t
    }
}
,
Cu = async function(t) {
    try {
        const e = Ou(this, bu, "f");
        if (!e)
            throw new Xl;
        if (!(Yc in Ou(this, Eu, "f").features))
            throw new Vl;
        if (!e.features.includes(Yc))
            throw new Kl;
        try {
            return (await Ou(this, Eu, "f").features[Yc].signMessage({
                account: e,
                message: t
            }))[0].signature
        } catch (t) {
            throw new Kl(t?.message,t)
        }
    } catch (t) {
        throw this.emit("error", t),
        t
    }
}
;
const Ru = function(t) {
    return Zc in t.features && tu in t.features && (Wc in t.features || Hc in t.features)
};
Er = o("gNDby");
var Du = {};
t(Du, "getWallets", (()=>Vu), (t=>Vu = t)),
t(Du, "DEPRECATED_getWallets", (()=>Xu), (t=>Xu = t));
var Bu, Lu = function(t, e, n, r, i) {
    if ("m" === r)
        throw new TypeError("Private method is not writable");
    if ("a" === r && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if ("function" == typeof e ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return "a" === r ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}, Fu = function(t, e, n, r) {
    if ("a" === n && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if ("function" == typeof e ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return "m" === n ? r : "a" === n ? r.call(t) : r ? r.value : e.get(t)
};
let ju;
const Uu = new Set
  , zu = {};
function Vu() {
    if (ju)
        return ju;
    if (ju = Object.freeze({
        register: Wu,
        get: Yu,
        on: Hu
    }),
    "undefined" == typeof window)
        return ju;
    const t = Object.freeze({
        register: Wu
    });
    try {
        window.addEventListener("wallet-standard:register-wallet", (({detail: e})=>e(t)))
    } catch (t) {
        console.error("wallet-standard:register-wallet event listener could not be added\n", t)
    }
    try {
        window.dispatchEvent(new Gu(t))
    } catch (t) {
        console.error("wallet-standard:app-ready event could not be dispatched\n", t)
    }
    return ju
}
function Wu(...t) {
    return (t = t.filter((t=>!Uu.has(t)))).length ? (t.forEach((t=>Uu.add(t))),
    zu.register?.forEach((e=>$u((()=>e(...t))))),
    function() {
        t.forEach((t=>Uu.delete(t))),
        zu.unregister?.forEach((e=>$u((()=>e(...t)))))
    }
    ) : ()=>{}
}
function Yu() {
    return [...Uu]
}
function Hu(t, e) {
    return zu[t]?.push(e) || (zu[t] = [e]),
    function() {
        zu[t] = zu[t]?.filter((t=>e !== t))
    }
}
function $u(t) {
    try {
        t()
    } catch (t) {
        console.error(t)
    }
}
class Gu extends Event {
    constructor(t) {
        super("wallet-standard:app-ready", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }),
        Bu.set(this, void 0),
        Lu(this, Bu, t, "f")
    }
    get detail() {
        return Fu(this, Bu, "f")
    }
    get type() {
        return "wallet-standard:app-ready"
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
function Xu() {
    if (ju)
        return ju;
    if (ju = Vu(),
    "undefined" == typeof window)
        return ju;
    const t = window.navigator.wallets || [];
    if (!Array.isArray(t))
        return console.error("window.navigator.wallets is not an array"),
        ju;
    const {register: e} = ju
      , n = (...t)=>t.forEach((t=>$u((()=>t({
        register: e
    })))));
    try {
        Object.defineProperty(window.navigator, "wallets", {
            value: Object.freeze({
                push: n
            })
        })
    } catch (t) {
        return console.error("window.navigator.wallets could not be set"),
        ju
    }
    return n(...t),
    ju
}
Bu = new WeakMap;
var qu, Ku, Qu, Zu, Ju, th, eh, nh, rh = function(t, e, n, r, i) {
    if ("m" === r)
        throw new TypeError("Private method is not writable");
    if ("a" === r && !i)
        throw new TypeError("Private accessor was defined without a setter");
    if ("function" == typeof e ? t !== e || !i : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return "a" === r ? i.call(t, n) : i ? i.value = n : e.set(t, n),
    n
}, ih = function(t, e, n, r) {
    if ("a" === n && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if ("function" == typeof e ? t !== e || !r : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return "m" === n ? r : "a" === n ? r.call(t) : r ? r.value : e.get(t)
};
class sh extends ru.ReadonlyWalletAccount {
    constructor({adapter: t, address: e, publicKey: n, chains: r}) {
        const i = [Wc];
        "signTransaction"in t && i.push(Hc),
        "signMessage"in t && i.push(Yc),
        super({
            address: e,
            publicKey: n,
            chains: r,
            features: i
        }),
        qu.set(this, void 0),
        new.target === sh && Object.freeze(this),
        rh(this, qu, t, "f")
    }
}
qu = new WeakMap;
Qu = new WeakMap,
Zu = new WeakMap,
Ju = new WeakMap,
th = new WeakMap,
new WeakMap,
eh = new WeakMap,
new WeakMap,
new WeakMap,
new WeakMap,
new WeakMap,
new WeakMap,
new WeakMap,
Ku = new WeakSet,
nh = function(t, ...e) {
    ih(this, Qu, "f")[t]?.forEach((t=>t.apply(null, e)))
}
,
r(zc, Vc),
r(zc, {});
d = o("acw62");
function oh(t) {
    const {get: e, on: n} = ah((()=>(0,
    Du.DEPRECATED_getWallets)()))
      , [r,i] = (0,
    d.useState)((()=>lh(e())))
      , s = ah((()=>new Set));
    return (0,
    d.useEffect)((()=>{
        const t = [n("register", ((...t)=>i((e=>[...e, ...lh(t)])))), n("unregister", ((...t)=>i((e=>e.filter((e=>t.some((t=>t === e.wallet))))))))];
        return ()=>t.forEach((t=>t()))
    }
    ), [n]),
    (0,
    d.useMemo)((()=>[...r, ...t.filter((({name: t})=>!r.some((e=>e.name === t)) || (s.has(t) || (s.add(t),
    console.warn(`${t} was registered as a Standard Wallet. The Wallet Adapter for ${t} can be removed from your app.`)),
    !1)))]), [r, t, s])
}
function ah(t) {
    const e = (0,
    d.useRef)();
    return e.current || (e.current = {
        value: t()
    }),
    e.current.value
}
function lh(t) {
    return t.filter(Ru).map((t=>new (0,
    Vc.StandardWalletAdapter)({
        wallet: t
    })))
}
var ch, uh;
d = o("acw62");
function hh({adapters: t, userAgentString: e}) {
    return t.some((t=>t.name !== Rc && t.readyState === Bl.Installed)) ? ch.DESKTOP_WEB : e && /android/i.test(e) && !function(t) {
        return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(t)
    }(e) ? ch.MOBILE_WEB : ch.DESKTOP_WEB
}
(uh = ch || (ch = {}))[uh.DESKTOP_WEB = 0] = "DESKTOP_WEB",
uh[uh.MOBILE_WEB = 1] = "MOBILE_WEB";
d = o("acw62");
function dh(t, e) {
    const n = (0,
    d.useState)((()=>{
        try {
            const e = localStorage.getItem(t);
            if (e)
                return JSON.parse(e)
        } catch (t) {
            "undefined" != typeof window && console.error(t)
        }
        return e
    }
    ))
      , r = n[0]
      , i = (0,
    d.useRef)(!0);
    return (0,
    d.useEffect)((()=>{
        if (i.current)
            i.current = !1;
        else
            try {
                null === r ? localStorage.removeItem(t) : localStorage.setItem(t, JSON.stringify(r))
            } catch (t) {
                "undefined" != typeof window && console.error(t)
            }
    }
    ), [r, t]),
    n
}
d = o("acw62");
class fh extends jl {
    constructor() {
        super(...arguments),
        this.name = "WalletNotSelectedError"
    }
}
d = o("acw62");
const ph = []
  , mh = {
    autoConnect: !1,
    connecting: !1,
    connected: !1,
    disconnecting: !1,
    select(t) {
        console.error(gh("get", "select"))
    },
    connect: ()=>Promise.reject(console.error(gh("get", "connect"))),
    disconnect: ()=>Promise.reject(console.error(gh("get", "disconnect"))),
    sendTransaction: (t,e,n)=>Promise.reject(console.error(gh("get", "sendTransaction"))),
    signTransaction: t=>Promise.reject(console.error(gh("get", "signTransaction"))),
    signAllTransactions: t=>Promise.reject(console.error(gh("get", "signAllTransactions"))),
    signMessage: t=>Promise.reject(console.error(gh("get", "signMessage")))
};
function gh(t, e) {
    return `You have tried to  ${t} "${e}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext`
}
Object.defineProperty(mh, "wallets", {
    get: ()=>(console.error(gh("read", "wallets")),
    ph)
}),
Object.defineProperty(mh, "wallet", {
    get: ()=>(console.error(gh("read", "wallet")),
    null)
}),
Object.defineProperty(mh, "publicKey", {
    get: ()=>(console.error(gh("read", "publicKey")),
    null)
});
const yh = (0,
d.createContext)(mh);
function bh() {
    return (0,
    d.useContext)(yh)
}
function vh({children: t, wallets: n, adapter: r, isUnloadingRef: i, onAutoConnectRequest: s, onConnectError: o, onError: a, onSelectWallet: l}) {
    const c = (0,
    d.useRef)(!1)
      , [u,h] = (0,
    d.useState)(!1)
      , f = (0,
    d.useRef)(!1)
      , [p,m] = (0,
    d.useState)(!1)
      , [g,y] = (0,
    d.useState)((()=>r?.publicKey ?? null))
      , [b,v] = (0,
    d.useState)((()=>r?.connected ?? !1))
      , w = (0,
    d.useRef)(a);
    (0,
    d.useEffect)((()=>(w.current = a,
    ()=>{
        w.current = void 0
    }
    )), [a]);
    const x = (0,
    d.useRef)(((t,e)=>(i.current || (w.current ? w.current(t, e) : (console.error(t, e),
    t instanceof Ul && "undefined" != typeof window && e && window.open(e.url, "_blank"))),
    t)))
      , [E,_] = (0,
    d.useState)((()=>n.map((t=>({
        adapter: t,
        readyState: t.readyState
    }))).filter((({readyState: t})=>t !== Bl.Unsupported))));
    (0,
    d.useEffect)((()=>{
        function t(t) {
            _((e=>{
                const n = e.findIndex((({adapter: t})=>t === this));
                if (-1 === n)
                    return e;
                const {adapter: r} = e[n];
                return [...e.slice(0, n), {
                    adapter: r,
                    readyState: t
                }, ...e.slice(n + 1)].filter((({readyState: t})=>t !== Bl.Unsupported))
            }
            ))
        }
        return _((t=>n.map(((e,n)=>{
            const r = t[n];
            return r && r.adapter === e && r.readyState === e.readyState ? r : {
                adapter: e,
                readyState: e.readyState
            }
        }
        )).filter((({readyState: t})=>t !== Bl.Unsupported)))),
        n.forEach((e=>e.on("readyStateChange", t, e))),
        ()=>{
            n.forEach((e=>e.off("readyStateChange", t, e)))
        }
    }
    ), [r, n]);
    const A = (0,
    d.useMemo)((()=>E.find((t=>t.adapter === r)) ?? null), [r, E]);
    (0,
    d.useEffect)((()=>{
        if (!r)
            return;
        const t = t=>{
            y(t),
            c.current = !1,
            h(!1),
            v(!0),
            f.current = !1,
            m(!1)
        }
          , e = ()=>{
            i.current || (y(null),
            c.current = !1,
            h(!1),
            v(!1),
            f.current = !1,
            m(!1))
        }
          , n = t=>{
            x.current(t, r)
        }
        ;
        return r.on("connect", t),
        r.on("disconnect", e),
        r.on("error", n),
        ()=>{
            r.off("connect", t),
            r.off("disconnect", e),
            r.off("error", n),
            e()
        }
    }
    ), [r, i]);
    const S = (0,
    d.useRef)(!1);
    (0,
    d.useEffect)((()=>()=>{
        S.current = !1
    }
    ), [r]),
    (0,
    d.useEffect)((()=>{
        S.current || c.current || b || !s || A?.readyState !== Bl.Installed && A?.readyState !== Bl.Loadable || (c.current = !0,
        h(!0),
        S.current = !0,
        async function() {
            try {
                await s()
            } catch {
                o()
            } finally {
                h(!1),
                c.current = !1
            }
        }())
    }
    ), [b, s, o, A]);
    const T = (0,
    d.useCallback)((async(t,e,n)=>{
        if (!r)
            throw x.current(new fh);
        if (!b)
            throw x.current(new Xl, r);
        return await r.sendTransaction(t, e, n)
    }
    ), [r, b])
      , k = (0,
    d.useMemo)((()=>r && "signTransaction"in r ? async t=>{
        if (!b)
            throw x.current(new Xl, r);
        return await r.signTransaction(t)
    }
    : void 0), [r, b])
      , I = (0,
    d.useMemo)((()=>r && "signAllTransactions"in r ? async t=>{
        if (!b)
            throw x.current(new Xl, r);
        return await r.signAllTransactions(t)
    }
    : void 0), [r, b])
      , M = (0,
    d.useMemo)((()=>r && "signMessage"in r ? async t=>{
        if (!b)
            throw x.current(new Xl, r);
        return await r.signMessage(t)
    }
    : void 0), [r, b])
      , C = (0,
    d.useCallback)((async()=>{
        if (c.current || f.current || A?.adapter.connected)
            return;
        if (!A)
            throw x.current(new fh);
        const {adapter: t, readyState: e} = A;
        if (e !== Bl.Installed && e !== Bl.Loadable)
            throw x.current(new Ul, t);
        c.current = !0,
        h(!0);
        try {
            await t.connect()
        } catch (t) {
            throw o(),
            t
        } finally {
            h(!1),
            c.current = !1
        }
    }
    ), [o, A])
      , P = (0,
    d.useCallback)((async()=>{
        if (!f.current && r) {
            f.current = !0,
            m(!0);
            try {
                await r.disconnect()
            } finally {
                m(!1),
                f.current = !1
            }
        }
    }
    ), [r]);
    return e(d).createElement(yh.Provider, {
        value: {
            autoConnect: !!s,
            wallets: E,
            wallet: A,
            publicKey: g,
            connected: b,
            connecting: u,
            disconnecting: p,
            select: l,
            connect: C,
            disconnect: P,
            sendTransaction: T,
            signTransaction: k,
            signAllTransactions: I,
            signMessage: M
        }
    }, t)
}
let wh;
function xh(t) {
    return hh({
        adapters: t,
        userAgentString: (void 0 === wh && (wh = globalThis.navigator?.userAgent ?? null),
        wh)
    }) === ch.MOBILE_WEB
}
function Eh() {
    const t = globalThis.location;
    if (null != t)
        return `${t.protocol}//${t.host}`
}
function _h({children: t, wallets: n, autoConnect: r, localStorageKey: i="walletName", onError: s}) {
    const {connection: o} = Rl()
      , a = oh(n)
      , l = (0,
    d.useMemo)((()=>{
        if (!xh(a))
            return null;
        const t = a.find((t=>t.name === Rc));
        return t || new Lc({
            addressSelector: {
                select(t) {
                    return Nc(this, void 0, void 0, (function*() {
                        return t[0]
                    }
                    ))
                }
            },
            appIdentity: {
                uri: Eh()
            },
            authorizationResultCache: jc(),
            cluster: (e = o?.rpcEndpoint,
            e ? /devnet/i.test(e) ? "devnet" : /testnet/i.test(e) ? "testnet" : "mainnet-beta" : "mainnet-beta"),
            onWalletNotFound: Uc
        });
        var e
    }
    ), [a, o?.rpcEndpoint])
      , c = (0,
    d.useMemo)((()=>null == l || -1 !== a.indexOf(l) ? a : [l, ...a]), [a, l])
      , [u,h] = dh(i, xh(a) ? Rc : null)
      , f = (0,
    d.useMemo)((()=>c.find((t=>t.name === u)) ?? null), [c, u])
      , p = (0,
    d.useCallback)((t=>{
        u !== t && (f && f.name !== Rc && f.disconnect(),
        h(t))
    }
    ), [f, h, u]);
    (0,
    d.useEffect)((()=>{
        if (null != f)
            return f.on("disconnect", t),
            ()=>{
                f.off("disconnect", t)
            }
            ;
        function t() {
            y.current || u === Rc && xh(a) || h(null)
        }
    }
    ), [f, a, h, u]);
    const m = (0,
    d.useRef)(!1)
      , g = (0,
    d.useMemo)((()=>{
        if (!0 === r && f)
            return ()=>m.current ? f.connect() : f.autoConnect()
    }
    ), [f, r])
      , y = (0,
    d.useRef)(!1);
    (0,
    d.useEffect)((()=>{
        if (u !== Rc || !xh(a))
            return window.addEventListener("beforeunload", t),
            ()=>{
                window.removeEventListener("beforeunload", t)
            }
            ;
        function t() {
            y.current = !0
        }
        y.current = !1
    }
    ), [a, u]);
    const b = (0,
    d.useCallback)((()=>{
        f && f.name !== Rc && p(null)
    }
    ), [f, p])
      , v = (0,
    d.useCallback)((t=>{
        m.current = !0,
        p(t)
    }
    ), [p]);
    return e(d).createElement(vh, {
        wallets: c,
        adapter: f,
        isUnloadingRef: y,
        onAutoConnectRequest: g,
        onConnectError: b,
        onError: s,
        onSelectWallet: v
    }, t)
}
d = o("acw62"),
d = o("acw62");
const Ah = {
    setVisible(t) {
        console.error(Sh("call", "setVisible"))
    },
    visible: !1
};
function Sh(t, e) {
    return `You have tried to  ${t} "${e}" on a WalletModalContext without providing one. Make sure to render a WalletModalProvider as an ancestor of the component that uses WalletModalContext`
}
Object.defineProperty(Ah, "visible", {
    get: ()=>(console.error(Sh("read", "visible")),
    !1)
});
const Th = (0,
d.createContext)(Ah);
function kh() {
    return (0,
    d.useContext)(Th)
}
d = o("acw62"),
d = o("acw62");
const Ih = ({id: t, children: n, expanded: r=!1})=>{
    const i = (0,
    d.useRef)(null)
      , s = (0,
    d.useRef)(!0);
    return (0,
    d.useLayoutEffect)((()=>{
        r ? (()=>{
            const t = i.current;
            t && requestAnimationFrame((()=>{
                t.style.height = t.scrollHeight + "px"
            }
            ))
        }
        )() : (()=>{
            const t = i.current;
            t && requestAnimationFrame((()=>{
                t.style.height = t.offsetHeight + "px",
                t.style.overflow = "hidden",
                requestAnimationFrame((()=>{
                    t.style.height = "0"
                }
                ))
            }
            ))
        }
        )()
    }
    ), [r]),
    (0,
    d.useLayoutEffect)((()=>{
        const t = i.current;
        if (t)
            return s.current && (e(),
            s.current = !1),
            t.addEventListener("transitionend", n),
            ()=>t.removeEventListener("transitionend", n);
        function e() {
            t && (t.style.overflow = r ? "initial" : "hidden",
            r && (t.style.height = "auto"))
        }
        function n(n) {
            t && n.target === t && "height" === n.propertyName && e()
        }
    }
    ), [r]),
    e(d).createElement("div", {
        className: "wallet-adapter-collapse",
        id: t,
        ref: i,
        role: "region",
        style: {
            height: 0,
            transition: s.current ? void 0 : "height 250ms ease-out"
        }
    }, n)
}
;
d = o("acw62"),
d = o("acw62");
const Mh = t=>e(d).createElement("button", {
    className: `wallet-adapter-button ${t.className || ""}`,
    disabled: t.disabled,
    style: t.style,
    onClick: t.onClick,
    tabIndex: t.tabIndex || 0,
    type: "button"
}, t.startIcon && e(d).createElement("i", {
    className: "wallet-adapter-button-start-icon"
}, t.startIcon), t.children, t.endIcon && e(d).createElement("i", {
    className: "wallet-adapter-button-end-icon"
}, t.endIcon));
d = o("acw62");
const Ch = ({wallet: t, ...n})=>t && e(d).createElement("img", {
    src: t.adapter.icon,
    alt: `${t.adapter.name} icon`,
    ...n
})
  , Ph = ({handleClick: t, tabIndex: n, wallet: r})=>e(d).createElement("li", null, e(d).createElement(Mh, {
    onClick: t,
    startIcon: e(d).createElement(Ch, {
        wallet: r
    }),
    tabIndex: n
}, r.adapter.name, r.readyState === Bl.Installed && e(d).createElement("span", null, "Detected")));
d = o("acw62");
const Oh = ()=>e(d).createElement("svg", {
    width: "97",
    height: "96",
    viewBox: "0 0 97 96",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
}, e(d).createElement("circle", {
    cx: "48.5",
    cy: "48",
    r: "48",
    fill: "url(#paint0_linear_880_5115)",
    fillOpacity: "0.1"
}), e(d).createElement("circle", {
    cx: "48.5",
    cy: "48",
    r: "47",
    stroke: "url(#paint1_linear_880_5115)",
    strokeOpacity: "0.4",
    strokeWidth: "2"
}), e(d).createElement("g", {
    clipPath: "url(#clip0_880_5115)"
}, e(d).createElement("path", {
    d: "M65.5769 28.1523H31.4231C27.6057 28.1523 24.5 31.258 24.5 35.0754V60.9215C24.5 64.7389 27.6057 67.8446 31.4231 67.8446H65.5769C69.3943 67.8446 72.5 64.7389 72.5 60.9215V35.0754C72.5 31.258 69.3943 28.1523 65.5769 28.1523ZM69.7308 52.1523H59.5769C57.2865 52.1523 55.4231 50.289 55.4231 47.9985C55.4231 45.708 57.2864 43.8446 59.5769 43.8446H69.7308V52.1523ZM69.7308 41.0754H59.5769C55.7595 41.0754 52.6539 44.1811 52.6539 47.9985C52.6539 51.8159 55.7595 54.9215 59.5769 54.9215H69.7308V60.9215C69.7308 63.2119 67.8674 65.0754 65.5769 65.0754H31.4231C29.1327 65.0754 27.2692 63.212 27.2692 60.9215V35.0754C27.2692 32.785 29.1326 30.9215 31.4231 30.9215H65.5769C67.8673 30.9215 69.7308 32.7849 69.7308 35.0754V41.0754Z",
    fill: "url(#paint2_linear_880_5115)"
}), e(d).createElement("path", {
    d: "M61.4231 46.6172H59.577C58.8123 46.6172 58.1924 47.2371 58.1924 48.0018C58.1924 48.7665 58.8123 49.3863 59.577 49.3863H61.4231C62.1878 49.3863 62.8077 48.7664 62.8077 48.0018C62.8077 47.2371 62.1878 46.6172 61.4231 46.6172Z",
    fill: "url(#paint3_linear_880_5115)"
})), e(d).createElement("defs", null, e(d).createElement("linearGradient", {
    id: "paint0_linear_880_5115",
    x1: "3.41664",
    y1: "98.0933",
    x2: "103.05",
    y2: "8.42498",
    gradientUnits: "userSpaceOnUse"
}, e(d).createElement("stop", {
    stopColor: "#9945FF"
}), e(d).createElement("stop", {
    offset: "0.14",
    stopColor: "#8A53F4"
}), e(d).createElement("stop", {
    offset: "0.42",
    stopColor: "#6377D6"
}), e(d).createElement("stop", {
    offset: "0.79",
    stopColor: "#24B0A7"
}), e(d).createElement("stop", {
    offset: "0.99",
    stopColor: "#00D18C"
}), e(d).createElement("stop", {
    offset: "1",
    stopColor: "#00D18C"
})), e(d).createElement("linearGradient", {
    id: "paint1_linear_880_5115",
    x1: "3.41664",
    y1: "98.0933",
    x2: "103.05",
    y2: "8.42498",
    gradientUnits: "userSpaceOnUse"
}, e(d).createElement("stop", {
    stopColor: "#9945FF"
}), e(d).createElement("stop", {
    offset: "0.14",
    stopColor: "#8A53F4"
}), e(d).createElement("stop", {
    offset: "0.42",
    stopColor: "#6377D6"
}), e(d).createElement("stop", {
    offset: "0.79",
    stopColor: "#24B0A7"
}), e(d).createElement("stop", {
    offset: "0.99",
    stopColor: "#00D18C"
}), e(d).createElement("stop", {
    offset: "1",
    stopColor: "#00D18C"
})), e(d).createElement("linearGradient", {
    id: "paint2_linear_880_5115",
    x1: "25.9583",
    y1: "68.7101",
    x2: "67.2337",
    y2: "23.7879",
    gradientUnits: "userSpaceOnUse"
}, e(d).createElement("stop", {
    stopColor: "#9945FF"
}), e(d).createElement("stop", {
    offset: "0.14",
    stopColor: "#8A53F4"
}), e(d).createElement("stop", {
    offset: "0.42",
    stopColor: "#6377D6"
}), e(d).createElement("stop", {
    offset: "0.79",
    stopColor: "#24B0A7"
}), e(d).createElement("stop", {
    offset: "0.99",
    stopColor: "#00D18C"
}), e(d).createElement("stop", {
    offset: "1",
    stopColor: "#00D18C"
})), e(d).createElement("linearGradient", {
    id: "paint3_linear_880_5115",
    x1: "58.3326",
    y1: "49.4467",
    x2: "61.0002",
    y2: "45.4453",
    gradientUnits: "userSpaceOnUse"
}, e(d).createElement("stop", {
    stopColor: "#9945FF"
}), e(d).createElement("stop", {
    offset: "0.14",
    stopColor: "#8A53F4"
}), e(d).createElement("stop", {
    offset: "0.42",
    stopColor: "#6377D6"
}), e(d).createElement("stop", {
    offset: "0.79",
    stopColor: "#24B0A7"
}), e(d).createElement("stop", {
    offset: "0.99",
    stopColor: "#00D18C"
}), e(d).createElement("stop", {
    offset: "1",
    stopColor: "#00D18C"
})), e(d).createElement("clipPath", {
    id: "clip0_880_5115"
}, e(d).createElement("rect", {
    width: "48",
    height: "48",
    fill: "white",
    transform: "translate(24.5 24)"
}))))
  , Nh = ({className: t="", container: n="body"})=>{
    const r = (0,
    d.useRef)(null)
      , {wallets: i, select: s} = bh()
      , {setVisible: o} = kh()
      , [a,l] = (0,
    d.useState)(!1)
      , [u,h] = (0,
    d.useState)(!1)
      , [f,p] = (0,
    d.useState)(null)
      , [m,g] = (0,
    d.useMemo)((()=>{
        const t = []
          , e = []
          , n = [];
        for (const r of i)
            r.readyState === Bl.NotDetected ? n.push(r) : r.readyState === Bl.Loadable ? e.push(r) : r.readyState === Bl.Installed && t.push(r);
        let r = []
          , s = [];
        return t.length ? (r = t,
        s = [...e, ...n]) : e.length ? (r = e,
        s = n) : s = n,
        [r, s]
    }
    ), [i])
      , y = (0,
    d.useCallback)((()=>{
        h(!1),
        setTimeout((()=>o(!1)), 150)
    }
    ), [o])
      , b = (0,
    d.useCallback)((t=>{
        t.preventDefault(),
        y()
    }
    ), [y])
      , v = (0,
    d.useCallback)(((t,e)=>{
        s(e),
        b(t)
    }
    ), [s, b])
      , w = (0,
    d.useCallback)((()=>l(!a)), [a])
      , x = (0,
    d.useCallback)((t=>{
        const e = r.current;
        if (!e)
            return;
        const n = e.querySelectorAll("button")
          , i = n[0]
          , s = n[n.length - 1];
        t.shiftKey ? document.activeElement === i && (s.focus(),
        t.preventDefault()) : document.activeElement === s && (i.focus(),
        t.preventDefault())
    }
    ), [r]);
    return (0,
    d.useLayoutEffect)((()=>{
        const t = t=>{
            "Escape" === t.key ? y() : "Tab" === t.key && x(t)
        }
          , {overflow: e} = window.getComputedStyle(document.body);
        return setTimeout((()=>h(!0)), 0),
        document.body.style.overflow = "hidden",
        window.addEventListener("keydown", t, !1),
        ()=>{
            document.body.style.overflow = e,
            window.removeEventListener("keydown", t, !1)
        }
    }
    ), [y, x]),
    (0,
    d.useLayoutEffect)((()=>p(document.querySelector(n))), [n]),
    f && (0,
    c.createPortal)(e(d).createElement("div", {
        "aria-labelledby": "wallet-adapter-modal-title",
        "aria-modal": "true",
        className: `wallet-adapter-modal ${u && "wallet-adapter-modal-fade-in"} ${t}`,
        ref: r,
        role: "dialog"
    }, e(d).createElement("div", {
        className: "wallet-adapter-modal-container"
    }, e(d).createElement("div", {
        className: "wallet-adapter-modal-wrapper"
    }, e(d).createElement("button", {
        onClick: b,
        className: "wallet-adapter-modal-button-close"
    }, e(d).createElement("svg", {
        width: "14",
        height: "14"
    }, e(d).createElement("path", {
        d: "M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z"
    }))), m.length ? e(d).createElement(e(d).Fragment, null, e(d).createElement("h1", {
        className: "wallet-adapter-modal-title"
    }, "Connect a wallet on Solana to continue"), e(d).createElement("ul", {
        className: "wallet-adapter-modal-list"
    }, m.map((t=>e(d).createElement(Ph, {
        key: t.adapter.name,
        handleClick: e=>v(e, t.adapter.name),
        wallet: t
    }))), g.length ? e(d).createElement(Ih, {
        expanded: a,
        id: "wallet-adapter-modal-collapse"
    }, g.map((t=>e(d).createElement(Ph, {
        key: t.adapter.name,
        handleClick: e=>v(e, t.adapter.name),
        tabIndex: a ? 0 : -1,
        wallet: t
    })))) : null), g.length ? e(d).createElement("button", {
        className: "wallet-adapter-modal-list-more",
        onClick: w,
        tabIndex: 0
    }, e(d).createElement("span", null, a ? "Less " : "More ", "options"), e(d).createElement("svg", {
        width: "13",
        height: "7",
        viewBox: "0 0 13 7",
        xmlns: "http://www.w3.org/2000/svg",
        className: "" + (a ? "wallet-adapter-modal-list-more-icon-rotate" : "")
    }, e(d).createElement("path", {
        d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
    }))) : null) : e(d).createElement(e(d).Fragment, null, e(d).createElement("h1", {
        className: "wallet-adapter-modal-title"
    }, "You'll need a wallet on Solana to continue"), e(d).createElement("div", {
        className: "wallet-adapter-modal-middle"
    }, e(d).createElement(Oh, null)), g.length ? e(d).createElement(e(d).Fragment, null, e(d).createElement("button", {
        className: "wallet-adapter-modal-list-more",
        onClick: w,
        tabIndex: 0
    }, e(d).createElement("span", null, a ? "Hide " : "Already have a wallet? View ", "options"), e(d).createElement("svg", {
        width: "13",
        height: "7",
        viewBox: "0 0 13 7",
        xmlns: "http://www.w3.org/2000/svg",
        className: "" + (a ? "wallet-adapter-modal-list-more-icon-rotate" : "")
    }, e(d).createElement("path", {
        d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
    }))), e(d).createElement(Ih, {
        expanded: a,
        id: "wallet-adapter-modal-collapse"
    }, e(d).createElement("ul", {
        className: "wallet-adapter-modal-list"
    }, g.map((t=>e(d).createElement(Ph, {
        key: t.adapter.name,
        handleClick: e=>v(e, t.adapter.name),
        tabIndex: a ? 0 : -1,
        wallet: t
    })))))) : null))), e(d).createElement("div", {
        className: "wallet-adapter-modal-overlay",
        onMouseDown: b
    })), f)
}
  , Rh = ({children: t, ...n})=>{
    const [r,i] = (0,
    d.useState)(!1);
    return e(d).createElement(Th.Provider, {
        value: {
            visible: r,
            setVisible: i
        }
    }, t, r && e(d).createElement(Nh, {
        ...n
    }))
}
;
Er = o("gNDby");
class Dh extends rc {
    constructor(t={}) {
        super(),
        this.name = "Backpack",
        this.url = "https://backpack.app",
        this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAbvSURBVHgB7Z1dUtxGEMf/LZH3fU0V4PUJQg4QVj5BnBOAT2BzAsMJAicwPoHJCRDrAxifgLVxVV73ObDqdEtsjKn4C8+0NDv9e7AxprRC85uvnp4RYYW5qKpxCVTcYKsgfiDfGjMwIsZIvh7d/lkmzAiYy5fzhultyZhdlagf1vU5VhjCiiGFXq01zYSJdqWgx/hB5AHN5I/6iuilyFBjxVgZAdqCZ34ORoVIqAzSOhxsvq6PsSIkL4A281LwL2IW/F1UhLKgRz/X9QyJUyBhuuae31gWviLjiPF1wxeX29vPkTjJtgAftrd3GHSMnmHw4eZ0uodESVKAoRT+kpQlSE6Ats/XZv/ONK5vZHC49+B1fYjESG4MUDKfYmCFr0ic4fmHqtpCYiQlgA66QsztIzFi5j+RGMl0AXebfgn0aOTuvGG8owIarZsXOj3ronlRuEYnn84CJLo4Lgi/QL/H/LHmy/RwI6GA0RoS4acFHi8kGieFXS/QhmijFfQXmH3uPy5lSkoLbIkYlfyzhuM4juM4juM4juMMj6TzATQ4JH9tlRqFk8BM2aV9RWHB9K5kzK/KLui0KqliSQmgBa4BIS54cpMD0OeawFye3jk19JdKkWq62OAFkEIfrTXNUxBV1okf38Ot3MGjlFqHwQrQZvQ22Cfw7xjg6t8XkZaBGzpKIXdwcAJojZeCP5SC30HipJBEOigBZLn3qdzSPlKr8V9hyEmkgxCgj8zefuD9jen0AAOidwE0i6ZhfjXgRI+gDK016DUjqE3ubPhNLoWvaDLJouHToaSP9SbA0DJ7LekyiviNPgP0TC9dQM6FfxeZ7eyuT6cv0RPmAmjTx11uXx/MiegEDd425cfcwWV+H4O3+uiO+pTAVIA2uMN8av6QiWr5TQ++JVlTc/tEiF3jOMScZGC43kME0VSA95PJhWXhM+Gt1Phn98nStZa1r9mB2SDQPqefjhayfnDfFG2J5882z84eynVM5u3thlONhRhj0gLc5PRfwAw62JjW+wjE5Xa1L0VkshO4kXt/EPDev4ZJCyBRvlcwggjHG4EfYHc9OoIBBWy3mEUX4H1V7Ur7ZvILaT8qy7FRduleF9jXc4RggOUWs/gtANs0nYquvMXaMaTXlQHlE1ggayLvf5OKY0DUMYDWfmpsBjZa+9enOmiLy+VkcmqxaNW2ZgX9GnsLXNQWoGj4KYzQ2g8LyG5WUDR4hshEE6CN+AFmg5lFiRMYcI0uKRQGyIAwegWKJkBjYO8tzq12C7efQ7CK2I00MomIxOsCiCcwQhaW3sEQ6W7sPi/yIDqKAHp8m2nIF7COoc9ghQw4NU8SkYgiQCmLKXCCUSziPc84XYBh83/DSiWR3qUo2tT4ONdGYDTub73cSzD/PNt0rojdQHAByoXxw0E7XfoFhsjnRduD+DnWIkkXXACJl1cwRoMmf3cbRaOjLRzDXnKZVj9GBIILUJBtbVzyj9HAU19AgR6I9VzDtwCgMXpAo2Yxp0v/Ybi49ennJtIFEPMY/TCKHTvv+aTSUQzBgwrQ92YHbQVi3UN3GAVZhrf/jzECE1SAq/7n4yOJ074KPSBcJoii598vxgwrqAByg70HZJZbr0JJ0G5XZz5Z1e1rYccA5TAicqEk0O5ECl/3LvYys7mLTLHHCEzS7wz6Esv3+nyYTF58rwha63XAl8PG1aCnhesWq6EdOcKM3WvmXRHh+Gvv/tNVTJlJPC4a3RVEK72+sCSZ4+J/FBVhTUS43J7gJqFjrnl33A3sxtCa3nAWhX6bbAT4hJugCsNZ2TGA8224AJnjAmSOC5A5LkDmuACZ4wJkjguQOS5A5rgAmeMCZI4LkDkuQOa4AJnjAmSOC5A5LkDmuACZ4wJkjguQOWEFYJvz85xwBBWgKM1P68oKKsI/36ACdC9nsDlWPTsIJ5t1Hfw01OBjgI1p/YwLegIibw0CwESz9gUYZ2d/wHEcx3Ecx3Ecx3Ecx3HuS5QjfdrXxTHv3JzEkd2xKwHR9xPNuKGjzdf1MSIQXAA9XUsuuw8nKPpK3PWzs+AvrgwqgP1LojOjoEf3fRv6Zy+JgBSLOGfaOx1NE/6o+rCrgeT9fWp4SljmuACZ4wJkjguQOS5A5rgAmeMCZI4LkDkuQOa4AJnjAmSOC5A5LkDmuACZ4wJkjguQOS5A5rgAmeMCZI4LkDkuQOa4AJnj5wRmTlABqHQBohKhggUVYAEEP8fO+UiMgziDCvCwrnU3aw0nOATMQu8LVIIPAq+JdAerdwWBaQ/fjEBwAaQVmMnN7sEJCB3EqP3tlRGJy6qqmPkFMcZw7sucmfZiHQ6hRBNgSXdaCHbA7KeFfBvz9pxlxtl1gcN2XBWRfwHK959XFRG6AgAAAABJRU5ErkJggg==",
        this.supportedTransactionVersions = null,
        this._readyState = "undefined" == typeof window || "undefined" == typeof document ? Bl.Unsupported : Bl.NotDetected,
        this._disconnected = ()=>{
            const t = this._wallet;
            t && (t.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new Yl),
            this.emit("disconnect"))
        }
        ,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._readyState !== Bl.Unsupported && Jl((()=>!!window.backpack?.isBackpack && (this._readyState = Bl.Installed,
        this.emit("readyStateChange", this._readyState),
        !0)))
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        return !!this._wallet?.isConnected
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Bl.Installed)
                throw new Ul;
            this._connecting = !0;
            const t = window.backpack;
            try {
                await t.connect()
            } catch (t) {
                throw new Wl(t?.message,t)
            }
            if (!t.publicKey)
                throw new $l;
            let e;
            try {
                e = new (0,
                Er.PublicKey)(t.publicKey.toBytes())
            } catch (t) {
                throw new Gl(t?.message,t)
            }
            t.on("disconnect", this._disconnected),
            this._wallet = t,
            this._publicKey = e,
            this.emit("connect", e)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._wallet;
        if (t) {
            t.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null;
            try {
                await t.disconnect()
            } catch (t) {
                this.emit("error", new Hl(t?.message,t))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(t, e, n={}) {
        try {
            const r = this._wallet;
            if (!r)
                throw new Xl;
            const {signers: i, ...s} = n;
            try {
                return await r.send(t, i, s, e, this.publicKey)
            } catch (t) {
                throw new ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signTransaction(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signTransaction(t, this.publicKey)
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signAllTransactions(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signAllTransactions(t, this.publicKey)
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signMessage(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signMessage(t, this.publicKey)
            } catch (t) {
                throw new Kl(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
}
Er = o("gNDby");
class Bh extends rc {
    constructor(t={}) {
        super(),
        this.name = "Brave",
        this.url = "https://brave.com/wallet",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTE4IiBoZWlnaHQ9IjEzNSIgdmlld0JveD0iMCAwIDExOCAxMzUiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTEyLjI5NCAzMi4zMTgxTDExNS40NTQgMjQuNTYyOEMxMTUuNDU0IDI0LjU2MjggMTExLjQzMiAyMC4yNTQzIDEwNi41NDkgMTUuMzcxM0MxMDEuNjY1IDEwLjQ4ODQgOTEuMzI0MyAxMy4zNjA3IDkxLjMyNDMgMTMuMzYwN0w3OS41NDY5IDBINTguODY0NkgzOC4xODIzTDI2LjQwNDkgMTMuMzYwN0MyNi40MDQ5IDEzLjM2MDcgMTYuMDYzOCAxMC40ODg0IDExLjE4MDUgMTUuMzcxM0M2LjI5NzEzIDIwLjI1NDMgMi4yNzU1OCAyNC41NjI4IDIuMjc1NTggMjQuNTYyOEw1LjQzNTM3IDMyLjMxODFMMS40MTM4MiA0My44MDc1QzEuNDEzODIgNDMuODA3NSAxMy4yNDE1IDg4LjYwMzEgMTQuNjI3NSA5NC4wNzM1QzE3LjM1NjQgMTA0Ljg0NSAxOS4yMjM2IDEwOS4wMSAyNi45Nzk0IDExNC40NjdDMzQuNzM1MyAxMTkuOTI1IDQ4LjgxMDcgMTI5LjQwMyA1MS4xMDg3IDEzMC44MzlDNTMuNDA2OCAxMzIuMjc2IDU2LjI3OTMgMTM0LjcyMiA1OC44NjQ2IDEzNC43MjJDNjEuNDQ5OSAxMzQuNzIyIDY0LjMyMjQgMTMyLjI3NiA2Ni42MjA1IDEzMC44MzlDNjguOTE4NSAxMjkuNDAzIDgyLjk5MzkgMTE5LjkyNSA5MC43NDk4IDExNC40NjdDOTguNTA1NiAxMDkuMDEgMTAwLjM3MyAxMDQuODQ1IDEwMy4xMDIgOTQuMDczNUMxMDQuNDg3IDg4LjYwMzEgMTE2LjMxNSA0My44MDc1IDExNi4zMTUgNDMuODA3NUwxMTIuMjk0IDMyLjMxODFaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXIpIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNzMuNTE0NiAyNC4yNzU2Qzc1LjIzODIgMjQuMjc1NiA4OC4wMjEgMjEuODM0MSA4OC4wMjEgMjEuODM0MUM4OC4wMjEgMjEuODM0MSAxMDMuMTcgNDAuMTQ1MyAxMDMuMTcgNDQuMDU4OEMxMDMuMTcgNDcuMjk0NiAxMDEuODY3IDQ4LjU2MTEgMTAwLjMzMyA1MC4wNTI2QzEwMC4wMTEgNTAuMzY1MSA5OS42Nzk4IDUwLjY4NzQgOTkuMzQ4IDUxLjAzOThDOTcuNDMyIDUzLjA3NDIgODkuMDY0IDYxLjk1OTUgODcuOTg5NCA2My4xMDA0Qzg3Ljg3NjggNjMuMjIgODcuNzUxNSA2My4zNDYgODcuNjE4OCA2My40Nzk0Qzg2LjQ4NSA2NC42MTkzIDg0LjgxNTUgNjYuMjk3OCA4NS45OTM1IDY5LjA4NTVDODYuMDcyMyA2OS4yNzE5IDg2LjE1MzMgNjkuNDYxMyA4Ni4yMzU1IDY5LjY1MzVDODcuNTI3MSA3Mi42NzM5IDg5LjEyMTUgNzYuNDAyMyA4Ny4wOTIgODAuMTgwOEM4NC45MzMgODQuMTk5OCA4MS4yMzQ2IDg2Ljg4MjMgNzguODY0OCA4Ni40Mzg4Qzc2LjQ5NDkgODUuOTk1IDcwLjkyOTQgODMuMDg2NyA2OC44ODI3IDgxLjc1ODNDNjYuODM2IDgwLjQyOTggNjAuMzQ5MiA3NS4wODA0IDYwLjM0OTIgNzMuMDMzNkM2MC4zNDkyIDcxLjMyNjUgNjUuMDE0MyA2OC40ODY2IDY3LjI4MSA2Ny4xMDY4QzY3LjczMTggNjYuODMyNCA2OC4wODc3IDY2LjYxNTcgNjguMjkzMiA2Ni40NzcxQzY4LjUyNzIgNjYuMzE5NSA2OC45MTg2IDY2LjA3NjQgNjkuNDAwMiA2NS43NzcyQzcxLjQ2OTEgNjQuNDkxOSA3NS4yMDQ2IDYyLjE3MTIgNzUuMjk4NSA2MS4xNDIzQzc1LjQxNCA1OS44NzM2IDc1LjM3IDU5LjUwMTcgNzMuNzAyNSA1Ni4zNjc0QzczLjM0NzkgNTUuNzAwOSA3Mi45MzMgNTQuOTg3IDcyLjUwNDIgNTQuMjQ5MkM3MC45MTYzIDUxLjUxNzMgNjkuMTM4MyA0OC40NTgzIDY5LjUzMTkgNDYuMjY3MUM2OS45NzYyIDQzLjc5MzUgNzMuODUyMyA0Mi4zNzUzIDc3LjEzNTYgNDEuMTc0Qzc3LjU0NiA0MS4wMjM4IDc3Ljk0NzEgNDAuODc3MSA3OC4zMzEgNDAuNzMyMUM3OS4yODkzIDQwLjM3MDIgODAuNDkzNSAzOS45MTkyIDgxLjc1MTMgMzkuNDQ4MUM4NS4wMjkzIDM4LjIyMDMgODguNjcxNCAzNi44NTYyIDg5LjI3MiAzNi41NzkyQzkwLjEwMzYgMzYuMTk1OCA4OS44ODg3IDM1LjgzMDcgODcuMzcwMyAzNS41OTJDODcuMDM3MiAzNS41NjA0IDg2LjYyMjkgMzUuNTE2NCA4Ni4xNDc1IDM1LjQ2NTlDODMuMDMwMSAzNS4xMzQ2IDc3LjI4MDUgMzQuNTIzNyA3NC40ODUzIDM1LjMwMjhDNzMuOTM1NSAzNS40NTYgNzMuMzE5MiAzNS42MjI5IDcyLjY3MjkgMzUuNzk3OUM2OS41MzI1IDM2LjY0ODMgNjUuNjgzOSAzNy42OTA0IDY1LjMxNDEgMzguMjkxMkM2NS4yNDk0IDM4LjM5NjMgNjUuMTg1OSAzOC40ODY2IDY1LjEyNTggMzguNTcyQzY0Ljc3MjEgMzkuMDc0NyA2NC41NDE1IDM5LjQwMjUgNjQuOTMyOSA0MS41Mzg5QzY1LjA0OTQgNDIuMTc1MSA2NS4yODkxIDQzLjQyNjYgNjUuNTg1NCA0NC45NzM5QzY2LjQ1MjggNDkuNTA0MiA2Ny44MDYgNTYuNTcxIDY3Ljk3NjQgNTguMTU4NkM2OC4wMDAzIDU4LjM4MDggNjguMDI2NSA1OC41OTUxIDY4LjA1MTggNTguODAxNEM2OC4yNjg5IDYwLjU3MjYgNjguNDEzMyA2MS43NTEyIDY2LjM1NjMgNjIuMjIxNUM2Ni4xODUgNjIuMjYwNiA2Ni4wMDUxIDYyLjMwMTkgNjUuODE4MSA2Mi4zNDQ4QzYzLjQ5NyA2Mi44Nzc0IDYwLjA5NDIgNjMuNjU4MiA1OC44NjQ3IDYzLjY1ODJDNTcuNjM0NyA2My42NTgyIDU0LjIyOTMgNjIuODc2OCA1MS45MDg0IDYyLjM0NDJDNTEuNzIyNCA2Mi4zMDE1IDUxLjU0MzUgNjIuMjYwNCA1MS4zNzMxIDYyLjIyMTVDNDkuMzE1OSA2MS43NTEyIDQ5LjQ2MDMgNjAuNTcyNiA0OS42NzczIDU4LjgwMTRDNDkuNzAyNiA1OC41OTUxIDQ5LjcyODggNTguMzgwOCA0OS43NTI3IDU4LjE1ODZDNDkuOTIzNiA1Ni41Njg3IDUxLjI4MDIgNDkuNDg0NSA1Mi4xNDc2IDQ0Ljk1NUM1Mi40NDIyIDQzLjQxNjQgNTIuNjgwNCA0Mi4xNzI1IDUyLjc5NjUgNDEuNTM4OUM1My4xODc2IDM5LjQwMjcgNTIuOTU3IDM5LjA3NDggNTIuNjAzNSAzOC41NzIxQzUyLjU0MzUgMzguNDg2NyA1Mi40Nzk5IDM4LjM5NjMgNTIuNDE1MyAzOC4yOTEyQzUyLjA0NTYgMzcuNjkwNCA0OC4xOTcyIDM2LjY0ODQgNDUuMDU2OCAzNS43OThDNDQuNDEwMyAzNS42MjMgNDMuNzkzOCAzNS40NTYxIDQzLjI0MzggMzUuMzAyOEM0MC40NDg3IDM0LjUyMzcgMzQuNjk5NyAzNS4xMzQ2IDMxLjU4MjEgMzUuNDY1OUMzMS4xMDY1IDM1LjUxNjQgMzAuNjkyMSAzNS41NjA0IDMwLjM1ODggMzUuNTkyQzI3Ljg0MDcgMzUuODMwNyAyNy42MjU4IDM2LjE5NTggMjguNDU3MiAzNi41NzkyQzI5LjA1NzggMzYuODU2MSAzMi42OTgxIDM4LjIxOTYgMzUuOTc1NSAzOS40NDcxQzM3LjIzNDIgMzkuOTE4NiAzOC40Mzk0IDQwLjM3IDM5LjM5ODQgNDAuNzMyMUMzOS43ODI1IDQwLjg3NzIgNDAuMTgzOCA0MS4wMjQgNDAuNTk0MyA0MS4xNzQyQzQzLjg3NzQgNDIuMzc1NSA0Ny43NTMzIDQzLjc5MzcgNDguMTk3NSA0Ni4yNjcxQzQ4LjU5MSA0OC40NTggNDYuODEzNCA1MS41MTY0IDQ1LjIyNTggNTQuMjQ4QzQ0Ljc5NjggNTQuOTg2MiA0NC4zODE2IDU1LjcwMDUgNDQuMDI2OSA1Ni4zNjc0QzQyLjM1OTQgNTkuNTAxNyA0Mi4zMTUxIDU5Ljg3MzYgNDIuNDMwOSA2MS4xNDIzQzQyLjUyNDYgNjIuMTcxIDQ2LjI1ODggNjQuNDkxIDQ4LjMyNzggNjUuNzc2NUM0OC44MSA2Ni4wNzYgNDkuMjAxNyA2Ni4zMTk0IDQ5LjQzNTkgNjYuNDc3MUM0OS42NDEzIDY2LjYxNTYgNDkuOTk2OSA2Ni44MzIgNTAuNDQ3MyA2Ny4xMDYyQzUyLjcxMzYgNjguNDg1OCA1Ny4zNzk5IDcxLjMyNjMgNTcuMzc5OSA3My4wMzM2QzU3LjM3OTkgNzUuMDgwNCA1MC44OTM0IDgwLjQyOTggNDguODQ2NyA4MS43NTgzQzQ2LjggODMuMDg2NyA0MS4yMzQ1IDg1Ljk5NSAzOC44NjQ3IDg2LjQzODhDMzYuNDk0OCA4Ni44ODIzIDMyLjc5NjQgODQuMTk5OCAzMC42Mzc0IDgwLjE4MDhDMjguNjA4IDc2LjQwMjYgMzAuMjAyMSA3Mi42NzQ1IDMxLjQ5MzQgNjkuNjU0MkMzMS41NzU3IDY5LjQ2MTcgMzEuNjU2OCA2OS4yNzIxIDMxLjczNTYgNjkuMDg1NUMzMi45MTM4IDY2LjI5NzUgMzEuMjQzOSA2NC42MTg5IDMwLjExIDYzLjQ3OUMyOS45Nzc1IDYzLjM0NTcgMjkuODUyMiA2My4yMTk5IDI5LjczOTcgNjMuMTAwNEMyOS4xMTY3IDYyLjQzODcgMjYuMDQgNTkuMTcxOSAyMy4xOTE2IDU2LjE0NzVDMjEuMTI4OSA1My45NTczIDE5LjE4NTkgNTEuODk0MyAxOC4zODEyIDUxLjAzOThDMTguMDQ5NCA1MC42ODc1IDE3LjcxNzkgNTAuMzY1MiAxNy4zOTY2IDUwLjA1MjhDMTUuODYyNCA0OC41NjEyIDE0LjU1OTggNDcuMjk0NyAxNC41NTk4IDQ0LjA1ODhDMTQuNTU5OCA0MC4xNDUzIDI5LjcwODQgMjEuODM0MSAyOS43MDg0IDIxLjgzNDFDMjkuNzA4NCAyMS44MzQxIDQyLjQ5MTIgMjQuMjc1NiA0NC4yMTQ4IDI0LjI3NTZDNDUuNTkwMSAyNC4yNzU2IDQ4LjI0NTcgMjMuMzYxMSA1MS4wMTQxIDIyLjQwNzhDNTEuNzE1IDIyLjE2NjUgNTIuNDIzMiAyMS45MjI2IDUzLjExOTYgMjEuNjkwNUM1Ni41NjY3IDIwLjU0MTUgNTguODY0NyAyMC41MzMyIDU4Ljg2NDcgMjAuNTMzMkM1OC44NjQ3IDIwLjUzMzIgNjEuMTYyNyAyMC41NDE1IDY0LjYwOTggMjEuNjkwNUM2NS4zMDYyIDIxLjkyMjYgNjYuMDE0NCAyMi4xNjY1IDY2LjcxNTQgMjIuNDA3OEM2OS40ODM3IDIzLjM2MTEgNzIuMTM5NCAyNC4yNzU2IDczLjUxNDYgMjQuMjc1NlpNNzEuMzIwNiA4OS4wNDQyQzc0LjAyMjggOTAuNDM2NiA3NS45Mzk4IDkxLjQyNDQgNzYuNjY0NiA5MS44Nzc5Qzc3LjYwMjIgOTIuNDY1IDc3LjAzMDMgOTMuNTcxNyA3Ni4xNzYzIDk0LjE3NTVDNzUuMzIyIDk0Ljc3OTMgNjMuODQzIDEwMy42NjcgNjIuNzI5MSAxMDQuNjVDNjIuNTg2NSAxMDQuNzc2IDYyLjQzNTQgMTA0LjkxMiA2Mi4yNzc5IDEwNS4wNTRDNjEuMjA0NSAxMDYuMDIxIDU5LjgzNTMgMTA3LjI1NSA1OC44NjQ2IDEwNy4yNTVDNTcuODkzNiAxMDcuMjU1IDU2LjUyMzUgMTA2LjAyIDU1LjQ1IDEwNS4wNTJDNTUuMjkzIDEwNC45MTEgNTUuMTQyNCAxMDQuNzc1IDU1LjAwMDIgMTA0LjY1QzUzLjg4NiAxMDMuNjY3IDQyLjQwNzMgOTQuNzc5MyA0MS41NTMgOTQuMTc1NUM0MC42OTg3IDkzLjU3MTcgNDAuMTI3MSA5Mi40NjUgNDEuMDY0NyA5MS44Nzc5QzQxLjc5IDkxLjQyNDEgNDMuNzA4OCA5MC40MzU0IDQ2LjQxMzcgODkuMDQxN0M0Ny4yMDY2IDg4LjYzMzIgNDguMDY2OSA4OC4xODk5IDQ4Ljk4NDYgODcuNzE1QzUzLjAzMjIgODUuNjIwNSA1OC4wNzczIDgzLjgzOTcgNTguODY0NiA4My44Mzk3QzU5LjY1MiA4My44Mzk3IDY0LjY5NjggODUuNjIwNSA2OC43NDUgODcuNzE1QzY5LjY2NDUgODguMTkwOCA3MC41MjY0IDg4LjYzNSA3MS4zMjA2IDg5LjA0NDJaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTkxLjMyNDMgMTMuMzYwN0w3OS41NDY5IDBINTguODY0NkgzOC4xODIzTDI2LjQwNDkgMTMuMzYwN0MyNi40MDQ5IDEzLjM2MDcgMTYuMDYzNyAxMC40ODg0IDExLjE4MDQgMTUuMzcxM0MxMS4xODA0IDE1LjM3MTMgMjQuOTY4NiAxNC4xMjY3IDI5LjcwODMgMjEuODM0MUMyOS43MDgzIDIxLjgzNDEgNDIuNDkxMSAyNC4yNzU2IDQ0LjIxNDYgMjQuMjc1NkM0NS45MzgxIDI0LjI3NTYgNDkuNjcyNCAyMi44Mzk0IDUzLjExOTUgMjEuNjkwNUM1Ni41NjY1IDIwLjU0MTUgNTguODY0NiAyMC41MzMyIDU4Ljg2NDYgMjAuNTMzMkM1OC44NjQ2IDIwLjUzMzIgNjEuMTYyNiAyMC41NDE1IDY0LjYwOTYgMjEuNjkwNUM2OC4wNTY3IDIyLjgzOTQgNzEuNzkxIDI0LjI3NTYgNzMuNTE0NSAyNC4yNzU2Qzc1LjIzOCAyNC4yNzU2IDg4LjAyMDggMjEuODM0MSA4OC4wMjA4IDIxLjgzNDFDOTIuNzYwNSAxNC4xMjY3IDEwNi41NDkgMTUuMzcxMyAxMDYuNTQ5IDE1LjM3MTNDMTAxLjY2NSAxMC40ODg0IDkxLjMyNDMgMTMuMzYwNyA5MS4zMjQzIDEzLjM2MDdaIiBmaWxsPSJ1cmwoI3BhaW50MV9saW5lYXIpIi8+CjxtYXNrIGlkPSJtYXNrMCIgbWFzay10eXBlPSJhbHBoYSIgbWFza1VuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeD0iMTEiIHk9IjAiIHdpZHRoPSI5NiIgaGVpZ2h0PSIyNSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTEuMzI0MyAxMy4zNjA3TDc5LjU0NjkgMEg1OC44NjQ2SDM4LjE4MjNMMjYuNDA0OSAxMy4zNjA3QzI2LjQwNDkgMTMuMzYwNyAxNi4wNjM3IDEwLjQ4ODQgMTEuMTgwNCAxNS4zNzEzQzExLjE4MDQgMTUuMzcxMyAyNC45Njg2IDE0LjEyNjcgMjkuNzA4MyAyMS44MzQxQzI5LjcwODMgMjEuODM0MSA0Mi40OTExIDI0LjI3NTYgNDQuMjE0NiAyNC4yNzU2QzQ1LjkzODEgMjQuMjc1NiA0OS42NzI0IDIyLjgzOTQgNTMuMTE5NSAyMS42OTA1QzU2LjU2NjUgMjAuNTQxNSA1OC44NjQ2IDIwLjUzMzIgNTguODY0NiAyMC41MzMyQzU4Ljg2NDYgMjAuNTMzMiA2MS4xNjI2IDIwLjU0MTUgNjQuNjA5NiAyMS42OTA1QzY4LjA1NjcgMjIuODM5NCA3MS43OTEgMjQuMjc1NiA3My41MTQ1IDI0LjI3NTZDNzUuMjM4IDI0LjI3NTYgODguMDIwOCAyMS44MzQxIDg4LjAyMDggMjEuODM0MUM5Mi43NjA1IDE0LjEyNjcgMTA2LjU0OSAxNS4zNzEzIDEwNi41NDkgMTUuMzcxM0MxMDEuNjY1IDEwLjQ4ODQgOTEuMzI0MyAxMy4zNjA3IDkxLjMyNDMgMTMuMzYwN1oiIGZpbGw9IndoaXRlIi8+CjwvbWFzaz4KPGcgbWFzaz0idXJsKCNtYXNrMCkiPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXIiIHgxPSIxLjQxMzgyIiB5MT0iMTM1LjY3MiIgeDI9IjExNi4zMTUiIHkyPSIxMzUuNjcyIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRjU1MDAiLz4KPHN0b3Agb2Zmc2V0PSIwLjQwOTg3NyIgc3RvcC1jb2xvcj0iI0ZGNTUwMCIvPgo8c3RvcCBvZmZzZXQ9IjAuNTgxOTgxIiBzdG9wLWNvbG9yPSIjRkYyMDAwIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGMjAwMCIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MV9saW5lYXIiIHgxPSIxMy4yMjkzIiB5MT0iMjQuMTg2MSIgeDI9IjEwNi41NDkiIHkyPSIyNC4xODYxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRjQ1MkEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkYyMDAwIi8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==",
        this.supportedTransactionVersions = null,
        this._readyState = "undefined" == typeof window || "undefined" == typeof document ? Bl.Unsupported : Bl.NotDetected,
        this._disconnected = ()=>{
            const t = this._wallet;
            t && (t.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new Yl),
            this.emit("disconnect"))
        }
        ,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._readyState !== Bl.Unsupported && Jl((()=>!!window.braveSolana?.isBraveWallet && (this._readyState = Bl.Installed,
        this.emit("readyStateChange", this._readyState),
        !0)))
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        return !!this._wallet?.isConnected
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Bl.Installed)
                throw new Ul;
            this._connecting = !0;
            const t = window.braveSolana;
            if (!t.isConnected)
                try {
                    await t.connect()
                } catch (t) {
                    throw new Wl(t?.message,t)
                }
            if (!t.publicKey)
                throw new $l;
            let e;
            try {
                e = new (0,
                Er.PublicKey)(t.publicKey.toBytes())
            } catch (t) {
                throw new Gl(t?.message,t)
            }
            t.on("disconnect", this._disconnected),
            this._wallet = t,
            this._publicKey = e,
            this.emit("connect", e)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._wallet;
        if (t) {
            t.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null;
            try {
                await t.disconnect()
            } catch (t) {
                this.emit("error", new Hl(t?.message,t))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(t, e, n={}) {
        try {
            const r = this._wallet;
            if (!r)
                throw new Xl;
            try {
                const {signers: i, ...s} = n;
                t = await this.prepareTransaction(t, e, s),
                i?.length && t.partialSign(...i),
                s.preflightCommitment = s.preflightCommitment || e.commitment;
                const {signature: o} = await r.signAndSendTransaction(t, s);
                return o
            } catch (t) {
                if (t instanceof jl)
                    throw t;
                throw new ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signTransaction(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signTransaction(t) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signAllTransactions(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signAllTransactions(t) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signMessage(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                const {signature: n} = await e.signMessage(t);
                return n
            } catch (t) {
                throw new Kl(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
}
Er = o("gNDby");
class Lh extends rc {
    constructor(t={}) {
        super(),
        this.name = "Coinbase Wallet",
        this.url = "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSI1MTIiIGN5PSI1MTIiIHI9IjUxMiIgZmlsbD0iIzAwNTJGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MiA1MTJDMTUyIDcxMC44MjMgMzEzLjE3NyA4NzIgNTEyIDg3MkM3MTAuODIzIDg3MiA4NzIgNzEwLjgyMyA4NzIgNTEyQzg3MiAzMTMuMTc3IDcxMC44MjMgMTUyIDUxMiAxNTJDMzEzLjE3NyAxNTIgMTUyIDMxMy4xNzcgMTUyIDUxMlpNNDIwIDM5NkM0MDYuNzQ1IDM5NiAzOTYgNDA2Ljc0NSAzOTYgNDIwVjYwNEMzOTYgNjE3LjI1NSA0MDYuNzQ1IDYyOCA0MjAgNjI4SDYwNEM2MTcuMjU1IDYyOCA2MjggNjE3LjI1NSA2MjggNjA0VjQyMEM2MjggNDA2Ljc0NSA2MTcuMjU1IDM5NiA2MDQgMzk2SDQyMFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",
        this.supportedTransactionVersions = null,
        this._readyState = "undefined" == typeof window || "undefined" == typeof document ? Bl.Unsupported : Bl.NotDetected,
        this._disconnected = ()=>{
            const t = this._wallet;
            t && (t.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new Yl),
            this.emit("disconnect"))
        }
        ,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._readyState !== Bl.Unsupported && Jl((()=>!!window?.coinbaseSolana && (this._readyState = Bl.Installed,
        this.emit("readyStateChange", this._readyState),
        !0)))
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Bl.Installed)
                throw new Ul;
            this._connecting = !0;
            const t = window.coinbaseSolana;
            try {
                await t.connect()
            } catch (t) {
                throw new Wl(t?.message,t)
            }
            if (!t.publicKey)
                throw new $l;
            let e;
            try {
                e = new (0,
                Er.PublicKey)(t.publicKey.toBytes())
            } catch (t) {
                throw new Gl(t?.message,t)
            }
            t.on("disconnect", this._disconnected),
            this._wallet = t,
            this._publicKey = e,
            this.emit("connect", e)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._wallet;
        if (t) {
            t.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null;
            try {
                await t.disconnect()
            } catch (t) {
                this.emit("error", new Hl(t?.message,t))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(t, e, n={}) {
        try {
            const r = this._wallet;
            if (!r)
                throw new Xl;
            try {
                const {signers: i, ...s} = n;
                t = await this.prepareTransaction(t, e, s),
                i?.length && t.partialSign(...i),
                s.preflightCommitment = s.preflightCommitment || e.commitment;
                const {signature: o} = await r.signAndSendTransaction(t, s);
                return o
            } catch (t) {
                if (t instanceof jl)
                    throw t;
                throw new ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signTransaction(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signTransaction(t) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signAllTransactions(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signAllTransactions(t) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signMessage(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                const {signature: n} = await e.signMessage(t);
                return n
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
}
Er = o("gNDby");
class Fh extends rc {
    constructor(t={}) {
        if (super(),
        this.name = "Glow",
        this.url = "https://glow.app",
        this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAB4FBMVEUAAACjON6dNNyjONd7C+GIHNq1S+K9W+O3TeLAVOe6TuSJHtqcMdPBVeiuQt2kOdeRJc7AVeeyRd95COR9DeF7CuKWKtCaL9KoPdr78/789/7//f+zPt7u0Pi7ROG5SuK9TOT67/315PzVYfHAT+bx1Pry4PuiMNWmMdaqN9moM9fv2vqvOdvtzff15/ysN9mxO9yzRN/13/ysPdz46Py/SeTFVemPE+/EUOe5QeC3P+DJW+y9SOOfLtPZYvT46/2TGOu2R+GNEPKaI9/PXO7t1fjbZfWgLNfu0/jIV+rQX++ZKdCQIdSWIOGmN9iYJNvCVOjRVe/CTOaKE+eZKNSgKd2TIdnLV+yECfGfKdqKEO2dJ9ylL9iNHdr02/uHC/KjLdp+BfCcKdbKU+t7B+eUJs+dLNKTHeG+ROXUW/GLGeCFFd6PHN+JDfOuQd3JS+vNWu2EEeGOF+WiNtbOUe2BDOf02fuSGuWOFOuUJdPWXfGFDuvMT+yVHOWIF9vCSOiZJteACeyLHNV9C+N4A+x1A+mGGOPHUOmKHN2aLtKFEOWXHubarPLXju7CfevoxvffuPXQmu7QfuvnvfXJje3dnPHBauTOcOu4bfDjp/SqUOytStugNu6yXd6bKueVNOUmkAxzAAAAGXRSTlMAIxB+3D9C/WLfo2CcxcXf34TffL6cvc/vU7i1KQAAOkJJREFUeNrElMFuqlAQhivICpLehFofgb6ET1CjCwk7drZNwA0SFqYJ8Upq1Ke+/wwz9hwurtT2m5lT0933z+jDLRgMPN/3w3AEnoihkAt1l10PU3SHN+aP8EwEQeC6ru973sB5+GWgHY4gW5jk1LlNjSFruy13FLEz5KGP/p9X5Xg8jp8D1/cGDz+N44WjYd6cKRorAozBDgHUaIX1YV13lo8WdS5OgKfrrxwFDsL1fuogHH80bHrcG/MEUAbqv6PC37ROU3v/zI7mjYb/ofZd/TfUUeyVyQQ9Du5/C174tGxsEEFViX7znYEF++/0AlJF/MmbS+Dtb2C7QZmQvHA2R5uM3Ttm4ITDJWg6EVTwRwsNHwBaqQ0QgrpTEa28wQat9Bx/+5q77/Lo3ycD72nJWOpsL/4NTV4Q3evP2krrQ4rz7zCdog3gzxFg/Wg27/nqvxvyR5qyLCPUJIomUeDdT395tucAyL8p+EEAyt5MwOBwsN0TLmRgAn3lLG4e/yvswdmerctyIoUUwNi/i76eAA3Loxu8NKeWYr/fFwu8pyzPEUSW11mW1TX1IevY69/pFC36SSL2cbyJ2RyNR3kXe4H0eaShj8H7eLsrGOj2vxo8/AlTVeTN6ixPb1GcsgL6GUWAb0IGyJ8TYFbpCtghYEg9QYM2gVh4pbHtgS4fq9fF4wi6BIMb/fSJPRfbV7AXOILWXi8A+idM1gvrrwiSp1a2WpsY+hguiuCSP906tPkC+nFvcf1DtV8qpE+jQF5ZIAHaPqYvgwPkoU9vukosNlr4SPom6m/IR2hOAK8ym83KWWlx9ffAGen1f9tTG/IoNlcWSgbWFy8A/miTrVYM7AhIHk36SiTAEto96PfAuW79JP5Fj/IX/gafmIXtvpcS5TXNCupo3j2eD06ASKnnsNf1b7cxdWzxrlj2ZfTyEkWia9RMX+bxil+CEOpfNEszgcriE71g4P/J5sJ6sRbIXAIgPmhA8pEw8/m8fbYEJ2DKm/r29l+QgOhe5IpfAmf0j9SyaWkjisIwrS0I7bbgIn/AUDBlFm4Ds8hKs2lloouQILrLIiATGAQDycZf3ed85c4dTTX2Oefe+LF6znlndGv2eQKUh7XKNzQ8oE5BigD6mFvxlam7OTef6N+r99h4CrL1z3/P74JcX+xzTuVw5Xz0Mfj0ZauE/kblOQ9afDbKs5hzuKhnTQDXMgLg9kupezEPrqgLs7+SekojwFtKL3D/3F5xccBeL/+CuwWPwUcef8jyr/pBs25aeAT0LGX90A0A8nSoI8/+XZ71y6Fh/jTPuZun+Ef2Q7+vgjgDd2EfoJ//MYFvBB+4N5tbGv3Zeq++FFxzHPbPZbD7WjMQj74yZgIXF2NPQHoIuvrJHlrr79v+T+mckC/8KCfHB/pvFey3txv8Z7cz/BNNhok3DIB2edG3DNS1qtPBlbgbZTkuYwREwNefE/LJX+j3+5f95Fvo9uOmikspvZSjg17/4c8ERB//dgAqumoPICH6Qo2/URvy7gt/2z/rl97p34wFVZ5oz0ejOTUy/46+4f7hzSn0FPY9aEiUo4P9Af3ZZqbs078mAKlSAuItWC/VnwkYZm5XaZg+TT3d2ADUH338R7hLOaGf9m/OdIIfKTEMncDB/gTAJ8DlEah2NHQ3AKuV+HNgpfrBfRuxd0pB9DlywWQ+gVEbt4+nP20fzpL4Ty86wa89DMcHPv9BSkCFv16N1nU1NfsUACbg21/VMoM6oea4O2OpFAHcXf9m4owS2V8/9++r/dkplcw5r3N5+d4JfL0N/7DfaK1lCFWbaTWdTq+b9v6BCbB7j0A2gMd72OmXbD8Y0+g7XXt4GQBfPnVWnLnkgJO+WFiZPingTXny6b3//4S+uQdVNaua2D76Qpb/AHd62B4A9o++/6BkAoEFwNiz/zwA7i9Y9tW6p6dHFxBDcMjA2/8PfO74awJcn9PZPvqcYJXA3dj5Gzt3lw9CPgUgi0CuH/4uj77lfoB3gm8W3Rgwgbf+K/6xNdzfymH/0EiZfh4AXgDOkh4OaZnDMA2ADAS5fjlO+kFXHzJ/DUCkfzAoegPoLVoFi0WWAV6G39/8A5DvP6MKEKdoKrE6TwkAnYDKox+8OoCbMtt/sDcA/vYHe/cNlF5ONgM6ZnD0zxeA+cf+YdPVb/RMXybg/Bx/118Nawp9G8AL/449144/O/3JngCEvQ1AMH0aYw5N/er1aPvJX9rN5bWpIIzi+BYFFz7AqOSWLBTflSKloQsTEFcuBR+BVHBbQUEUpIviMjFtbSmllv6tnvkePTN37qRW6ZmZGxvr4nfmfN8MCQKfMTgxtQHk/Y/5dzl+uv/OzwR81QTgdcU1Go1evsR8SX6sV3Tg1bs0AYM7gzuYoG8KAOBBpAb4tpuehAXpu3ORBVPawLW0/DFzA4ZhQGoB8Q8SMB/wJQMSA2hlRAMCfFjkBz6m0TMB0JImAPjgN/wkAbr7c6CfJbvimwFYeHovMBWL4EzS/+gA2PEwftUyxnDYRwSUHvhvA7zQm4z+2SjI8GHASGT8YJcl9K/wIP8SDBB6237Meybtf1IAef1z88GukjciC84WDKidgGkBEN8cEANE/f686huGw2OAHuOZ4pMfCwEYRfjGj2kGhOeLpRdLA5HwswCCAdx/zATf4amPmHiPKSgVwZVaAJRcZ7b/y8vgDwnoiwVmgEzh9weebgCeFgDDpwVAlwX5/mMGiQGDgd0ATcr/2NsfJiWZ73bJTx/owKniCQA5PwbF64/zQ8M+ZA0Q8gpgAr5KBFgBln5Mp9ceIOjUm7CWVANRHADQewBmzYFI3Vvdbneh+wQO9Gr8qIKg4klwjfyEfx0eQ+M/CD/xYQCWByBYUGsBkDuA7dfhGWACVPQB9W9SfnNA+EGv4glICf3CAvAXYEAPSm1wBy6VOmC9/0F5BcAAzP6yBiDil6fBf/YAIAIrGGkPBD5FAzwARp8HgAbMzTXhgx0jqIfpiqrAe+HZUgdUC8guz1oHcFkCpAWYvAnOB3ywi4TYEwDt7Uy2xutrnU7rpqjVub+2Pt6YnKtyA1Sof0zgqwGYNID4EOBdPRggj5CENARNEbioXwA4PS3AyPlZA6p5SughwfcegCXa35mMO0Au6v7mxrm75GcFRB8CCL/guwGsfvK32712L8oAliYA4lGYBeADO0C6/8N8/xv52QSUHvtvCdgj+yHqbE6qmL92CfLyB37Cj/B3ia8WVJEJUyNwJnwFCDEAbP/N/OgBhQBYBr56DGTnx4j7UdQZb98dDOhAnACI/HEFOL2pCqtHWRdojMA14ce3PzwANQJ5/pmAsgHGji6I+O9P1m7+k9Ymv5t64F29A0BpACDlT9SrggniQ9wGahE4cfAdsNKzBZT4+4UA1LW/C/p/1+YEBtzLWsADVUMCJPqJqoopEHq/DpxMvgeCYACvQAJPlfe/HACM3a1C8o9SC7/LPSA5AS0BNXgoFEJV7wPpdfA0+P0b0OYPQModsJwAbv7/6eF2/FF48yWILSDBD8tf1AD2gUtxC9QEQJL/1YS/0P+oZv6dqfg3dOrjUHUmtY8CD/hn4wuw81NAp5gBMSBqg1eiAKyyA/AAsNtfKQAU8W83UxOb5DfiUbLgl1qg/HkPzM4AaLFytWVUtaPgFCvA+YGPscoEJOkfEr/IT/ycnha4iFx+jxYEAx6zBbAC8v1fxAgGtDGzCHgGLvEMcPE7cOC78v5XdIC1nyNhMgEyigngr6UWbHsPVEkFMACgjwxok32x5oCHAOcAz4Afwv/+g9KTf+iiAYfw763X6ZOf/En0JBHsDvxNar1KL4LpHUDwGQFhl4HpOUgicJ63IJXhvwZ/Af/wApi0GuC5u3zBYDRu2Ip+lT9Eam2kPZABqDfARagK0yKgFvBKGBw45S2ABqgF+ArsSPtPA/aeJ/SOxx+zzJPTX5O/zEL0qCoYUA8AJPz2jKvAE3BZ+U9GLcBEAwr4BQO2ai3PFP0pfsr7GTTTIL+U18IGSyA2oJscAAeawZIU0AA6oE3gjLcASPFX2QBKNwDyU779hjRNtMbtoBl8W15pURSC5kMw5a+wPAfsA0kXOMtbQJIAsH9X/iOcAFr9bHT/p/q/T1LQ+mkGzBZKYJGamUEGsCoXbwPeBa/mFQB8LOcf/k0BjDaiA+wYlKZg/EQc4D0wSwAF+pm4EUT3wQtJD/zCCgj4UHr9L+Sf8Vf84+DPU/BoxvlZAbUO+FTgRfInJsAjYFehT94DvqQJ8Bvw3wRgt8XtP07RgkfbWQ+o7/9TYcfS13oNQNflHij/ASY2wL4ErtV/Tk9NDP8Y6WmB6w9v5/7aZhWHccVLRUHw9kO80L6hBrUaFdu1IJIpFBWVjnlBNm84UFj7SyeSiSjiYMY1TROb1Rrb+a/6fO/n5OStlzmfc96TqKB8nvOc75t0fb/uugHCXxqwsgITlB8GLKQGyGeB2+kmcMX41QDAWw2o/wJEwzX+3/jjpgBdTwPgDjj9wgpdC4nKCNBt4D4yQB8C0gAI/od/9xNAfwq/gesWKkLQdwPK/cfmqwF+BiIDbsA9dBcUA74W0W8Bx03wHP8haNCX+CU/1LDl1pgRGRiGAWGBJUCO/0qRgNSAO+ibABug+MiAHgDAn9Pb4GufFviJAetJ8Ws0MCG8ykL8eMF0W+LdTchq4dJ8+V1Y+FV/4QDdBx9OA8APAcCANAEn7v/O6qCyO5/BhwfhREhcMldkoVVl/ya3q0ZxCGBAyY+L+c2BxbIKmAF3SgL8CEBUACQBmPJnwHUGrA9Wj1rOX6/woRRnRC4FFvoiKeGIWFANHp97wmuACehMD15e8bIYEVjIDKCvQ5spP+DVAZZwY62vf50jfAgU/H+rR8MHUUQk3pcpeey5ucfnm6gDVgLiLuDxx8KvZkFEIAy4UhoAAV62/1x5/EP08be1c/ry4VLKfxNW8PAJYbUhHmPVAzLC5wAUYHXA9z9LANAJfsUPwfSNEF+GcwPUAvsNKFx5BBw/7v8j/F7A0ahxSxVumCWtuWcff/wX+TxA/O5A3AMF/+zK4uLiAl2lAfRJ6Hbm31b+LAEYLDhQ//kPWzGBAwhBQ1Vh3ALlh2T0Ir4MLTT1MyGdgcCPMwB8SgBbIJpfCAfEgLskALkD51LVff6dMD/UPoIB72YhqGzcGk/25ujPx1/Ys/vhr/4T0eC3/OPiCNghyMvg3TCABH6W8tMw5fQhFH+Iq99Qfkv+aMnRQ5kL/40T7fHTT9OPRHb9dtiYyz8IMz+T8/678kMgn4XvKxMAJftPi+OHdpwfOgQ/6XD9nyWg+jf4o5f4h+PPzi833IHWgpVA49ftF3otA5KBLAH3sAHcAKLmBOh9cHVaI+eHmjv6sNQfg8bfS0BF17+pGvizUv4Twpde6jcgc+C3tARqAII+IpA6IF8GHrqyLQG4RgZcKwwA+rnVkn9g/KIxJ+Aq5h+jEjB/X2H6q6sqnJo2ibQ/x78wSgn4pQFFBnbjBKQF0Oj51TKQnIE71AAE4Bqkz0GeS7U6S0eV8psm9tTwVbMAqipQJJxVAR//sFT5T/aP6bdm5bfl5lFwzAIpA8oPxR3wrPJHAEoD9FPANrUB0Mdf/9qAVsJfEefQ+cmCwbpsoe8l1KgdVb7/9jqVpHb/+BV/au7p568rv2fgkyIB2H58CMglBsQZeOC2R7a3v6bhDQC+pcc/DZ7GDI2dvzIdMj+m6HCdmTENqWI1Sn76R+EVzdw8qTLjr754RQzgBMwbfzhwPSkBtv8YZ/MUBD8bcC++DcMBiA3Qh4Czp0ASnaYJHQl/YOGltcMlIDQZVaVKfD/qNf+sIu0fywPEkYB+o3TgQAJg9DQXCZ9nmQAzYBuKBMgRwLAEkPhXYMsDQPgdQ+sMQB/axPjjcFjNNCETg2besOL90vgrbx9iCThopEoOARng4v3HsqYGlA7AgIe3SVkCsodAcGHRAOA6LQdA8t9JHGh1we0maC8l8uCmtDQ6juZB4IfIgOfyEumHIBKAIfSsxVBUwdSAa6IIAMZlOMD0wh9//l15AXB1MAaCHxG4aQ+G4+Op/jF6BAZWHXMHGqeSACySBSaEYHFN+HMD7mcDwgHgk/ghQMxVnr77GPCg7/wdF3nQ+i7n36Srt0nXZPyPTVgfHbzCjbSCP4rgEqHzCcnLwJ4bcJYdCBVVoM4APgTpU5CrMiIBkzgAUxok+GDH2sPa6232oC8ng/56x+NCk18wptUajo5/zvvnZQY8NeDsRQbiEPwaCWDsMGCtPANhwJUsAcYfFjA6Llar4De1uoGP2SP+ngzVxmQwHu4JepCHBet7o8HxV9FFL+2gZPzQvvB7qQwH3vA/EWD4OABra2vGv5hEAAZYR1Cit88BKb/8Dnzo0G4AnVKDogTABKX/HtfHNKA/fj8eDMaj/lA1Go3Gg4Pjr37+hhT4ZgDRYxr/XFXIHdjVBOQG0H1gdgQehAHKzxZwAtAR4TKG7b+hFwGojcDFi3QEeoSf6PuP2QLT24UMXy3w+Pv+awnsn2DAshhAnwCNXSZCMIOfDLBOmJQAa4AC/EhAxn/o/O1Ou8LAmzbT03oI9ovE30PrPNl6WuWd49fzg90TMLsCQr9Xs+QRKBIAer0TrpU3QjJAdJWWd6+GBSKCvlwGoGLkSoa+wJGh8GNhD1gRAOd/GwMz7aaZN1HEDE3tPwegPgPLOf8aLxBlwBQ1gBNwRR24ui3faC/RCAMu1wQAvApu/LBkQvS9q9h/zICP/e+FBbVNJIHPY2b+6R5Y60BEIHZfBimNwDxLDJBWoIQfjcDCAFYZAMaFBRBeXCPuGMcuyBL0zi5DE1AG4BvwJyr4B3zjqD8Eb2QBcC3yIppRBNmAbWXHoFczoAxARfD5YFXt1jvcMi/1gLUlAQhFAj7AAH/gSw/N8vzrs7P79B/CVBPKCPxKd0HbfSxYhd8DYA5EDUAb3DwCl1j+FLhpzwNQNw63ROQDzd4WsW9R+Le8i2YeAOCHyu0Peub/ndmxYC0MKCKwFlqUmUcABoBd+DEUXgZagAh86Ogv+dtDghcLMHHBAtHHNQFI+YV+6vNPdA+iHwbucgBUFc8iAil/fgoEPz0Dt20CHxc74Am4JNJH4N2GvhiAA1DvwA3BReM4lXXQpGGNdL9R/g+ijfJ7mNQ6EtPw38puf/rY4HrHpZ+k4zSoAb/FCWAFf/HTcTJAxQmwCHAbGEt/xKAVARCV/O3B1iXtm8aDuUWgtz66eAd4lrDTOqODquHHc7NzgR8hYCOiDDbOiAPBHg6o0gSorl2UBOgRgLgPSvTC8BIIzELE7mfgyxB7AAEdF1ags6SJLhblx+4zPhbb/ah+SeeIUadUJS5EBH6RBET+g39NzsDMBFgAQI+pNSBNwBAGcABO1A3tmCZT36cNVGX7pYsqVuw87T6GKGue7Pj22CyfgOXCAjsHEoEn9QyclIAFws8NoI9wYFd8PgTY+HgQ/sgrwIkaaLswdwGDuscx/Abv/gZetI3qD8Q+pS8Kfn9car5zkjwCp+pPwJmpM2AGXNzkLsCMbl2gTuc6tACcrCHgIfZAV+Br21S84JXpOQCEX9KXN3/rm/YLth+jTnYjuA7+mRYY/mKSABPzwwFeoK4UAH8I/vSeBeBkLd0g5ugXt4GZigygBrLcQRfCEvQqo4/tBzxpn+CX/zICT+oRKFR+I8wNIHShNwNCN+gERADqNbFOYRs09B2odUA/hNA41fQ5FLufGhB9k5YhOIBFFYaUZ6CsARhn3ADmLwzASPvA8QOgch/ACZAANNsna8z7XvQM8wQAO/idniX4UIb/jPVMeP5gWdShJSwIWRncXVH8+gjUJwBL1yXwmN1+BKDZbLoNpR3DIM+lm7+B6dvPw/QK0ef4WdeMZ0cM7+Io8BQrIgL7HoAyA6xIgP9PQDQBOb/gd2m2ogQ2obbMWboB/lLaM9Kap85QRp+dfusatW/obYxUHgM1oJEa8NOpIgJRBMwALYKSgK5Z8F0XDSCIf6c7kXsA6Bkdrzwg+2v7G83JLAMYH9d5mucz8NdJSm+KtnFp07A2sDEz+igLePEIvJwYcIouT8BaGPBqHIHvv/cEcACC/zSaP5AHh3YCmq62v9FVPRioAdErbQML6FneNvPzaBj3OVuAMdU3L7afdUAGGH+YkBYGM+B68Bt+fQLAbwZsSRvkpA0i8PFmpztMDGjxJYo3bfOgnwbg/eiWF/xZx7hQ0TVPy9+zqnHbIqBrqU5SBDj+GKd4YBJ+/oXwVTaA6MEvBmCgD3TCT+pGCWDUFkYTSzN945HYMwNAThbU8efw2e7nj4pbw4hhWxyIWQiHgA1YFgNAjxIARQL0ThgJQP2LAACfZAFwdW9wCaAAKG2bkf1Nlof3s0Zx3CMt2gWGMv5i+5P8m/baoghBfQTezIpgODD9o+HbLAAia4E/ZUCXamBWAmACLfEGw4LRnBC/4bPOswPWLC3k/KqsZ3RC/wIvhg9ZNaw1YPes4WsEwoLFMzgBJE1AHgHgk7L9RzUcSwngAADWlnhDabAwDBhfQ+AKenlFuyzf/Y+KpqnJ8beuYXOC7/zt2QZUXgVB/9MFOgai9PtA1ACgO34YAH2XaagnQHMur0quPkQ0xnoEYv9d2fZ/hvGRbD8cyPsFPa8GRL8U3ARSGXvpgFZBLv8/Af+C8mMm9wFLgP0/0KIGCH83d2A9NcAy0G61gj0OQrMv/FCQJx5oqzjGJ2UtI/OekYGPazfD57W+CCxLAuQEYLK8CCxEDQD7j/z/gepFDehSAMKALzHTEtDiBRJm5EFccO2l6T+fROAzDFpMH5mYvrz7RQBIfYMPE06ognoXvIBTAAOsDJgFkQDQs3oegUv6Ew2z4B28Wg0U7ta0mjKhFg8+Alz04AIug5c3oeAvm0VBwu7aF+bEAMzaIvAyGwD8C6gDloDAx7QEkAW9qIGQFoF3MCBaJlwDEQADTlV68ZLy57LNLwPwjPLnx3/agCfkkza4m/CB8We5oAbsEi1t/wWWOHBGIpAmwALQI36rAdEF/Ttc8OLQSkAddf76uycA+x/4uGp3vwyApd/VbsZXEFyqMgKZAT8RPE0xgEKgRSASoAbo7osB0Qedf7A1Lgw4UQfgB75l4LzhY6mPv/PXBOBPys7tJ64qjOJVY+o16otaK6WFTlERtQwYLV7SWJSi9mKaEqMSY2PFxAhJDYmmCY0vjQmUFgpIGv9X13fba1/mUF3nMjNeHtZvr+/bew4zZ05n7zfUPpJgAHBUTQAA9g2A2g//ECNQ9AD84Q4BoH+zT607gHLYubcAvhGx/X19YPm/kRNQ++XNchTAYZgPBraLvBJaANspAAUA+oc8Af4roLD/Hey3AJCAu+yBjHq37lysekBjH3t9u9Dy6ke4p3Z98CF95hSsIPIIGIBNser+CeC9S7EWZBOEDIAiwDXsFsCXm0fZA0dqBu3L+/5zCSkAHf0/3BfrX+w2AxLAqwagfvuN3aVdseyCPQJQBK5LeRMggLAfBVADmCWAjhZY1MM9vfIBVfa7OyAXQGo/BO/Y7bSlrtkICAMTgxAoAUx5CwgxA5dsKsxXghoAQ2B/zviy0qkAMO6m47GVA2j8d9qvbhfIBhjD/6oR2PJBj4dWU+CA08cG4PZtBMAInM8jcMmaABPACoD8V4CqAPx0AgB8EhhX/wcjWJcSeLh/I9B2ALNf3Tb8nY1klEGILBBJmgePZAF4FwhwSgAMgQGIFui/gxkFcLFsgkcdQG573DcRwRiA2v/XrX+6L94BVDeLo38DwPQz/ykAdo6FwG0oCJzHFgnQErAm4CVAAvUc+AkBaAnQN7aSBB7IYN1KwGe/cv3TUf8QO6DK218OYBI7VtqtyIEA3rtd9QACYA0gARAB6CSAv+PE7+Bgkxc/YSXcJIAswreDCADyxj/sU+0CMJTyT/sh4SAAaJePVAmAywCM/3lNACcCJiD3f/UX7QDZj+B4EpAAWQeN0HWbfr4MAHrhQ+wPaAAIvqu2b3eNHwgABCwEB4oJYAWgBbAJQHFJgAAgAIB9yAPwSYw/fhjNALxVuBwPGhx6fSQAqBn/jgCw/ov7hVKeAEyzxiFYtBHwpSAAsAMsnIfePZ+KQNyzBByBfHIBCWAAZPcewJWwe20fWAcG4GtV2f6prvzTfwtA7E8yBrKJ+LwBcNsBuOqJkADcPpTG3xKAXQGcUAAjZpGO/RgnCW+Ct3j1uwHQ+m8ngMEAJjH+CiEYpCBMYVMSUEyDt6Hcv7QC1oBfGQUAlSZAFQFQAgmALITYAzzu6jpynyOxEuj2X8e/vQRG+9TWJCKgG62ThR1AEQmYUvtOQErAqiAmQlUA+O7PlIAvr8YvAToDfUkAYrgoBI5/Vg73fgj7GYAu+yUA+m8BjFgGJsM2/WevIwGT6Y3AwoIQWDD/DqA7ARfhHs4pDcSmLYQ8ADb8yXdwYCDu4zcTTZ3pZ/7pvqMBMgGSgawR1idsLIFeJADOPQIkwIVA3QMuQjQvIdBF4d1YCI0PlFKxklDdAQBXd/dvABT+W+1OZjVg403/bAUBYCI6wAISgF3l/knAAXzBACQCFAisE0AHAT9qAB3L/3r9f/AEcEbPhydDWQ8clIApBbBtABauLUBKwWUEmADYVwCeAGw1AawM70cJjB8gMvgnADSrX9rv/hsA1PiHjk+SgJ1om3tKwH4AUPO0XyyFDIB8aNsB+Md46h/Du3iHCXiICOAz/dtf4/+Njvybe78CMFCTpQrjLAdbCuOiqANwkQEAMAIOQBPgAZAdrulf9Pf/A/BAAUDff1b6by+A0j8vgZQ/GwRZCibC+Sk7Ff75xAFsGQAYN7EPFguBQ2JfE/AFe4CcywT0/x8A/9yLMChXfy0Be/9XNEDaD9nL7SoAZRTSamDqhALYM//UiiNgDRgAIyD+2QPgWa1/YwHAyS+K/jcAQwDQ2Dfntf0k1n81+kSwU/g/hd02YpAtAGgASGBGM0ACJ50AAMSXtwyAC97FNwCYTuHd0H8GsH4FAExE0LZ/Eujof/QPGASQE4CMgrrXScAATBYAVlZWFlayubBNgAKIDHyDDQhkj5LAPJgAzGIL8SmFhSABcPrj5f9m+neJ/ToAlK2EOO7MgO9WAX5ZfKL2D5UALnkCYN0Q6KeXmQB7MBgxDWAtHI5BgU8rGHcSgG8/o30TAYgq+1Az/ARwuAnAIs6LiiBqIS0D9mMdCPtQICCAVAL86pKNPzzrZntoNwDAprknB4ehe8yC6ccim+7XPfxtB3zffj3MAQxn7rFxl5eL+jDCSSBLQALANhgAmICrmoCLkQEyMApfcxowl7O+EQifPUgVQP/Mf+X/7e7xf18kZ0cwAY9BgBDUvQeAPXAlJgECUARG4JITAACzbwREt2j+Gyh9tvWUTwNhk5sT4bOJK1ECY5qAdvLDHwAPan+8YbwpUrCPuOf2Pfl8IAB9M0z/LIK6DQKAILiqBYAIQBeVgQkUzP8tdkFGnb6LBKwTAET7B+XflLm38FNCYMesLqpVL/5F1gF29kADEPYZAb84RgAYf5N/iUPk/kkA/0y64MAEBASe7l+hf89+2/1oH2rLP90pNSewt7iItEvgZefQZ/UQPXAD9nMA56ILtAlIkgiYxDalAK72y2kg3OuZu/dAyD/8WF/9MP9R/V0XwCL/xyCc5VESMLy4CN8CYbFYCSAU8Sp64N5NAqCsDbIJEMBVScCtIPDND5n/H6QAQOCEdUF3HxD4klkYg/8PLQBV/Pl7ad3tjw0Q1pMsA5uIgMVeQHj64yQNIiYBtgAZfQgR4ExQJuDHmAR/D/8/AMDXsI5DdQsqm8BsBoGjP4vn0N0rP1zvAJB//rWq/9q/D3yJYGdRA6BFQAQ4DAqqw9eB2zdvOgDaZxvkRIhZIH2DXwBcDQBqHwDkQ+14eatqAux4DkMeoyruXZHvPjT+Ofqmjukv818A0G6wtQi5ddusF0QJsAUIgN8WFi7D/+VzJgVAAiyBHxUAhC+xiX3oa0oIQLdujflKQEfa7OLsDyZ7+s91AOB3Pvlzye34w34NoMh/HYFhA5AlINci3wuvSAAuw6xavywQuBpSRQ2kBEBXDEBFwPxDm/F+aLZS9Q/GrqMC1H85/cvsb+IHAAavf2m/JiBNQCGkEOQCAJsEewjAb7/BrJnvigAB/GgA4B87ARQJuJJqYPZArV/h9/7Ki99F+Lv6P/PfyJoACGBzAhoFChVgV4MUwOWFc3kCCCDvglYC9vVtVdgnANMVqwFrAgdplwD40Q8r/3b51z3/txIoux4AJyDmmQMCmJcOIC0gEsAIdCQgKoAEKgTy71gDB+nBdQAI/wMXPzg6/LP+g8AHVQSG1HwhEoirQRPWAi+7dSCYd//QIABMQADABU07cF1HauCK6B/OA93avp4BUO+Mfzn8fPvf+C9/MosEpAag8aIERJYDzgEggArA6HsC5ueFQQ3gkpeABYA1AMG3CQwSgbETnAc6db8JAPx31L/5J4D2F7Owf6B7ENhdXI0aoGI6iFXQ8s2b6AAWgJ9//lnME4AsB2dAIAHgFEAAMvCZtAag+1kbHJqNkz1hBbADMP3038a/+c28LAAiQ+A6OYQA6E6ldsBV0E34dwDnfsY+D5UJIACMf7QABqCS18CDsg3SOp9uf84AtG/9Wf2dy1/aJwArgyX9RzuWgGBAZS0QBcAEmOa1CLgaJIDnpQIaAESQA0AblIsCCmBIdhxVCHZRAc0X/zn3t/5pnwBY/5SHYGlvFd5Xx3GulFpgb1n9MwHz2ByASv5UEE3gSQCA8hJoAwAedRuEX9mwk4OeL6QAcPFL/53tn+Xf/lwOtXRsaenY0CrMrzYBKFrgbxEAAHCxCvQieQ0ACFoAlMZCIxAXxmAWMgi26b6OALADDux+NN+Mfwtg2o5pOS19sCQENlYXJQBCYRxHHYC2BcpG/wAww2mAAH7EDVxMrICKwHX8S74jUvtGQU/2uGsdkA2g6f2mgf4ZfwKgLANLSydXxb0icK0yAEckADmAeSAY/Xl+dHQeGEAgpoEZAuDd+zgJmMZ0U5l/SC4NTr1lAKA5bFAg2GYHzH4pPgfQ7d9U268QLEF3hYDEQM84VGkOFP/RAuAeCEZFFoEVAgABA0D7SuB6IkBhVJ3A53xDEO5xThzuMwCsfyn+7sVPs/4hgHBPLQEB2qAZt14gT4sAWAVAmP7UPgDMWwAsAjPoAYMAMAFyPSdCQAKobgD4/FTeBeYm5Mws9BmA8meyu6/9Mv7Y2vy3CDQClKcgOgADwP4HBCKLwLmVmRn41xKAagDXr4v9H+ifGbgO4T+qIgACc1b+eHaP/r0B9Duq//jx3b29rQ3X1tbe7u7Jevw7tLS0tVqrXAWrfxDwBojxH5UT2yAQeAIA4CUCAIG4i4td0cIhAocPIQGACMhaYMojMJtvCADv/RwNsF+O/tnDexs769tzcz3ss3Ozs71eb67nmri7v7G1d9KHv5vAV0MNgHoKgHTw//jj5z/EvkkJlACePfQiAcBeBkCMi+xRCWgE/knLQe99OGy/92EA8G//FZd9Tx/eugfnFKzDf6vt/Y29k5n/r3yjNjoDsMUASP/D4dZ187dE8L+gNfBuDYD+FQAFACIAgPCJMSwHIwLY49QvCiCb/mB+Y108z85RcC8HznKarSns7M1U3gPBUh0BaYHWAbeXAcD9ewJGM/lEcE67gDVBAjAFgBh9NaQA2AX6fFPIVQB0j/6L/nd4C+aH5nDImbI60ANnIWHexzMI9jsB78ntIBSHI9gYGICjR+ZTAMy9A/jDMyAR0HkA8hpoAfBWPpWI4D5XQ2HfA8AGEPYPb2yrb84Vg4UE0D61ub/1VRIQrE1Pr2F7b2i1h83EKXBf/AcAcc8AsAewBgzAM4MT4IIfJMDkAIBgln3QNJsFIC0AZOw3hyhNQKeQAOy0nzHYyxHkXaBXd8AiAAEAR0wDo04AALwHPAUA3QF4DTsJMAP6tnhqBATEu6tv/tP4n76zTt+y6Qs9wEF3ymqgS5sbM04AhbAm29pmr0f/fBvMDugRGC2lBGYgJAD+HQAJ0L8BoMoQ3GMRRATuZP4BYHhjk0tlWlcNToBs3WIMtAzW9no9+JejLgB2gI/U8kfYmAFNgAFgAtoCaP2/FgCMgRSBL4dMd/u5/8M++LZYnMAc4SMvmxKoO0Iv2mGrcY/BltmXA7rbE/vw3xQAhNH34Q8IKkUQACwCLxx6rADQjP8b2AZk4AFmgqIN7Ga3voV996fmITzB5gFozBMC9v+AQLWwqgQ4A9QFAOno0zwToDpfAWAHoH1jADkDpuC+LYcmT42rn/X0ZwCzPzE0MTE3IeM/FAlQFHje0Q57B9dAi2CjVyyBdqIAIPP/EQBg8HE4BJ8Iw78n4Onk/y8HkI9/CEFgBlRlG+hH/mHf/NuwT5hvP+P1rGxFAyyrgHXQhSAAXNssGsAyAfj4W/0rAPq3ElhRAJcA4IkcQBMAOKI0AmRwIbUBZOCON4Bhs2+b7ZZ+tS4IojOoPAqMAHUgguXltbXltT3xHw1gYbnugBp/kXIoegCnAQB4XAG0/nlVX8o6EMSyEEIbCALb9n/079O+JgCGgwIeZnFoEeCZcTAKZp8xEM2lbYD2Z0AACHbYAOfNPwNgBFQMQERgRmQA8IuT1RTY3tFMKbiiDwiDf45GI3yg/8edTfiESWfAk21zeCHuxbofegox/Q+Pwsay6NpQrAD22gIQ53pAZQKg6AHvAsAjBuAvCwCcVffzAwA7vBUIAYdw3wiM3Jf/48G62mUGsFebw4nh50YRgQWguw6EwF40wOXlpgN+hD2pXg3PpB7wCACwA0QA2m+0GYiog9A9JTBhw+9Df5D/WS8FeXAIOLI2kFrhw7V/DgT24Z8NkAGAfScw+qluXAxFBM5bCTx66FB0AAIob2lH4ZUAyBisg8DsAxl+eJMAQAGAIEjATt4WsUwwAL6r/VxD2LpgrC4O7YFATyeAfAnkAXD/nz4sAfjl6efVP0qAARCTvKOHHZoCy4ApCNwZe+3OOBZEUuO5e7LgFv9SW4IslHxlyNWwusauh51b+QIIyZ8/cXQbHGL86d/cf4qdTcACQAD469hhBUD/TQN4G7uLCAKAzAnj98b66/q+CBkwhVUcAaKgwDYJ/xMegCHPPk5BQFh0MPAF0OL88sYkht8bAN8FswF4GTADBiBWgs8CwIuSgDoAF/hnvVJMgan/2oNTRz5GJ5QMBAKPerite0L+JNogACgFaM4QYPNz63/SF0AnNpZXNP91AXgEIgHsAZn/GQfwDOyLCKD5Rnsfx5v9Nx1AMHAMm9oJfUU0MUiKoc5BahMiWw9g/MM23aeaoLJLIJPivl4BRP1bDbgGJ+ApAHjMAOQVcKFw3+/DPvwrAgj+k4TVuhPA+4JeTYBloQeHPxBwGvAnZp/55+7SN4Dx5cibzD9nAI4/xCbAJsgEvAAAT5ctEPYvXKhuakf12QsoJfAxCIw7gQ4KEgI9kwMB6FP4rHoAdxzuf4T+1T6U/EM+/h0AoCwBTwDA46kCxkiAf9fq93lbU1EiIIj881/3lMAUvrTERtApLpZqyehDDEC9M/42/6t7jn8RAHOvJ9GgaVAWggDwCAFAN8bMfwqAePfd1Q8ElN1sDgQYgg6xIKAKQk8OH+0O+/SP26aGfwLIGgBkCEaRAUlAaoPwr8KXBrAQ1HmQADwAr1+wHoDh7wsBV98gvF0ikGXC7sgrbAQMQZc4TRICJV47hz/8H9li/MM/J0DzzgQwAkUCsAyAXkpzwI0bYzcUQPhPACimoNDwSDQChGBubuI/qiVA89Uew/+xtf9RWC/8Q3kDZAKcQMcyAHrG/EM3UAL0/7oCoP1Xcwb9AgEycdpuOfifQ8CVUgXAoEQK2uG39neO7lXW/4IAAwDVACDxLwSeUgBPGwD6B4BIAOwXt7QqYoB/r977ViobJ17xXkgEne5dRFCItln9kxz+Izs+9ysA5p/+KSTAFoOpBUCcBESPA0D4v3Ej9w8ZANinLAtWCYDAzz9YGWgIJlcflgJeLxgsdU77HH6Jf9b96wUQ/ZcJ4CwQ7wRsEoAeZQLgvwTA73O3CMCm1s5RD8EIPrrYe3gh2DujLgA+J9C+3yz0Zlv+HH8CSHXQtIB4M/juo4dUzzMBJQBIC6BVtIRwjif64riEIBCsdiLg+6LODEz0aF/Tj7WPDv8e3/wX/jkD0L7tQDA4AeiB3gXZA9S/SyqbAajFnqhh0CfQzgmpgxNThmCcDLpAdKqnMvueflQ/F38Hjz81ygAUk6D2wOiCat9LAHL/TuDVbhUTpJ2P4/MDCQFjcPCaqB1/iOGP9E+M3hTV/q3+sdF+XQFcCfN6kLSAaAK6ChAGuX8I7gv/ZwZBwFbd/rVGAAZD/y8D7r6w38OFwNY/pP47AuAI0iTAOUDWga4X473wjQrAoI+0d3EwCHbecgSYEYzBuNTzAf2gY/BpH5e+9VJw65/V32m/bYKoAGkBoccsAfks2DcCdQCwq/AwgACzQASIgc4JqwhCXQ3F2yJ96BXuZeL30Yd9UVf+OxoAFwJ5ACIBL4R/rAQ8AFAEIAHgLR2S3vfHzqZABGRgEExptDkJ0rslfyT/0Zwhs88CoP9y/EeTCKCzB6ICQi/pm+G2BACAovX3/c4Gorocompw3poAApsVjYFBSBgoeod5uLfoq32v/RoA819eAoFz3UzpzUC9DJRFwJNqnTUwFj0AcgD1dzrju/xJXUGIyjl5V2MABg4BFBSDgaAWoUmId8Y195j49veWkzgDlv1fpGlX/yKF4BNBcTGAq4AnMgCPpiag9rH1X/cA/EoC4fwYDiIIKaMWxta2/14/GACCUQCHWiMq+6kg/obw0N41Mb6Ggx2ge/4f1RM3fc0CYAs8f0krgHqxnAUusAQq/3Rv32tXBl2N8YwyOYlSUAaA4BQcBMWfSUrm4X4H7s15HoBknzMA4x8MrAxsHTRKAvU7QbbBKgEO4NVIwGlYeT99pUFPOGyHoi2KX86TbJvDW6gFhwAKygEkku30o7FmHu6PbG9cW7PBl4d2BoB7VVn/Mf66Q6j/rgDYKogRiGkgawF4058K4PTpVACNLAZymP8ztZTP7samQRAOLlhW2+HcRn5qe2dmbc3th+Lyf9kAIdqPAOR1UAJw/1wE5BEggJgFISQgAHgABgOA2AzkqP0bvuG9nc1xWASIVkfN+9btNZfaX+uYANv6H/UDmz31BAz6qyBbICPgABgBUdh/9fSZM6cVQJcMQRRDq2zy2MUnxu9uTqyOHDmqOjI1NbS5vbOxNbO0tLaG3aXu6V8BVAEY5QogtpgCcOqqgBnOgXkE6N8yEAkwCPxWd5fMXetcdtZPDnGpFc2HmP92BqB/dcwm4C8+yqbAUQaAHaCIwFhFIEsAAnD6YQDS/NAMPHY5+fnYmaX3sZXu12xbSwS0+xX51w7QOf6Q9/7Bw99cDGz1CPxn82DfaiBmAahugh/IaXhwDBwDB9/+6RJ23+AaEUjuVeHfnVf5p//mCmAQ4AJAX5d/EWMAuAYo9Jh3QVXZBdEDAOAs/Wdf7tSzZ8BEwyaOP3zL0Z0A+s8SMNA/lwCcAXyvA8DxtwDwbVCpR58TAFwK9Z1AGYGzdG9nEf+Bq1gu6iv3zvF3BAwACbD7037rn1MACRQtwOy31wLZAes+2DQBSLqg+T8r9ulf86/usctWSQccUsNnjtG9RP8Y7ScItK8EOPzWAJJ9NsBR+rfUKwH3zjVw9akAdsBGz3ApxBqIAIDAaU2Al746H/5gePgDVw1hCf0uhh0vfGua/xrd19N/W//4LrT45x9BiUDEK+H2T8I/AYh/FkBbBDealYC6x24IIJh3Bm4dDMDBGTQQuHX5h6ax5/4h3Boe9pv+d84DYO3N/uSBs8545UXArABoXwLw5KOHOvVIXgNsAgHgrEi8GwMxHgoCpBBn9WxP3L4hYOPHN0AQgOks/V8pghj/azH8Nv7zVgFOADIAFM2XCwDOAN16LACwC8osQAAQnGMXJdfHSaBJgvrFA31XCdDvgDAAX4n929jUv98U7vLlFf82+LwkYBT+1X6a97KCkIMfEM8nQGwsgK424ASgvAaQAQUgXfCsRiAYwDn8Hz+OAximiQAHfIvUvj8WUuc4sLnM/W0WgN8STMcf0gTo+AcB2iaK0RD9138LOLANtF2APUC64FlxDgZmH7ax47BzLSkF2MfRaBoyBmF/TbL/3m3VtaQFIRD2kYBRBCAEAhECq4IMwDz2wv9BDYBtQAi4f9YAS4BtQCnoNGAR8BywKzAK0JId2vH4tVBjoOYh/7XoZRJQ97wlmBYAirr4MlAqAP9ILPZEoB7/J9kAugm8DACpBIiADLIeYC7NOxkcnwYGmCxugkEO04V93XX0Re6e/oXAyoLZRwSg5I8UfOCr3teO/2H6P0BPpwio+f6vv/pKiCEYzsQEZDJz8MqTGaf/TF/F8GsAVOV9oc9FA4BgrBJ983nr/zwvAvwvAkxAMRNk9mUHgW6pZ2NCtfbRAGGfHYD+IQUwLxVg5rDTcoWBX5Mtxp/+H6rHog1eIIHTTQaIQDPQyQD1EF7xorFvAHzscdB/DWAeAEZBwPtbGwX6Z/t3vcsV4H8jwC4A+0bg1wzA8Fmal/NxmQs7ExAg6D//Vvx708i+IIAMAX8fp0oAlAY4eaVvumf8PQD0/38IeBfQUxYBIggI0PFh+m01zYciBCenxbnsMK8A6J8JYASgPAE5DrpX87V95P9/6d/izp+1kRiI4l4vKOvFdvBVKY642ebKI7AEXLm0K5HmvkUI3PeHe9LM5K2klTnsmPz0x06KwHt6M1pIsd3TXysCMcEiAGZqANCDEogOW/z8PHuoH4bh7W2I8g15S7ae/8nkw4CPsxgQjjdLwJlDofyT6H+o6q8/D0xrAPz+WY1AbIMX9A/6CcnxR3wMyuswFQ/5StAPRL95AF1ngxlg7LX0Vb4ZYPf/NQ78kgjIZYgAvGMkjfAZg8CDug8DAj9ggw1T9HXgYgDW+DoKagCYWBCwJAS93Hn0qfzxSv1guQ4ZeDFgASPAEJTkwmWXGUkcCPKB7qMhAQhFAKgfU1C91B2X2EP5Wv79cnEd7acD75oBjMQE1sB/ZMAMqCbA4/iVUwTypQ+YB2gEMgC/qnZA9dTP9ndVGaANGNGCIgVVihgwBKUJwHtsdIAWiAMHyJeN0ifYr6byR3Bl/FkGvAmyDBwnPGfSGYecIawCy4CHAZ4OKAcxAaI+dKAUDvHYOQ6UzssP7JaL23CP9i8CZoBlYKTdkPL3WQXEmTng4xbVez96YAaEhYP8ozkQYepDmOSMlYU//pmVW9xOiypgBhILjvSAHTE3oWTI8TEE0I8ZGDFpAQi3GU2ow9r3PP6badZsBOIA9BtHsq9QGoBRWGA5MCwFYUghIAtiwrwRvPdOIn/TUMPNdfCShQBjzoNYCHlH0L3qgRf5r/pdsVaAKTmAOig0+Vgfc+oPo+A3bvGVdFv2gawOaEJZD7waZcMigwxM4NkRzQEM2mClcNKQJ4mPG+Rjp/yvxq1pgVC3YC/7bDVgowWYZoHXGfGAPmAG+OJUOeyTjpB6KOdrdUfIvwdN91hJAT3IfYDoI2MwfzlMrwa64DPGBFEr/YHSgfcbtL670bTbLAVhJNAEpqFoCLXeCNKCyCy4jA/q3eLONG6tJogBrISUoidgS/uCUvGAPmQ2YIRNpxjjw+dq1/Hs78vStf32iZUwfUC84MM+8YF1gZXfD9hYEIqv8rDpO3d/8WUWOviwfRITFH677ENigzBTEjqJxySrVd/vOtcsvpll41zXtW3b9zAE/FAgXGb+4CgWpGmQNfPYuFI2oAe73a7rnGu+RPc/7NDmX/6EDAkAAAAASUVORK5CYII=",
        this.supportedTransactionVersions = null,
        this._readyState = "undefined" == typeof window || "undefined" == typeof document ? Bl.Unsupported : Bl.NotDetected,
        this._disconnected = ()=>{
            const t = this._wallet;
            t && (t.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new Yl),
            this.emit("disconnect"))
        }
        ,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._network = t.network || null,
        this._readyState !== Bl.Unsupported) {
            const t = e=>{
                "object" == typeof e.data && e.data.__glow_loaded && (this._readyState !== Bl.Installed && (this._readyState = Bl.Installed,
                this.emit("readyStateChange", this._readyState)),
                window.removeEventListener("message", t))
            }
            ;
            window.addEventListener("message", t),
            Jl((()=>!!window.glowSolana?.isGlow && (window.removeEventListener("message", t),
            this._readyState !== Bl.Installed && (this._readyState = Bl.Installed,
            this.emit("readyStateChange", this._readyState)),
            !0)))
        }
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        return !!this._wallet?.isConnected
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Bl.Installed)
                throw new Ul;
            this._connecting = !0;
            const t = window.glowSolana;
            try {
                await t.connect()
            } catch (t) {
                throw new Wl(t?.message,t)
            }
            if (!t.publicKey)
                throw new $l;
            let e;
            try {
                e = new (0,
                Er.PublicKey)(t.publicKey.toBytes())
            } catch (t) {
                throw new Gl(t?.message,t)
            }
            t.on("disconnect", this._disconnected),
            this._wallet = t,
            this._publicKey = e,
            this.emit("connect", e)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._wallet;
        if (t) {
            t.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null;
            try {
                await t.disconnect()
            } catch (t) {
                this.emit("error", new Hl(t?.message,t))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(t, e, n={}) {
        try {
            const r = this._wallet;
            if (!r)
                throw new Xl;
            try {
                const {signers: i, ...s} = n;
                t = await this.prepareTransaction(t, e, s),
                i?.length && t.partialSign(...i),
                s.preflightCommitment = s.preflightCommitment || e.commitment;
                const {signature: o} = await r.signAndSendTransaction(t, {
                    ...s,
                    network: this._network
                });
                return o
            } catch (t) {
                if (t instanceof jl)
                    throw t;
                throw new ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signTransaction(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signTransaction(t, this._network) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signAllTransactions(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signAllTransactions(t, this._network) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signMessage(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                const {signature: n} = await e.signMessage(t);
                return n
            } catch (t) {
                throw new Kl(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
}
o("4KAV8");
var jh = o("degpm")
  , Uh = (Er = o("gNDby"),
o("6ZWSX").Buffer);
function zh(t, e) {
    const n = void 0 !== t ? void 0 === e ? 3 : 4 : 2
      , r = Uh.alloc(1 + 4 * n);
    let i = r.writeUInt8(n, 0);
    return i = r.writeUInt32BE(Wh(44), i),
    i = r.writeUInt32BE(Wh(501), i),
    void 0 !== t && (i = r.writeUInt32BE(Wh(t), i),
    void 0 !== e && r.writeUInt32BE(Wh(e), i)),
    r
}
const Vh = 2147483648;
function Wh(t) {
    return (t | Vh) >>> 0
}
const Yh = 5
  , Hh = 6
  , $h = 0
  , Gh = 1
  , Xh = 1
  , qh = 2
  , Kh = 255
  , Qh = 224;
async function Zh(t, e) {
    const n = await td(t, Yh, $h, e);
    return new (0,
    Er.PublicKey)(n)
}
async function Jh(t, e, n) {
    const r = Uh.alloc(1);
    r.writeUInt8(1, 0);
    const i = ec(e) ? e.message.serialize() : e.serializeMessage()
      , s = Uh.concat([r, n, i]);
    return await td(t, Hh, Gh, s)
}
async function td(t, e, n, r) {
    let i = 0
      , s = 0;
    if (r.length > Kh)
        for (; r.length - s > Kh; ) {
            const o = r.slice(s, s + Kh);
            if (2 !== (await t.send(Qh, e, n, i | qh, o)).length)
                throw new (0,
                jh.TransportStatusError)(jh.StatusCodes.INCORRECT_DATA);
            i |= Xh,
            s += Kh
        }
    const o = r.slice(s)
      , a = await t.send(Qh, e, n, i, o);
    return a.slice(0, a.length - 2)
}
class ed extends nc {
    constructor(t={}) {
        super(),
        this.name = "Ledger",
        this.url = "https://ledger.com",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzUgMzUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI2ZmZiI+PHBhdGggZD0ibTIzLjU4OCAwaC0xNnYyMS41ODNoMjEuNnYtMTZhNS41ODUgNS41ODUgMCAwIDAgLTUuNi01LjU4M3oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5KSIvPjxwYXRoIGQ9Im04LjM0MiAwaC0yLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCAtNS41ODUgNS41ODV2Mi43NTdoOC4zNDJ6Ii8+PHBhdGggZD0ibTAgNy41OWg4LjM0MnY4LjM0MmgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDUuNzM5KSIvPjxwYXRoIGQ9Im0xNS4xOCAyMy40NTFoMi43NTdhNS41ODUgNS41ODUgMCAwIDAgNS41ODUtNS42di0yLjY3MWgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMS40NzggMTEuNDc4KSIvPjxwYXRoIGQ9Im03LjU5IDE1LjE4aDguMzQydjguMzQyaC04LjM0MnoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5IDExLjQ3OCkiLz48cGF0aCBkPSJtMCAxNS4xOHYyLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCA1LjU4NSA1LjU4NWgyLjc1N3YtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDExLjQ3OCkiLz48L2c+PC9zdmc+",
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this._readyState = "undefined" != typeof window && "undefined" != typeof document && "undefined" != typeof navigator && navigator.hid ? Bl.Loadable : Bl.Unsupported,
        this._disconnected = ()=>{
            const t = this._transport;
            t && (t.off("disconnect", this._disconnected),
            this._transport = null,
            this._publicKey = null,
            this.emit("error", new Yl),
            this.emit("disconnect"))
        }
        ,
        this._derivationPath = t.derivationPath || zh(0, 0),
        this._connecting = !1,
        this._transport = null,
        this._publicKey = null
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Bl.Loadable)
                throw new Ul;
            let t, e, n;
            this._connecting = !0;
            try {
                t = (await o("3scHN")).default
            } catch (t) {
                throw new zl(t?.message,t)
            }
            try {
                e = await t.create()
            } catch (t) {
                throw new Wl(t?.message,t)
            }
            try {
                n = await Zh(e, this._derivationPath)
            } catch (t) {
                throw new Gl(t?.message,t)
            }
            e.on("disconnect", this._disconnected),
            this._transport = e,
            this._publicKey = n,
            this.emit("connect", n)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._transport;
        if (t) {
            t.off("disconnect", this._disconnected),
            this._transport = null,
            this._publicKey = null;
            try {
                await t.close()
            } catch (t) {
                this.emit("error", new Hl(t?.message,t))
            }
        }
        this.emit("disconnect")
    }
    async signTransaction(t) {
        try {
            const e = this._transport
              , n = this._publicKey;
            if (!e || !n)
                throw new Xl;
            try {
                const r = await Jh(e, t, this._derivationPath);
                t.addSignature(n, r)
            } catch (t) {
                throw new Ql(t?.message,t)
            }
            return t
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
}
var nd;
Er = o("gNDby"),
gu = o("0DhcF");
nd = gu("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
class rd extends rc {
    constructor(t={}) {
        super(),
        this.name = "Slope",
        this.url = "https://slope.finance",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiByeD0iNjQiIGZpbGw9IiM2RTY2RkEiLz4KPHBhdGggZD0iTTI3Ljk0NzUgNTIuMTU5Nkw1MS45ODI2IDI4LjA1NzJMNzIuNjA5OCA3LjY1Mzg5QzczLjg3MzQgNi40MDQwMSA3Ni4wMTc4IDcuMjk5MSA3Ni4wMTc4IDkuMDc2NDJMNzYuMDE4NyA1Mi4xNTlMNTEuOTgzNiA3Ni4xMjY4TDI3Ljk0NzUgNTIuMTU5NloiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8zNzk1XzI1NTQzKSIvPgo8cGF0aCBkPSJNMTAwLjA1MyA3NS45OTNMNzYuMDE4IDUxLjk1OEw1MS45ODI5IDc1Ljk5MzFMNTEuOTgyOSAxMTguOTI0QzUxLjk4MjkgMTIwLjcwMyA1NC4xMzEyIDEyMS41OTcgNTUuMzkzNyAxMjAuMzQzTDEwMC4wNTMgNzUuOTkzWiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3OTVfMjU1NDMpIi8+CjxwYXRoIGQ9Ik0yNy45NDcgNTIuMTYwMUg0NC42ODM5QzQ4LjcxNDcgNTIuMTYwMSA1MS45ODIyIDU1LjQyNzYgNTEuOTgyMiA1OS40NTgzVjc2LjEyNjlIMzUuMjQ1M0MzMS4yMTQ2IDc2LjEyNjkgMjcuOTQ3IDcyLjg1OTQgMjcuOTQ3IDY4LjgyODdWNTIuMTYwMVoiIGZpbGw9IiNGMUYwRkYiLz4KPHBhdGggZD0iTTc2LjAxNzggNTIuMTYwMUg5Mi43NTQ3Qzk2Ljc4NTUgNTIuMTYwMSAxMDAuMDUzIDU1LjQyNzYgMTAwLjA1MyA1OS40NTgzVjc2LjEyNjlIODMuMzE2MUM3OS4yODU0IDc2LjEyNjkgNzYuMDE3OCA3Mi44NTk0IDc2LjAxNzggNjguODI4N1Y1Mi4xNjAxWiIgZmlsbD0iI0YxRjBGRiIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzM3OTVfMjU1NDMiIHgxPSI1MS45ODMxIiB5MT0iNy4wNzE1NSIgeDI9IjUxLjk4MzEiIHkyPSI3Ni4xMjY4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNBOEFERkYiLz4KPHN0b3Agb2Zmc2V0PSIwLjY0ODU1NiIgc3RvcC1jb2xvcj0id2hpdGUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3OTVfMjU1NDMiIHgxPSI3Ni4wMTgiIHkxPSI1MS45NTgiIHgyPSI3Ni4wMTgiIHkyPSIxMjAuOTI4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC4yNjA3ODQiIHN0b3AtY29sb3I9IiNCNkJBRkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRTRFMkZGIi8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==",
        this.supportedTransactionVersions = null,
        this._readyState = "undefined" == typeof window || "undefined" == typeof document ? Bl.Unsupported : Bl.NotDetected,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._readyState !== Bl.Unsupported && Jl((()=>!("function" != typeof window.Slope && !window.slopeApp) && (this._readyState = Bl.Installed,
        this.emit("readyStateChange", this._readyState),
        !0)))
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Bl.Installed || "function" != typeof window.Slope)
                throw new Ul;
            this._connecting = !0;
            const t = new window.Slope;
            let e, n;
            try {
                ({data: e} = await t.connect())
            } catch (t) {
                throw new Wl(t?.message,t)
            }
            if (!e.publicKey)
                throw new $l;
            try {
                n = new (0,
                Er.PublicKey)(e.publicKey)
            } catch (t) {
                throw new Gl(t?.message,t)
            }
            this._wallet = t,
            this._publicKey = n,
            this.emit("connect", n)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._wallet;
        if (t) {
            this._wallet = null,
            this._publicKey = null;
            try {
                let e;
                try {
                    ({msg: e} = await t.disconnect())
                } catch (t) {
                    throw new Hl(t?.message,t)
                }
                if ("ok" !== e)
                    throw new Hl(e)
            } catch (t) {
                this.emit("error", t)
            }
        }
        this.emit("disconnect")
    }
    async signTransaction(t) {
        try {
            const n = this._wallet;
            if (!n)
                throw new Xl;
            try {
                const r = e(nd).encode(t.serializeMessage())
                  , {msg: i, data: s} = await n.signTransaction(r);
                if (!s.publicKey || !s.signature)
                    throw new Ql(i);
                const o = new (0,
                Er.PublicKey)(s.publicKey)
                  , a = e(nd).decode(s.signature);
                return t.addSignature(o, a),
                t
            } catch (t) {
                if (t instanceof jl)
                    throw t;
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signAllTransactions(t) {
        try {
            const n = this._wallet;
            if (!n)
                throw new Xl;
            try {
                const r = t.map((t=>e(nd).encode(t.serializeMessage())))
                  , {msg: i, data: s} = await n.signAllTransactions(r)
                  , o = t.length;
                if (!s.publicKey || s.signatures?.length !== o)
                    throw new Ql(i);
                const a = new (0,
                Er.PublicKey)(s.publicKey);
                for (let n = 0; n < o; n++)
                    t[n].addSignature(a, e(nd).decode(s.signatures[n]));
                return t
            } catch (t) {
                if (t instanceof jl)
                    throw t;
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signMessage(t) {
        try {
            const n = this._wallet;
            if (!n)
                throw new Xl;
            try {
                const r = await n.signMessage(t);
                return e(nd).decode(r.data.signature)
            } catch (t) {
                throw new Kl(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
}
Er = o("gNDby");
class id extends rc {
    constructor(t={}) {
        super(),
        this.name = "Solflare",
        this.url = "https://solflare.com",
        this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+",
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this._readyState = "undefined" == typeof window || "undefined" == typeof document ? Bl.Unsupported : Bl.Loadable,
        this._disconnected = ()=>{
            const t = this._wallet;
            t && (t.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new Yl),
            this.emit("disconnect"))
        }
        ,
        this._accountChanged = t=>{
            if (!t)
                return;
            const e = this._publicKey;
            if (e) {
                try {
                    t = new (0,
                    Er.PublicKey)(t.toBytes())
                } catch (t) {
                    return void this.emit("error", new Gl(t?.message,t))
                }
                e.equals(t) || (this._publicKey = t,
                this.emit("connect", t))
            }
        }
        ,
        this._connecting = !1,
        this._publicKey = null,
        this._wallet = null,
        this._config = t,
        this._readyState !== Bl.Unsupported && Jl((()=>!(!window.solflare?.isSolflare && !window.SolflareApp) && (this._readyState = Bl.Installed,
        this.emit("readyStateChange", this._readyState),
        !0)))
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        return !!this._wallet?.connected
    }
    get readyState() {
        return this._readyState
    }
    async autoConnect() {
        this.readyState === Bl.Loadable && tc() || await this.connect()
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Bl.Loadable && this._readyState !== Bl.Installed)
                throw new Ul;
            if (this.readyState === Bl.Loadable && tc()) {
                const t = encodeURIComponent(window.location.href)
                  , e = encodeURIComponent(window.location.origin);
                return void (window.location.href = `https://solflare.com/ul/v1/browse/${t}?ref=${e}`)
            }
            let t, e, n;
            try {
                t = (await o("lWt5S")).default
            } catch (t) {
                throw new zl(t?.message,t)
            }
            try {
                e = new t({
                    network: this._config.network
                })
            } catch (t) {
                throw new Vl(t?.message,t)
            }
            if (this._connecting = !0,
            !e.connected)
                try {
                    await e.connect()
                } catch (t) {
                    throw new Wl(t?.message,t)
                }
            if (!e.publicKey)
                throw new Wl;
            try {
                n = new (0,
                Er.PublicKey)(e.publicKey.toBytes())
            } catch (t) {
                throw new Gl(t?.message,t)
            }
            e.on("disconnect", this._disconnected),
            e.on("accountChanged", this._accountChanged),
            this._wallet = e,
            this._publicKey = n,
            this.emit("connect", n)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._wallet;
        if (t) {
            t.off("disconnect", this._disconnected),
            t.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null;
            try {
                await t.disconnect()
            } catch (t) {
                this.emit("error", new Hl(t?.message,t))
            }
        }
        this.emit("disconnect")
    }
    async signTransaction(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signTransaction(t) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signAllTransactions(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signAllTransactions(t) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signMessage(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signMessage(t, "utf8")
            } catch (t) {
                throw new Kl(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
}
Er = o("gNDby");
class sd extends rc {
    constructor({params: t={
        showTorusButton: !1
    }}={
        params: {
            showTorusButton: !1
        }
    }) {
        super(),
        this.name = "Torus",
        this.url = "https://tor.us",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMyAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYuNSIgY3k9IjE2IiByPSIxNiIgZmlsbD0iIzAzNjRGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjIxODYgOS40OTIxOUMxMC40NTM5IDkuNDkyMTkgOS44MzM5OCAxMC4xMTIxIDkuODMzOTggMTAuODc2OFYxMi40ODk4QzkuODMzOTggMTMuMjU0NSAxMC40NTM5IDEzLjg3NDQgMTEuMjE4NiAxMy44NzQ0SDEzLjY2ODRWMjIuODk3NkMxMy42Njg0IDIzLjY2MjMgMTQuMjg4MyAyNC4yODIyIDE1LjA1MyAyNC4yODIySDE2LjY2NkMxNy40MzA3IDI0LjI4MjIgMTguMDUwNiAyMy42NjIzIDE4LjA1MDYgMjIuODk3NlYxMi41MDE1QzE4LjA1MDYgMTIuNDk3NiAxOC4wNTA2IDEyLjQ5MzcgMTguMDUwNiAxMi40ODk4VjEwLjg3NjhDMTguMDUwNiAxMC4xMTIxIDE3LjQzMDcgOS40OTIxOSAxNi42NjYgOS40OTIxOUgxNS4wNTNIMTEuMjE4NloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMS4zMzc2IDEzLjg3NDRDMjIuNTQ3NyAxMy44NzQ0IDIzLjUyODcgMTIuODkzNCAyMy41Mjg3IDExLjY4MzNDMjMuNTI4NyAxMC40NzMyIDIyLjU0NzcgOS40OTIxOSAyMS4zMzc2IDkuNDkyMTlDMjAuMTI3NSA5LjQ5MjE5IDE5LjE0NjUgMTAuNDczMiAxOS4xNDY1IDExLjY4MzNDMTkuMTQ2NSAxMi44OTM0IDIwLjEyNzUgMTMuODc0NCAyMS4zMzc2IDEzLjg3NDRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K",
        this.supportedTransactionVersions = null,
        this._readyState = "undefined" == typeof window || "undefined" == typeof document ? Bl.Unsupported : Bl.Loadable,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._params = t
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        return !!this._wallet?.isLoggedIn
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== Bl.Loadable)
                throw new Ul;
            let t, e, n, r;
            this._connecting = !0;
            try {
                t = (await o("2fzOa")).default
            } catch (t) {
                throw new zl(t?.message,t)
            }
            try {
                e = window.torus || new t
            } catch (t) {
                throw new Vl(t?.message,t)
            }
            if (!e.isInitialized)
                try {
                    await e.init(this._params)
                } catch (t) {
                    throw new Wl(t?.message,t)
                }
            try {
                n = await e.login()
            } catch (t) {
                throw new $l(t?.message,t)
            }
            try {
                r = new (0,
                Er.PublicKey)(n[0])
            } catch (t) {
                throw new Gl(t?.message,t)
            }
            this._wallet = e,
            this._publicKey = r,
            this.emit("connect", r)
        } catch (t) {
            throw this.emit("error", t),
            t
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const t = this._wallet;
        if (t) {
            this._wallet = null,
            this._publicKey = null;
            try {
                t.isLoggedIn && await t.cleanUp()
            } catch (t) {
                this.emit("error", new Hl(t?.message,t))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(t, e, n={}) {
        try {
            const r = this._wallet;
            if (!r)
                throw new Xl;
            try {
                const {signers: i, ...s} = n;
                t = await this.prepareTransaction(t, e, s),
                i?.length && t.partialSign(...i),
                s.preflightCommitment = s.preflightCommitment || e.commitment;
                const {signature: o} = await r.signAndSendTransaction(t, s);
                return o
            } catch (t) {
                if (t instanceof jl)
                    throw t;
                throw new ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signTransaction(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signTransaction(t) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signAllTransactions(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signAllTransactions(t) || t
            } catch (t) {
                throw new Ql(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
    async signMessage(t) {
        try {
            const e = this._wallet;
            if (!e)
                throw new Xl;
            try {
                return await e.signMessage(t)
            } catch (t) {
                throw new Kl(t?.message,t)
            }
        } catch (t) {
            throw this.emit("error", t),
            t
        }
    }
}
d = o("acw62");
const od = ()=>{
    const {state: {sessionToken: t}} = Al()
      , e = (0,
    d.useMemo)((()=>[new Lh, new Fh, new rd, new id, new sd, new ed, new Dh, new Bh]), []);
    return (0,
    a.jsx)(Dl, {
        endpoint: "https://rpc.helius.xyz/?api-key=0d21c3b6-4281-4904-a588-03ba49bc33f1",
        children: (0,
        a.jsx)(_h, {
            wallets: e,
            autoConnect: !!t,
            children: (0,
            a.jsx)(Rh, {
                children: (0,
                a.jsx)(kt, {})
            })
        })
    })
}
;
var ad, ld = {};
t(ld, "wallet-layout", (()=>ad), (t=>ad = t)),
ad = "VjagbG_wallet-layout";
const cd = ()=>(0,
a.jsx)("div", {
    className: Tr(e(ld), "wallet-layout"),
    children: (0,
    a.jsx)(od, {})
});
d = o("acw62");
const ud = async(t,e)=>{
    let n, r = bl.sessionToken;
    if (r) {
        try {
            n = await or.request({
                ...t,
                headers: {
                    Authorization: `Bearer ${r}`
                }
            })
        } catch (i) {
            if (or.isAxiosError(i) && 401 === i.response?.status && bl.sessionConnect) {
                try {
                    const e = await or.post("/api/v1/hub/refresh", void 0, {
                        withCredentials: !0
                    });
                    if (e && bl.setSessionToken)
                        return r = e.data.sessionToken,
                        bl.sessionToken = r,
                        bl.setSessionToken(r),
                        n = await or.request({
                            ...t,
                            headers: {
                                Authorization: `Bearer ${r}`
                            }
                        }),
                        n
                } catch (t) {
                    console.log(t)
                }
                try {
                    pe.info("Your token is out of date, please sign again the authentification message"),
                    bl.disconnect && bl.disconnect()
                } catch (t) {
                    console.log(t),
                    "string" == typeof t ? pe.error(t) : pe.error("Unknown error, please try again or contact the support team")
                }
            } else
                e ? e(i) : or.isAxiosError(i) ? pe.error(i.response?.data ?? "Unknown error, please try again or contact the support team") : pe.error("Unknown error, please try again or contact the support team");
            console.log(i)
        }
        return n
    }
    pe.error("Impossible to retrieve the sessionToken, please refresh the page.")
}
  , hd = async(t,e)=>(await or({
    url: "/api/v1/hub/nonce",
    method: "get",
    params: {
        ledger: t,
        publicKey: e
    }
})).data
  , dd = async t=>{
    const {publicKey: e, nonce: n, signature: r, message: i, signedTx: s} = t;
    return await or.get("/api/v1/hub/connect", {
        params: {
            publicKey: e,
            nonce: n,
            signature: r,
            message: i,
            signedTx: s
        }
    })
}
  , fd = async t=>await ud({
    url: "/api/v1/hub/check-connection",
    method: "GET"
}, t)
  , pd = async t=>await ud({
    url: "/api/v1/hub/load-balancer",
    method: "GET"
}, t)
  , md = async(t,e)=>await ud({
    url: "/api/v1/hub/estimated-leaderboard",
    method: "GET",
    params: {
        score: t
    }
}, e)
  , gd = async t=>await ud({
    url: "/api/v1/hub/global-leaderboard",
    method: "GET"
}, t)
  , yd = async t=>await ud({
    url: "/api/v1/hub/weekly-leaderboard",
    method: "GET"
}, t)
  , bd = async t=>{
    const e = await ud({
        url: "/api/v1/hub/get-whitelist-available",
        method: "GET"
    }, t);
    return e?.data
}
  , vd = async t=>await ud({
    url: "/api/v1/hub/claim-whitelist",
    method: "POST"
}, t)
  , wd = async t=>await ud({
    url: "/api/v1/hub/use-nft",
    method: "POST"
}, t)
  , xd = async(t,e)=>await ud({
    url: "/api/v1/hub/verify-nft-use",
    method: "GET",
    params: {
        signature: t
    }
}, e);
o("acw62");
const Ed = t=>{
    const {dispatch: e} = Al();
    return (0,
    a.jsx)(Ga, {
        ...t,
        onClick: ()=>{
            e({
                type: "SET_SHOW_CONNECT_MODAL",
                showConnectModal: !0
            })
        }
        ,
        children: "Connect"
    })
}
;
d = o("acw62");
const _d = ({children: t, disabled: n, onClick: r, ...i})=>{
    const {wallet: s, disconnect: o, disconnecting: a} = bh()
      , l = (0,
    d.useCallback)((t=>{
        r && r(t),
        t.defaultPrevented || o().catch((()=>{}
        ))
    }
    ), [r, o])
      , c = (0,
    d.useMemo)((()=>t || (a ? "Disconnecting ..." : s ? "Disconnect" : "Disconnect Wallet")), [t, a, s]);
    return e(d).createElement(Mh, {
        className: "wallet-adapter-button-trigger",
        disabled: n || !s,
        startIcon: s ? e(d).createElement(Ch, {
            wallet: s
        }) : void 0,
        onClick: l,
        ...i
    }, c)
}
;
d = o("acw62"),
d = o("acw62");
const Ad = ({children: t, disabled: n, onClick: r, ...i})=>{
    const {wallet: s, connect: o, connecting: a, connected: l} = bh()
      , c = (0,
    d.useCallback)((t=>{
        r && r(t),
        t.defaultPrevented || o().catch((()=>{}
        ))
    }
    ), [r, o])
      , u = (0,
    d.useMemo)((()=>t || (a ? "Connecting ..." : l ? "Connected" : s ? "Connect" : "Connect Wallet")), [t, a, l, s]);
    return e(d).createElement(Mh, {
        className: "wallet-adapter-button-trigger",
        disabled: n || !s || a || l,
        startIcon: s ? e(d).createElement(Ch, {
            wallet: s
        }) : void 0,
        onClick: c,
        ...i
    }, u)
}
;
d = o("acw62");
const Sd = ({children: t="Select Wallet", onClick: n, ...r})=>{
    const {visible: i, setVisible: s} = kh()
      , o = (0,
    d.useCallback)((t=>{
        n && n(t),
        t.defaultPrevented || s(!i)
    }
    ), [n, s, i]);
    return e(d).createElement(Mh, {
        className: "wallet-adapter-button-trigger",
        onClick: o,
        ...r
    }, t)
}
  , Td = ({children: t, ...n})=>{
    const {publicKey: r, wallet: i, disconnect: s} = bh()
      , {setVisible: o} = kh()
      , [a,l] = (0,
    d.useState)(!1)
      , [c,u] = (0,
    d.useState)(!1)
      , h = (0,
    d.useRef)(null)
      , f = (0,
    d.useMemo)((()=>r?.toBase58()), [r])
      , p = (0,
    d.useMemo)((()=>t || (i && f ? f.slice(0, 4) + ".." + f.slice(-4) : null)), [t, i, f])
      , m = (0,
    d.useCallback)((async()=>{
        f && (await navigator.clipboard.writeText(f),
        l(!0),
        setTimeout((()=>l(!1)), 400))
    }
    ), [f])
      , g = (0,
    d.useCallback)((()=>{
        u(!0)
    }
    ), [])
      , y = (0,
    d.useCallback)((()=>{
        u(!1)
    }
    ), [])
      , b = (0,
    d.useCallback)((()=>{
        o(!0),
        y()
    }
    ), [o, y]);
    return (0,
    d.useEffect)((()=>{
        const t = t=>{
            const e = h.current;
            e && !e.contains(t.target) && y()
        }
        ;
        return document.addEventListener("mousedown", t),
        document.addEventListener("touchstart", t),
        ()=>{
            document.removeEventListener("mousedown", t),
            document.removeEventListener("touchstart", t)
        }
    }
    ), [h, y]),
    i ? f ? e(d).createElement("div", {
        className: "wallet-adapter-dropdown"
    }, e(d).createElement(Mh, {
        "aria-expanded": c,
        className: "wallet-adapter-button-trigger",
        style: {
            pointerEvents: c ? "none" : "auto",
            ...n.style
        },
        onClick: g,
        startIcon: e(d).createElement(Ch, {
            wallet: i
        }),
        ...n
    }, p), e(d).createElement("ul", {
        "aria-label": "dropdown-list",
        className: `wallet-adapter-dropdown-list ${c && "wallet-adapter-dropdown-list-active"}`,
        ref: h,
        role: "menu"
    }, e(d).createElement("li", {
        onClick: m,
        className: "wallet-adapter-dropdown-list-item",
        role: "menuitem"
    }, a ? "Copied" : "Copy address"), e(d).createElement("li", {
        onClick: b,
        className: "wallet-adapter-dropdown-list-item",
        role: "menuitem"
    }, "Change wallet"), e(d).createElement("li", {
        onClick: s,
        className: "wallet-adapter-dropdown-list-item",
        role: "menuitem"
    }, "Disconnect"))) : e(d).createElement(Ad, {
        ...n
    }, t) : e(d).createElement(Sd, {
        ...n
    }, t)
}
;
d = o("acw62");
var kd = {};
Object.defineProperty(kd, "__esModule", {
    value: !0
});
d = o("acw62");
var Id, Md = (Id = d) && "object" == typeof Id && "default"in Id ? Id.default : Id, Cd = o("b8sjQ"), Pd = new Cd, Od = Pd.getBrowser(), Nd = Pd.getCPU(), Rd = Pd.getDevice(), Dd = Pd.getEngine(), Bd = Pd.getOS(), Ld = Pd.getUA(), Fd = function(t) {
    return Pd.setUA(t)
}, jd = function(t) {
    if (t) {
        var e = new Cd(t);
        return {
            UA: e,
            browser: e.getBrowser(),
            cpu: e.getCPU(),
            device: e.getDevice(),
            engine: e.getEngine(),
            os: e.getOS(),
            ua: e.getUA(),
            setUserAgent: function(t) {
                return e.setUA(t)
            }
        }
    }
    console.error("No userAgent string was provided")
}, Ud = Object.freeze({
    ClientUAInstance: Pd,
    browser: Od,
    cpu: Nd,
    device: Rd,
    engine: Dd,
    os: Bd,
    ua: Ld,
    setUa: Fd,
    parseUserAgent: jd
});
function zd(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter((function(e) {
            return Object.getOwnPropertyDescriptor(t, e).enumerable
        }
        ))),
        n.push.apply(n, r)
    }
    return n
}
function Vd(t) {
    return Vd = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
    ,
    Vd(t)
}
function Wd(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(t, r.key, r)
    }
}
function Yd(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n,
    t
}
function Hd() {
    return Hd = Object.assign || function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
                Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }
    ,
    Hd.apply(this, arguments)
}
function $d(t) {
    return $d = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
    }
    ,
    $d(t)
}
function Gd(t, e) {
    return Gd = Object.setPrototypeOf || function(t, e) {
        return t.__proto__ = e,
        t
    }
    ,
    Gd(t, e)
}
function Xd(t, e) {
    if (null == t)
        return {};
    var n, r, i = function(t, e) {
        if (null == t)
            return {};
        var n, r, i = {}, s = Object.keys(t);
        for (r = 0; r < s.length; r++)
            n = s[r],
            e.indexOf(n) >= 0 || (i[n] = t[n]);
        return i
    }(t, e);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(t);
        for (r = 0; r < s.length; r++)
            n = s[r],
            e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
    }
    return i
}
function qd(t) {
    if (void 0 === t)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}
function Kd(t, e) {
    return function(t) {
        if (Array.isArray(t))
            return t
    }(t) || function(t, e) {
        var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
        if (null == n)
            return;
        var r, i, s = [], o = !0, a = !1;
        try {
            for (n = n.call(t); !(o = (r = n.next()).done) && (s.push(r.value),
            !e || s.length !== e); o = !0)
                ;
        } catch (t) {
            a = !0,
            i = t
        } finally {
            try {
                o || null == n.return || n.return()
            } finally {
                if (a)
                    throw i
            }
        }
        return s
    }(t, e) || function(t, e) {
        if (!t)
            return;
        if ("string" == typeof t)
            return Qd(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        "Object" === n && t.constructor && (n = t.constructor.name);
        if ("Map" === n || "Set" === n)
            return Array.from(t);
        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return Qd(t, e)
    }(t, e) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }()
}
function Qd(t, e) {
    (null == e || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++)
        r[n] = t[n];
    return r
}
var Zd = "mobile"
  , Jd = "tablet"
  , tf = "smarttv"
  , ef = "console"
  , nf = "wearable"
  , rf = "embedded"
  , sf = void 0
  , of = {
    Chrome: "Chrome",
    Firefox: "Firefox",
    Opera: "Opera",
    Yandex: "Yandex",
    Safari: "Safari",
    InternetExplorer: "Internet Explorer",
    Edge: "Edge",
    Chromium: "Chromium",
    Ie: "IE",
    MobileSafari: "Mobile Safari",
    EdgeChromium: "Edge Chromium",
    MIUI: "MIUI Browser",
    SamsungBrowser: "Samsung Browser"
}
  , af = {
    IOS: "iOS",
    Android: "Android",
    WindowsPhone: "Windows Phone",
    Windows: "Windows",
    MAC_OS: "Mac OS"
}
  , lf = {
    isMobile: !1,
    isTablet: !1,
    isBrowser: !1,
    isSmartTV: !1,
    isConsole: !1,
    isWearable: !1
}
  , cf = function(t) {
    switch (t) {
    case Zd:
        return {
            isMobile: !0
        };
    case Jd:
        return {
            isTablet: !0
        };
    case tf:
        return {
            isSmartTV: !0
        };
    case ef:
        return {
            isConsole: !0
        };
    case nf:
        return {
            isWearable: !0
        };
    case sf:
        return {
            isBrowser: !0
        };
    case rf:
        return {
            isEmbedded: !0
        };
    default:
        return lf
    }
}
  , uf = function(t) {
    return t || (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "none")
}
  , hf = function() {
    return !("undefined" == typeof window || !window.navigator && !navigator) && (window.navigator || navigator)
}
  , df = function(t) {
    var e = hf();
    return e && e.platform && (-1 !== e.platform.indexOf(t) || "MacIntel" === e.platform && e.maxTouchPoints > 1 && !window.MSStream)
}
  , ff = function(t, e, n, r, i) {
    return {
        isBrowser: t,
        browserMajorVersion: uf(e.major),
        browserFullVersion: uf(e.version),
        browserName: uf(e.name),
        engineName: uf(n.name),
        engineVersion: uf(n.version),
        osName: uf(r.name),
        osVersion: uf(r.version),
        userAgent: uf(i)
    }
}
  , pf = function(t, e, n, r) {
    return function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {};
            e % 2 ? zd(Object(n), !0).forEach((function(e) {
                Yd(t, e, n[e])
            }
            )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : zd(Object(n)).forEach((function(e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
            }
            ))
        }
        return t
    }({}, t, {
        vendor: uf(e.vendor),
        model: uf(e.model),
        os: uf(n.name),
        osVersion: uf(n.version),
        ua: uf(r)
    })
}
  , mf = function(t, e, n, r) {
    return {
        isSmartTV: t,
        engineName: uf(e.name),
        engineVersion: uf(e.version),
        osName: uf(n.name),
        osVersion: uf(n.version),
        userAgent: uf(r)
    }
}
  , gf = function(t, e, n, r) {
    return {
        isConsole: t,
        engineName: uf(e.name),
        engineVersion: uf(e.version),
        osName: uf(n.name),
        osVersion: uf(n.version),
        userAgent: uf(r)
    }
}
  , yf = function(t, e, n, r) {
    return {
        isWearable: t,
        engineName: uf(e.name),
        engineVersion: uf(e.version),
        osName: uf(n.name),
        osVersion: uf(n.version),
        userAgent: uf(r)
    }
}
  , bf = function(t, e, n, r, i) {
    return {
        isEmbedded: t,
        vendor: uf(e.vendor),
        model: uf(e.model),
        engineName: uf(n.name),
        engineVersion: uf(n.version),
        osName: uf(r.name),
        osVersion: uf(r.version),
        userAgent: uf(i)
    }
};
var vf = function(t) {
    return t.type === Zd
}
  , wf = function(t) {
    return t.type === Jd
}
  , xf = function(t) {
    var e = t.type;
    return e === Zd || e === Jd
}
  , Ef = function(t) {
    return t.type === tf
}
  , _f = function(t) {
    return t.type === sf
}
  , Af = function(t) {
    return t.type === nf
}
  , Sf = function(t) {
    return t.type === ef
}
  , Tf = function(t) {
    return t.type === rf
}
  , kf = function(t) {
    var e = t.vendor;
    return uf(e)
}
  , If = function(t) {
    var e = t.model;
    return uf(e)
}
  , Mf = function(t) {
    var e = t.type;
    return uf(e, "browser")
}
  , Cf = function(t) {
    return t.name === af.Android
}
  , Pf = function(t) {
    return t.name === af.Windows
}
  , Of = function(t) {
    return t.name === af.MAC_OS
}
  , Nf = function(t) {
    return t.name === af.WindowsPhone
}
  , Rf = function(t) {
    return t.name === af.IOS
}
  , Df = function(t) {
    var e = t.version;
    return uf(e)
}
  , Bf = function(t) {
    var e = t.name;
    return uf(e)
}
  , Lf = function(t) {
    return t.name === of.Chrome
}
  , Ff = function(t) {
    return t.name === of.Firefox
}
  , jf = function(t) {
    return t.name === of.Chromium
}
  , Uf = function(t) {
    return t.name === of.Edge
}
  , zf = function(t) {
    return t.name === of.Yandex
}
  , Vf = function(t) {
    var e = t.name;
    return e === of.Safari || e === of.MobileSafari
}
  , Wf = function(t) {
    return t.name === of.MobileSafari
}
  , Yf = function(t) {
    return t.name === of.Opera
}
  , Hf = function(t) {
    var e = t.name;
    return e === of.InternetExplorer || e === of.Ie
}
  , $f = function(t) {
    return t.name === of.MIUI
}
  , Gf = function(t) {
    return t.name === of.SamsungBrowser
}
  , Xf = function(t) {
    var e = t.version;
    return uf(e)
}
  , qf = function(t) {
    var e = t.major;
    return uf(e)
}
  , Kf = function(t) {
    var e = t.name;
    return uf(e)
}
  , Qf = function(t) {
    var e = t.name;
    return uf(e)
}
  , Zf = function(t) {
    var e = t.version;
    return uf(e)
}
  , Jf = function() {
    var t = hf()
      , e = t && t.userAgent && t.userAgent.toLowerCase();
    return "string" == typeof e && /electron/.test(e)
}
  , tp = function(t) {
    return "string" == typeof t && -1 !== t.indexOf("Edg/")
}
  , ep = function() {
    var t = hf();
    return t && (/iPad|iPhone|iPod/.test(t.platform) || "MacIntel" === t.platform && t.maxTouchPoints > 1) && !window.MSStream
}
  , np = function() {
    return df("iPad")
}
  , rp = function() {
    return df("iPhone")
}
  , ip = function() {
    return df("iPod")
}
  , sp = function(t) {
    return uf(t)
};
function op(t) {
    var e = t || Ud
      , n = e.device
      , r = e.browser
      , i = e.os
      , s = e.engine
      , o = e.ua;
    return {
        isSmartTV: Ef(n),
        isConsole: Sf(n),
        isWearable: Af(n),
        isEmbedded: Tf(n),
        isMobileSafari: Wf(r) || np(),
        isChromium: jf(r),
        isMobile: xf(n) || np(),
        isMobileOnly: vf(n),
        isTablet: wf(n) || np(),
        isBrowser: _f(n),
        isDesktop: _f(n),
        isAndroid: Cf(i),
        isWinPhone: Nf(i),
        isIOS: Rf(i) || np(),
        isChrome: Lf(r),
        isFirefox: Ff(r),
        isSafari: Vf(r),
        isOpera: Yf(r),
        isIE: Hf(r),
        osVersion: Df(i),
        osName: Bf(i),
        fullBrowserVersion: Xf(r),
        browserVersion: qf(r),
        browserName: Kf(r),
        mobileVendor: kf(n),
        mobileModel: If(n),
        engineName: Qf(s),
        engineVersion: Zf(s),
        getUA: sp(o),
        isEdge: Uf(r) || tp(o),
        isYandex: zf(r),
        deviceType: Mf(n),
        isIOS13: ep(),
        isIPad13: np(),
        isIPhone13: rp(),
        isIPod13: ip(),
        isElectron: Jf(),
        isEdgeChromium: tp(o),
        isLegacyEdge: Uf(r) && !tp(o),
        isWindows: Pf(i),
        isMacOs: Of(i),
        isMIUI: $f(r),
        isSamsungBrowser: Gf(r)
    }
}
var ap = Ef(Rd)
  , lp = Sf(Rd)
  , cp = Af(Rd)
  , up = Tf(Rd)
  , hp = Wf(Od) || np()
  , dp = jf(Od)
  , fp = xf(Rd) || np()
  , pp = vf(Rd)
  , mp = wf(Rd) || np()
  , gp = _f(Rd)
  , yp = _f(Rd)
  , bp = Cf(Bd)
  , vp = Nf(Bd)
  , wp = Rf(Bd) || np()
  , xp = Lf(Od)
  , Ep = Ff(Od)
  , _p = Vf(Od)
  , Ap = Yf(Od)
  , Sp = Hf(Od)
  , Tp = Df(Bd)
  , kp = Bf(Bd)
  , Ip = Xf(Od)
  , Mp = qf(Od)
  , Cp = Kf(Od)
  , Pp = kf(Rd)
  , Op = If(Rd)
  , Np = Qf(Dd)
  , Rp = Zf(Dd)
  , Dp = sp(Ld)
  , Bp = Uf(Od) || tp(Ld)
  , Lp = zf(Od)
  , Fp = Mf(Rd)
  , jp = ep()
  , Up = np()
  , zp = rp()
  , Vp = ip()
  , Wp = Jf()
  , Yp = tp(Ld)
  , Hp = Uf(Od) && !tp(Ld)
  , $p = Pf(Bd)
  , Gp = Of(Bd)
  , Xp = $f(Od)
  , qp = Gf(Od);
function Kp(t) {
    var e = t || window.navigator.userAgent;
    return jd(e)
}
kd.AndroidView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return bp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.BrowserTypes = of,
kd.BrowserView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return gp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.ConsoleView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return lp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.CustomView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = (t.viewClassName,
    t.style,
    t.condition)
      , i = Xd(t, ["renderWithFragment", "children", "viewClassName", "style", "condition"]);
    return r ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", i, n) : null
}
,
kd.IEView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return Sp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.IOSView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return wp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.MobileOnlyView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = (t.viewClassName,
    t.style,
    Xd(t, ["renderWithFragment", "children", "viewClassName", "style"]));
    return pp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.MobileView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return fp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.OsTypes = af,
kd.SmartTVView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return ap ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.TabletView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return mp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.WearableView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return cp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.WinPhoneView = function(t) {
    var e = t.renderWithFragment
      , n = t.children
      , r = Xd(t, ["renderWithFragment", "children"]);
    return vp ? e ? Md.createElement(d.Fragment, null, n) : Md.createElement("div", r, n) : null
}
,
kd.browserName = Cp,
kd.browserVersion = Mp,
kd.deviceDetect = function(t) {
    var e = t ? jd(t) : Ud
      , n = e.device
      , r = e.browser
      , i = e.engine
      , s = e.os
      , o = e.ua
      , a = cf(n.type)
      , l = a.isBrowser
      , c = a.isMobile
      , u = a.isTablet
      , h = a.isSmartTV
      , d = a.isConsole
      , f = a.isWearable
      , p = a.isEmbedded;
    return l ? ff(l, r, i, s, o) : h ? mf(h, i, s, o) : d ? gf(d, i, s, o) : c || u ? pf(a, n, s, o) : f ? yf(f, i, s, o) : p ? bf(p, n, i, s, o) : void 0
}
,
kd.deviceType = Fp,
kd.engineName = Np,
kd.engineVersion = Rp,
kd.fullBrowserVersion = Ip,
kd.getSelectorsByUserAgent = function(t) {
    if (t && "string" == typeof t) {
        var e = jd(t);
        return op({
            device: e.device,
            browser: e.browser,
            os: e.os,
            engine: e.engine,
            ua: e.ua
        })
    }
    console.error("No valid user agent string was provided")
}
,
kd.getUA = Dp,
kd.isAndroid = bp,
kd.isBrowser = gp,
kd.isChrome = xp,
kd.isChromium = dp,
kd.isConsole = lp,
kd.isDesktop = yp,
kd.isEdge = Bp,
kd.isEdgeChromium = Yp,
kd.isElectron = Wp,
kd.isEmbedded = up,
kd.isFirefox = Ep,
kd.isIE = Sp,
kd.isIOS = wp,
kd.isIOS13 = jp,
kd.isIPad13 = Up,
kd.isIPhone13 = zp,
kd.isIPod13 = Vp,
kd.isLegacyEdge = Hp,
kd.isMIUI = Xp,
kd.isMacOs = Gp,
kd.isMobile = fp,
kd.isMobileOnly = pp,
kd.isMobileSafari = hp,
kd.isOpera = Ap,
kd.isSafari = _p,
kd.isSamsungBrowser = qp,
kd.isSmartTV = ap,
kd.isTablet = mp,
kd.isWearable = cp,
kd.isWinPhone = vp,
kd.isWindows = $p,
kd.isYandex = Lp,
kd.mobileModel = Op,
kd.mobileVendor = Pp,
kd.osName = kp,
kd.osVersion = Tp,
kd.parseUserAgent = jd,
kd.setUserAgent = function(t) {
    return Fd(t)
}
,
kd.useDeviceData = Kp,
kd.useDeviceSelectors = function(t) {
    var e = Kp(t || window.navigator.userAgent);
    return [op(e), e]
}
,
kd.useMobileOrientation = function() {
    var t = Kd(d.useState((function() {
        var t = window.innerWidth > window.innerHeight ? 90 : 0;
        return {
            isPortrait: 0 === t,
            isLandscape: 90 === t,
            orientation: 0 === t ? "portrait" : "landscape"
        }
    }
    )), 2)
      , e = t[0]
      , n = t[1]
      , r = d.useCallback((function() {
        var t = window.innerWidth > window.innerHeight ? 90 : 0
          , r = {
            isPortrait: 0 === t,
            isLandscape: 90 === t,
            orientation: 0 === t ? "portrait" : "landscape"
        };
        e.orientation !== r.orientation && n(r)
    }
    ), [e.orientation]);
    return d.useEffect((function() {
        return void 0 !== ("undefined" == typeof window ? "undefined" : Vd(window)) && fp && (r(),
        window.addEventListener("load", r, !1),
        window.addEventListener("resize", r, !1)),
        function() {
            window.removeEventListener("resize", r, !1),
            window.removeEventListener("load", r, !1)
        }
    }
    ), [r]),
    e
}
,
kd.withOrientationChange = function(t) {
    return function(e) {
        function n(t) {
            var e;
            return function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, n),
            (e = function(t, e) {
                if (e && ("object" == typeof e || "function" == typeof e))
                    return e;
                if (void 0 !== e)
                    throw new TypeError("Derived constructors may only return object or undefined");
                return qd(t)
            }(this, $d(n).call(this, t))).isEventListenerAdded = !1,
            e.handleOrientationChange = e.handleOrientationChange.bind(qd(e)),
            e.onOrientationChange = e.onOrientationChange.bind(qd(e)),
            e.onPageLoad = e.onPageLoad.bind(qd(e)),
            e.state = {
                isLandscape: !1,
                isPortrait: !1
            },
            e
        }
        var r, i, s;
        return function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }),
            e && Gd(t, e)
        }(n, Md.Component),
        r = n,
        (i = [{
            key: "handleOrientationChange",
            value: function() {
                this.isEventListenerAdded || (this.isEventListenerAdded = !0);
                var t = window.innerWidth > window.innerHeight ? 90 : 0;
                this.setState({
                    isPortrait: 0 === t,
                    isLandscape: 90 === t
                })
            }
        }, {
            key: "onOrientationChange",
            value: function() {
                this.handleOrientationChange()
            }
        }, {
            key: "onPageLoad",
            value: function() {
                this.handleOrientationChange()
            }
        }, {
            key: "componentDidMount",
            value: function() {
                void 0 !== ("undefined" == typeof window ? "undefined" : Vd(window)) && fp && (this.isEventListenerAdded ? window.removeEventListener("load", this.onPageLoad, !1) : (this.handleOrientationChange(),
                window.addEventListener("load", this.onPageLoad, !1)),
                window.addEventListener("resize", this.onOrientationChange, !1))
            }
        }, {
            key: "componentWillUnmount",
            value: function() {
                window.removeEventListener("resize", this.onOrientationChange, !1)
            }
        }, {
            key: "render",
            value: function() {
                return Md.createElement(t, Hd({}, this.props, {
                    isLandscape: this.state.isLandscape,
                    isPortrait: this.state.isPortrait
                }))
            }
        }]) && Wd(r.prototype, i),
        s && Wd(r, s),
        n
    }()
}
;
Er = o("gNDby"),
Sc = o("bYkMz"),
d = o("acw62");
var Qp = o("6ZWSX").Buffer;
const Zp = ()=>{
    const {disconnect: t} = Sl()
      , {dispatch: n, state: {publicKey: r, isLedger: i}} = Al()
      , {signMessage: s, signTransaction: o, sendTransaction: a, disconnect: l, publicKey: c, connected: u, wallet: h} = bh()
      , [f,p] = (0,
    d.useState)(!1)
      , m = !!h
      , g = (0,
    d.useCallback)((async()=>{
        if (c) {
            try {
                let r;
                p(!0);
                const {nonce: a, tx: l} = await hd(i, c.toString());
                if (!a)
                    return pe.error("Impossible to get a nonce, please try again later or contact the support team."),
                    void p(!1);
                if (i) {
                    if (!o)
                        return;
                    if (!l)
                        return pe.error("Impossible to get the transaction to sign with your Ledger, please try again later or contact the support team."),
                        void p(!1);
                    const t = Er.Transaction.from(Qp.from(l, "base64"))
                      , e = await o(t);
                    r = await dd({
                        publicKey: c.toString(),
                        signedTx: e.serialize().toString("base64"),
                        nonce: a
                    })
                } else {
                    if (!s)
                        return;
                    const t = "wallet-ownership-verification"
                      , n = await s((new TextEncoder).encode(`${t}_${a}`));
                    r = await dd({
                        publicKey: c.toString(),
                        signature: e(Sc).encode(n),
                        message: t,
                        nonce: a
                    })
                }
                if (401 === r.status)
                    pe.error("We cannot verify your wallet ownership, please try again later or contact the support team."),
                    t();
                else if (404 === r.status)
                    pe.error("Request error, please try again later or contact the support team."),
                    t();
                else {
                    const e = r.data;
                    if (e && e.sessionToken)
                        return n({
                            type: "SET_SESSION_TOKEN",
                            sessionToken: e.sessionToken
                        }),
                        n({
                            type: "SET_PUBLIC_KEY",
                            publicKey: c.toString()
                        }),
                        Ir({
                            sessionToken: e.sessionToken,
                            publicKey: c.toString(),
                            twitterUsername: e.twitter?.username,
                            discordUsername: e.discord?.username,
                            discordServerJoined: e.discord?.serverJoined,
                            username: e.username,
                            isLedger: i
                        }),
                        bl.sessionToken = e.sessionToken,
                        e.twitter?.username && n({
                            type: "SET_TWITTER_USERNAME",
                            twitterUsername: e.twitter.username
                        }),
                        e.discord?.username && n({
                            type: "SET_DISCORD_USERNAME",
                            discordUsername: e.discord.username
                        }),
                        e.discord?.serverJoined && n({
                            type: "SET_DISCORD_SERVER_JOINED",
                            discordServerJoined: e.discord.serverJoined
                        }),
                        e.username && n({
                            type: "SET_USERNAME",
                            username: e.username
                        }),
                        e.userUuid && n({
                            type: "SET_USER_UUID",
                            userUuid: e.userUuid
                        }),
                        pe.success("You are now connected!"),
                        p(!1),
                        e;
                    pe.error("Impossible to find the sessionToken, please try again later or contact the support team"),
                    t()
                }
            } catch (e) {
                if (e instanceof Kl && -32002 === e.error.code)
                    return;
                pe.info("Wallet change or request error, try to connect again or contact the support team"),
                t(),
                console.info(e)
            }
            p(!1)
        }
    }
    ), [c, s]);
    return (0,
    d.useEffect)((()=>{
        u && r && r !== c?.toString() && (t(),
        bl.showModal && bl.showModal({
            title: "Disconnected",
            text: "You have been disconnected"
        }))
    }
    ), [t, u, c, r]),
    {
        connect: g,
        disconnect: l,
        signMessage: s,
        signTransaction: o,
        sendTransaction: a,
        connected: u,
        walletConnected: m,
        loading: f,
        publicKey: c?.toString()
    }
}
;
o("acw62");
var Jp, tm, em, nm, rm = {};
t(rm, "switch", (()=>Jp), (t=>Jp = t)),
t(rm, "slider", (()=>tm), (t=>tm = t)),
t(rm, "toggle", (()=>em), (t=>em = t)),
t(rm, "round", (()=>nm), (t=>nm = t)),
Jp = "KW2K-a_switch",
tm = "KW2K-a_slider",
em = "KW2K-a_toggle",
nm = "KW2K-a_round";
const im = ({containerClassName: t, ...n})=>(0,
a.jsx)("div", {
    className: Tr(e(rm), `toggle ${t ?? ""}`),
    children: (0,
    a.jsxs)("label", {
        className: Tr(e(rm), "switch"),
        children: [(0,
        a.jsx)("input", {
            type: "checkbox",
            ...n
        }), (0,
        a.jsx)("span", {
            className: Tr(e(rm), "slider round")
        })]
    })
});
var sm, om, am, lm, cm, um, hm, dm, fm = {};
t(fm, "connect-modal-overlay", (()=>sm), (t=>sm = t)),
t(fm, "gray", (()=>om), (t=>om = t)),
t(fm, "wallet", (()=>am), (t=>am = t)),
t(fm, "connect-modal", (()=>lm), (t=>lm = t)),
t(fm, "toggle", (()=>cm), (t=>cm = t)),
t(fm, "install-wallet", (()=>um), (t=>um = t)),
t(fm, "form", (()=>hm), (t=>hm = t)),
t(fm, "ledger-toggle", (()=>dm), (t=>dm = t)),
sm = "dImszG_connect-modal-overlay",
om = "dImszG_gray",
am = "dImszG_wallet",
lm = "dImszG_connect-modal",
cm = "dImszG_toggle",
um = "dImszG_install-wallet",
hm = "dImszG_form",
dm = "dImszG_ledger-toggle";
const pm = ({className: t, onHide: n, ...r})=>{
    const {dispatch: i, state: {sessionToken: s, isLedger: o}} = Al()
      , {connected: l, connect: c, walletConnected: u, loading: h, disconnect: f, signMessage: p, signTransaction: m, sendTransaction: g} = Zp();
    return (0,
    d.useEffect)((()=>{
        !s && l && void 0 === kr() && c()
    }
    ), [c, l, s]),
    (0,
    d.useEffect)((()=>{
        n()
    }
    ), [s]),
    (0,
    d.useEffect)((()=>{
        bl.sessionConnect = c,
        bl.signMessage = p,
        bl.signTransaction = m,
        bl.sendTransaction = g
    }
    ), [c, p, m, g]),
    (0,
    d.useEffect)((()=>{
        i({
            type: "SET_DISCONNECT_WALLET",
            disconnectWallet: f
        })
    }
    ), [f]),
    (0,
    a.jsx)(dl, {
        className: Tr(e(fm), `connect-modal-overlay ${t}`),
        ...r,
        children: (0,
        a.jsx)("div", {
            className: Tr(e(fm), "connect-modal"),
            children: (0,
            a.jsx)("div", {
                className: Tr(e(fm), "wallet"),
                children: Ar ? (0,
                a.jsx)("div", {
                    className: Tr(e(fm), "form"),
                    children: h && l ? (0,
                    a.jsx)("p", {
                        children: "Please sign and wait..."
                    }) : !l && (0,
                    a.jsxs)(a.Fragment, {
                        children: [(0,
                        a.jsx)("p", {
                            children: "Connect a Solana wallet"
                        }), (0,
                        a.jsx)(Td, {
                            children: u ? "Connect" : "Select wallet"
                        }), u && (0,
                        a.jsx)(_d, {
                            className: Tr(e(fm), "gray"),
                            children: "Change wallet"
                        }), (0,
                        a.jsxs)("span", {
                            className: Tr(e(fm), "ledger-toggle"),
                            onClick: ()=>i({
                                type: "SET_IS_LEDGER",
                                isLedger: !o
                            }),
                            children: [(0,
                            a.jsx)(im, {
                                containerClassName: Tr(e(fm), "toggle"),
                                checked: o ?? !1,
                                readOnly: !0
                            }), (0,
                            a.jsx)("span", {
                                children: "Ledger wallet"
                            })]
                        })]
                    })
                }) : (0,
                a.jsx)("div", {
                    className: Tr(e(fm), "install-wallet"),
                    children: kd.isAndroid ? (0,
                    a.jsxs)(a.Fragment, {
                        children: [(0,
                        a.jsx)("p", {
                            children: "To connect, please use the Phantom App browser"
                        }), (0,
                        a.jsx)("a", {
                            href: "https://play.google.com/store/apps/details?id=app.phantom",
                            children: "Open Android app"
                        })]
                    }) : kd.isIOS ? (0,
                    a.jsxs)(a.Fragment, {
                        children: [(0,
                        a.jsx)("p", {
                            children: "To connect, please use the Phantom App browser"
                        }), (0,
                        a.jsx)("a", {
                            href: "https://apps.apple.com/app/phantom-solana-wallet/1598432977",
                            children: "Open iOS app"
                        })]
                    }) : (0,
                    a.jsxs)(a.Fragment, {
                        children: [(0,
                        a.jsx)("p", {
                            children: "To connect, please use the Phantom wallet extension"
                        }), (0,
                        a.jsx)("a", {
                            href: "https://phantom.app/",
                            children: "Phantom Website"
                        })]
                    })
                })
            })
        })
    })
}
;
var mm, gm, ym, bm, vm, wm, xm, Em, _m, Am, Sm = {};
t(Sm, "player-view", (()=>mm), (t=>mm = t)),
t(Sm, "connect-button", (()=>gm), (t=>gm = t)),
t(Sm, "developed-by", (()=>ym), (t=>ym = t)),
t(Sm, "dashboard", (()=>bm), (t=>bm = t)),
t(Sm, "container", (()=>vm), (t=>vm = t)),
t(Sm, "permission", (()=>wm), (t=>wm = t)),
t(Sm, "connection", (()=>xm), (t=>xm = t)),
t(Sm, "limited-height", (()=>Em), (t=>Em = t)),
t(Sm, "content", (()=>_m), (t=>_m = t)),
t(Sm, "logo", (()=>Am), (t=>Am = t)),
mm = "tb19nW_player-view",
gm = "tb19nW_connect-button",
ym = "tb19nW_developed-by",
bm = "tb19nW_dashboard",
vm = "tb19nW_container",
wm = "tb19nW_permission",
xm = "tb19nW_connection",
Em = "tb19nW_limited-height",
_m = "tb19nW_content",
Am = "tb19nW_logo";
const Tm = ()=>{
    const {state: {sessionToken: t, showConnectModal: n}, dispatch: r} = Al()
      , [i,s] = (0,
    d.useState)("function" == typeof DeviceOrientationEvent.requestPermission)
      , {connected: o, wallet: l} = bh()
      , c = ()=>{
        r({
            type: "SET_SHOW_CONNECT_MODAL",
            showConnectModal: !1
        })
    }
    ;
    return (0,
    d.useEffect)((()=>{
        if (!t)
            return;
        fd((()=>{
            bl.disconnect && bl.disconnect()
        }
        ));
        const e = setInterval((()=>{
            fd()
        }
        ), 36e4);
        return ()=>{
            clearInterval(e)
        }
    }
    ), [t]),
    (0,
    a.jsxs)("div", {
        className: Tr(e(Sm), "dashboard"),
        children: [(0,
        a.jsx)("div", {
            className: Tr(e(Sm), "container limited-height"),
            children: (0,
            a.jsx)("div", {
                className: Tr(e(Sm), "content overflow-hidden phone-without-padding"),
                children: i ? (0,
                a.jsxs)("div", {
                    className: Tr(e(Sm), "permission"),
                    children: ["Device orientation permission needed on iOS 13+", (0,
                    a.jsx)(Ga, {
                        onClick: async()=>{
                            "granted" === await DeviceOrientationEvent.requestPermission() && s(!1)
                        }
                        ,
                        children: "grant permission"
                    })]
                }) : t ? (0,
                a.jsx)(kt, {}) : (0,
                a.jsxs)("div", {
                    className: Tr(e(Sm), "connection"),
                    children: [(0,
                    a.jsx)("img", {
                        className: Tr(e(Sm), "logo"),
                        src: "https://cdn.piratesquadnft.com/clients/meegos/game/visual/ui/logo.png",
                        alt: "logo"
                    }), (0,
                    a.jsx)(Ed, {
                        className: Tr(e(Sm), "connect-button")
                    }), (0,
                    a.jsx)("div", {
                        className: Tr(e(Sm), "developed-by")
                    })]
                })
            })
        }), (0,
        a.jsx)(pm, {
            show: !o && !l || n,
            onHide: ()=>c(),
            onClickBackground: ()=>c()
        })]
    })
}
;
Er = o("gNDby");
let km;
function Im() {
    return km
}
var Mm = (t=>(t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY",
t[t.WEBGL = 1] = "WEBGL",
t[t.WEBGL2 = 2] = "WEBGL2",
t))(Mm || {})
  , Cm = (t=>(t[t.UNKNOWN = 0] = "UNKNOWN",
t[t.WEBGL = 1] = "WEBGL",
t[t.CANVAS = 2] = "CANVAS",
t))(Cm || {})
  , Pm = (t=>(t[t.COLOR = 16384] = "COLOR",
t[t.DEPTH = 256] = "DEPTH",
t[t.STENCIL = 1024] = "STENCIL",
t))(Pm || {})
  , Om = (t=>(t[t.NORMAL = 0] = "NORMAL",
t[t.ADD = 1] = "ADD",
t[t.MULTIPLY = 2] = "MULTIPLY",
t[t.SCREEN = 3] = "SCREEN",
t[t.OVERLAY = 4] = "OVERLAY",
t[t.DARKEN = 5] = "DARKEN",
t[t.LIGHTEN = 6] = "LIGHTEN",
t[t.COLOR_DODGE = 7] = "COLOR_DODGE",
t[t.COLOR_BURN = 8] = "COLOR_BURN",
t[t.HARD_LIGHT = 9] = "HARD_LIGHT",
t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT",
t[t.DIFFERENCE = 11] = "DIFFERENCE",
t[t.EXCLUSION = 12] = "EXCLUSION",
t[t.HUE = 13] = "HUE",
t[t.SATURATION = 14] = "SATURATION",
t[t.COLOR = 15] = "COLOR",
t[t.LUMINOSITY = 16] = "LUMINOSITY",
t[t.NORMAL_NPM = 17] = "NORMAL_NPM",
t[t.ADD_NPM = 18] = "ADD_NPM",
t[t.SCREEN_NPM = 19] = "SCREEN_NPM",
t[t.NONE = 20] = "NONE",
t[t.SRC_OVER = 0] = "SRC_OVER",
t[t.SRC_IN = 21] = "SRC_IN",
t[t.SRC_OUT = 22] = "SRC_OUT",
t[t.SRC_ATOP = 23] = "SRC_ATOP",
t[t.DST_OVER = 24] = "DST_OVER",
t[t.DST_IN = 25] = "DST_IN",
t[t.DST_OUT = 26] = "DST_OUT",
t[t.DST_ATOP = 27] = "DST_ATOP",
t[t.ERASE = 26] = "ERASE",
t[t.SUBTRACT = 28] = "SUBTRACT",
t[t.XOR = 29] = "XOR",
t))(Om || {})
  , Nm = (t=>(t[t.POINTS = 0] = "POINTS",
t[t.LINES = 1] = "LINES",
t[t.LINE_LOOP = 2] = "LINE_LOOP",
t[t.LINE_STRIP = 3] = "LINE_STRIP",
t[t.TRIANGLES = 4] = "TRIANGLES",
t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP",
t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN",
t))(Nm || {})
  , Rm = (t=>(t[t.RGBA = 6408] = "RGBA",
t[t.RGB = 6407] = "RGB",
t[t.RG = 33319] = "RG",
t[t.RED = 6403] = "RED",
t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
t[t.RGB_INTEGER = 36248] = "RGB_INTEGER",
t[t.RG_INTEGER = 33320] = "RG_INTEGER",
t[t.RED_INTEGER = 36244] = "RED_INTEGER",
t[t.ALPHA = 6406] = "ALPHA",
t[t.LUMINANCE = 6409] = "LUMINANCE",
t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
t))(Rm || {})
  , Dm = (t=>(t[t.TEXTURE_2D = 3553] = "TEXTURE_2D",
t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP",
t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY",
t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X",
t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X",
t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y",
t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y",
t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z",
t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z",
t))(Dm || {})
  , Bm = (t=>(t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
t[t.BYTE = 5120] = "BYTE",
t[t.SHORT = 5122] = "SHORT",
t[t.INT = 5124] = "INT",
t[t.FLOAT = 5126] = "FLOAT",
t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
t[t.HALF_FLOAT = 36193] = "HALF_FLOAT",
t))(Bm || {})
  , Lm = (t=>(t[t.FLOAT = 0] = "FLOAT",
t[t.INT = 1] = "INT",
t[t.UINT = 2] = "UINT",
t))(Lm || {})
  , Fm = (t=>(t[t.NEAREST = 0] = "NEAREST",
t[t.LINEAR = 1] = "LINEAR",
t))(Fm || {})
  , jm = (t=>(t[t.CLAMP = 33071] = "CLAMP",
t[t.REPEAT = 10497] = "REPEAT",
t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT",
t))(jm || {})
  , Um = (t=>(t[t.OFF = 0] = "OFF",
t[t.POW2 = 1] = "POW2",
t[t.ON = 2] = "ON",
t[t.ON_MANUAL = 3] = "ON_MANUAL",
t))(Um || {})
  , zm = (t=>(t[t.NPM = 0] = "NPM",
t[t.UNPACK = 1] = "UNPACK",
t[t.PMA = 2] = "PMA",
t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA",
t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD",
t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA",
t))(zm || {})
  , Vm = (t=>(t[t.NO = 0] = "NO",
t[t.YES = 1] = "YES",
t[t.AUTO = 2] = "AUTO",
t[t.BLEND = 0] = "BLEND",
t[t.CLEAR = 1] = "CLEAR",
t[t.BLIT = 2] = "BLIT",
t))(Vm || {})
  , Wm = (t=>(t[t.AUTO = 0] = "AUTO",
t[t.MANUAL = 1] = "MANUAL",
t))(Wm || {})
  , Ym = (t=>(t.LOW = "lowp",
t.MEDIUM = "mediump",
t.HIGH = "highp",
t))(Ym || {})
  , Hm = (t=>(t[t.NONE = 0] = "NONE",
t[t.SCISSOR = 1] = "SCISSOR",
t[t.STENCIL = 2] = "STENCIL",
t[t.SPRITE = 3] = "SPRITE",
t[t.COLOR = 4] = "COLOR",
t))(Hm || {})
  , $m = (t=>(t[t.NONE = 0] = "NONE",
t[t.LOW = 2] = "LOW",
t[t.MEDIUM = 4] = "MEDIUM",
t[t.HIGH = 8] = "HIGH",
t))($m || {})
  , Gm = (t=>(t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER",
t))(Gm || {});
const Xm = {
    ADAPTER: {
        createCanvas: (t,e)=>{
            const n = document.createElement("canvas");
            return n.width = t,
            n.height = e,
            n
        }
        ,
        getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,
        getWebGLRenderingContext: ()=>WebGLRenderingContext,
        getNavigator: ()=>navigator,
        getBaseUrl: ()=>document.baseURI ?? window.location.href,
        getFontFaceSet: ()=>document.fonts,
        fetch: (t,e)=>fetch(t, e),
        parseXML: t=>(new DOMParser).parseFromString(t, "text/xml")
    },
    RESOLUTION: 1,
    CREATE_IMAGE_BITMAP: !1,
    ROUND_PIXELS: !1
};
var qm = /iPhone/i
  , Km = /iPod/i
  , Qm = /iPad/i
  , Zm = /\biOS-universal(?:.+)Mac\b/i
  , Jm = /\bAndroid(?:.+)Mobile\b/i
  , tg = /Android/i
  , eg = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i
  , ng = /Silk/i
  , rg = /Windows Phone/i
  , ig = /\bWindows(?:.+)ARM\b/i
  , sg = /BlackBerry/i
  , og = /BB10/i
  , ag = /Opera Mini/i
  , lg = /\b(CriOS|Chrome)(?:.+)Mobile/i
  , cg = /Mobile(?:.+)Firefox\b/i
  , ug = function(t) {
    return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream
};
function hg(t) {
    var e = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
    };
    t || "undefined" == typeof navigator ? "string" == typeof t ? e.userAgent = t : t && t.userAgent && (e = {
        userAgent: t.userAgent,
        platform: t.platform,
        maxTouchPoints: t.maxTouchPoints || 0
    }) : e = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    };
    var n = e.userAgent
      , r = n.split("[FBAN");
    void 0 !== r[1] && (n = r[0]),
    void 0 !== (r = n.split("Twitter"))[1] && (n = r[0]);
    var i = function(t) {
        return function(e) {
            return e.test(t)
        }
    }(n)
      , s = {
        apple: {
            phone: i(qm) && !i(rg),
            ipod: i(Km),
            tablet: !i(qm) && (i(Qm) || ug(e)) && !i(rg),
            universal: i(Zm),
            device: (i(qm) || i(Km) || i(Qm) || i(Zm) || ug(e)) && !i(rg)
        },
        amazon: {
            phone: i(eg),
            tablet: !i(eg) && i(ng),
            device: i(eg) || i(ng)
        },
        android: {
            phone: !i(rg) && i(eg) || !i(rg) && i(Jm),
            tablet: !i(rg) && !i(eg) && !i(Jm) && (i(ng) || i(tg)),
            device: !i(rg) && (i(eg) || i(ng) || i(Jm) || i(tg)) || i(/\bokhttp\b/i)
        },
        windows: {
            phone: i(rg),
            tablet: i(ig),
            device: i(rg) || i(ig)
        },
        other: {
            blackberry: i(sg),
            blackberry10: i(og),
            opera: i(ag),
            firefox: i(cg),
            chrome: i(lg),
            device: i(sg) || i(og) || i(ag) || i(cg) || i(lg)
        },
        any: !1,
        phone: !1,
        tablet: !1
    };
    return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device,
    s.phone = s.apple.phone || s.android.phone || s.windows.phone,
    s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet,
    s
}
const dg = (hg.default ?? hg)(globalThis.navigator);
var fg = {};
t(fg, "isMobile", (()=>dg)),
t(fg, "EventEmitter", (()=>e(pg))),
t(fg, "earcut", (()=>e(Sg))),
t(fg, "url", (()=>gy)),
t(fg, "path", (()=>vy)),
t(fg, "sayHello", (()=>_y)),
t(fg, "skipHello", (()=>Ey)),
t(fg, "isWebGLSupported", (()=>Sy)),
t(fg, "hex2rgb", (()=>rb)),
t(fg, "hex2string", (()=>ib)),
t(fg, "rgb2hex", (()=>ob)),
t(fg, "string2hex", (()=>sb)),
t(fg, "correctBlendMode", (()=>lb)),
t(fg, "premultiplyBlendMode", (()=>ab)),
t(fg, "premultiplyRgba", (()=>cb)),
t(fg, "premultiplyTint", (()=>ub)),
t(fg, "premultiplyTintToRgba", (()=>hb)),
t(fg, "DATA_URI", (()=>db)),
t(fg, "createIndicesForQuads", (()=>fb)),
t(fg, "getBufferType", (()=>pb)),
t(fg, "interleaveTypedArrays", (()=>gb)),
t(fg, "isPow2", (()=>bb)),
t(fg, "log2", (()=>vb)),
t(fg, "nextPow2", (()=>yb)),
t(fg, "removeItems", (()=>wb)),
t(fg, "sign", (()=>xb)),
t(fg, "uid", (()=>_b)),
t(fg, "deprecation", (()=>xy)),
t(fg, "BoundingBox", (()=>Sb)),
t(fg, "BaseTextureCache", (()=>Ib)),
t(fg, "ProgramCache", (()=>Tb)),
t(fg, "TextureCache", (()=>kb)),
t(fg, "clearTextureCache", (()=>Cb)),
t(fg, "destroyTextureCache", (()=>Mb)),
t(fg, "CanvasRenderTarget", (()=>Pb)),
t(fg, "getCanvasBoundingBox", (()=>Rb)),
t(fg, "trimCanvas", (()=>Db)),
t(fg, "decomposeDataUri", (()=>Bb)),
t(fg, "determineCrossOrigin", (()=>Fb)),
t(fg, "getResolutionOfUrl", (()=>jb)),
Xm.RETINA_PREFIX = /@([0-9\.]+)x/,
Xm.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var pg = {}
  , mg = Object.prototype.hasOwnProperty
  , gg = "~";
function yg() {}
function bg(t, e, n) {
    this.fn = t,
    this.context = e,
    this.once = n || !1
}
function vg(t, e, n, r, i) {
    if ("function" != typeof n)
        throw new TypeError("The listener must be a function");
    var s = new bg(n,r || t,i)
      , o = gg ? gg + e : e;
    return t._events[o] ? t._events[o].fn ? t._events[o] = [t._events[o], s] : t._events[o].push(s) : (t._events[o] = s,
    t._eventsCount++),
    t
}
function wg(t, e) {
    0 == --t._eventsCount ? t._events = new yg : delete t._events[e]
}
function xg() {
    this._events = new yg,
    this._eventsCount = 0
}
Object.create && (yg.prototype = Object.create(null),
(new yg).__proto__ || (gg = !1)),
xg.prototype.eventNames = function() {
    var t, e, n = [];
    if (0 === this._eventsCount)
        return n;
    for (e in t = this._events)
        mg.call(t, e) && n.push(gg ? e.slice(1) : e);
    return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n
}
,
xg.prototype.listeners = function(t) {
    var e = gg ? gg + t : t
      , n = this._events[e];
    if (!n)
        return [];
    if (n.fn)
        return [n.fn];
    for (var r = 0, i = n.length, s = new Array(i); r < i; r++)
        s[r] = n[r].fn;
    return s
}
,
xg.prototype.listenerCount = function(t) {
    var e = gg ? gg + t : t
      , n = this._events[e];
    return n ? n.fn ? 1 : n.length : 0
}
,
xg.prototype.emit = function(t, e, n, r, i, s) {
    var o = gg ? gg + t : t;
    if (!this._events[o])
        return !1;
    var a, l, c = this._events[o], u = arguments.length;
    if (c.fn) {
        switch (c.once && this.removeListener(t, c.fn, void 0, !0),
        u) {
        case 1:
            return c.fn.call(c.context),
            !0;
        case 2:
            return c.fn.call(c.context, e),
            !0;
        case 3:
            return c.fn.call(c.context, e, n),
            !0;
        case 4:
            return c.fn.call(c.context, e, n, r),
            !0;
        case 5:
            return c.fn.call(c.context, e, n, r, i),
            !0;
        case 6:
            return c.fn.call(c.context, e, n, r, i, s),
            !0
        }
        for (l = 1,
        a = new Array(u - 1); l < u; l++)
            a[l - 1] = arguments[l];
        c.fn.apply(c.context, a)
    } else {
        var h, d = c.length;
        for (l = 0; l < d; l++)
            switch (c[l].once && this.removeListener(t, c[l].fn, void 0, !0),
            u) {
            case 1:
                c[l].fn.call(c[l].context);
                break;
            case 2:
                c[l].fn.call(c[l].context, e);
                break;
            case 3:
                c[l].fn.call(c[l].context, e, n);
                break;
            case 4:
                c[l].fn.call(c[l].context, e, n, r);
                break;
            default:
                if (!a)
                    for (h = 1,
                    a = new Array(u - 1); h < u; h++)
                        a[h - 1] = arguments[h];
                c[l].fn.apply(c[l].context, a)
            }
    }
    return !0
}
,
xg.prototype.on = function(t, e, n) {
    return vg(this, t, e, n, !1)
}
,
xg.prototype.once = function(t, e, n) {
    return vg(this, t, e, n, !0)
}
,
xg.prototype.removeListener = function(t, e, n, r) {
    var i = gg ? gg + t : t;
    if (!this._events[i])
        return this;
    if (!e)
        return wg(this, i),
        this;
    var s = this._events[i];
    if (s.fn)
        s.fn !== e || r && !s.once || n && s.context !== n || wg(this, i);
    else {
        for (var o = 0, a = [], l = s.length; o < l; o++)
            (s[o].fn !== e || r && !s[o].once || n && s[o].context !== n) && a.push(s[o]);
        a.length ? this._events[i] = 1 === a.length ? a[0] : a : wg(this, i)
    }
    return this
}
,
xg.prototype.removeAllListeners = function(t) {
    var e;
    return t ? (e = gg ? gg + t : t,
    this._events[e] && wg(this, e)) : (this._events = new yg,
    this._eventsCount = 0),
    this
}
,
xg.prototype.off = xg.prototype.removeListener,
xg.prototype.addListener = xg.prototype.on,
xg.prefixed = gg,
xg.EventEmitter = xg,
pg = xg;
var Eg, _g, Ag, Sg = {};
function Tg(t, e, n) {
    n = n || 2;
    var r, i, s, o, a, l, c, u = e && e.length, h = u ? e[0] * n : t.length, d = kg(t, 0, h, n, !0), f = [];
    if (!d || d.next === d.prev)
        return f;
    if (u && (d = function(t, e, n, r) {
        var i, s, o, a = [];
        for (i = 0,
        s = e.length; i < s; i++)
            (o = kg(t, e[i] * r, i < s - 1 ? e[i + 1] * r : t.length, r, !1)) === o.next && (o.steiner = !0),
            a.push(Fg(o));
        for (a.sort(Rg),
        i = 0; i < a.length; i++)
            n = Dg(a[i], n);
        return n
    }(t, e, d, n)),
    t.length > 80 * n) {
        r = s = t[0],
        i = o = t[1];
        for (var p = n; p < h; p += n)
            (a = t[p]) < r && (r = a),
            (l = t[p + 1]) < i && (i = l),
            a > s && (s = a),
            l > o && (o = l);
        c = 0 !== (c = Math.max(s - r, o - i)) ? 32767 / c : 0
    }
    return Mg(d, f, n, r, i, c, 0),
    f
}
function kg(t, e, n, r, i) {
    var s, o;
    if (i === Qg(t, e, n, r) > 0)
        for (s = e; s < n; s += r)
            o = Xg(s, t[s], t[s + 1], o);
    else
        for (s = n - r; s >= e; s -= r)
            o = Xg(s, t[s], t[s + 1], o);
    return o && Vg(o, o.next) && (qg(o),
    o = o.next),
    o
}
function Ig(t, e) {
    if (!t)
        return t;
    e || (e = t);
    var n, r = t;
    do {
        if (n = !1,
        r.steiner || !Vg(r, r.next) && 0 !== zg(r.prev, r, r.next))
            r = r.next;
        else {
            if (qg(r),
            (r = e = r.prev) === r.next)
                break;
            n = !0
        }
    } while (n || r !== e);
    return e
}
function Mg(t, e, n, r, i, s, o) {
    if (t) {
        !o && s && function(t, e, n, r) {
            var i = t;
            do {
                0 === i.z && (i.z = Lg(i.x, i.y, e, n, r)),
                i.prevZ = i.prev,
                i.nextZ = i.next,
                i = i.next
            } while (i !== t);
            i.prevZ.nextZ = null,
            i.prevZ = null,
            function(t) {
                var e, n, r, i, s, o, a, l, c = 1;
                do {
                    for (n = t,
                    t = null,
                    s = null,
                    o = 0; n; ) {
                        for (o++,
                        r = n,
                        a = 0,
                        e = 0; e < c && (a++,
                        r = r.nextZ); e++)
                            ;
                        for (l = c; a > 0 || l > 0 && r; )
                            0 !== a && (0 === l || !r || n.z <= r.z) ? (i = n,
                            n = n.nextZ,
                            a--) : (i = r,
                            r = r.nextZ,
                            l--),
                            s ? s.nextZ = i : t = i,
                            i.prevZ = s,
                            s = i;
                        n = r
                    }
                    s.nextZ = null,
                    c *= 2
                } while (o > 1)
            }(i)
        }(t, r, i, s);
        for (var a, l, c = t; t.prev !== t.next; )
            if (a = t.prev,
            l = t.next,
            s ? Pg(t, r, i, s) : Cg(t))
                e.push(a.i / n | 0),
                e.push(t.i / n | 0),
                e.push(l.i / n | 0),
                qg(t),
                t = l.next,
                c = l.next;
            else if ((t = l) === c) {
                o ? 1 === o ? Mg(t = Og(Ig(t), e, n), e, n, r, i, s, 2) : 2 === o && Ng(t, e, n, r, i, s) : Mg(Ig(t), e, n, r, i, s, 1);
                break
            }
    }
}
function Cg(t) {
    var e = t.prev
      , n = t
      , r = t.next;
    if (zg(e, n, r) >= 0)
        return !1;
    for (var i = e.x, s = n.x, o = r.x, a = e.y, l = n.y, c = r.y, u = i < s ? i < o ? i : o : s < o ? s : o, h = a < l ? a < c ? a : c : l < c ? l : c, d = i > s ? i > o ? i : o : s > o ? s : o, f = a > l ? a > c ? a : c : l > c ? l : c, p = r.next; p !== e; ) {
        if (p.x >= u && p.x <= d && p.y >= h && p.y <= f && jg(i, a, s, l, o, c, p.x, p.y) && zg(p.prev, p, p.next) >= 0)
            return !1;
        p = p.next
    }
    return !0
}
function Pg(t, e, n, r) {
    var i = t.prev
      , s = t
      , o = t.next;
    if (zg(i, s, o) >= 0)
        return !1;
    for (var a = i.x, l = s.x, c = o.x, u = i.y, h = s.y, d = o.y, f = a < l ? a < c ? a : c : l < c ? l : c, p = u < h ? u < d ? u : d : h < d ? h : d, m = a > l ? a > c ? a : c : l > c ? l : c, g = u > h ? u > d ? u : d : h > d ? h : d, y = Lg(f, p, e, n, r), b = Lg(m, g, e, n, r), v = t.prevZ, w = t.nextZ; v && v.z >= y && w && w.z <= b; ) {
        if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== i && v !== o && jg(a, u, l, h, c, d, v.x, v.y) && zg(v.prev, v, v.next) >= 0)
            return !1;
        if (v = v.prevZ,
        w.x >= f && w.x <= m && w.y >= p && w.y <= g && w !== i && w !== o && jg(a, u, l, h, c, d, w.x, w.y) && zg(w.prev, w, w.next) >= 0)
            return !1;
        w = w.nextZ
    }
    for (; v && v.z >= y; ) {
        if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== i && v !== o && jg(a, u, l, h, c, d, v.x, v.y) && zg(v.prev, v, v.next) >= 0)
            return !1;
        v = v.prevZ
    }
    for (; w && w.z <= b; ) {
        if (w.x >= f && w.x <= m && w.y >= p && w.y <= g && w !== i && w !== o && jg(a, u, l, h, c, d, w.x, w.y) && zg(w.prev, w, w.next) >= 0)
            return !1;
        w = w.nextZ
    }
    return !0
}
function Og(t, e, n) {
    var r = t;
    do {
        var i = r.prev
          , s = r.next.next;
        !Vg(i, s) && Wg(i, r, r.next, s) && $g(i, s) && $g(s, i) && (e.push(i.i / n | 0),
        e.push(r.i / n | 0),
        e.push(s.i / n | 0),
        qg(r),
        qg(r.next),
        r = t = s),
        r = r.next
    } while (r !== t);
    return Ig(r)
}
function Ng(t, e, n, r, i, s) {
    var o = t;
    do {
        for (var a = o.next.next; a !== o.prev; ) {
            if (o.i !== a.i && Ug(o, a)) {
                var l = Gg(o, a);
                return o = Ig(o, o.next),
                l = Ig(l, l.next),
                Mg(o, e, n, r, i, s, 0),
                void Mg(l, e, n, r, i, s, 0)
            }
            a = a.next
        }
        o = o.next
    } while (o !== t)
}
function Rg(t, e) {
    return t.x - e.x
}
function Dg(t, e) {
    var n = function(t, e) {
        var n, r = e, i = t.x, s = t.y, o = -1 / 0;
        do {
            if (s <= r.y && s >= r.next.y && r.next.y !== r.y) {
                var a = r.x + (s - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                if (a <= i && a > o && (o = a,
                n = r.x < r.next.x ? r : r.next,
                a === i))
                    return n
            }
            r = r.next
        } while (r !== e);
        if (!n)
            return null;
        var l, c = n, u = n.x, h = n.y, d = 1 / 0;
        r = n;
        do {
            i >= r.x && r.x >= u && i !== r.x && jg(s < h ? i : o, s, u, h, s < h ? o : i, s, r.x, r.y) && (l = Math.abs(s - r.y) / (i - r.x),
            $g(r, t) && (l < d || l === d && (r.x > n.x || r.x === n.x && Bg(n, r))) && (n = r,
            d = l)),
            r = r.next
        } while (r !== c);
        return n
    }(t, e);
    if (!n)
        return e;
    var r = Gg(n, t);
    return Ig(r, r.next),
    Ig(n, n.next)
}
function Bg(t, e) {
    return zg(t.prev, t, e.prev) < 0 && zg(e.next, t, t.next) < 0
}
function Lg(t, e, n, r, i) {
    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
}
function Fg(t) {
    var e = t
      , n = t;
    do {
        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
        e = e.next
    } while (e !== t);
    return n
}
function jg(t, e, n, r, i, s, o, a) {
    return (i - o) * (e - a) >= (t - o) * (s - a) && (t - o) * (r - a) >= (n - o) * (e - a) && (n - o) * (s - a) >= (i - o) * (r - a)
}
function Ug(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
        var n = t;
        do {
            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Wg(n, n.next, t, e))
                return !0;
            n = n.next
        } while (n !== t);
        return !1
    }(t, e) && ($g(t, e) && $g(e, t) && function(t, e) {
        var n = t
          , r = !1
          , i = (t.x + e.x) / 2
          , s = (t.y + e.y) / 2;
        do {
            n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r),
            n = n.next
        } while (n !== t);
        return r
    }(t, e) && (zg(t.prev, t, e.prev) || zg(t, e.prev, e)) || Vg(t, e) && zg(t.prev, t, t.next) > 0 && zg(e.prev, e, e.next) > 0)
}
function zg(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
}
function Vg(t, e) {
    return t.x === e.x && t.y === e.y
}
function Wg(t, e, n, r) {
    var i = Hg(zg(t, e, n))
      , s = Hg(zg(t, e, r))
      , o = Hg(zg(n, r, t))
      , a = Hg(zg(n, r, e));
    return i !== s && o !== a || (!(0 !== i || !Yg(t, n, e)) || (!(0 !== s || !Yg(t, r, e)) || (!(0 !== o || !Yg(n, t, r)) || !(0 !== a || !Yg(n, e, r)))))
}
function Yg(t, e, n) {
    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
}
function Hg(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
}
function $g(t, e) {
    return zg(t.prev, t, t.next) < 0 ? zg(t, e, t.next) >= 0 && zg(t, t.prev, e) >= 0 : zg(t, e, t.prev) < 0 || zg(t, t.next, e) < 0
}
function Gg(t, e) {
    var n = new Kg(t.i,t.x,t.y)
      , r = new Kg(e.i,e.x,e.y)
      , i = t.next
      , s = e.prev;
    return t.next = e,
    e.prev = t,
    n.next = i,
    i.prev = n,
    r.next = n,
    n.prev = r,
    s.next = r,
    r.prev = s,
    r
}
function Xg(t, e, n, r) {
    var i = new Kg(t,e,n);
    return r ? (i.next = r.next,
    i.prev = r,
    r.next.prev = i,
    r.next = i) : (i.prev = i,
    i.next = i),
    i
}
function qg(t) {
    t.next.prev = t.prev,
    t.prev.next = t.next,
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ)
}
function Kg(t, e, n) {
    this.i = t,
    this.x = e,
    this.y = n,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function Qg(t, e, n, r) {
    for (var i = 0, s = e, o = n - r; s < n; s += r)
        i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]),
        o = s;
    return i
}
(Sg = Tg).default = Tg,
Tg.deviation = function(t, e, n, r) {
    var i = e && e.length
      , s = i ? e[0] * n : t.length
      , o = Math.abs(Qg(t, 0, s, n));
    if (i)
        for (var a = 0, l = e.length; a < l; a++) {
            var c = e[a] * n
              , u = a < l - 1 ? e[a + 1] * n : t.length;
            o -= Math.abs(Qg(t, c, u, n))
        }
    var h = 0;
    for (a = 0; a < r.length; a += 3) {
        var d = r[a] * n
          , f = r[a + 1] * n
          , p = r[a + 2] * n;
        h += Math.abs((t[d] - t[p]) * (t[f + 1] - t[d + 1]) - (t[d] - t[f]) * (t[p + 1] - t[d + 1]))
    }
    return 0 === o && 0 === h ? 0 : Math.abs((h - o) / o)
}
,
Tg.flatten = function(t) {
    for (var e = t[0][0].length, n = {
        vertices: [],
        holes: [],
        dimensions: e
    }, r = 0, i = 0; i < t.length; i++) {
        for (var s = 0; s < t[i].length; s++)
            for (var o = 0; o < e; o++)
                n.vertices.push(t[i][s][o]);
        i > 0 && (r += t[i - 1].length,
        n.holes.push(r))
    }
    return n
}
;
var Zg = o("dBHwk")
  , Jg = {};
function ty() {
    this.protocol = null,
    this.slashes = null,
    this.auth = null,
    this.host = null,
    this.port = null,
    this.hostname = null,
    this.hash = null,
    this.search = null,
    this.query = null,
    this.pathname = null,
    this.path = null,
    this.href = null
}
Jg = {
    isString: function(t) {
        return "string" == typeof t
    },
    isObject: function(t) {
        return "object" == typeof t && null !== t
    },
    isNull: function(t) {
        return null === t
    },
    isNullOrUndefined: function(t) {
        return null == t
    }
},
Eg = my,
_g = function(t, e) {
    return my(t, !1, !0).resolve(e)
}
,
Ag = function(t) {
    Jg.isString(t) && (t = my(t));
    return t instanceof ty ? t.format() : ty.prototype.format.call(t)
}
;
var ey, ny, ry = /^([a-z0-9.+-]+:)/i, iy = /:[0-9]*$/, sy = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, oy = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]), ay = ["'"].concat(oy), ly = ["%", "/", "?", ";", "#"].concat(ay), cy = ["/", "?", "#"], uy = /^[+a-z0-9A-Z_-]{0,63}$/, hy = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, dy = {
    javascript: !0,
    "javascript:": !0
}, fy = {
    javascript: !0,
    "javascript:": !0
}, py = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
};
function my(t, e, n) {
    if (t && Jg.isObject(t) && t instanceof ty)
        return t;
    var r = new ty;
    return r.parse(t, e, n),
    r
}
ey = o("kzGqM"),
ny = o("kWD7b"),
ty.prototype.parse = function(t, e, n) {
    if (!Jg.isString(t))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
    var r = t.indexOf("?")
      , i = -1 !== r && r < t.indexOf("#") ? "?" : "#"
      , s = t.split(i);
    s[0] = s[0].replace(/\\/g, "/");
    var o = t = s.join(i);
    if (o = o.trim(),
    !n && 1 === t.split("#").length) {
        var a = sy.exec(o);
        if (a)
            return this.path = o,
            this.href = o,
            this.pathname = a[1],
            a[2] ? (this.search = a[2],
            this.query = e ? ey(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "",
            this.query = {}),
            this
    }
    var l = ry.exec(o);
    if (l) {
        var c = (l = l[0]).toLowerCase();
        this.protocol = c,
        o = o.substr(l.length)
    }
    if (n || l || o.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var u = "//" === o.substr(0, 2);
        !u || l && fy[l] || (o = o.substr(2),
        this.slashes = !0)
    }
    if (!fy[l] && (u || l && !py[l])) {
        for (var h, d, f = -1, p = 0; p < cy.length; p++) {
            -1 !== (m = o.indexOf(cy[p])) && (-1 === f || m < f) && (f = m)
        }
        -1 !== (d = -1 === f ? o.lastIndexOf("@") : o.lastIndexOf("@", f)) && (h = o.slice(0, d),
        o = o.slice(d + 1),
        this.auth = decodeURIComponent(h)),
        f = -1;
        for (p = 0; p < ly.length; p++) {
            var m;
            -1 !== (m = o.indexOf(ly[p])) && (-1 === f || m < f) && (f = m)
        }
        -1 === f && (f = o.length),
        this.host = o.slice(0, f),
        o = o.slice(f),
        this.parseHost(),
        this.hostname = this.hostname || "";
        var g = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
        if (!g)
            for (var y = this.hostname.split(/\./), b = (p = 0,
            y.length); p < b; p++) {
                var v = y[p];
                if (v && !v.match(uy)) {
                    for (var w = "", x = 0, E = v.length; x < E; x++)
                        v.charCodeAt(x) > 127 ? w += "x" : w += v[x];
                    if (!w.match(uy)) {
                        var _ = y.slice(0, p)
                          , A = y.slice(p + 1)
                          , S = v.match(hy);
                        S && (_.push(S[1]),
                        A.unshift(S[2])),
                        A.length && (o = "/" + A.join(".") + o),
                        this.hostname = _.join(".");
                        break
                    }
                }
            }
        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
        g || (this.hostname = Zg.toASCII(this.hostname));
        var T = this.port ? ":" + this.port : ""
          , k = this.hostname || "";
        this.host = k + T,
        this.href += this.host,
        g && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
        "/" !== o[0] && (o = "/" + o))
    }
    if (!dy[c])
        for (p = 0,
        b = ay.length; p < b; p++) {
            var I = ay[p];
            if (-1 !== o.indexOf(I)) {
                var M = encodeURIComponent(I);
                M === I && (M = escape(I)),
                o = o.split(I).join(M)
            }
        }
    var C = o.indexOf("#");
    -1 !== C && (this.hash = o.substr(C),
    o = o.slice(0, C));
    var P = o.indexOf("?");
    if (-1 !== P ? (this.search = o.substr(P),
    this.query = o.substr(P + 1),
    e && (this.query = ey(this.query)),
    o = o.slice(0, P)) : e && (this.search = "",
    this.query = {}),
    o && (this.pathname = o),
    py[c] && this.hostname && !this.pathname && (this.pathname = "/"),
    this.pathname || this.search) {
        T = this.pathname || "";
        var O = this.search || "";
        this.path = T + O
    }
    return this.href = this.format(),
    this
}
,
ty.prototype.format = function() {
    var t = this.auth || "";
    t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"),
    t += "@");
    var e = this.protocol || ""
      , n = this.pathname || ""
      , r = this.hash || ""
      , i = !1
      , s = "";
    this.host ? i = t + this.host : this.hostname && (i = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"),
    this.port && (i += ":" + this.port)),
    this.query && Jg.isObject(this.query) && Object.keys(this.query).length && (s = ny(this.query));
    var o = this.search || s && "?" + s || "";
    return e && ":" !== e.substr(-1) && (e += ":"),
    this.slashes || (!e || py[e]) && !1 !== i ? (i = "//" + (i || ""),
    n && "/" !== n.charAt(0) && (n = "/" + n)) : i || (i = ""),
    r && "#" !== r.charAt(0) && (r = "#" + r),
    o && "?" !== o.charAt(0) && (o = "?" + o),
    e + i + (n = n.replace(/[?#]/g, (function(t) {
        return encodeURIComponent(t)
    }
    ))) + (o = o.replace("#", "%23")) + r
}
,
ty.prototype.resolve = function(t) {
    return this.resolveObject(my(t, !1, !0)).format()
}
,
ty.prototype.resolveObject = function(t) {
    if (Jg.isString(t)) {
        var e = new ty;
        e.parse(t, !1, !0),
        t = e
    }
    for (var n = new ty, r = Object.keys(this), i = 0; i < r.length; i++) {
        var s = r[i];
        n[s] = this[s]
    }
    if (n.hash = t.hash,
    "" === t.href)
        return n.href = n.format(),
        n;
    if (t.slashes && !t.protocol) {
        for (var o = Object.keys(t), a = 0; a < o.length; a++) {
            var l = o[a];
            "protocol" !== l && (n[l] = t[l])
        }
        return py[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = "/"),
        n.href = n.format(),
        n
    }
    if (t.protocol && t.protocol !== n.protocol) {
        if (!py[t.protocol]) {
            for (var c = Object.keys(t), u = 0; u < c.length; u++) {
                var h = c[u];
                n[h] = t[h]
            }
            return n.href = n.format(),
            n
        }
        if (n.protocol = t.protocol,
        t.host || fy[t.protocol])
            n.pathname = t.pathname;
        else {
            for (var d = (t.pathname || "").split("/"); d.length && !(t.host = d.shift()); )
                ;
            t.host || (t.host = ""),
            t.hostname || (t.hostname = ""),
            "" !== d[0] && d.unshift(""),
            d.length < 2 && d.unshift(""),
            n.pathname = d.join("/")
        }
        if (n.search = t.search,
        n.query = t.query,
        n.host = t.host || "",
        n.auth = t.auth,
        n.hostname = t.hostname || t.host,
        n.port = t.port,
        n.pathname || n.search) {
            var f = n.pathname || ""
              , p = n.search || "";
            n.path = f + p
        }
        return n.slashes = n.slashes || t.slashes,
        n.href = n.format(),
        n
    }
    var m = n.pathname && "/" === n.pathname.charAt(0)
      , g = t.host || t.pathname && "/" === t.pathname.charAt(0)
      , y = g || m || n.host && t.pathname
      , b = y
      , v = n.pathname && n.pathname.split("/") || []
      , w = (d = t.pathname && t.pathname.split("/") || [],
    n.protocol && !py[n.protocol]);
    if (w && (n.hostname = "",
    n.port = null,
    n.host && ("" === v[0] ? v[0] = n.host : v.unshift(n.host)),
    n.host = "",
    t.protocol && (t.hostname = null,
    t.port = null,
    t.host && ("" === d[0] ? d[0] = t.host : d.unshift(t.host)),
    t.host = null),
    y = y && ("" === d[0] || "" === v[0])),
    g)
        n.host = t.host || "" === t.host ? t.host : n.host,
        n.hostname = t.hostname || "" === t.hostname ? t.hostname : n.hostname,
        n.search = t.search,
        n.query = t.query,
        v = d;
    else if (d.length)
        v || (v = []),
        v.pop(),
        v = v.concat(d),
        n.search = t.search,
        n.query = t.query;
    else if (!Jg.isNullOrUndefined(t.search)) {
        if (w)
            n.hostname = n.host = v.shift(),
            (S = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = S.shift(),
            n.host = n.hostname = S.shift());
        return n.search = t.search,
        n.query = t.query,
        Jg.isNull(n.pathname) && Jg.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
        n.href = n.format(),
        n
    }
    if (!v.length)
        return n.pathname = null,
        n.search ? n.path = "/" + n.search : n.path = null,
        n.href = n.format(),
        n;
    for (var x = v.slice(-1)[0], E = (n.host || t.host || v.length > 1) && ("." === x || ".." === x) || "" === x, _ = 0, A = v.length; A >= 0; A--)
        "." === (x = v[A]) ? v.splice(A, 1) : ".." === x ? (v.splice(A, 1),
        _++) : _ && (v.splice(A, 1),
        _--);
    if (!y && !b)
        for (; _--; _)
            v.unshift("..");
    !y || "" === v[0] || v[0] && "/" === v[0].charAt(0) || v.unshift(""),
    E && "/" !== v.join("/").substr(-1) && v.push("");
    var S, T = "" === v[0] || v[0] && "/" === v[0].charAt(0);
    w && (n.hostname = n.host = T ? "" : v.length ? v.shift() : "",
    (S = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = S.shift(),
    n.host = n.hostname = S.shift()));
    return (y = y || n.host && v.length) && !T && v.unshift(""),
    v.length ? n.pathname = v.join("/") : (n.pathname = null,
    n.path = null),
    Jg.isNull(n.pathname) && Jg.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
    n.auth = t.auth || n.auth,
    n.slashes = n.slashes || t.slashes,
    n.href = n.format(),
    n
}
,
ty.prototype.parseHost = function() {
    var t = this.host
      , e = iy.exec(t);
    e && (":" !== (e = e[0]) && (this.port = e.substr(1)),
    t = t.substr(0, t.length - e.length)),
    t && (this.hostname = t)
}
;
const gy = {
    parse: Eg,
    format: Ag,
    resolve: _g
};
function yy(t) {
    if ("string" != typeof t)
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`)
}
function by(t) {
    return t.split("?")[0].split("#")[0]
}
const vy = {
    toPosix(t) {
        return e = "\\",
        n = "/",
        t.replace(new RegExp(e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),"g"), n);
        var e, n
    },
    isUrl(t) {
        return /^https?:/.test(this.toPosix(t))
    },
    isDataUrl: t=>/^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t),
    hasProtocol(t) {
        return /^[^/:]+:\//.test(this.toPosix(t))
    },
    getProtocol(t) {
        yy(t),
        t = this.toPosix(t);
        let e = "";
        const n = /^file:\/\/\//.exec(t)
          , r = /^[^/:]+:\/\//.exec(t)
          , i = /^[^/:]+:\//.exec(t);
        if (n || r || i) {
            const s = n?.[0] || r?.[0] || i?.[0];
            e = s,
            t = t.slice(s.length)
        }
        return e
    },
    toAbsolute(t, e, n) {
        if (this.isDataUrl(t))
            return t;
        const r = by(this.toPosix(e ?? Xm.ADAPTER.getBaseUrl()))
          , i = by(this.toPosix(n ?? this.rootname(r)));
        if (yy(t),
        (t = this.toPosix(t)).startsWith("/"))
            return vy.join(i, t.slice(1));
        return this.isAbsolute(t) ? t : this.join(r, t)
    },
    normalize(t) {
        if (yy(t = this.toPosix(t)),
        0 === t.length)
            return ".";
        let e = "";
        const n = t.startsWith("/");
        this.hasProtocol(t) && (e = this.rootname(t),
        t = t.slice(e.length));
        const r = t.endsWith("/");
        return (t = function(t, e) {
            let n = ""
              , r = 0
              , i = -1
              , s = 0
              , o = -1;
            for (let a = 0; a <= t.length; ++a) {
                if (a < t.length)
                    o = t.charCodeAt(a);
                else {
                    if (47 === o)
                        break;
                    o = 47
                }
                if (47 === o) {
                    if (i === a - 1 || 1 === s)
                        ;
                    else if (i !== a - 1 && 2 === s) {
                        if (n.length < 2 || 2 !== r || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2))
                            if (n.length > 2) {
                                const t = n.lastIndexOf("/");
                                if (t !== n.length - 1) {
                                    -1 === t ? (n = "",
                                    r = 0) : (n = n.slice(0, t),
                                    r = n.length - 1 - n.lastIndexOf("/")),
                                    i = a,
                                    s = 0;
                                    continue
                                }
                            } else if (2 === n.length || 1 === n.length) {
                                n = "",
                                r = 0,
                                i = a,
                                s = 0;
                                continue
                            }
                        e && (n.length > 0 ? n += "/.." : n = "..",
                        r = 2)
                    } else
                        n.length > 0 ? n += `/${t.slice(i + 1, a)}` : n = t.slice(i + 1, a),
                        r = a - i - 1;
                    i = a,
                    s = 0
                } else
                    46 === o && -1 !== s ? ++s : s = -1
            }
            return n
        }(t, !1)).length > 0 && r && (t += "/"),
        n ? `/${t}` : e + t
    },
    isAbsolute(t) {
        return yy(t),
        t = this.toPosix(t),
        !!this.hasProtocol(t) || t.startsWith("/")
    },
    join(...t) {
        if (0 === t.length)
            return ".";
        let e;
        for (let n = 0; n < t.length; ++n) {
            const r = t[n];
            if (yy(r),
            r.length > 0)
                if (void 0 === e)
                    e = r;
                else {
                    const i = t[n - 1] ?? "";
                    this.extname(i) ? e += `/../${r}` : e += `/${r}`
                }
        }
        return void 0 === e ? "." : this.normalize(e)
    },
    dirname(t) {
        if (yy(t),
        0 === t.length)
            return ".";
        let e = (t = this.toPosix(t)).charCodeAt(0);
        const n = 47 === e;
        let r = -1
          , i = !0;
        const s = this.getProtocol(t)
          , o = t;
        for (let n = (t = t.slice(s.length)).length - 1; n >= 1; --n)
            if (e = t.charCodeAt(n),
            47 === e) {
                if (!i) {
                    r = n;
                    break
                }
            } else
                i = !1;
        return -1 === r ? n ? "/" : this.isUrl(o) ? s + t : s : n && 1 === r ? "//" : s + t.slice(0, r)
    },
    rootname(t) {
        yy(t);
        let e = "";
        if (e = (t = this.toPosix(t)).startsWith("/") ? "/" : this.getProtocol(t),
        this.isUrl(t)) {
            const n = t.indexOf("/", e.length);
            e = -1 !== n ? t.slice(0, n) : t,
            e.endsWith("/") || (e += "/")
        }
        return e
    },
    basename(t, e) {
        yy(t),
        e && yy(e),
        t = by(this.toPosix(t));
        let n, r = 0, i = -1, s = !0;
        if (void 0 !== e && e.length > 0 && e.length <= t.length) {
            if (e.length === t.length && e === t)
                return "";
            let o = e.length - 1
              , a = -1;
            for (n = t.length - 1; n >= 0; --n) {
                const l = t.charCodeAt(n);
                if (47 === l) {
                    if (!s) {
                        r = n + 1;
                        break
                    }
                } else
                    -1 === a && (s = !1,
                    a = n + 1),
                    o >= 0 && (l === e.charCodeAt(o) ? -1 == --o && (i = n) : (o = -1,
                    i = a))
            }
            return r === i ? i = a : -1 === i && (i = t.length),
            t.slice(r, i)
        }
        for (n = t.length - 1; n >= 0; --n)
            if (47 === t.charCodeAt(n)) {
                if (!s) {
                    r = n + 1;
                    break
                }
            } else
                -1 === i && (s = !1,
                i = n + 1);
        return -1 === i ? "" : t.slice(r, i)
    },
    extname(t) {
        yy(t);
        let e = -1
          , n = 0
          , r = -1
          , i = !0
          , s = 0;
        for (let o = (t = by(this.toPosix(t))).length - 1; o >= 0; --o) {
            const a = t.charCodeAt(o);
            if (47 !== a)
                -1 === r && (i = !1,
                r = o + 1),
                46 === a ? -1 === e ? e = o : 1 !== s && (s = 1) : -1 !== e && (s = -1);
            else if (!i) {
                n = o + 1;
                break
            }
        }
        return -1 === e || -1 === r || 0 === s || 1 === s && e === r - 1 && e === n + 1 ? "" : t.slice(e, r)
    },
    parse(t) {
        yy(t);
        const e = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (0 === t.length)
            return e;
        let n = (t = by(this.toPosix(t))).charCodeAt(0);
        const r = this.isAbsolute(t);
        let i;
        e.root = this.rootname(t),
        i = r || this.hasProtocol(t) ? 1 : 0;
        let s = -1
          , o = 0
          , a = -1
          , l = !0
          , c = t.length - 1
          , u = 0;
        for (; c >= i; --c)
            if (n = t.charCodeAt(c),
            47 !== n)
                -1 === a && (l = !1,
                a = c + 1),
                46 === n ? -1 === s ? s = c : 1 !== u && (u = 1) : -1 !== s && (u = -1);
            else if (!l) {
                o = c + 1;
                break
            }
        return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === o + 1 ? -1 !== a && (e.base = e.name = 0 === o && r ? t.slice(1, a) : t.slice(o, a)) : (0 === o && r ? (e.name = t.slice(1, s),
        e.base = t.slice(1, a)) : (e.name = t.slice(o, s),
        e.base = t.slice(o, a)),
        e.ext = t.slice(s, a)),
        e.dir = this.dirname(t),
        e
    },
    sep: "/",
    delimiter: ":"
}
  , wy = {};
function xy(t, e, n=3) {
    if (wy[e])
        return;
    let r = (new Error).stack;
    void 0 === r ? console.warn("PixiJS Deprecation Warning: ", `${e}\nDeprecated since v${t}`) : (r = r.split("\n").splice(n).join("\n"),
    console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}\nDeprecated since v${t}`),
    console.warn(r),
    console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}\nDeprecated since v${t}`),
    console.warn(r))),
    wy[e] = !0
}
function Ey() {
    xy("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")
}
function _y() {
    xy("7.0.0", 'sayHello is deprecated, please use Renderer\'s "hello" option')
}
let Ay;
function Sy() {
    return void 0 === Ay && (Ay = function() {
        const t = {
            stencil: !0,
            failIfMajorPerformanceCaveat: Xm.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
            if (!Xm.ADAPTER.getWebGLRenderingContext())
                return !1;
            const e = Xm.ADAPTER.createCanvas();
            let n = e.getContext("webgl", t) || e.getContext("experimental-webgl", t);
            const r = !!n?.getContextAttributes()?.stencil;
            if (n) {
                const t = n.getExtension("WEBGL_lose_context");
                t && t.loseContext()
            }
            return n = null,
            r
        } catch (t) {
            return !1
        }
    }()),
    Ay
}
var Ty, ky = {
    grad: .9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
}, Iy = function(t) {
    return "string" == typeof t ? t.length > 0 : "number" == typeof t
}, My = function(t, e, n) {
    return void 0 === e && (e = 0),
    void 0 === n && (n = Math.pow(10, e)),
    Math.round(n * t) / n + 0
}, Cy = function(t, e, n) {
    return void 0 === e && (e = 0),
    void 0 === n && (n = 1),
    t > n ? n : t > e ? t : e
}, Py = function(t) {
    return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360
}, Oy = function(t) {
    return {
        r: Cy(t.r, 0, 255),
        g: Cy(t.g, 0, 255),
        b: Cy(t.b, 0, 255),
        a: Cy(t.a)
    }
}, Ny = function(t) {
    return {
        r: My(t.r),
        g: My(t.g),
        b: My(t.b),
        a: My(t.a, 3)
    }
}, Ry = /^#([0-9a-f]{3,8})$/i, Dy = function(t) {
    var e = t.toString(16);
    return e.length < 2 ? "0" + e : e
}, By = function(t) {
    var e = t.r
      , n = t.g
      , r = t.b
      , i = t.a
      , s = Math.max(e, n, r)
      , o = s - Math.min(e, n, r)
      , a = o ? s === e ? (n - r) / o : s === n ? 2 + (r - e) / o : 4 + (e - n) / o : 0;
    return {
        h: 60 * (a < 0 ? a + 6 : a),
        s: s ? o / s * 100 : 0,
        v: s / 255 * 100,
        a: i
    }
}, Ly = function(t) {
    var e = t.h
      , n = t.s
      , r = t.v
      , i = t.a;
    e = e / 360 * 6,
    n /= 100,
    r /= 100;
    var s = Math.floor(e)
      , o = r * (1 - n)
      , a = r * (1 - (e - s) * n)
      , l = r * (1 - (1 - e + s) * n)
      , c = s % 6;
    return {
        r: 255 * [r, a, o, o, l, r][c],
        g: 255 * [l, r, r, a, o, o][c],
        b: 255 * [o, o, l, r, r, a][c],
        a: i
    }
}, Fy = function(t) {
    return {
        h: Py(t.h),
        s: Cy(t.s, 0, 100),
        l: Cy(t.l, 0, 100),
        a: Cy(t.a)
    }
}, jy = function(t) {
    return {
        h: My(t.h),
        s: My(t.s),
        l: My(t.l),
        a: My(t.a, 3)
    }
}, Uy = function(t) {
    var e, n, r;
    return Ly((n = (e = t).s,
    {
        h: e.h,
        s: (n *= ((r = e.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * n / (r + n) * 100 : 0,
        v: r + n,
        a: e.a
    }))
}, zy = function(t) {
    var e, n, r, i;
    return {
        h: (e = By(t)).h,
        s: (i = (200 - (n = e.s)) * (r = e.v) / 100) > 0 && i < 200 ? n * r / 100 / (i <= 100 ? i : 200 - i) * 100 : 0,
        l: i / 2,
        a: e.a
    }
}, Vy = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Wy = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Yy = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Hy = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, $y = {
    string: [[function(t) {
        var e = Ry.exec(t);
        return e ? (t = e[1]).length <= 4 ? {
            r: parseInt(t[0] + t[0], 16),
            g: parseInt(t[1] + t[1], 16),
            b: parseInt(t[2] + t[2], 16),
            a: 4 === t.length ? My(parseInt(t[3] + t[3], 16) / 255, 2) : 1
        } : 6 === t.length || 8 === t.length ? {
            r: parseInt(t.substr(0, 2), 16),
            g: parseInt(t.substr(2, 2), 16),
            b: parseInt(t.substr(4, 2), 16),
            a: 8 === t.length ? My(parseInt(t.substr(6, 2), 16) / 255, 2) : 1
        } : null : null
    }
    , "hex"], [function(t) {
        var e = Yy.exec(t) || Hy.exec(t);
        return e ? e[2] !== e[4] || e[4] !== e[6] ? null : Oy({
            r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
            g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
            b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
            a: void 0 === e[7] ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
        }) : null
    }
    , "rgb"], [function(t) {
        var e = Vy.exec(t) || Wy.exec(t);
        if (!e)
            return null;
        var n, r, i = Fy({
            h: (n = e[1],
            r = e[2],
            void 0 === r && (r = "deg"),
            Number(n) * (ky[r] || 1)),
            s: Number(e[3]),
            l: Number(e[4]),
            a: void 0 === e[5] ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
        });
        return Uy(i)
    }
    , "hsl"]],
    object: [[function(t) {
        var e = t.r
          , n = t.g
          , r = t.b
          , i = t.a
          , s = void 0 === i ? 1 : i;
        return Iy(e) && Iy(n) && Iy(r) ? Oy({
            r: Number(e),
            g: Number(n),
            b: Number(r),
            a: Number(s)
        }) : null
    }
    , "rgb"], [function(t) {
        var e = t.h
          , n = t.s
          , r = t.l
          , i = t.a
          , s = void 0 === i ? 1 : i;
        if (!Iy(e) || !Iy(n) || !Iy(r))
            return null;
        var o = Fy({
            h: Number(e),
            s: Number(n),
            l: Number(r),
            a: Number(s)
        });
        return Uy(o)
    }
    , "hsl"], [function(t) {
        var e = t.h
          , n = t.s
          , r = t.v
          , i = t.a
          , s = void 0 === i ? 1 : i;
        if (!Iy(e) || !Iy(n) || !Iy(r))
            return null;
        var o = function(t) {
            return {
                h: Py(t.h),
                s: Cy(t.s, 0, 100),
                v: Cy(t.v, 0, 100),
                a: Cy(t.a)
            }
        }({
            h: Number(e),
            s: Number(n),
            v: Number(r),
            a: Number(s)
        });
        return Ly(o)
    }
    , "hsv"]]
}, Gy = function(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n][0](t);
        if (r)
            return [r, e[n][1]]
    }
    return [null, void 0]
}, Xy = function(t) {
    return "string" == typeof t ? Gy(t.trim(), $y.string) : "object" == typeof t && null !== t ? Gy(t, $y.object) : [null, void 0]
}, qy = function(t, e) {
    var n = zy(t);
    return {
        h: n.h,
        s: Cy(n.s + 100 * e, 0, 100),
        l: n.l,
        a: n.a
    }
}, Ky = function(t) {
    return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255
}, Qy = function(t, e) {
    var n = zy(t);
    return {
        h: n.h,
        s: n.s,
        l: Cy(n.l + 100 * e, 0, 100),
        a: n.a
    }
}, Zy = function() {
    function t(t) {
        this.parsed = Xy(t)[0],
        this.rgba = this.parsed || {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        }
    }
    return t.prototype.isValid = function() {
        return null !== this.parsed
    }
    ,
    t.prototype.brightness = function() {
        return My(Ky(this.rgba), 2)
    }
    ,
    t.prototype.isDark = function() {
        return Ky(this.rgba) < .5
    }
    ,
    t.prototype.isLight = function() {
        return Ky(this.rgba) >= .5
    }
    ,
    t.prototype.toHex = function() {
        var t, e, n, r, i, s;
        return e = (t = Ny(this.rgba)).r,
        n = t.g,
        r = t.b,
        s = (i = t.a) < 1 ? Dy(My(255 * i)) : "",
        "#" + Dy(e) + Dy(n) + Dy(r) + s
    }
    ,
    t.prototype.toRgb = function() {
        return Ny(this.rgba)
    }
    ,
    t.prototype.toRgbString = function() {
        var t, e, n, r, i;
        return e = (t = Ny(this.rgba)).r,
        n = t.g,
        r = t.b,
        (i = t.a) < 1 ? "rgba(" + e + ", " + n + ", " + r + ", " + i + ")" : "rgb(" + e + ", " + n + ", " + r + ")"
    }
    ,
    t.prototype.toHsl = function() {
        return jy(zy(this.rgba))
    }
    ,
    t.prototype.toHslString = function() {
        var t, e, n, r, i;
        return e = (t = jy(zy(this.rgba))).h,
        n = t.s,
        r = t.l,
        (i = t.a) < 1 ? "hsla(" + e + ", " + n + "%, " + r + "%, " + i + ")" : "hsl(" + e + ", " + n + "%, " + r + "%)"
    }
    ,
    t.prototype.toHsv = function() {
        var t;
        return t = By(this.rgba),
        {
            h: My(t.h),
            s: My(t.s),
            v: My(t.v),
            a: My(t.a, 3)
        }
    }
    ,
    t.prototype.invert = function() {
        var t;
        return Jy({
            r: 255 - (t = this.rgba).r,
            g: 255 - t.g,
            b: 255 - t.b,
            a: t.a
        })
    }
    ,
    t.prototype.saturate = function(t) {
        return void 0 === t && (t = .1),
        Jy(qy(this.rgba, t))
    }
    ,
    t.prototype.desaturate = function(t) {
        return void 0 === t && (t = .1),
        Jy(qy(this.rgba, -t))
    }
    ,
    t.prototype.grayscale = function() {
        return Jy(qy(this.rgba, -1))
    }
    ,
    t.prototype.lighten = function(t) {
        return void 0 === t && (t = .1),
        Jy(Qy(this.rgba, t))
    }
    ,
    t.prototype.darken = function(t) {
        return void 0 === t && (t = .1),
        Jy(Qy(this.rgba, -t))
    }
    ,
    t.prototype.rotate = function(t) {
        return void 0 === t && (t = 15),
        this.hue(this.hue() + t)
    }
    ,
    t.prototype.alpha = function(t) {
        var e;
        return "number" == typeof t ? Jy({
            r: (e = this.rgba).r,
            g: e.g,
            b: e.b,
            a: t
        }) : My(this.rgba.a, 3)
    }
    ,
    t.prototype.hue = function(t) {
        var e = zy(this.rgba);
        return "number" == typeof t ? Jy({
            h: t,
            s: e.s,
            l: e.l,
            a: e.a
        }) : My(e.h)
    }
    ,
    t.prototype.isEqual = function(t) {
        return this.toHex() === Jy(t).toHex()
    }
    ,
    t
}(), Jy = function(t) {
    return t instanceof Zy ? t : new Zy(t)
}, tb = [];
Ty = [function(t, e) {
    var n = {
        white: "#ffffff",
        bisque: "#ffe4c4",
        blue: "#0000ff",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        azure: "#f0ffff",
        whitesmoke: "#f5f5f5",
        papayawhip: "#ffefd5",
        plum: "#dda0dd",
        blanchedalmond: "#ffebcd",
        black: "#000000",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gainsboro: "#dcdcdc",
        cornsilk: "#fff8dc",
        cornflowerblue: "#6495ed",
        burlywood: "#deb887",
        aquamarine: "#7fffd4",
        beige: "#f5f5dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkkhaki: "#bdb76b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        peachpuff: "#ffdab9",
        darkmagenta: "#8b008b",
        darkred: "#8b0000",
        darkorchid: "#9932cc",
        darkorange: "#ff8c00",
        darkslateblue: "#483d8b",
        gray: "#808080",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        wheat: "#f5deb3",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        ghostwhite: "#f8f8ff",
        darkviolet: "#9400d3",
        magenta: "#ff00ff",
        green: "#008000",
        dodgerblue: "#1e90ff",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        blueviolet: "#8a2be2",
        forestgreen: "#228b22",
        lawngreen: "#7cfc00",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        fuchsia: "#ff00ff",
        brown: "#a52a2a",
        maroon: "#800000",
        mediumblue: "#0000cd",
        lightcoral: "#f08080",
        darkturquoise: "#00ced1",
        lightcyan: "#e0ffff",
        ivory: "#fffff0",
        lightyellow: "#ffffe0",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        linen: "#faf0e6",
        mediumaquamarine: "#66cdaa",
        lemonchiffon: "#fffacd",
        lime: "#00ff00",
        khaki: "#f0e68c",
        mediumseagreen: "#3cb371",
        limegreen: "#32cd32",
        mediumspringgreen: "#00fa9a",
        lightskyblue: "#87cefa",
        lightblue: "#add8e6",
        midnightblue: "#191970",
        lightpink: "#ffb6c1",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        mintcream: "#f5fffa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        navajowhite: "#ffdead",
        navy: "#000080",
        mediumvioletred: "#c71585",
        powderblue: "#b0e0e6",
        palegoldenrod: "#eee8aa",
        oldlace: "#fdf5e6",
        paleturquoise: "#afeeee",
        mediumturquoise: "#48d1cc",
        mediumorchid: "#ba55d3",
        rebeccapurple: "#663399",
        lightsteelblue: "#b0c4de",
        mediumslateblue: "#7b68ee",
        thistle: "#d8bfd8",
        tan: "#d2b48c",
        orchid: "#da70d6",
        mediumpurple: "#9370db",
        purple: "#800080",
        pink: "#ffc0cb",
        skyblue: "#87ceeb",
        springgreen: "#00ff7f",
        palegreen: "#98fb98",
        red: "#ff0000",
        yellow: "#ffff00",
        slateblue: "#6a5acd",
        lavenderblush: "#fff0f5",
        peru: "#cd853f",
        palevioletred: "#db7093",
        violet: "#ee82ee",
        teal: "#008080",
        slategray: "#708090",
        slategrey: "#708090",
        aliceblue: "#f0f8ff",
        darkseagreen: "#8fbc8f",
        darkolivegreen: "#556b2f",
        greenyellow: "#adff2f",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        tomato: "#ff6347",
        silver: "#c0c0c0",
        sienna: "#a0522d",
        lavender: "#e6e6fa",
        lightgreen: "#90ee90",
        orange: "#ffa500",
        orangered: "#ff4500",
        steelblue: "#4682b4",
        royalblue: "#4169e1",
        turquoise: "#40e0d0",
        yellowgreen: "#9acd32",
        salmon: "#fa8072",
        saddlebrown: "#8b4513",
        sandybrown: "#f4a460",
        rosybrown: "#bc8f8f",
        darksalmon: "#e9967a",
        lightgoldenrodyellow: "#fafad2",
        snow: "#fffafa",
        lightgrey: "#d3d3d3",
        lightgray: "#d3d3d3",
        dimgray: "#696969",
        dimgrey: "#696969",
        olivedrab: "#6b8e23",
        olive: "#808000"
    }
      , r = {};
    for (var i in n)
        r[n[i]] = i;
    var s = {};
    t.prototype.toName = function(e) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
            return "transparent";
        var i, o, a = r[this.toHex()];
        if (a)
            return a;
        if (null == e ? void 0 : e.closest) {
            var l = this.toRgb()
              , c = 1 / 0
              , u = "black";
            if (!s.length)
                for (var h in n)
                    s[h] = new t(n[h]).toRgb();
            for (var d in n) {
                var f = (i = l,
                o = s[d],
                Math.pow(i.r - o.r, 2) + Math.pow(i.g - o.g, 2) + Math.pow(i.b - o.b, 2));
                f < c && (c = f,
                u = d)
            }
            return u
        }
    }
    ,
    e.string.push([function(e) {
        var r = e.toLowerCase()
          , i = "transparent" === r ? "#0000" : n[r];
        return i ? new t(i).toRgb() : null
    }
    , "name"])
}
],
Ty.forEach((function(t) {
    tb.indexOf(t) < 0 && (t(Zy, $y),
    tb.push(t))
}
));
const eb = class {
    constructor(t=16777215) {
        this._value = null,
        this._components = new Float32Array(4),
        this._components.fill(1),
        this._int = 16777215,
        this.value = t
    }
    get red() {
        return this._components[0]
    }
    get green() {
        return this._components[1]
    }
    get blue() {
        return this._components[2]
    }
    get alpha() {
        return this._components[3]
    }
    setValue(t) {
        return this.value = t,
        this
    }
    set value(t) {
        if (t instanceof eb)
            this._value = this.cloneSource(t._value),
            this._int = t._int,
            this._components.set(t._components);
        else {
            if (null === t)
                throw new Error("Cannot set PIXI.Color#value to null");
            null !== this._value && this.isSourceEqual(this._value, t) || (this.normalize(t),
            this._value = this.cloneSource(t))
        }
    }
    get value() {
        return this._value
    }
    cloneSource(t) {
        return "string" == typeof t || "number" == typeof t || t instanceof Number || null === t ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : "object" == typeof t && null !== t ? {
            ...t
        } : t
    }
    isSourceEqual(t, e) {
        const n = typeof t;
        if (n !== typeof e)
            return !1;
        if ("number" === n || "string" === n || t instanceof Number)
            return t === e;
        if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
            return t.length === e.length && t.every(((t,n)=>t === e[n]));
        if (null !== t && null !== e) {
            const n = Object.keys(t)
              , r = Object.keys(e);
            return n.length === r.length && n.every((n=>t[n] === e[n]))
        }
        return t === e
    }
    toRgba() {
        const [t,e,n,r] = this._components;
        return {
            r: t,
            g: e,
            b: n,
            a: r
        }
    }
    toRgb() {
        const [t,e,n] = this._components;
        return {
            r: t,
            g: e,
            b: n
        }
    }
    toRgbaString() {
        const [t,e,n] = this.toUint8RgbArray();
        return `rgba(${t},${e},${n},${this.alpha})`
    }
    toUint8RgbArray(t) {
        const [e,n,r] = this._components;
        return (t = t ?? [])[0] = Math.round(255 * e),
        t[1] = Math.round(255 * n),
        t[2] = Math.round(255 * r),
        t
    }
    toRgbArray(t) {
        t = t ?? [];
        const [e,n,r] = this._components;
        return t[0] = e,
        t[1] = n,
        t[2] = r,
        t
    }
    toNumber() {
        return this._int
    }
    toLittleEndianNumber() {
        const t = this._int;
        return (t >> 16) + (65280 & t) + ((255 & t) << 16)
    }
    multiply(t) {
        const [e,n,r,i] = eb.temp.setValue(t)._components;
        return this._components[0] *= e,
        this._components[1] *= n,
        this._components[2] *= r,
        this._components[3] *= i,
        this.refreshInt(),
        this._value = null,
        this
    }
    premultiply(t, e=!0) {
        return e && (this._components[0] *= t,
        this._components[1] *= t,
        this._components[2] *= t),
        this._components[3] = t,
        this.refreshInt(),
        this._value = null,
        this
    }
    toPremultiplied(t, e=!0) {
        if (1 === t)
            return -16777216 + this._int;
        if (0 === t)
            return e ? 0 : this._int;
        let n = this._int >> 16 & 255
          , r = this._int >> 8 & 255
          , i = 255 & this._int;
        return e && (n = n * t + .5 | 0,
        r = r * t + .5 | 0,
        i = i * t + .5 | 0),
        (255 * t << 24) + (n << 16) + (r << 8) + i
    }
    toHex() {
        const t = this._int.toString(16);
        return `#${"000000".substring(0, 6 - t.length) + t}`
    }
    toHexa() {
        const t = Math.round(255 * this._components[3]).toString(16);
        return this.toHex() + "00".substring(0, 2 - t.length) + t
    }
    setAlpha(t) {
        return this._components[3] = this._clamp(t),
        this
    }
    round(t) {
        const [e,n,r] = this._components;
        return this._components[0] = Math.round(e * t) / t,
        this._components[1] = Math.round(n * t) / t,
        this._components[2] = Math.round(r * t) / t,
        this.refreshInt(),
        this._value = null,
        this
    }
    toArray(t) {
        t = t ?? [];
        const [e,n,r,i] = this._components;
        return t[0] = e,
        t[1] = n,
        t[2] = r,
        t[3] = i,
        t
    }
    normalize(t) {
        let e, n, r, i;
        if (("number" == typeof t || t instanceof Number) && t >= 0 && t <= 16777215) {
            e = (t >> 16 & 255) / 255,
            n = (t >> 8 & 255) / 255,
            r = (255 & t) / 255,
            i = 1
        } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4)
            t = this._clamp(t),
            [e,n,r,i=1] = t;
        else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4)
            t = this._clamp(t, 0, 255),
            [e,n,r,i=255] = t,
            e /= 255,
            n /= 255,
            r /= 255,
            i /= 255;
        else if ("string" == typeof t || "object" == typeof t) {
            if ("string" == typeof t) {
                const e = eb.HEX_PATTERN.exec(t);
                e && (t = `#${e[2]}`)
            }
            const s = Jy(t);
            s.isValid() && (({r: e, g: n, b: r, a: i} = s.rgba),
            e /= 255,
            n /= 255,
            r /= 255)
        }
        if (void 0 === e)
            throw new Error(`Unable to convert color ${t}`);
        this._components[0] = e,
        this._components[1] = n,
        this._components[2] = r,
        this._components[3] = i,
        this.refreshInt()
    }
    refreshInt() {
        this._clamp(this._components);
        const [t,e,n] = this._components;
        this._int = (255 * t << 16) + (255 * e << 8) + (255 * n | 0)
    }
    _clamp(t, e=0, n=1) {
        return "number" == typeof t ? Math.min(Math.max(t, e), n) : (t.forEach(((r,i)=>{
            t[i] = Math.min(Math.max(r, e), n)
        }
        )),
        t)
    }
}
;
let nb = eb;
function rb(t, e=[]) {
    return xy("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"),
    nb.shared.setValue(t).toRgbArray(e)
}
function ib(t) {
    return xy("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"),
    nb.shared.setValue(t).toHex()
}
function sb(t) {
    return xy("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"),
    nb.shared.setValue(t).toNumber()
}
function ob(t) {
    return xy("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"),
    nb.shared.setValue(t).toNumber()
}
nb.shared = new eb,
nb.temp = new eb,
nb.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
const ab = function() {
    const t = []
      , e = [];
    for (let n = 0; n < 32; n++)
        t[n] = n,
        e[n] = n;
    t[Om.NORMAL_NPM] = Om.NORMAL,
    t[Om.ADD_NPM] = Om.ADD,
    t[Om.SCREEN_NPM] = Om.SCREEN,
    e[Om.NORMAL] = Om.NORMAL_NPM,
    e[Om.ADD] = Om.ADD_NPM,
    e[Om.SCREEN] = Om.SCREEN_NPM;
    const n = [];
    return n.push(e),
    n.push(t),
    n
}();
function lb(t, e) {
    return ab[e ? 1 : 0][t]
}
function cb(t, e, n, r=!0) {
    return xy("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"),
    nb.shared.setValue(t).premultiply(e, r).toArray(n ?? new Float32Array(4))
}
function ub(t, e) {
    return xy("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"),
    nb.shared.setValue(t).toPremultiplied(e)
}
function hb(t, e, n, r=!0) {
    return xy("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"),
    nb.shared.setValue(t).premultiply(e, r).toArray(n ?? new Float32Array(4))
}
const db = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
function fb(t, e=null) {
    const n = 6 * t;
    if ((e = e || new Uint16Array(n)).length !== n)
        throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${n}`);
    for (let t = 0, r = 0; t < n; t += 6,
    r += 4)
        e[t + 0] = r + 0,
        e[t + 1] = r + 1,
        e[t + 2] = r + 2,
        e[t + 3] = r + 0,
        e[t + 4] = r + 2,
        e[t + 5] = r + 3;
    return e
}
function pb(t) {
    if (4 === t.BYTES_PER_ELEMENT)
        return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (2 === t.BYTES_PER_ELEMENT) {
        if (t instanceof Uint16Array)
            return "Uint16Array"
    } else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array)
        return "Uint8Array";
    return null
}
const mb = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array
};
function gb(t, e) {
    let n = 0
      , r = 0;
    const i = {};
    for (let i = 0; i < t.length; i++)
        r += e[i],
        n += t[i].length;
    const s = new ArrayBuffer(4 * n);
    let o = null
      , a = 0;
    for (let n = 0; n < t.length; n++) {
        const l = e[n]
          , c = t[n]
          , u = pb(c);
        i[u] || (i[u] = new mb[u](s)),
        o = i[u];
        for (let t = 0; t < c.length; t++) {
            o[(t / l | 0) * r + a + t % l] = c[t]
        }
        a += l
    }
    return new Float32Array(s)
}
function yb(t) {
    return t += 0 === t ? 1 : 0,
    --t,
    t |= t >>> 1,
    t |= t >>> 2,
    t |= t >>> 4,
    t |= t >>> 8,
    (t |= t >>> 16) + 1
}
function bb(t) {
    return !(t & t - 1 || !t)
}
function vb(t) {
    let e = (t > 65535 ? 1 : 0) << 4
      , n = ((t >>>= e) > 255 ? 1 : 0) << 3;
    return e |= n,
    n = ((t >>>= n) > 15 ? 1 : 0) << 2,
    e |= n,
    n = ((t >>>= n) > 3 ? 1 : 0) << 1,
    e |= n,
    e | (t >>>= n) >> 1
}
function wb(t, e, n) {
    const r = t.length;
    let i;
    if (e >= r || 0 === n)
        return;
    const s = r - (n = e + n > r ? r - e : n);
    for (i = e; i < s; ++i)
        t[i] = t[i + n];
    t.length = s
}
function xb(t) {
    return 0 === t ? 0 : t < 0 ? -1 : 1
}
let Eb = 0;
function _b() {
    return ++Eb
}
const Ab = class {
    constructor(t, e, n, r) {
        this.left = t,
        this.top = e,
        this.right = n,
        this.bottom = r
    }
    get width() {
        return this.right - this.left
    }
    get height() {
        return this.bottom - this.top
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
}
;
let Sb = Ab;
Sb.EMPTY = new Ab(0,0,0,0);
const Tb = {}
  , kb = Object.create(null)
  , Ib = Object.create(null);
function Mb() {
    let t;
    for (t in kb)
        kb[t].destroy();
    for (t in Ib)
        Ib[t].destroy()
}
function Cb() {
    let t;
    for (t in kb)
        delete kb[t];
    for (t in Ib)
        delete Ib[t]
}
class Pb {
    constructor(t, e, n) {
        this._canvas = Xm.ADAPTER.createCanvas(),
        this._context = this._canvas.getContext("2d"),
        this.resolution = n || Xm.RESOLUTION,
        this.resize(t, e)
    }
    clear() {
        this._checkDestroyed(),
        this._context.setTransform(1, 0, 0, 1, 0, 0),
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
    }
    resize(t, e) {
        this._checkDestroyed(),
        this._canvas.width = Math.round(t * this.resolution),
        this._canvas.height = Math.round(e * this.resolution)
    }
    destroy() {
        this._context = null,
        this._canvas = null
    }
    get width() {
        return this._checkDestroyed(),
        this._canvas.width
    }
    set width(t) {
        this._checkDestroyed(),
        this._canvas.width = Math.round(t)
    }
    get height() {
        return this._checkDestroyed(),
        this._canvas.height
    }
    set height(t) {
        this._checkDestroyed(),
        this._canvas.height = Math.round(t)
    }
    get canvas() {
        return this._checkDestroyed(),
        this._canvas
    }
    get context() {
        return this._checkDestroyed(),
        this._context
    }
    _checkDestroyed() {
        if (null === this._canvas)
            throw new TypeError("The CanvasRenderTarget has already been destroyed")
    }
}
function Ob(t, e, n) {
    for (let r = 0, i = 4 * n * e; r < e; ++r,
    i += 4)
        if (0 !== t[i + 3])
            return !1;
    return !0
}
function Nb(t, e, n, r, i) {
    const s = 4 * e;
    for (let e = r, o = r * s + 4 * n; e <= i; ++e,
    o += s)
        if (0 !== t[o + 3])
            return !1;
    return !0
}
function Rb(t) {
    const {width: e, height: n} = t
      , r = t.getContext("2d", {
        willReadFrequently: !0
    });
    if (null === r)
        throw new TypeError("Failed to get canvas 2D context");
    const i = r.getImageData(0, 0, e, n).data;
    let s = 0
      , o = 0
      , a = e - 1
      , l = n - 1;
    for (; o < n && Ob(i, e, o); )
        ++o;
    if (o === n)
        return Sb.EMPTY;
    for (; Ob(i, e, l); )
        --l;
    for (; Nb(i, e, s, o, l); )
        ++s;
    for (; Nb(i, e, a, o, l); )
        --a;
    return ++a,
    ++l,
    new Sb(s,o,a,l)
}
function Db(t) {
    const e = Rb(t)
      , {width: n, height: r} = e;
    let i = null;
    if (!e.isEmpty()) {
        const s = t.getContext("2d");
        if (null === s)
            throw new TypeError("Failed to get canvas 2D context");
        i = s.getImageData(e.left, e.top, n, r)
    }
    return {
        width: n,
        height: r,
        data: i
    }
}
function Bb(t) {
    const e = db.exec(t);
    if (e)
        return {
            mediaType: e[1] ? e[1].toLowerCase() : void 0,
            subType: e[2] ? e[2].toLowerCase() : void 0,
            charset: e[3] ? e[3].toLowerCase() : void 0,
            encoding: e[4] ? e[4].toLowerCase() : void 0,
            data: e[5]
        }
}
let Lb;
function Fb(t, e=globalThis.location) {
    if (t.startsWith("data:"))
        return "";
    e = e || globalThis.location,
    Lb || (Lb = document.createElement("a")),
    Lb.href = t;
    const n = gy.parse(Lb.href)
      , r = !n.port && "" === e.port || n.port === e.port;
    return n.hostname === e.hostname && r && n.protocol === e.protocol ? "" : "anonymous"
}
function jb(t, e=1) {
    const n = Xm.RETINA_PREFIX?.exec(t);
    return n ? parseFloat(n[1]) : e
}
var Ub = (t=>(t.Renderer = "renderer",
t.Application = "application",
t.RendererSystem = "renderer-webgl-system",
t.RendererPlugin = "renderer-webgl-plugin",
t.CanvasRendererSystem = "renderer-canvas-system",
t.CanvasRendererPlugin = "renderer-canvas-plugin",
t.Asset = "asset",
t.LoadParser = "load-parser",
t.ResolveParser = "resolve-parser",
t.CacheParser = "cache-parser",
t.DetectionParser = "detection-parser",
t))(Ub || {});
const zb = t=>{
    if ("function" == typeof t || "object" == typeof t && t.extension) {
        if (!t.extension)
            throw new Error("Extension class must have an extension object");
        t = {
            ..."object" != typeof t.extension ? {
                type: t.extension
            } : t.extension,
            ref: t
        }
    }
    if ("object" != typeof t)
        throw new Error("Invalid extension type");
    return "string" == typeof (t = {
        ...t
    }).type && (t.type = [t.type]),
    t
}
  , Vb = (t,e)=>zb(t).priority ?? e
  , Wb = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...t) {
        return t.map(zb).forEach((t=>{
            t.type.forEach((e=>this._removeHandlers[e]?.(t)))
        }
        )),
        this
    },
    add(...t) {
        return t.map(zb).forEach((t=>{
            t.type.forEach((e=>{
                const n = this._addHandlers
                  , r = this._queue;
                n[e] ? n[e](t) : (r[e] = r[e] || [],
                r[e].push(t))
            }
            ))
        }
        )),
        this
    },
    handle(t, e, n) {
        const r = this._addHandlers
          , i = this._removeHandlers;
        if (r[t] || i[t])
            throw new Error(`Extension type ${t} already has a handler`);
        r[t] = e,
        i[t] = n;
        const s = this._queue;
        return s[t] && (s[t].forEach((t=>e(t))),
        delete s[t]),
        this
    },
    handleByMap(t, e) {
        return this.handle(t, (t=>{
            e[t.name] = t.ref
        }
        ), (t=>{
            delete e[t.name]
        }
        ))
    },
    handleByList(t, e, n=-1) {
        return this.handle(t, (t=>{
            e.includes(t.ref) || (e.push(t.ref),
            e.sort(((t,e)=>Vb(e, n) - Vb(t, n))))
        }
        ), (t=>{
            const n = e.indexOf(t.ref);
            -1 !== n && e.splice(n, 1)
        }
        ))
    }
};
class Yb {
    constructor(t) {
        "number" == typeof t ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t,
        this.uint32View = new Uint32Array(this.rawBinaryData),
        this.float32View = new Float32Array(this.rawBinaryData)
    }
    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
        this._int8View
    }
    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
        this._uint8View
    }
    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
        this._int16View
    }
    get uint16View() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)),
        this._uint16View
    }
    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
        this._int32View
    }
    view(t) {
        return this[`${t}View`]
    }
    destroy() {
        this.rawBinaryData = null,
        this._int8View = null,
        this._uint8View = null,
        this._int16View = null,
        this._uint16View = null,
        this._int32View = null,
        this.uint32View = null,
        this.float32View = null
    }
    static sizeOf(t) {
        switch (t) {
        case "int8":
        case "uint8":
            return 1;
        case "int16":
        case "uint16":
            return 2;
        case "int32":
        case "uint32":
        case "float32":
            return 4;
        default:
            throw new Error(`${t} isn't a valid view type`)
        }
    }
}
const Hb = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");
function $b(t) {
    let e = "";
    for (let n = 0; n < t; ++n)
        n > 0 && (e += "\nelse "),
        n < t - 1 && (e += `if(test == ${n}.0){}`);
    return e
}
function Gb(t, e) {
    if (0 === t)
        throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const n = e.createShader(e.FRAGMENT_SHADER);
    for (; ; ) {
        const r = Hb.replace(/%forloop%/gi, $b(t));
        if (e.shaderSource(n, r),
        e.compileShader(n),
        e.getShaderParameter(n, e.COMPILE_STATUS))
            break;
        t = t / 2 | 0
    }
    return t
}
class Xb {
    constructor() {
        this.data = 0,
        this.blendMode = Om.NORMAL,
        this.polygonOffset = 0,
        this.blend = !0,
        this.depthMask = !0
    }
    get blend() {
        return !!(1 & this.data)
    }
    set blend(t) {
        !!(1 & this.data) !== t && (this.data ^= 1)
    }
    get offsets() {
        return !!(2 & this.data)
    }
    set offsets(t) {
        !!(2 & this.data) !== t && (this.data ^= 2)
    }
    get culling() {
        return !!(4 & this.data)
    }
    set culling(t) {
        !!(4 & this.data) !== t && (this.data ^= 4)
    }
    get depthTest() {
        return !!(8 & this.data)
    }
    set depthTest(t) {
        !!(8 & this.data) !== t && (this.data ^= 8)
    }
    get depthMask() {
        return !!(32 & this.data)
    }
    set depthMask(t) {
        !!(32 & this.data) !== t && (this.data ^= 32)
    }
    get clockwiseFrontFace() {
        return !!(16 & this.data)
    }
    set clockwiseFrontFace(t) {
        !!(16 & this.data) !== t && (this.data ^= 16)
    }
    get blendMode() {
        return this._blendMode
    }
    set blendMode(t) {
        this.blend = t !== Om.NONE,
        this._blendMode = t
    }
    get polygonOffset() {
        return this._polygonOffset
    }
    set polygonOffset(t) {
        this.offsets = !!t,
        this._polygonOffset = t
    }
    toString() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
    }
    static for2d() {
        const t = new Xb;
        return t.depthTest = !1,
        t.blend = !0,
        t
    }
}
const qb = [];
function Kb(t, e) {
    if (!t)
        return null;
    let n = "";
    if ("string" == typeof t) {
        const e = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
        e && (n = e[1].toLowerCase())
    }
    for (let r = qb.length - 1; r >= 0; --r) {
        const i = qb[r];
        if (i.test && i.test(t, n))
            return new i(t,e)
    }
    throw new Error("Unrecognized source type to auto-detect Resource")
}
class Qb {
    constructor(t) {
        this.items = [],
        this._name = t,
        this._aliasCount = 0
    }
    emit(t, e, n, r, i, s, o, a) {
        if (arguments.length > 8)
            throw new Error("max arguments reached");
        const {name: l, items: c} = this;
        this._aliasCount++;
        for (let u = 0, h = c.length; u < h; u++)
            c[u][l](t, e, n, r, i, s, o, a);
        return c === this.items && this._aliasCount--,
        this
    }
    ensureNonAliasedItems() {
        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0,
        this.items = this.items.slice(0))
    }
    add(t) {
        return t[this._name] && (this.ensureNonAliasedItems(),
        this.remove(t),
        this.items.push(t)),
        this
    }
    remove(t) {
        const e = this.items.indexOf(t);
        return -1 !== e && (this.ensureNonAliasedItems(),
        this.items.splice(e, 1)),
        this
    }
    contains(t) {
        return this.items.includes(t)
    }
    removeAll() {
        return this.ensureNonAliasedItems(),
        this.items.length = 0,
        this
    }
    destroy() {
        this.removeAll(),
        this.items = null,
        this._name = null
    }
    get empty() {
        return 0 === this.items.length
    }
    get name() {
        return this._name
    }
}
Object.defineProperties(Qb.prototype, {
    dispatch: {
        value: Qb.prototype.emit
    },
    run: {
        value: Qb.prototype.emit
    }
});
class Zb {
    constructor(t=0, e=0) {
        this._width = t,
        this._height = e,
        this.destroyed = !1,
        this.internal = !1,
        this.onResize = new Qb("setRealSize"),
        this.onUpdate = new Qb("update"),
        this.onError = new Qb("onError")
    }
    bind(t) {
        this.onResize.add(t),
        this.onUpdate.add(t),
        this.onError.add(t),
        (this._width || this._height) && this.onResize.emit(this._width, this._height)
    }
    unbind(t) {
        this.onResize.remove(t),
        this.onUpdate.remove(t),
        this.onError.remove(t)
    }
    resize(t, e) {
        t === this._width && e === this._height || (this._width = t,
        this._height = e,
        this.onResize.emit(t, e))
    }
    get valid() {
        return !!this._width && !!this._height
    }
    update() {
        this.destroyed || this.onUpdate.emit()
    }
    load() {
        return Promise.resolve(this)
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    style(t, e, n) {
        return !1
    }
    dispose() {}
    destroy() {
        this.destroyed || (this.destroyed = !0,
        this.dispose(),
        this.onError.removeAll(),
        this.onError = null,
        this.onResize.removeAll(),
        this.onResize = null,
        this.onUpdate.removeAll(),
        this.onUpdate = null)
    }
    static test(t, e) {
        return !1
    }
}
class Jb extends Zb {
    constructor(t, e) {
        const {width: n, height: r} = e || {};
        if (!n || !r)
            throw new Error("BufferResource width or height invalid");
        super(n, r),
        this.data = t
    }
    upload(t, e, n) {
        const r = t.gl;
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === zm.UNPACK);
        const i = e.realWidth
          , s = e.realHeight;
        return n.width === i && n.height === s ? r.texSubImage2D(e.target, 0, 0, 0, i, s, e.format, n.type, this.data) : (n.width = i,
        n.height = s,
        r.texImage2D(e.target, 0, n.internalFormat, i, s, 0, e.format, n.type, this.data)),
        !0
    }
    dispose() {
        this.data = null
    }
    static test(t) {
        return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
    }
}
const tv = {
    scaleMode: Fm.NEAREST,
    format: Rm.RGBA,
    alphaMode: zm.NPM
}
  , ev = class extends (e(pg)) {
    constructor(t=null, e=null) {
        super(),
        e = Object.assign({}, ev.defaultOptions, e);
        const {alphaMode: n, mipmap: r, anisotropicLevel: i, scaleMode: s, width: o, height: a, wrapMode: l, format: c, type: u, target: h, resolution: d, resourceOptions: f} = e;
        !t || t instanceof Zb || ((t = Kb(t, f)).internal = !0),
        this.resolution = d || Xm.RESOLUTION,
        this.width = Math.round((o || 0) * this.resolution) / this.resolution,
        this.height = Math.round((a || 0) * this.resolution) / this.resolution,
        this._mipmap = r,
        this.anisotropicLevel = i,
        this._wrapMode = l,
        this._scaleMode = s,
        this.format = c,
        this.type = u,
        this.target = h,
        this.alphaMode = n,
        this.uid = _b(),
        this.touched = 0,
        this.isPowerOfTwo = !1,
        this._refreshPOT(),
        this._glTextures = {},
        this.dirtyId = 0,
        this.dirtyStyleId = 0,
        this.cacheId = null,
        this.valid = o > 0 && a > 0,
        this.textureCacheIds = [],
        this.destroyed = !1,
        this.resource = null,
        this._batchEnabled = 0,
        this._batchLocation = 0,
        this.parentTextureArray = null,
        this.setResource(t)
    }
    get realWidth() {
        return Math.round(this.width * this.resolution)
    }
    get realHeight() {
        return Math.round(this.height * this.resolution)
    }
    get mipmap() {
        return this._mipmap
    }
    set mipmap(t) {
        this._mipmap !== t && (this._mipmap = t,
        this.dirtyStyleId++)
    }
    get scaleMode() {
        return this._scaleMode
    }
    set scaleMode(t) {
        this._scaleMode !== t && (this._scaleMode = t,
        this.dirtyStyleId++)
    }
    get wrapMode() {
        return this._wrapMode
    }
    set wrapMode(t) {
        this._wrapMode !== t && (this._wrapMode = t,
        this.dirtyStyleId++)
    }
    setStyle(t, e) {
        let n;
        return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t,
        n = !0),
        void 0 !== e && e !== this.mipmap && (this.mipmap = e,
        n = !0),
        n && this.dirtyStyleId++,
        this
    }
    setSize(t, e, n) {
        return n = n || this.resolution,
        this.setRealSize(t * n, e * n, n)
    }
    setRealSize(t, e, n) {
        return this.resolution = n || this.resolution,
        this.width = Math.round(t) / this.resolution,
        this.height = Math.round(e) / this.resolution,
        this._refreshPOT(),
        this.update(),
        this
    }
    _refreshPOT() {
        this.isPowerOfTwo = bb(this.realWidth) && bb(this.realHeight)
    }
    setResolution(t) {
        const e = this.resolution;
        return e === t || (this.resolution = t,
        this.valid && (this.width = Math.round(this.width * e) / t,
        this.height = Math.round(this.height * e) / t,
        this.emit("update", this)),
        this._refreshPOT()),
        this
    }
    setResource(t) {
        if (this.resource === t)
            return this;
        if (this.resource)
            throw new Error("Resource can be set only once");
        return t.bind(this),
        this.resource = t,
        this
    }
    update() {
        this.valid ? (this.dirtyId++,
        this.dirtyStyleId++,
        this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0,
        this.emit("loaded", this),
        this.emit("update", this))
    }
    onError(t) {
        this.emit("error", this, t)
    }
    destroy() {
        this.resource && (this.resource.unbind(this),
        this.resource.internal && this.resource.destroy(),
        this.resource = null),
        this.cacheId && (delete Ib[this.cacheId],
        delete kb[this.cacheId],
        this.cacheId = null),
        this.dispose(),
        ev.removeFromCache(this),
        this.textureCacheIds = null,
        this.destroyed = !0
    }
    dispose() {
        this.emit("dispose", this)
    }
    castToBaseTexture() {
        return this
    }
    static from(t, e, n=Xm.STRICT_TEXTURE_CACHE) {
        const r = "string" == typeof t;
        let i = null;
        if (r)
            i = t;
        else {
            if (!t._pixiId) {
                const n = e?.pixiIdPrefix || "pixiid";
                t._pixiId = `${n}_${_b()}`
            }
            i = t._pixiId
        }
        let s = Ib[i];
        if (r && n && !s)
            throw new Error(`The cacheId "${i}" does not exist in BaseTextureCache.`);
        return s || (s = new ev(t,e),
        s.cacheId = i,
        ev.addToCache(s, i)),
        s
    }
    static fromBuffer(t, e, n, r) {
        t = t || new Float32Array(e * n * 4);
        const i = new Jb(t,{
            width: e,
            height: n
        })
          , s = t instanceof Float32Array ? Bm.FLOAT : Bm.UNSIGNED_BYTE;
        return new ev(i,Object.assign({}, tv, {
            type: s
        }, r))
    }
    static addToCache(t, e) {
        e && (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e),
        Ib[e] && Ib[e] !== t && console.warn(`BaseTexture added to the cache with an id [${e}] that already had an entry`),
        Ib[e] = t)
    }
    static removeFromCache(t) {
        if ("string" == typeof t) {
            const e = Ib[t];
            if (e) {
                const n = e.textureCacheIds.indexOf(t);
                return n > -1 && e.textureCacheIds.splice(n, 1),
                delete Ib[t],
                e
            }
        } else if (t?.textureCacheIds) {
            for (let e = 0; e < t.textureCacheIds.length; ++e)
                delete Ib[t.textureCacheIds[e]];
            return t.textureCacheIds.length = 0,
            t
        }
        return null
    }
}
;
let nv = ev;
nv.defaultOptions = {
    mipmap: Um.POW2,
    anisotropicLevel: 0,
    scaleMode: Fm.LINEAR,
    wrapMode: jm.CLAMP,
    alphaMode: zm.UNPACK,
    target: Dm.TEXTURE_2D,
    format: Rm.RGBA,
    type: Bm.UNSIGNED_BYTE
},
nv._globalBatch = 0;
class rv {
    constructor() {
        this.texArray = null,
        this.blend = 0,
        this.type = Nm.TRIANGLES,
        this.start = 0,
        this.size = 0,
        this.data = null
    }
}
let iv = 0;
class sv {
    constructor(t, e=!0, n=!1) {
        this.data = t || new Float32Array(1),
        this._glBuffers = {},
        this._updateID = 0,
        this.index = n,
        this.static = e,
        this.id = iv++,
        this.disposeRunner = new Qb("disposeBuffer")
    }
    update(t) {
        t instanceof Array && (t = new Float32Array(t)),
        this.data = t || this.data,
        this._updateID++
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
        this.data = null
    }
    set index(t) {
        this.type = t ? Gm.ELEMENT_ARRAY_BUFFER : Gm.ARRAY_BUFFER
    }
    get index() {
        return this.type === Gm.ELEMENT_ARRAY_BUFFER
    }
    static from(t) {
        return t instanceof Array && (t = new Float32Array(t)),
        new sv(t)
    }
}
class ov {
    constructor(t, e=0, n=!1, r=Bm.FLOAT, i, s, o, a=1) {
        this.buffer = t,
        this.size = e,
        this.normalized = n,
        this.type = r,
        this.stride = i,
        this.start = s,
        this.instance = o,
        this.divisor = a
    }
    destroy() {
        this.buffer = null
    }
    static from(t, e, n, r, i) {
        return new ov(t,e,n,r,i)
    }
}
const av = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array
};
function lv(t, e) {
    let n = 0
      , r = 0;
    const i = {};
    for (let i = 0; i < t.length; i++)
        r += e[i],
        n += t[i].length;
    const s = new ArrayBuffer(4 * n);
    let o = null
      , a = 0;
    for (let n = 0; n < t.length; n++) {
        const l = e[n]
          , c = t[n]
          , u = pb(c);
        i[u] || (i[u] = new av[u](s)),
        o = i[u];
        for (let t = 0; t < c.length; t++) {
            o[(t / l | 0) * r + a + t % l] = c[t]
        }
        a += l
    }
    return new Float32Array(s)
}
const cv = {
    5126: 4,
    5123: 2,
    5121: 1
};
let uv = 0;
const hv = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
    Uint16Array: Uint16Array
};
class dv {
    constructor(t=[], e={}) {
        this.buffers = t,
        this.indexBuffer = null,
        this.attributes = e,
        this.glVertexArrayObjects = {},
        this.id = uv++,
        this.instanced = !1,
        this.instanceCount = 1,
        this.disposeRunner = new Qb("disposeGeometry"),
        this.refCount = 0
    }
    addAttribute(t, e, n=0, r=!1, i, s, o, a=!1) {
        if (!e)
            throw new Error("You must pass a buffer when creating an attribute");
        e instanceof sv || (e instanceof Array && (e = new Float32Array(e)),
        e = new sv(e));
        const l = t.split("|");
        if (l.length > 1) {
            for (let t = 0; t < l.length; t++)
                this.addAttribute(l[t], e, n, r, i);
            return this
        }
        let c = this.buffers.indexOf(e);
        return -1 === c && (this.buffers.push(e),
        c = this.buffers.length - 1),
        this.attributes[t] = new ov(c,n,r,i,s,o,a),
        this.instanced = this.instanced || a,
        this
    }
    getAttribute(t) {
        return this.attributes[t]
    }
    getBuffer(t) {
        return this.buffers[this.getAttribute(t).buffer]
    }
    addIndex(t) {
        return t instanceof sv || (t instanceof Array && (t = new Uint16Array(t)),
        t = new sv(t)),
        t.type = Gm.ELEMENT_ARRAY_BUFFER,
        this.indexBuffer = t,
        this.buffers.includes(t) || this.buffers.push(t),
        this
    }
    getIndex() {
        return this.indexBuffer
    }
    interleave() {
        if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer)
            return this;
        const t = []
          , e = []
          , n = new sv;
        let r;
        for (r in this.attributes) {
            const n = this.attributes[r]
              , i = this.buffers[n.buffer];
            t.push(i.data),
            e.push(n.size * cv[n.type] / 4),
            n.buffer = 0
        }
        for (n.data = lv(t, e),
        r = 0; r < this.buffers.length; r++)
            this.buffers[r] !== this.indexBuffer && this.buffers[r].destroy();
        return this.buffers = [n],
        this.indexBuffer && this.buffers.push(this.indexBuffer),
        this
    }
    getSize() {
        for (const t in this.attributes) {
            const e = this.attributes[t];
            return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
        }
        return 0
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
        this.buffers = null,
        this.indexBuffer = null,
        this.attributes = null
    }
    clone() {
        const t = new dv;
        for (let e = 0; e < this.buffers.length; e++)
            t.buffers[e] = new sv(this.buffers[e].data.slice(0));
        for (const e in this.attributes) {
            const n = this.attributes[e];
            t.attributes[e] = new ov(n.buffer,n.size,n.normalized,n.type,n.stride,n.start,n.instance)
        }
        return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)],
        t.indexBuffer.type = Gm.ELEMENT_ARRAY_BUFFER),
        t
    }
    static merge(t) {
        const e = new dv
          , n = []
          , r = []
          , i = [];
        let s;
        for (let e = 0; e < t.length; e++) {
            s = t[e];
            for (let t = 0; t < s.buffers.length; t++)
                r[t] = r[t] || 0,
                r[t] += s.buffers[t].data.length,
                i[t] = 0
        }
        for (let t = 0; t < s.buffers.length; t++)
            n[t] = new (hv[pb(s.buffers[t].data)])(r[t]),
            e.buffers[t] = new sv(n[t]);
        for (let e = 0; e < t.length; e++) {
            s = t[e];
            for (let t = 0; t < s.buffers.length; t++)
                n[t].set(s.buffers[t].data, i[t]),
                i[t] += s.buffers[t].data.length
        }
        if (e.attributes = s.attributes,
        s.indexBuffer) {
            e.indexBuffer = e.buffers[s.buffers.indexOf(s.indexBuffer)],
            e.indexBuffer.type = Gm.ELEMENT_ARRAY_BUFFER;
            let n = 0
              , r = 0
              , i = 0
              , o = 0;
            for (let t = 0; t < s.buffers.length; t++)
                if (s.buffers[t] !== s.indexBuffer) {
                    o = t;
                    break
                }
            for (const t in s.attributes) {
                const e = s.attributes[t];
                (0 | e.buffer) === o && (r += e.size * cv[e.type] / 4)
            }
            for (let s = 0; s < t.length; s++) {
                const a = t[s].indexBuffer.data;
                for (let t = 0; t < a.length; t++)
                    e.indexBuffer.data[t + i] += n;
                n += t[s].buffers[o].data.length / r,
                i += a.length
            }
        }
        return e
    }
}
class fv extends dv {
    constructor(t=!1) {
        super(),
        this._buffer = new sv(null,t,!1),
        this._indexBuffer = new sv(null,t,!0),
        this.addAttribute("aVertexPosition", this._buffer, 2, !1, Bm.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, Bm.FLOAT).addAttribute("aColor", this._buffer, 4, !0, Bm.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, Bm.FLOAT).addIndex(this._indexBuffer)
    }
}
const pv = 2 * Math.PI
  , mv = 180 / Math.PI
  , gv = Math.PI / 180;
var yv = (t=>(t[t.POLY = 0] = "POLY",
t[t.RECT = 1] = "RECT",
t[t.CIRC = 2] = "CIRC",
t[t.ELIP = 3] = "ELIP",
t[t.RREC = 4] = "RREC",
t))(yv || {});
class bv {
    constructor(t=0, e=0) {
        this.x = 0,
        this.y = 0,
        this.x = t,
        this.y = e
    }
    clone() {
        return new bv(this.x,this.y)
    }
    copyFrom(t) {
        return this.set(t.x, t.y),
        this
    }
    copyTo(t) {
        return t.set(this.x, this.y),
        t
    }
    equals(t) {
        return t.x === this.x && t.y === this.y
    }
    set(t=0, e=t) {
        return this.x = t,
        this.y = e,
        this
    }
    toString() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`
    }
}
const vv = [new bv, new bv, new bv, new bv];
class wv {
    constructor(t=0, e=0, n=0, r=0) {
        this.x = Number(t),
        this.y = Number(e),
        this.width = Number(n),
        this.height = Number(r),
        this.type = yv.RECT
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    static get EMPTY() {
        return new wv(0,0,0,0)
    }
    clone() {
        return new wv(this.x,this.y,this.width,this.height)
    }
    copyFrom(t) {
        return this.x = t.x,
        this.y = t.y,
        this.width = t.width,
        this.height = t.height,
        this
    }
    copyTo(t) {
        return t.x = this.x,
        t.y = this.y,
        t.width = this.width,
        t.height = this.height,
        t
    }
    contains(t, e) {
        return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height)
    }
    intersects(t, e) {
        if (!e) {
            const e = this.x < t.x ? t.x : this.x;
            if ((this.right > t.right ? t.right : this.right) <= e)
                return !1;
            const n = this.y < t.y ? t.y : this.y;
            return (this.bottom > t.bottom ? t.bottom : this.bottom) > n
        }
        const n = this.left
          , r = this.right
          , i = this.top
          , s = this.bottom;
        if (r <= n || s <= i)
            return !1;
        const o = vv[0].set(t.left, t.top)
          , a = vv[1].set(t.left, t.bottom)
          , l = vv[2].set(t.right, t.top)
          , c = vv[3].set(t.right, t.bottom);
        if (l.x <= o.x || a.y <= o.y)
            return !1;
        const u = Math.sign(e.a * e.d - e.b * e.c);
        if (0 === u)
            return !1;
        if (e.apply(o, o),
        e.apply(a, a),
        e.apply(l, l),
        e.apply(c, c),
        Math.max(o.x, a.x, l.x, c.x) <= n || Math.min(o.x, a.x, l.x, c.x) >= r || Math.max(o.y, a.y, l.y, c.y) <= i || Math.min(o.y, a.y, l.y, c.y) >= s)
            return !1;
        const h = u * (a.y - o.y)
          , d = u * (o.x - a.x)
          , f = h * n + d * i
          , p = h * r + d * i
          , m = h * n + d * s
          , g = h * r + d * s;
        if (Math.max(f, p, m, g) <= h * o.x + d * o.y || Math.min(f, p, m, g) >= h * c.x + d * c.y)
            return !1;
        const y = u * (o.y - l.y)
          , b = u * (l.x - o.x)
          , v = y * n + b * i
          , w = y * r + b * i
          , x = y * n + b * s
          , E = y * r + b * s;
        return !(Math.max(v, w, x, E) <= y * o.x + b * o.y || Math.min(v, w, x, E) >= y * c.x + b * c.y)
    }
    pad(t=0, e=t) {
        return this.x -= t,
        this.y -= e,
        this.width += 2 * t,
        this.height += 2 * e,
        this
    }
    fit(t) {
        const e = Math.max(this.x, t.x)
          , n = Math.min(this.x + this.width, t.x + t.width)
          , r = Math.max(this.y, t.y)
          , i = Math.min(this.y + this.height, t.y + t.height);
        return this.x = e,
        this.width = Math.max(n - e, 0),
        this.y = r,
        this.height = Math.max(i - r, 0),
        this
    }
    ceil(t=1, e=.001) {
        const n = Math.ceil((this.x + this.width - e) * t) / t
          , r = Math.ceil((this.y + this.height - e) * t) / t;
        return this.x = Math.floor((this.x + e) * t) / t,
        this.y = Math.floor((this.y + e) * t) / t,
        this.width = n - this.x,
        this.height = r - this.y,
        this
    }
    enlarge(t) {
        const e = Math.min(this.x, t.x)
          , n = Math.max(this.x + this.width, t.x + t.width)
          , r = Math.min(this.y, t.y)
          , i = Math.max(this.y + this.height, t.y + t.height);
        return this.x = e,
        this.width = n - e,
        this.y = r,
        this.height = i - r,
        this
    }
    toString() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
class xv {
    constructor(t=0, e=0, n=0) {
        this.x = t,
        this.y = e,
        this.radius = n,
        this.type = yv.CIRC
    }
    clone() {
        return new xv(this.x,this.y,this.radius)
    }
    contains(t, e) {
        if (this.radius <= 0)
            return !1;
        const n = this.radius * this.radius;
        let r = this.x - t
          , i = this.y - e;
        return r *= r,
        i *= i,
        r + i <= n
    }
    getBounds() {
        return new wv(this.x - this.radius,this.y - this.radius,2 * this.radius,2 * this.radius)
    }
    toString() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
    }
}
class Ev {
    constructor(t=0, e=0, n=0, r=0) {
        this.x = t,
        this.y = e,
        this.width = n,
        this.height = r,
        this.type = yv.ELIP
    }
    clone() {
        return new Ev(this.x,this.y,this.width,this.height)
    }
    contains(t, e) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        let n = (t - this.x) / this.width
          , r = (e - this.y) / this.height;
        return n *= n,
        r *= r,
        n + r <= 1
    }
    getBounds() {
        return new wv(this.x - this.width,this.y - this.height,this.width,this.height)
    }
    toString() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
class _v {
    constructor(...t) {
        let e = Array.isArray(t[0]) ? t[0] : t;
        if ("number" != typeof e[0]) {
            const t = [];
            for (let n = 0, r = e.length; n < r; n++)
                t.push(e[n].x, e[n].y);
            e = t
        }
        this.points = e,
        this.type = yv.POLY,
        this.closeStroke = !0
    }
    clone() {
        const t = this.points.slice()
          , e = new _v(t);
        return e.closeStroke = this.closeStroke,
        e
    }
    contains(t, e) {
        let n = !1;
        const r = this.points.length / 2;
        for (let i = 0, s = r - 1; i < r; s = i++) {
            const r = this.points[2 * i]
              , o = this.points[2 * i + 1]
              , a = this.points[2 * s]
              , l = this.points[2 * s + 1];
            o > e != l > e && t < (e - o) / (l - o) * (a - r) + r && (n = !n)
        }
        return n
    }
    toString() {
        return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce(((t,e)=>`${t}, ${e}`), "")}]`
    }
}
class Av {
    constructor(t=0, e=0, n=0, r=0, i=20) {
        this.x = t,
        this.y = e,
        this.width = n,
        this.height = r,
        this.radius = i,
        this.type = yv.RREC
    }
    clone() {
        return new Av(this.x,this.y,this.width,this.height,this.radius)
    }
    contains(t, e) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
            const n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (e >= this.y + n && e <= this.y + this.height - n || t >= this.x + n && t <= this.x + this.width - n)
                return !0;
            let r = t - (this.x + n)
              , i = e - (this.y + n);
            const s = n * n;
            if (r * r + i * i <= s)
                return !0;
            if (r = t - (this.x + this.width - n),
            r * r + i * i <= s)
                return !0;
            if (i = e - (this.y + this.height - n),
            r * r + i * i <= s)
                return !0;
            if (r = t - (this.x + n),
            r * r + i * i <= s)
                return !0
        }
        return !1
    }
    toString() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
    }
}
class Sv {
    constructor(t=1, e=0, n=0, r=1, i=0, s=0) {
        this.array = null,
        this.a = t,
        this.b = e,
        this.c = n,
        this.d = r,
        this.tx = i,
        this.ty = s
    }
    fromArray(t) {
        this.a = t[0],
        this.b = t[1],
        this.c = t[3],
        this.d = t[4],
        this.tx = t[2],
        this.ty = t[5]
    }
    set(t, e, n, r, i, s) {
        return this.a = t,
        this.b = e,
        this.c = n,
        this.d = r,
        this.tx = i,
        this.ty = s,
        this
    }
    toArray(t, e) {
        this.array || (this.array = new Float32Array(9));
        const n = e || this.array;
        return t ? (n[0] = this.a,
        n[1] = this.b,
        n[2] = 0,
        n[3] = this.c,
        n[4] = this.d,
        n[5] = 0,
        n[6] = this.tx,
        n[7] = this.ty,
        n[8] = 1) : (n[0] = this.a,
        n[1] = this.c,
        n[2] = this.tx,
        n[3] = this.b,
        n[4] = this.d,
        n[5] = this.ty,
        n[6] = 0,
        n[7] = 0,
        n[8] = 1),
        n
    }
    apply(t, e) {
        e = e || new bv;
        const n = t.x
          , r = t.y;
        return e.x = this.a * n + this.c * r + this.tx,
        e.y = this.b * n + this.d * r + this.ty,
        e
    }
    applyInverse(t, e) {
        e = e || new bv;
        const n = 1 / (this.a * this.d + this.c * -this.b)
          , r = t.x
          , i = t.y;
        return e.x = this.d * n * r + -this.c * n * i + (this.ty * this.c - this.tx * this.d) * n,
        e.y = this.a * n * i + -this.b * n * r + (-this.ty * this.a + this.tx * this.b) * n,
        e
    }
    translate(t, e) {
        return this.tx += t,
        this.ty += e,
        this
    }
    scale(t, e) {
        return this.a *= t,
        this.d *= e,
        this.c *= t,
        this.b *= e,
        this.tx *= t,
        this.ty *= e,
        this
    }
    rotate(t) {
        const e = Math.cos(t)
          , n = Math.sin(t)
          , r = this.a
          , i = this.c
          , s = this.tx;
        return this.a = r * e - this.b * n,
        this.b = r * n + this.b * e,
        this.c = i * e - this.d * n,
        this.d = i * n + this.d * e,
        this.tx = s * e - this.ty * n,
        this.ty = s * n + this.ty * e,
        this
    }
    append(t) {
        const e = this.a
          , n = this.b
          , r = this.c
          , i = this.d;
        return this.a = t.a * e + t.b * r,
        this.b = t.a * n + t.b * i,
        this.c = t.c * e + t.d * r,
        this.d = t.c * n + t.d * i,
        this.tx = t.tx * e + t.ty * r + this.tx,
        this.ty = t.tx * n + t.ty * i + this.ty,
        this
    }
    setTransform(t, e, n, r, i, s, o, a, l) {
        return this.a = Math.cos(o + l) * i,
        this.b = Math.sin(o + l) * i,
        this.c = -Math.sin(o - a) * s,
        this.d = Math.cos(o - a) * s,
        this.tx = t - (n * this.a + r * this.c),
        this.ty = e - (n * this.b + r * this.d),
        this
    }
    prepend(t) {
        const e = this.tx;
        if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
            const e = this.a
              , n = this.c;
            this.a = e * t.a + this.b * t.c,
            this.b = e * t.b + this.b * t.d,
            this.c = n * t.a + this.d * t.c,
            this.d = n * t.b + this.d * t.d
        }
        return this.tx = e * t.a + this.ty * t.c + t.tx,
        this.ty = e * t.b + this.ty * t.d + t.ty,
        this
    }
    decompose(t) {
        const e = this.a
          , n = this.b
          , r = this.c
          , i = this.d
          , s = t.pivot
          , o = -Math.atan2(-r, i)
          , a = Math.atan2(n, e)
          , l = Math.abs(o + a);
        return l < 1e-5 || Math.abs(pv - l) < 1e-5 ? (t.rotation = a,
        t.skew.x = t.skew.y = 0) : (t.rotation = 0,
        t.skew.x = o,
        t.skew.y = a),
        t.scale.x = Math.sqrt(e * e + n * n),
        t.scale.y = Math.sqrt(r * r + i * i),
        t.position.x = this.tx + (s.x * e + s.y * r),
        t.position.y = this.ty + (s.x * n + s.y * i),
        t
    }
    invert() {
        const t = this.a
          , e = this.b
          , n = this.c
          , r = this.d
          , i = this.tx
          , s = t * r - e * n;
        return this.a = r / s,
        this.b = -e / s,
        this.c = -n / s,
        this.d = t / s,
        this.tx = (n * this.ty - r * i) / s,
        this.ty = -(t * this.ty - e * i) / s,
        this
    }
    identity() {
        return this.a = 1,
        this.b = 0,
        this.c = 0,
        this.d = 1,
        this.tx = 0,
        this.ty = 0,
        this
    }
    clone() {
        const t = new Sv;
        return t.a = this.a,
        t.b = this.b,
        t.c = this.c,
        t.d = this.d,
        t.tx = this.tx,
        t.ty = this.ty,
        t
    }
    copyTo(t) {
        return t.a = this.a,
        t.b = this.b,
        t.c = this.c,
        t.d = this.d,
        t.tx = this.tx,
        t.ty = this.ty,
        t
    }
    copyFrom(t) {
        return this.a = t.a,
        this.b = t.b,
        this.c = t.c,
        this.d = t.d,
        this.tx = t.tx,
        this.ty = t.ty,
        this
    }
    toString() {
        return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
    }
    static get IDENTITY() {
        return new Sv
    }
    static get TEMP_MATRIX() {
        return new Sv
    }
}
const Tv = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
  , kv = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
  , Iv = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
  , Mv = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
  , Cv = []
  , Pv = []
  , Ov = Math.sign;
!function() {
    for (let t = 0; t < 16; t++) {
        const e = [];
        Cv.push(e);
        for (let n = 0; n < 16; n++) {
            const r = Ov(Tv[t] * Tv[n] + Iv[t] * kv[n])
              , i = Ov(kv[t] * Tv[n] + Mv[t] * kv[n])
              , s = Ov(Tv[t] * Iv[n] + Iv[t] * Mv[n])
              , o = Ov(kv[t] * Iv[n] + Mv[t] * Mv[n]);
            for (let t = 0; t < 16; t++)
                if (Tv[t] === r && kv[t] === i && Iv[t] === s && Mv[t] === o) {
                    e.push(t);
                    break
                }
        }
    }
    for (let t = 0; t < 16; t++) {
        const e = new Sv;
        e.set(Tv[t], kv[t], Iv[t], Mv[t], 0, 0),
        Pv.push(e)
    }
}();
const Nv = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: t=>Tv[t],
    uY: t=>kv[t],
    vX: t=>Iv[t],
    vY: t=>Mv[t],
    inv: t=>8 & t ? 15 & t : 7 & -t,
    add: (t,e)=>Cv[t][e],
    sub: (t,e)=>Cv[t][Nv.inv(e)],
    rotate180: t=>4 ^ t,
    isVertical: t=>2 == (3 & t),
    byDirection: (t,e)=>2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? Nv.S : Nv.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? Nv.E : Nv.W : e > 0 ? t > 0 ? Nv.SE : Nv.SW : t > 0 ? Nv.NE : Nv.NW,
    matrixAppendRotationInv: (t,e,n=0,r=0)=>{
        const i = Pv[Nv.inv(e)];
        i.tx = n,
        i.ty = r,
        t.append(i)
    }
};
class Rv {
    constructor(t, e, n=0, r=0) {
        this._x = n,
        this._y = r,
        this.cb = t,
        this.scope = e
    }
    clone(t=this.cb, e=this.scope) {
        return new Rv(t,e,this._x,this._y)
    }
    set(t=0, e=t) {
        return this._x === t && this._y === e || (this._x = t,
        this._y = e,
        this.cb.call(this.scope)),
        this
    }
    copyFrom(t) {
        return this._x === t.x && this._y === t.y || (this._x = t.x,
        this._y = t.y,
        this.cb.call(this.scope)),
        this
    }
    copyTo(t) {
        return t.set(this._x, this._y),
        t
    }
    equals(t) {
        return t.x === this._x && t.y === this._y
    }
    toString() {
        return `[@pixi/math:ObservablePoint x=0 y=0 scope=${this.scope}]`
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x !== t && (this._x = t,
        this.cb.call(this.scope))
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y !== t && (this._y = t,
        this.cb.call(this.scope))
    }
}
const Dv = class {
    constructor() {
        this.worldTransform = new Sv,
        this.localTransform = new Sv,
        this.position = new Rv(this.onChange,this,0,0),
        this.scale = new Rv(this.onChange,this,1,1),
        this.pivot = new Rv(this.onChange,this,0,0),
        this.skew = new Rv(this.updateSkew,this,0,0),
        this._rotation = 0,
        this._cx = 1,
        this._sx = 0,
        this._cy = 0,
        this._sy = 1,
        this._localID = 0,
        this._currentLocalID = 0,
        this._worldID = 0,
        this._parentID = 0
    }
    onChange() {
        this._localID++
    }
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y),
        this._sx = Math.sin(this._rotation + this.skew.y),
        this._cy = -Math.sin(this._rotation - this.skew.x),
        this._sy = Math.cos(this._rotation - this.skew.x),
        this._localID++
    }
    toString() {
        return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
    }
    updateLocalTransform() {
        const t = this.localTransform;
        this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x,
        t.b = this._sx * this.scale.x,
        t.c = this._cy * this.scale.y,
        t.d = this._sy * this.scale.y,
        t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c),
        t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d),
        this._currentLocalID = this._localID,
        this._parentID = -1)
    }
    updateTransform(t) {
        const e = this.localTransform;
        if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x,
        e.b = this._sx * this.scale.x,
        e.c = this._cy * this.scale.y,
        e.d = this._sy * this.scale.y,
        e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c),
        e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d),
        this._currentLocalID = this._localID,
        this._parentID = -1),
        this._parentID !== t._worldID) {
            const n = t.worldTransform
              , r = this.worldTransform;
            r.a = e.a * n.a + e.b * n.c,
            r.b = e.a * n.b + e.b * n.d,
            r.c = e.c * n.a + e.d * n.c,
            r.d = e.c * n.b + e.d * n.d,
            r.tx = e.tx * n.a + e.ty * n.c + n.tx,
            r.ty = e.tx * n.b + e.ty * n.d + n.ty,
            this._parentID = t._worldID,
            this._worldID++
        }
    }
    setFromMatrix(t) {
        t.decompose(this),
        this._localID++
    }
    get rotation() {
        return this._rotation
    }
    set rotation(t) {
        this._rotation !== t && (this._rotation = t,
        this.updateSkew())
    }
}
;
let Bv = Dv;
Bv.IDENTITY = new Dv;
function Lv(t, e, n) {
    const r = t.createShader(e);
    return t.shaderSource(r, n),
    t.compileShader(r),
    r
}
function Fv(t) {
    const e = new Array(t);
    for (let t = 0; t < e.length; t++)
        e[t] = !1;
    return e
}
function jv(t, e) {
    switch (t) {
    case "float":
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
        return 0;
    case "vec2":
        return new Float32Array(2 * e);
    case "vec3":
        return new Float32Array(3 * e);
    case "vec4":
        return new Float32Array(4 * e);
    case "ivec2":
        return new Int32Array(2 * e);
    case "ivec3":
        return new Int32Array(3 * e);
    case "ivec4":
        return new Int32Array(4 * e);
    case "uvec2":
        return new Uint32Array(2 * e);
    case "uvec3":
        return new Uint32Array(3 * e);
    case "uvec4":
        return new Uint32Array(4 * e);
    case "bool":
        return !1;
    case "bvec2":
        return Fv(2 * e);
    case "bvec3":
        return Fv(3 * e);
    case "bvec4":
        return Fv(4 * e);
    case "mat2":
        return new Float32Array([1, 0, 0, 1]);
    case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    case "mat4":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
const Uv = [{
    test: t=>"float" === t.type && 1 === t.size && !t.isArray,
    code: t=>`\n            if(uv["${t}"] !== ud["${t}"].value)\n            {\n                ud["${t}"].value = uv["${t}"]\n                gl.uniform1f(ud["${t}"].location, uv["${t}"])\n            }\n            `
}, {
    test: (t,e)=>!("sampler2D" !== t.type && "samplerCube" !== t.type && "sampler2DArray" !== t.type || 1 !== t.size || t.isArray || null != e && void 0 === e.castToBaseTexture),
    code: t=>`t = syncData.textureCount++;\n\n            renderer.texture.bind(uv["${t}"], t);\n\n            if(ud["${t}"].value !== t)\n            {\n                ud["${t}"].value = t;\n                gl.uniform1i(ud["${t}"].location, t);\n; // eslint-disable-line max-len\n            }`
}, {
    test: (t,e)=>"mat3" === t.type && 1 === t.size && !t.isArray && void 0 !== e.a,
    code: t=>`\n            gl.uniformMatrix3fv(ud["${t}"].location, false, uv["${t}"].toArray(true));\n            `,
    codeUbo: t=>`\n                var ${t}_matrix = uv.${t}.toArray(true);\n\n                data[offset] = ${t}_matrix[0];\n                data[offset+1] = ${t}_matrix[1];\n                data[offset+2] = ${t}_matrix[2];\n        \n                data[offset + 4] = ${t}_matrix[3];\n                data[offset + 5] = ${t}_matrix[4];\n                data[offset + 6] = ${t}_matrix[5];\n        \n                data[offset + 8] = ${t}_matrix[6];\n                data[offset + 9] = ${t}_matrix[7];\n                data[offset + 10] = ${t}_matrix[8];\n            `
}, {
    test: (t,e)=>"vec2" === t.type && 1 === t.size && !t.isArray && void 0 !== e.x,
    code: t=>`\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["${t}"].location, v.x, v.y);\n                }`,
    codeUbo: t=>`\n                v = uv.${t};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `
}, {
    test: t=>"vec2" === t.type && 1 === t.size && !t.isArray,
    code: t=>`\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["${t}"].location, v[0], v[1]);\n                }\n            `
}, {
    test: (t,e)=>"vec4" === t.type && 1 === t.size && !t.isArray && void 0 !== e.width,
    code: t=>`\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["${t}"].location, v.x, v.y, v.width, v.height)\n                }`,
    codeUbo: t=>`\n                    v = uv.${t};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `
}, {
    test: (t,e)=>"vec4" === t.type && 1 === t.size && !t.isArray && void 0 !== e.red,
    code: t=>`\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n                    cv[3] = v.alpha;\n                    gl.uniform4f(ud["${t}"].location, v.red, v.green, v.blue, v.alpha)\n                }`,
    codeUbo: t=>`\n                    v = uv.${t};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                    data[offset+3] = v.alpha;\n                `
}, {
    test: (t,e)=>"vec3" === t.type && 1 === t.size && !t.isArray && void 0 !== e.red,
    code: t=>`\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n    \n                    gl.uniform3f(ud["${t}"].location, v.red, v.green, v.blue)\n                }`,
    codeUbo: t=>`\n                    v = uv.${t};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                `
}, {
    test: t=>"vec4" === t.type && 1 === t.size && !t.isArray,
    code: t=>`\n                cv = ud["${t}"].value;\n                v = uv["${t}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["${t}"].location, v[0], v[1], v[2], v[3])\n                }`
}]
  , zv = {
    float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
    vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
    vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
    vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
    int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
    ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
    ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
    ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
    uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
    uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
    uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
    uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
    bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
    bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
    bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
    bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
    samplerCube: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
    sampler2DArray: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }"
}
  , Vv = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)"
};
function Wv(t, e) {
    const n = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
    for (const r in t.uniforms) {
        const i = e[r];
        if (!i) {
            t.uniforms[r]?.group && (t.uniforms[r].ubo ? n.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${r}, '${r}');\n                    `) : n.push(`\n                        renderer.shader.syncUniformGroup(uv.${r}, syncData);\n                    `));
            continue
        }
        const s = t.uniforms[r];
        let o = !1;
        for (let t = 0; t < Uv.length; t++)
            if (Uv[t].test(i, s)) {
                n.push(Uv[t].code(r, s)),
                o = !0;
                break
            }
        if (!o) {
            const t = (1 !== i.size || i.isArray ? Vv : zv)[i.type].replace("location", `ud["${r}"].location`);
            n.push(`\n            cu = ud["${r}"];\n            cv = cu.value;\n            v = uv["${r}"];\n            ${t};`)
        }
    }
    return new Function("ud","uv","renderer","syncData",n.join("\n"))
}
const Yv = {};
let Hv, $v = Yv;
function Gv() {
    if ($v === Yv || $v?.isContextLost()) {
        const t = Xm.ADAPTER.createCanvas();
        let e;
        Xm.PREFER_ENV >= Mm.WEBGL2 && (e = t.getContext("webgl2", {})),
        e || (e = t.getContext("webgl", {}) || t.getContext("experimental-webgl", {}),
        e ? e.getExtension("WEBGL_draw_buffers") : e = null),
        $v = e
    }
    return $v
}
function Xv() {
    if (!Hv) {
        Hv = Ym.MEDIUM;
        const t = Gv();
        if (t && t.getShaderPrecisionFormat) {
            const e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
            Hv = e.precision ? Ym.HIGH : Ym.MEDIUM
        }
    }
    return Hv
}
function qv(t, e) {
    const n = t.getShaderSource(e).split("\n").map(((t,e)=>`${e}: ${t}`))
      , r = t.getShaderInfoLog(e)
      , i = r.split("\n")
      , s = {}
      , o = i.map((t=>parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1")))).filter((t=>!(!t || s[t]) && (s[t] = !0,
    !0)))
      , a = [""];
    o.forEach((t=>{
        n[t - 1] = `%c${n[t - 1]}%c`,
        a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    }
    ));
    const l = n.join("\n");
    a[0] = l,
    console.error(r),
    console.groupCollapsed("click to view full shader code"),
    console.warn(...a),
    console.groupEnd()
}
function Kv(t, e, n, r) {
    t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(n, t.COMPILE_STATUS) || qv(t, n),
    t.getShaderParameter(r, t.COMPILE_STATUS) || qv(t, r),
    console.error("PixiJS Error: Could not initialize shader."),
    "" !== t.getProgramInfoLog(e) && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(e)))
}
const Qv = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
};
function Zv(t) {
    return Qv[t]
}
let Jv = null;
const tw = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function ew(t, e) {
    if (!Jv) {
        const e = Object.keys(tw);
        Jv = {};
        for (let n = 0; n < e.length; ++n) {
            const r = e[n];
            Jv[t[r]] = tw[r]
        }
    }
    return Jv[e]
}
function nw(t, e, n) {
    if ("precision" !== t.substring(0, 9)) {
        let r = e;
        return e === Ym.HIGH && n !== Ym.HIGH && (r = Ym.MEDIUM),
        `precision ${r} float;\n${t}`
    }
    return n !== Ym.HIGH && "precision highp" === t.substring(0, 15) ? t.replace("precision highp", "precision mediump") : t
}
let rw;
function iw() {
    if ("boolean" == typeof rw)
        return rw;
    try {
        const t = new Function("param1","param2","param3","return param1[param2] === param3;");
        rw = !0 === t({
            a: "b"
        }, "a", "b")
    } catch (t) {
        rw = !1
    }
    return rw
}
let sw = 0;
const ow = {}
  , aw = class {
    constructor(t, e, n="pixi-shader", r={}) {
        this.extra = {},
        this.id = sw++,
        this.vertexSrc = t || aw.defaultVertexSrc,
        this.fragmentSrc = e || aw.defaultFragmentSrc,
        this.vertexSrc = this.vertexSrc.trim(),
        this.fragmentSrc = this.fragmentSrc.trim(),
        this.extra = r,
        "#version" !== this.vertexSrc.substring(0, 8) && (n = n.replace(/\s+/g, "-"),
        ow[n] ? (ow[n]++,
        n += `-${ow[n]}`) : ow[n] = 1,
        this.vertexSrc = `#define SHADER_NAME ${n}\n${this.vertexSrc}`,
        this.fragmentSrc = `#define SHADER_NAME ${n}\n${this.fragmentSrc}`,
        this.vertexSrc = nw(this.vertexSrc, aw.defaultVertexPrecision, Ym.HIGH),
        this.fragmentSrc = nw(this.fragmentSrc, aw.defaultFragmentPrecision, Xv())),
        this.glPrograms = {},
        this.syncUniforms = null
    }
    static get defaultVertexSrc() {
        return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"
    }
    static get defaultFragmentSrc() {
        return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"
    }
    static from(t, e, n) {
        const r = t + e;
        let i = Tb[r];
        return i || (Tb[r] = i = new aw(t,e,n)),
        i
    }
}
;
let lw = aw;
lw.defaultVertexPrecision = Ym.HIGH,
lw.defaultFragmentPrecision = dg.apple.device ? Ym.HIGH : Ym.MEDIUM;
let cw = 0;
class uw {
    constructor(t, e, n) {
        this.group = !0,
        this.syncUniforms = {},
        this.dirtyId = 0,
        this.id = cw++,
        this.static = !!e,
        this.ubo = !!n,
        t instanceof sv ? (this.buffer = t,
        this.buffer.type = Gm.UNIFORM_BUFFER,
        this.autoManage = !1,
        this.ubo = !0) : (this.uniforms = t,
        this.ubo && (this.buffer = new sv(new Float32Array(1)),
        this.buffer.type = Gm.UNIFORM_BUFFER,
        this.autoManage = !0))
    }
    update() {
        this.dirtyId++,
        !this.autoManage && this.buffer && this.buffer.update()
    }
    add(t, e, n) {
        if (this.ubo)
            throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
        this.uniforms[t] = new uw(e,n)
    }
    static from(t, e, n) {
        return new uw(t,e,n)
    }
    static uboFrom(t, e) {
        return new uw(t,e ?? !0,!0)
    }
}
class hw {
    constructor(t, e) {
        this.uniformBindCount = 0,
        this.program = t,
        this.uniformGroup = e ? e instanceof uw ? e : new uw(e) : new uw({}),
        this.disposeRunner = new Qb("disposeShader")
    }
    checkUniformExists(t, e) {
        if (e.uniforms[t])
            return !0;
        for (const n in e.uniforms) {
            const r = e.uniforms[n];
            if (r.group && this.checkUniformExists(t, r))
                return !0
        }
        return !1
    }
    destroy() {
        this.uniformGroup = null,
        this.disposeRunner.emit(this),
        this.disposeRunner.destroy()
    }
    get uniforms() {
        return this.uniformGroup.uniforms
    }
    static from(t, e, n) {
        const r = lw.from(t, e);
        return new hw(r,n)
    }
}
class dw {
    constructor(t, e) {
        if (this.vertexSrc = t,
        this.fragTemplate = e,
        this.programCache = {},
        this.defaultGroupCache = {},
        !e.includes("%count%"))
            throw new Error('Fragment template must contain "%count%".');
        if (!e.includes("%forloop%"))
            throw new Error('Fragment template must contain "%forloop%".')
    }
    generateShader(t) {
        if (!this.programCache[t]) {
            const e = new Int32Array(t);
            for (let n = 0; n < t; n++)
                e[n] = n;
            this.defaultGroupCache[t] = uw.from({
                uSamplers: e
            }, !0);
            let n = this.fragTemplate;
            n = n.replace(/%count%/gi, `${t}`),
            n = n.replace(/%forloop%/gi, this.generateSampleSrc(t)),
            this.programCache[t] = new lw(this.vertexSrc,n)
        }
        const e = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Sv,
            default: this.defaultGroupCache[t]
        };
        return new hw(this.programCache[t],e)
    }
    generateSampleSrc(t) {
        let e = "";
        e += "\n",
        e += "\n";
        for (let n = 0; n < t; n++)
            n > 0 && (e += "\nelse "),
            n < t - 1 && (e += `if(vTextureId < ${n}.5)`),
            e += "\n{",
            e += `\n\tcolor = texture2D(uSamplers[${n}], vTextureCoord);`,
            e += "\n}";
        return e += "\n",
        e += "\n",
        e
    }
}
class fw {
    constructor() {
        this.elements = [],
        this.ids = [],
        this.count = 0
    }
    clear() {
        for (let t = 0; t < this.count; t++)
            this.elements[t] = null;
        this.count = 0
    }
}
function pw(t) {
    let e = !0;
    const n = Xm.ADAPTER.getNavigator();
    if (dg.tablet || dg.phone) {
        if (dg.apple.device) {
            const t = n.userAgent.match(/OS (\d+)_(\d+)?/);
            if (t) {
                parseInt(t[1], 10) < 11 && (e = !1)
            }
        }
        if (dg.android.device) {
            const t = n.userAgent.match(/Android\s([0-9.]*)/);
            if (t) {
                parseInt(t[1], 10) < 7 && (e = !1)
            }
        }
    }
    return e ? t : 4
}
class mw {
    constructor(t) {
        this.renderer = t
    }
    flush() {}
    destroy() {
        this.renderer = null
    }
    start() {}
    stop() {
        this.flush()
    }
    render(t) {}
}
const gw = class extends mw {
    constructor(t) {
        super(t),
        this.setShaderGenerator(),
        this.geometryClass = fv,
        this.vertexSize = 6,
        this.state = Xb.for2d(),
        this.size = 4 * gw.defaultBatchSize,
        this._vertexCount = 0,
        this._indexCount = 0,
        this._bufferedElements = [],
        this._bufferedTextures = [],
        this._bufferSize = 0,
        this._shader = null,
        this._packedGeometries = [],
        this._packedGeometryPoolSize = 2,
        this._flushId = 0,
        this._aBuffers = {},
        this._iBuffers = {},
        this.maxTextures = 1,
        this.renderer.on("prerender", this.onPrerender, this),
        t.runners.contextChange.add(this),
        this._dcIndex = 0,
        this._aIndex = 0,
        this._iIndex = 0,
        this._attributeBuffer = null,
        this._indexBuffer = null,
        this._tempBoundTextures = []
    }
    static get defaultMaxTextures() {
        return this._defaultMaxTextures = this._defaultMaxTextures ?? pw(32),
        this._defaultMaxTextures
    }
    static set defaultMaxTextures(t) {
        this._defaultMaxTextures = t
    }
    static get canUploadSameBuffer() {
        return this._canUploadSameBuffer = this._canUploadSameBuffer ?? !dg.apple.device,
        this._canUploadSameBuffer
    }
    static set canUploadSameBuffer(t) {
        this._canUploadSameBuffer = t
    }
    get MAX_TEXTURES() {
        return xy("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"),
        this.maxTextures
    }
    static get defaultVertexSrc() {
        return "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n"
    }
    static get defaultFragmentTemplate() {
        return "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n"
    }
    setShaderGenerator({vertex: t=gw.defaultVertexSrc, fragment: e=gw.defaultFragmentTemplate}={}) {
        this.shaderGenerator = new dw(t,e)
    }
    contextChange() {
        const t = this.renderer.gl;
        Xm.PREFER_ENV === Mm.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), gw.defaultMaxTextures),
        this.maxTextures = Gb(this.maxTextures, t)),
        this._shader = this.shaderGenerator.generateShader(this.maxTextures);
        for (let t = 0; t < this._packedGeometryPoolSize; t++)
            this._packedGeometries[t] = new this.geometryClass;
        this.initFlushBuffers()
    }
    initFlushBuffers() {
        const {_drawCallPool: t, _textureArrayPool: e} = gw
          , n = this.size / 4
          , r = Math.floor(n / this.maxTextures) + 1;
        for (; t.length < n; )
            t.push(new rv);
        for (; e.length < r; )
            e.push(new fw);
        for (let t = 0; t < this.maxTextures; t++)
            this._tempBoundTextures[t] = null
    }
    onPrerender() {
        this._flushId = 0
    }
    render(t) {
        t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(),
        this._vertexCount += t.vertexData.length / 2,
        this._indexCount += t.indices.length,
        this._bufferedTextures[this._bufferSize] = t._texture.baseTexture,
        this._bufferedElements[this._bufferSize++] = t)
    }
    buildTexturesAndDrawCalls() {
        const {_bufferedTextures: t, maxTextures: e} = this
          , n = gw._textureArrayPool
          , r = this.renderer.batch
          , i = this._tempBoundTextures
          , s = this.renderer.textureGC.count;
        let o = ++nv._globalBatch
          , a = 0
          , l = n[0]
          , c = 0;
        r.copyBoundTextures(i, e);
        for (let u = 0; u < this._bufferSize; ++u) {
            const h = t[u];
            t[u] = null,
            h._batchEnabled !== o && (l.count >= e && (r.boundArray(l, i, o, e),
            this.buildDrawCalls(l, c, u),
            c = u,
            l = n[++a],
            ++o),
            h._batchEnabled = o,
            h.touched = s,
            l.elements[l.count++] = h)
        }
        l.count > 0 && (r.boundArray(l, i, o, e),
        this.buildDrawCalls(l, c, this._bufferSize),
        ++a,
        ++o);
        for (let t = 0; t < i.length; t++)
            i[t] = null;
        nv._globalBatch = o
    }
    buildDrawCalls(t, e, n) {
        const {_bufferedElements: r, _attributeBuffer: i, _indexBuffer: s, vertexSize: o} = this
          , a = gw._drawCallPool;
        let l = this._dcIndex
          , c = this._aIndex
          , u = this._iIndex
          , h = a[l];
        h.start = this._iIndex,
        h.texArray = t;
        for (let d = e; d < n; ++d) {
            const n = r[d]
              , f = n._texture.baseTexture
              , p = ab[f.alphaMode ? 1 : 0][n.blendMode];
            r[d] = null,
            e < d && h.blend !== p && (h.size = u - h.start,
            e = d,
            h = a[++l],
            h.texArray = t,
            h.start = u),
            this.packInterleavedGeometry(n, i, s, c, u),
            c += n.vertexData.length / 2 * o,
            u += n.indices.length,
            h.blend = p
        }
        e < n && (h.size = u - h.start,
        ++l),
        this._dcIndex = l,
        this._aIndex = c,
        this._iIndex = u
    }
    bindAndClearTexArray(t) {
        const e = this.renderer.texture;
        for (let n = 0; n < t.count; n++)
            e.bind(t.elements[n], t.ids[n]),
            t.elements[n] = null;
        t.count = 0
    }
    updateGeometry() {
        const {_packedGeometries: t, _attributeBuffer: e, _indexBuffer: n} = this;
        gw.canUploadSameBuffer ? (t[this._flushId]._buffer.update(e.rawBinaryData),
        t[this._flushId]._indexBuffer.update(n),
        this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++,
        t[this._flushId] = new this.geometryClass),
        t[this._flushId]._buffer.update(e.rawBinaryData),
        t[this._flushId]._indexBuffer.update(n),
        this.renderer.geometry.bind(t[this._flushId]),
        this.renderer.geometry.updateBuffers(),
        this._flushId++)
    }
    drawBatches() {
        const t = this._dcIndex
          , {gl: e, state: n} = this.renderer
          , r = gw._drawCallPool;
        let i = null;
        for (let s = 0; s < t; s++) {
            const {texArray: t, type: o, size: a, start: l, blend: c} = r[s];
            i !== t && (i = t,
            this.bindAndClearTexArray(t)),
            this.state.blendMode = c,
            n.set(this.state),
            e.drawElements(o, a, e.UNSIGNED_SHORT, 2 * l)
        }
    }
    flush() {
        0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount),
        this._indexBuffer = this.getIndexBuffer(this._indexCount),
        this._aIndex = 0,
        this._iIndex = 0,
        this._dcIndex = 0,
        this.buildTexturesAndDrawCalls(),
        this.updateGeometry(),
        this.drawBatches(),
        this._bufferSize = 0,
        this._vertexCount = 0,
        this._indexCount = 0)
    }
    start() {
        this.renderer.state.set(this.state),
        this.renderer.texture.ensureSamplerType(this.maxTextures),
        this.renderer.shader.bind(this._shader),
        gw.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
    }
    stop() {
        this.flush()
    }
    destroy() {
        for (let t = 0; t < this._packedGeometryPoolSize; t++)
            this._packedGeometries[t] && this._packedGeometries[t].destroy();
        this.renderer.off("prerender", this.onPrerender, this),
        this._aBuffers = null,
        this._iBuffers = null,
        this._packedGeometries = null,
        this._attributeBuffer = null,
        this._indexBuffer = null,
        this._shader && (this._shader.destroy(),
        this._shader = null),
        super.destroy()
    }
    getAttributeBuffer(t) {
        const e = yb(Math.ceil(t / 8))
          , n = vb(e)
          , r = 8 * e;
        this._aBuffers.length <= n && (this._iBuffers.length = n + 1);
        let i = this._aBuffers[r];
        return i || (this._aBuffers[r] = i = new Yb(r * this.vertexSize * 4)),
        i
    }
    getIndexBuffer(t) {
        const e = yb(Math.ceil(t / 12))
          , n = vb(e)
          , r = 12 * e;
        this._iBuffers.length <= n && (this._iBuffers.length = n + 1);
        let i = this._iBuffers[n];
        return i || (this._iBuffers[n] = i = new Uint16Array(r)),
        i
    }
    packInterleavedGeometry(t, e, n, r, i) {
        const {uint32View: s, float32View: o} = e
          , a = r / this.vertexSize
          , l = t.uvs
          , c = t.indices
          , u = t.vertexData
          , h = t._texture.baseTexture._batchLocation
          , d = Math.min(t.worldAlpha, 1)
          , f = nb.shared.setValue(t._tintRGB).toPremultiplied(d, t._texture.baseTexture.alphaMode > 0);
        for (let t = 0; t < u.length; t += 2)
            o[r++] = u[t],
            o[r++] = u[t + 1],
            o[r++] = l[t],
            o[r++] = l[t + 1],
            s[r++] = f,
            o[r++] = h;
        for (let t = 0; t < c.length; t++)
            n[i++] = a + c[t]
    }
}
;
let yw = gw;
yw.defaultBatchSize = 4096,
yw.extension = {
    name: "batch",
    type: Ub.RendererPlugin
},
yw._drawCallPool = [],
yw._textureArrayPool = [],
Wb.add(yw);
const bw = class extends hw {
    constructor(t, e, n) {
        super(lw.from(t || bw.defaultVertexSrc, e || bw.defaultFragmentSrc), n),
        this.padding = 0,
        this.resolution = bw.defaultResolution,
        this.multisample = bw.defaultMultisample,
        this.enabled = !0,
        this.autoFit = !0,
        this.state = new Xb
    }
    apply(t, e, n, r, i) {
        t.applyFilter(this, e, n, r)
    }
    get blendMode() {
        return this.state.blendMode
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._resolution = t
    }
    static get defaultVertexSrc() {
        return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"
    }
    static get defaultFragmentSrc() {
        return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"
    }
}
;
let vw = bw;
vw.defaultResolution = 1,
vw.defaultMultisample = $m.NONE;
class ww {
    constructor() {
        this.clearBeforeRender = !0,
        this._backgroundColor = new nb(0),
        this.alpha = 1
    }
    init(t) {
        this.clearBeforeRender = t.clearBeforeRender;
        const {backgroundColor: e, background: n, backgroundAlpha: r} = t
          , i = n ?? e;
        void 0 !== i && (this.color = i),
        this.alpha = r
    }
    get color() {
        return this._backgroundColor.value
    }
    set color(t) {
        this._backgroundColor.setValue(t)
    }
    get alpha() {
        return this._backgroundColor.alpha
    }
    set alpha(t) {
        this._backgroundColor.setAlpha(t)
    }
    get backgroundColor() {
        return this._backgroundColor
    }
    destroy() {}
}
ww.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: !0
},
ww.extension = {
    type: [Ub.RendererSystem, Ub.CanvasRendererSystem],
    name: "background"
},
Wb.add(ww);
class xw {
    constructor(t) {
        this.renderer = t,
        this.emptyRenderer = new mw(t),
        this.currentRenderer = this.emptyRenderer
    }
    setObjectRenderer(t) {
        this.currentRenderer !== t && (this.currentRenderer.stop(),
        this.currentRenderer = t,
        this.currentRenderer.start())
    }
    flush() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    reset() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    copyBoundTextures(t, e) {
        const {boundTextures: n} = this.renderer.texture;
        for (let r = e - 1; r >= 0; --r)
            t[r] = n[r] || null,
            t[r] && (t[r]._batchLocation = r)
    }
    boundArray(t, e, n, r) {
        const {elements: i, ids: s, count: o} = t;
        let a = 0;
        for (let t = 0; t < o; t++) {
            const o = i[t]
              , l = o._batchLocation;
            if (l >= 0 && l < r && e[l] === o)
                s[t] = l;
            else
                for (; a < r; ) {
                    const r = e[a];
                    if (!r || r._batchEnabled !== n || r._batchLocation !== a) {
                        s[t] = a,
                        o._batchLocation = a,
                        e[a] = o;
                        break
                    }
                    a++
                }
        }
    }
    destroy() {
        this.renderer = null
    }
}
xw.extension = {
    type: Ub.RendererSystem,
    name: "batch"
},
Wb.add(xw);
let Ew = 0;
class _w {
    constructor(t) {
        this.renderer = t,
        this.webGLVersion = 1,
        this.extensions = {},
        this.supports = {
            uint32Indices: !1
        },
        this.handleContextLost = this.handleContextLost.bind(this),
        this.handleContextRestored = this.handleContextRestored.bind(this)
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(t) {
        this.gl = t,
        this.renderer.gl = t,
        this.renderer.CONTEXT_UID = Ew++
    }
    init(t) {
        if (t.context)
            this.initFromContext(t.context);
        else {
            const e = this.renderer.background.alpha < 1
              , n = t.premultipliedAlpha;
            this.preserveDrawingBuffer = t.preserveDrawingBuffer,
            this.useContextAlpha = t.useContextAlpha,
            this.powerPreference = t.powerPreference,
            this.initFromOptions({
                alpha: e,
                premultipliedAlpha: n,
                antialias: t.antialias,
                stencil: !0,
                preserveDrawingBuffer: t.preserveDrawingBuffer,
                powerPreference: t.powerPreference
            })
        }
    }
    initFromContext(t) {
        this.gl = t,
        this.validateContext(t),
        this.renderer.gl = t,
        this.renderer.CONTEXT_UID = Ew++,
        this.renderer.runners.contextChange.emit(t);
        const e = this.renderer.view;
        void 0 !== e.addEventListener && (e.addEventListener("webglcontextlost", this.handleContextLost, !1),
        e.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
    }
    initFromOptions(t) {
        const e = this.createContext(this.renderer.view, t);
        this.initFromContext(e)
    }
    createContext(t, e) {
        let n;
        if (Xm.PREFER_ENV >= Mm.WEBGL2 && (n = t.getContext("webgl2", e)),
        n)
            this.webGLVersion = 2;
        else if (this.webGLVersion = 1,
        n = t.getContext("webgl", e) || t.getContext("experimental-webgl", e),
        !n)
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        return this.gl = n,
        this.getExtensions(),
        this.gl
    }
    getExtensions() {
        const {gl: t} = this
          , e = {
            loseContext: t.getExtension("WEBGL_lose_context"),
            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: t.getExtension("WEBGL_compressed_texture_etc"),
            etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: t.getExtension("WEBGL_compressed_texture_atc"),
            astc: t.getExtension("WEBGL_compressed_texture_astc")
        };
        1 === this.webGLVersion ? Object.assign(this.extensions, e, {
            drawBuffers: t.getExtension("WEBGL_draw_buffers"),
            depthTexture: t.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: t.getExtension("OES_element_index_uint"),
            floatTexture: t.getExtension("OES_texture_float"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            textureHalfFloat: t.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
        }) : 2 === this.webGLVersion && Object.assign(this.extensions, e, {
            colorBufferFloat: t.getExtension("EXT_color_buffer_float")
        })
    }
    handleContextLost(t) {
        t.preventDefault(),
        setTimeout((()=>{
            this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
        }
        ), 0)
    }
    handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        const t = this.renderer.view;
        this.renderer = null,
        void 0 !== t.removeEventListener && (t.removeEventListener("webglcontextlost", this.handleContextLost),
        t.removeEventListener("webglcontextrestored", this.handleContextRestored)),
        this.gl.useProgram(null),
        this.extensions.loseContext && this.extensions.loseContext.loseContext()
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
    }
    validateContext(t) {
        const e = t.getContextAttributes()
          , n = "WebGL2RenderingContext"in globalThis && t instanceof globalThis.WebGL2RenderingContext;
        n && (this.webGLVersion = 2),
        e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const r = n || !!t.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = r,
        r || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
    }
}
_w.defaultOptions = {
    context: null,
    antialias: !1,
    premultipliedAlpha: !0,
    preserveDrawingBuffer: !1,
    powerPreference: "default"
},
_w.extension = {
    type: Ub.RendererSystem,
    name: "context"
},
Wb.add(_w);
class Aw extends Jb {
    upload(t, e, n) {
        const r = t.gl;
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === zm.UNPACK);
        const i = e.realWidth
          , s = e.realHeight;
        return n.width === i && n.height === s ? r.texSubImage2D(e.target, 0, 0, 0, i, s, e.format, n.type, this.data) : (n.width = i,
        n.height = s,
        r.texImage2D(e.target, 0, n.internalFormat, i, s, 0, e.format, n.type, this.data)),
        !0
    }
}
class Sw {
    constructor(t, e) {
        this.width = Math.round(t || 100),
        this.height = Math.round(e || 100),
        this.stencil = !1,
        this.depth = !1,
        this.dirtyId = 0,
        this.dirtyFormat = 0,
        this.dirtySize = 0,
        this.depthTexture = null,
        this.colorTextures = [],
        this.glFramebuffers = {},
        this.disposeRunner = new Qb("disposeFramebuffer"),
        this.multisample = $m.NONE
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    addColorTexture(t=0, e) {
        return this.colorTextures[t] = e || new nv(null,{
            scaleMode: Fm.NEAREST,
            resolution: 1,
            mipmap: Um.OFF,
            width: this.width,
            height: this.height
        }),
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    addDepthTexture(t) {
        return this.depthTexture = t || new nv(new Aw(null,{
            width: this.width,
            height: this.height
        }),{
            scaleMode: Fm.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: Um.OFF,
            format: Rm.DEPTH_COMPONENT,
            type: Bm.UNSIGNED_SHORT
        }),
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    enableDepth() {
        return this.depth = !0,
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    enableStencil() {
        return this.stencil = !0,
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    resize(t, e) {
        if (t = Math.round(t),
        e = Math.round(e),
        t !== this.width || e !== this.height) {
            this.width = t,
            this.height = e,
            this.dirtyId++,
            this.dirtySize++;
            for (let n = 0; n < this.colorTextures.length; n++) {
                const r = this.colorTextures[n]
                  , i = r.resolution;
                r.setSize(t / i, e / i)
            }
            if (this.depthTexture) {
                const n = this.depthTexture.resolution;
                this.depthTexture.setSize(t / n, e / n)
            }
        }
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroyDepthTexture() {
        this.depthTexture && (this.depthTexture.destroy(),
        this.depthTexture = null,
        ++this.dirtyId,
        ++this.dirtyFormat)
    }
}
class Tw extends nv {
    constructor(t={}) {
        if ("number" == typeof t) {
            t = {
                width: arguments[0],
                height: arguments[1],
                scaleMode: arguments[2],
                resolution: arguments[3]
            }
        }
        t.width = t.width || 100,
        t.height = t.height || 100,
        t.multisample ?? (t.multisample = $m.NONE),
        super(null, t),
        this.mipmap = Um.OFF,
        this.valid = !0,
        this._clear = new nb([0, 0, 0, 0]),
        this.framebuffer = new Sw(this.realWidth,this.realHeight).addColorTexture(0, this),
        this.framebuffer.multisample = t.multisample,
        this.maskStack = [],
        this.filterStack = [{}]
    }
    set clearColor(t) {
        this._clear.setValue(t)
    }
    get clearColor() {
        return this._clear.value
    }
    get clear() {
        return this._clear
    }
    resize(t, e) {
        this.framebuffer.resize(t * this.resolution, e * this.resolution),
        this.setRealSize(this.framebuffer.width, this.framebuffer.height)
    }
    dispose() {
        this.framebuffer.dispose(),
        super.dispose()
    }
    destroy() {
        super.destroy(),
        this.framebuffer.destroyDepthTexture(),
        this.framebuffer = null
    }
}
class kw extends Zb {
    constructor(t) {
        const e = t;
        super(e.naturalWidth || e.videoWidth || e.width, e.naturalHeight || e.videoHeight || e.height),
        this.source = t,
        this.noSubImage = !1
    }
    static crossOrigin(t, e, n) {
        void 0 !== n || e.startsWith("data:") ? !1 !== n && (t.crossOrigin = "string" == typeof n ? n : "anonymous") : t.crossOrigin = Fb(e)
    }
    upload(t, e, n, r) {
        const i = t.gl
          , s = e.realWidth
          , o = e.realHeight;
        if (r = r || this.source,
        "undefined" != typeof HTMLImageElement && r instanceof HTMLImageElement) {
            if (!r.complete || 0 === r.naturalWidth)
                return !1
        } else if ("undefined" != typeof HTMLVideoElement && r instanceof HTMLVideoElement && r.readyState <= 1 && 0 === r.buffered.length)
            return !1;
        return i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === zm.UNPACK),
        this.noSubImage || e.target !== i.TEXTURE_2D || n.width !== s || n.height !== o ? (n.width = s,
        n.height = o,
        i.texImage2D(e.target, 0, n.internalFormat, e.format, n.type, r)) : i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, e.format, n.type, r),
        !0
    }
    update() {
        if (this.destroyed)
            return;
        const t = this.source
          , e = t.naturalWidth || t.videoWidth || t.width
          , n = t.naturalHeight || t.videoHeight || t.height;
        this.resize(e, n),
        super.update()
    }
    dispose() {
        this.source = null
    }
}
class Iw extends kw {
    constructor(t, e) {
        if (e = e || {},
        "string" == typeof t) {
            const n = new Image;
            kw.crossOrigin(n, t, e.crossorigin),
            n.src = t,
            t = n
        }
        super(t),
        !t.complete && this._width && this._height && (this._width = 0,
        this._height = 0),
        this.url = t.src,
        this._process = null,
        this.preserveBitmap = !1,
        this.createBitmap = (e.createBitmap ?? Xm.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap,
        this.alphaMode = "number" == typeof e.alphaMode ? e.alphaMode : null,
        this.bitmap = null,
        this._load = null,
        !1 !== e.autoLoad && this.load()
    }
    load(t) {
        return this._load || (void 0 !== t && (this.createBitmap = t),
        this._load = new Promise(((t,e)=>{
            const n = this.source;
            this.url = n.src;
            const r = ()=>{
                this.destroyed || (n.onload = null,
                n.onerror = null,
                this.resize(n.width, n.height),
                this._load = null,
                this.createBitmap ? t(this.process()) : t(this))
            }
            ;
            n.complete && n.src ? r() : (n.onload = r,
            n.onerror = t=>{
                e(t),
                this.onError.emit(t)
            }
            )
        }
        ))),
        this._load
    }
    process() {
        const t = this.source;
        if (null !== this._process)
            return this._process;
        if (null !== this.bitmap || !globalThis.createImageBitmap)
            return Promise.resolve(this);
        const e = globalThis.createImageBitmap
          , n = !t.crossOrigin || "anonymous" === t.crossOrigin;
        return this._process = fetch(t.src, {
            mode: n ? "cors" : "no-cors"
        }).then((t=>t.blob())).then((n=>e(n, 0, 0, t.width, t.height, {
            premultiplyAlpha: null === this.alphaMode || this.alphaMode === zm.UNPACK ? "premultiply" : "none"
        }))).then((t=>this.destroyed ? Promise.reject() : (this.bitmap = t,
        this.update(),
        this._process = null,
        Promise.resolve(this)))),
        this._process
    }
    upload(t, e, n) {
        if ("number" == typeof this.alphaMode && (e.alphaMode = this.alphaMode),
        !this.createBitmap)
            return super.upload(t, e, n);
        if (!this.bitmap && (this.process(),
        !this.bitmap))
            return !1;
        if (super.upload(t, e, n, this.bitmap),
        !this.preserveBitmap) {
            let t = !0;
            const r = e._glTextures;
            for (const i in r) {
                const s = r[i];
                if (s !== n && s.dirtyId !== e.dirtyId) {
                    t = !1;
                    break
                }
            }
            t && (this.bitmap.close && this.bitmap.close(),
            this.bitmap = null)
        }
        return !0
    }
    dispose() {
        this.source.onload = null,
        this.source.onerror = null,
        super.dispose(),
        this.bitmap && (this.bitmap.close(),
        this.bitmap = null),
        this._process = null,
        this._load = null
    }
    static test(t) {
        return "undefined" != typeof HTMLImageElement && ("string" == typeof t || t instanceof HTMLImageElement)
    }
}
class Mw {
    constructor() {
        this.x0 = 0,
        this.y0 = 0,
        this.x1 = 1,
        this.y1 = 0,
        this.x2 = 1,
        this.y2 = 1,
        this.x3 = 0,
        this.y3 = 1,
        this.uvsFloat32 = new Float32Array(8)
    }
    set(t, e, n) {
        const r = e.width
          , i = e.height;
        if (n) {
            const e = t.width / 2 / r
              , s = t.height / 2 / i
              , o = t.x / r + e
              , a = t.y / i + s;
            n = Nv.add(n, Nv.NW),
            this.x0 = o + e * Nv.uX(n),
            this.y0 = a + s * Nv.uY(n),
            n = Nv.add(n, 2),
            this.x1 = o + e * Nv.uX(n),
            this.y1 = a + s * Nv.uY(n),
            n = Nv.add(n, 2),
            this.x2 = o + e * Nv.uX(n),
            this.y2 = a + s * Nv.uY(n),
            n = Nv.add(n, 2),
            this.x3 = o + e * Nv.uX(n),
            this.y3 = a + s * Nv.uY(n)
        } else
            this.x0 = t.x / r,
            this.y0 = t.y / i,
            this.x1 = (t.x + t.width) / r,
            this.y1 = t.y / i,
            this.x2 = (t.x + t.width) / r,
            this.y2 = (t.y + t.height) / i,
            this.x3 = t.x / r,
            this.y3 = (t.y + t.height) / i;
        this.uvsFloat32[0] = this.x0,
        this.uvsFloat32[1] = this.y0,
        this.uvsFloat32[2] = this.x1,
        this.uvsFloat32[3] = this.y1,
        this.uvsFloat32[4] = this.x2,
        this.uvsFloat32[5] = this.y2,
        this.uvsFloat32[6] = this.x3,
        this.uvsFloat32[7] = this.y3
    }
    toString() {
        return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
    }
}
const Cw = new Mw;
function Pw(t) {
    t.destroy = function() {}
    ,
    t.on = function() {}
    ,
    t.once = function() {}
    ,
    t.emit = function() {}
}
class Ow extends (e(pg)) {
    constructor(t, e, n, r, i, s, o) {
        if (super(),
        this.noFrame = !1,
        e || (this.noFrame = !0,
        e = new wv(0,0,1,1)),
        t instanceof Ow && (t = t.baseTexture),
        this.baseTexture = t,
        this._frame = e,
        this.trim = r,
        this.valid = !1,
        this._uvs = Cw,
        this.uvMatrix = null,
        this.orig = n || e,
        this._rotate = Number(i || 0),
        !0 === i)
            this._rotate = 2;
        else if (this._rotate % 2 != 0)
            throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        this.defaultAnchor = s ? new bv(s.x,s.y) : new bv(0,0),
        this.defaultBorders = o,
        this._updateID = 0,
        this.textureCacheIds = [],
        t.valid ? this.noFrame ? t.valid && this.onBaseTextureUpdated(t) : this.frame = e : t.once("loaded", this.onBaseTextureUpdated, this),
        this.noFrame && t.on("update", this.onBaseTextureUpdated, this)
    }
    update() {
        this.baseTexture.resource && this.baseTexture.resource.update()
    }
    onBaseTextureUpdated(t) {
        if (this.noFrame) {
            if (!this.baseTexture.valid)
                return;
            this._frame.width = t.width,
            this._frame.height = t.height,
            this.valid = !0,
            this.updateUvs()
        } else
            this.frame = this._frame;
        this.emit("update", this)
    }
    destroy(t) {
        if (this.baseTexture) {
            if (t) {
                const {resource: t} = this.baseTexture;
                t?.url && kb[t.url] && Ow.removeFromCache(t.url),
                this.baseTexture.destroy()
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this),
            this.baseTexture.off("update", this.onBaseTextureUpdated, this),
            this.baseTexture = null
        }
        this._frame = null,
        this._uvs = null,
        this.trim = null,
        this.orig = null,
        this.valid = !1,
        Ow.removeFromCache(this),
        this.textureCacheIds = null
    }
    clone() {
        const t = this._frame.clone()
          , e = this._frame === this.orig ? t : this.orig.clone()
          , n = new Ow(this.baseTexture,!this.noFrame && t,e,this.trim?.clone(),this.rotate,this.defaultAnchor,this.defaultBorders);
        return this.noFrame && (n._frame = t),
        n
    }
    updateUvs() {
        this._uvs === Cw && (this._uvs = new Mw),
        this._uvs.set(this._frame, this.baseTexture, this.rotate),
        this._updateID++
    }
    static from(t, e={}, n=Xm.STRICT_TEXTURE_CACHE) {
        const r = "string" == typeof t;
        let i = null;
        if (r)
            i = t;
        else if (t instanceof nv) {
            if (!t.cacheId) {
                const n = e?.pixiIdPrefix || "pixiid";
                t.cacheId = `${n}-${_b()}`,
                nv.addToCache(t, t.cacheId)
            }
            i = t.cacheId
        } else {
            if (!t._pixiId) {
                const n = e?.pixiIdPrefix || "pixiid";
                t._pixiId = `${n}_${_b()}`
            }
            i = t._pixiId
        }
        let s = kb[i];
        if (r && n && !s)
            throw new Error(`The cacheId "${i}" does not exist in TextureCache.`);
        return s || t instanceof nv ? !s && t instanceof nv && (s = new Ow(t),
        Ow.addToCache(s, i)) : (e.resolution || (e.resolution = jb(t)),
        s = new Ow(new nv(t,e)),
        s.baseTexture.cacheId = i,
        nv.addToCache(s.baseTexture, i),
        Ow.addToCache(s, i)),
        s
    }
    static fromURL(t, e) {
        const n = Object.assign({
            autoLoad: !1
        }, e?.resourceOptions)
          , r = Ow.from(t, Object.assign({
            resourceOptions: n
        }, e), !1)
          , i = r.baseTexture.resource;
        return r.baseTexture.valid ? Promise.resolve(r) : i.load().then((()=>Promise.resolve(r)))
    }
    static fromBuffer(t, e, n, r) {
        return new Ow(nv.fromBuffer(t, e, n, r))
    }
    static fromLoader(t, e, n, r) {
        const i = new nv(t,Object.assign({
            scaleMode: nv.defaultOptions.scaleMode,
            resolution: jb(e)
        }, r))
          , {resource: s} = i;
        s instanceof Iw && (s.url = e);
        const o = new Ow(i);
        return n || (n = e),
        nv.addToCache(o.baseTexture, n),
        Ow.addToCache(o, n),
        n !== e && (nv.addToCache(o.baseTexture, e),
        Ow.addToCache(o, e)),
        o.baseTexture.valid ? Promise.resolve(o) : new Promise((t=>{
            o.baseTexture.once("loaded", (()=>t(o)))
        }
        ))
    }
    static addToCache(t, e) {
        e && (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e),
        kb[e] && kb[e] !== t && console.warn(`Texture added to the cache with an id [${e}] that already had an entry`),
        kb[e] = t)
    }
    static removeFromCache(t) {
        if ("string" == typeof t) {
            const e = kb[t];
            if (e) {
                const n = e.textureCacheIds.indexOf(t);
                return n > -1 && e.textureCacheIds.splice(n, 1),
                delete kb[t],
                e
            }
        } else if (t?.textureCacheIds) {
            for (let e = 0; e < t.textureCacheIds.length; ++e)
                kb[t.textureCacheIds[e]] === t && delete kb[t.textureCacheIds[e]];
            return t.textureCacheIds.length = 0,
            t
        }
        return null
    }
    get resolution() {
        return this.baseTexture.resolution
    }
    get frame() {
        return this._frame
    }
    set frame(t) {
        this._frame = t,
        this.noFrame = !1;
        const {x: e, y: n, width: r, height: i} = t
          , s = e + r > this.baseTexture.width
          , o = n + i > this.baseTexture.height;
        if (s || o) {
            const t = s && o ? "and" : "or"
              , a = `X: ${e} + ${r} = ${e + r} > ${this.baseTexture.width}`
              , l = `Y: ${n} + ${i} = ${n + i} > ${this.baseTexture.height}`;
            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${a} ${t} ${l}`)
        }
        this.valid = r && i && this.baseTexture.valid,
        this.trim || this.rotate || (this.orig = t),
        this.valid && this.updateUvs()
    }
    get rotate() {
        return this._rotate
    }
    set rotate(t) {
        this._rotate = t,
        this.valid && this.updateUvs()
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    castToBaseTexture() {
        return this.baseTexture
    }
    static get EMPTY() {
        return Ow._EMPTY || (Ow._EMPTY = new Ow(new nv),
        Pw(Ow._EMPTY),
        Pw(Ow._EMPTY.baseTexture)),
        Ow._EMPTY
    }
    static get WHITE() {
        if (!Ow._WHITE) {
            const t = Xm.ADAPTER.createCanvas(16, 16)
              , e = t.getContext("2d");
            t.width = 16,
            t.height = 16,
            e.fillStyle = "white",
            e.fillRect(0, 0, 16, 16),
            Ow._WHITE = new Ow(nv.from(t)),
            Pw(Ow._WHITE),
            Pw(Ow._WHITE.baseTexture)
        }
        return Ow._WHITE
    }
}
class Nw extends Ow {
    constructor(t, e) {
        super(t, e),
        this.valid = !0,
        this.filterFrame = null,
        this.filterPoolKey = null,
        this.updateUvs()
    }
    get framebuffer() {
        return this.baseTexture.framebuffer
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, e, n=!0) {
        const r = this.baseTexture.resolution
          , i = Math.round(t * r) / r
          , s = Math.round(e * r) / r;
        this.valid = i > 0 && s > 0,
        this._frame.width = this.orig.width = i,
        this._frame.height = this.orig.height = s,
        n && this.baseTexture.resize(i, s),
        this.updateUvs()
    }
    setResolution(t) {
        const {baseTexture: e} = this;
        e.resolution !== t && (e.setResolution(t),
        this.resize(e.width, e.height, !1))
    }
    static create(t) {
        return new Nw(new Tw(t))
    }
}
class Rw {
    constructor(t) {
        this.texturePool = {},
        this.textureOptions = t || {},
        this.enableFullScreen = !1,
        this._pixelsWidth = 0,
        this._pixelsHeight = 0
    }
    createTexture(t, e, n=$m.NONE) {
        const r = new Tw(Object.assign({
            width: t,
            height: e,
            resolution: 1,
            multisample: n
        }, this.textureOptions));
        return new Nw(r)
    }
    getOptimalTexture(t, e, n=1, r=$m.NONE) {
        let i;
        t = Math.ceil(t * n - 1e-6),
        e = Math.ceil(e * n - 1e-6),
        this.enableFullScreen && t === this._pixelsWidth && e === this._pixelsHeight ? i = r > 1 ? -r : -1 : (i = ((65535 & (t = yb(t))) << 16 | 65535 & (e = yb(e))) >>> 0,
        r > 1 && (i += 4294967296 * r)),
        this.texturePool[i] || (this.texturePool[i] = []);
        let s = this.texturePool[i].pop();
        return s || (s = this.createTexture(t, e, r)),
        s.filterPoolKey = i,
        s.setResolution(n),
        s
    }
    getFilterTexture(t, e, n) {
        const r = this.getOptimalTexture(t.width, t.height, e || t.resolution, n || $m.NONE);
        return r.filterFrame = t.filterFrame,
        r
    }
    returnTexture(t) {
        const e = t.filterPoolKey;
        t.filterFrame = null,
        this.texturePool[e].push(t)
    }
    returnFilterTexture(t) {
        this.returnTexture(t)
    }
    clear(t) {
        if (t = !1 !== t)
            for (const t in this.texturePool) {
                const e = this.texturePool[t];
                if (e)
                    for (let t = 0; t < e.length; t++)
                        e[t].destroy(!0)
            }
        this.texturePool = {}
    }
    setScreenSize(t) {
        if (t.width !== this._pixelsWidth || t.height !== this._pixelsHeight) {
            this.enableFullScreen = t.width > 0 && t.height > 0;
            for (const t in this.texturePool) {
                if (!(Number(t) < 0))
                    continue;
                const e = this.texturePool[t];
                if (e)
                    for (let t = 0; t < e.length; t++)
                        e[t].destroy(!0);
                this.texturePool[t] = []
            }
            this._pixelsWidth = t.width,
            this._pixelsHeight = t.height
        }
    }
}
Rw.SCREEN_KEY = -1;
class Dw extends dv {
    constructor() {
        super(),
        this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
    }
}
class Bw extends dv {
    constructor() {
        super(),
        this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]),
        this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        this.vertexBuffer = new sv(this.vertices),
        this.uvBuffer = new sv(this.uvs),
        this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
    }
    map(t, e) {
        let n = 0
          , r = 0;
        return this.uvs[0] = n,
        this.uvs[1] = r,
        this.uvs[2] = n + e.width / t.width,
        this.uvs[3] = r,
        this.uvs[4] = n + e.width / t.width,
        this.uvs[5] = r + e.height / t.height,
        this.uvs[6] = n,
        this.uvs[7] = r + e.height / t.height,
        n = e.x,
        r = e.y,
        this.vertices[0] = n,
        this.vertices[1] = r,
        this.vertices[2] = n + e.width,
        this.vertices[3] = r,
        this.vertices[4] = n + e.width,
        this.vertices[5] = r + e.height,
        this.vertices[6] = n,
        this.vertices[7] = r + e.height,
        this.invalidate(),
        this
    }
    invalidate() {
        return this.vertexBuffer._updateID++,
        this.uvBuffer._updateID++,
        this
    }
}
class Lw {
    constructor() {
        this.renderTexture = null,
        this.target = null,
        this.legacy = !1,
        this.resolution = 1,
        this.multisample = $m.NONE,
        this.sourceFrame = new wv,
        this.destinationFrame = new wv,
        this.bindingSourceFrame = new wv,
        this.bindingDestinationFrame = new wv,
        this.filters = [],
        this.transform = null
    }
    clear() {
        this.target = null,
        this.filters = null,
        this.renderTexture = null
    }
}
const Fw = [new bv, new bv, new bv, new bv]
  , jw = new Sv;
class Uw {
    constructor(t) {
        this.renderer = t,
        this.defaultFilterStack = [{}],
        this.texturePool = new Rw,
        this.statePool = [],
        this.quad = new Dw,
        this.quadUv = new Bw,
        this.tempRect = new wv,
        this.activeState = {},
        this.globalUniforms = new uw({
            outputFrame: new wv,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4)
        },!0),
        this.forceClear = !1,
        this.useMaxPadding = !1
    }
    init() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    push(t, e) {
        const n = this.renderer
          , r = this.defaultFilterStack
          , i = this.statePool.pop() || new Lw
          , s = this.renderer.renderTexture;
        let o = e[0].resolution
          , a = e[0].multisample
          , l = e[0].padding
          , c = e[0].autoFit
          , u = e[0].legacy ?? !0;
        for (let t = 1; t < e.length; t++) {
            const n = e[t];
            o = Math.min(o, n.resolution),
            a = Math.min(a, n.multisample),
            l = this.useMaxPadding ? Math.max(l, n.padding) : l + n.padding,
            c = c && n.autoFit,
            u = u || (n.legacy ?? !0)
        }
        1 === r.length && (this.defaultFilterStack[0].renderTexture = s.current),
        r.push(i),
        i.resolution = o,
        i.multisample = a,
        i.legacy = u,
        i.target = t,
        i.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
        i.sourceFrame.pad(l);
        const h = this.tempRect.copyFrom(s.sourceFrame);
        n.projection.transform && this.transformAABB(jw.copyFrom(n.projection.transform).invert(), h),
        c ? (i.sourceFrame.fit(h),
        (i.sourceFrame.width <= 0 || i.sourceFrame.height <= 0) && (i.sourceFrame.width = 0,
        i.sourceFrame.height = 0)) : i.sourceFrame.intersects(h) || (i.sourceFrame.width = 0,
        i.sourceFrame.height = 0),
        this.roundFrame(i.sourceFrame, s.current ? s.current.resolution : n.resolution, s.sourceFrame, s.destinationFrame, n.projection.transform),
        i.renderTexture = this.getOptimalFilterTexture(i.sourceFrame.width, i.sourceFrame.height, o, a),
        i.filters = e,
        i.destinationFrame.width = i.renderTexture.width,
        i.destinationFrame.height = i.renderTexture.height;
        const d = this.tempRect;
        d.x = 0,
        d.y = 0,
        d.width = i.sourceFrame.width,
        d.height = i.sourceFrame.height,
        i.renderTexture.filterFrame = i.sourceFrame,
        i.bindingSourceFrame.copyFrom(s.sourceFrame),
        i.bindingDestinationFrame.copyFrom(s.destinationFrame),
        i.transform = n.projection.transform,
        n.projection.transform = null,
        s.bind(i.renderTexture, i.sourceFrame, d),
        n.framebuffer.clear(0, 0, 0, 0)
    }
    pop() {
        const t = this.defaultFilterStack
          , e = t.pop()
          , n = e.filters;
        this.activeState = e;
        const r = this.globalUniforms.uniforms;
        r.outputFrame = e.sourceFrame,
        r.resolution = e.resolution;
        const i = r.inputSize
          , s = r.inputPixel
          , o = r.inputClamp;
        if (i[0] = e.destinationFrame.width,
        i[1] = e.destinationFrame.height,
        i[2] = 1 / i[0],
        i[3] = 1 / i[1],
        s[0] = Math.round(i[0] * e.resolution),
        s[1] = Math.round(i[1] * e.resolution),
        s[2] = 1 / s[0],
        s[3] = 1 / s[1],
        o[0] = .5 * s[2],
        o[1] = .5 * s[3],
        o[2] = e.sourceFrame.width * i[2] - .5 * s[2],
        o[3] = e.sourceFrame.height * i[3] - .5 * s[3],
        e.legacy) {
            const t = r.filterArea;
            t[0] = e.destinationFrame.width,
            t[1] = e.destinationFrame.height,
            t[2] = e.sourceFrame.x,
            t[3] = e.sourceFrame.y,
            r.filterClamp = r.inputClamp
        }
        this.globalUniforms.update();
        const a = t[t.length - 1];
        if (this.renderer.framebuffer.blit(),
        1 === n.length)
            n[0].apply(this, e.renderTexture, a.renderTexture, Vm.BLEND, e),
            this.returnFilterTexture(e.renderTexture);
        else {
            let t = e.renderTexture
              , r = this.getOptimalFilterTexture(t.width, t.height, e.resolution);
            r.filterFrame = t.filterFrame;
            let i = 0;
            for (i = 0; i < n.length - 1; ++i) {
                1 === i && e.multisample > 1 && (r = this.getOptimalFilterTexture(t.width, t.height, e.resolution),
                r.filterFrame = t.filterFrame),
                n[i].apply(this, t, r, Vm.CLEAR, e);
                const s = t;
                t = r,
                r = s
            }
            n[i].apply(this, t, a.renderTexture, Vm.BLEND, e),
            i > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture),
            this.returnFilterTexture(t),
            this.returnFilterTexture(r)
        }
        e.clear(),
        this.statePool.push(e)
    }
    bindAndClear(t, e=Vm.CLEAR) {
        const {renderTexture: n, state: r} = this.renderer;
        if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null,
        t?.filterFrame) {
            const e = this.tempRect;
            e.x = 0,
            e.y = 0,
            e.width = t.filterFrame.width,
            e.height = t.filterFrame.height,
            n.bind(t, t.filterFrame, e)
        } else
            t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        const i = 1 & r.stateId || this.forceClear;
        (e === Vm.CLEAR || e === Vm.BLIT && i) && this.renderer.framebuffer.clear(0, 0, 0, 0)
    }
    applyFilter(t, e, n, r) {
        const i = this.renderer;
        i.state.set(t.state),
        this.bindAndClear(n, r),
        t.uniforms.uSampler = e,
        t.uniforms.filterGlobals = this.globalUniforms,
        i.shader.bind(t),
        t.legacy = !!t.program.attributeData.aTextureCoord,
        t.legacy ? (this.quadUv.map(e._frame, e.filterFrame),
        i.geometry.bind(this.quadUv),
        i.geometry.draw(Nm.TRIANGLES)) : (i.geometry.bind(this.quad),
        i.geometry.draw(Nm.TRIANGLE_STRIP))
    }
    calculateSpriteMatrix(t, e) {
        const {sourceFrame: n, destinationFrame: r} = this.activeState
          , {orig: i} = e._texture
          , s = t.set(r.width, 0, 0, r.height, n.x, n.y)
          , o = e.worldTransform.copyTo(Sv.TEMP_MATRIX);
        return o.invert(),
        s.prepend(o),
        s.scale(1 / i.width, 1 / i.height),
        s.translate(e.anchor.x, e.anchor.y),
        s
    }
    destroy() {
        this.renderer = null,
        this.texturePool.clear(!1)
    }
    getOptimalFilterTexture(t, e, n=1, r=$m.NONE) {
        return this.texturePool.getOptimalTexture(t, e, n, r)
    }
    getFilterTexture(t, e, n) {
        if ("number" == typeof t) {
            const n = t;
            t = e,
            e = n
        }
        t = t || this.activeState.renderTexture;
        const r = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, n || $m.NONE);
        return r.filterFrame = t.filterFrame,
        r
    }
    returnFilterTexture(t) {
        this.texturePool.returnTexture(t)
    }
    emptyPool() {
        this.texturePool.clear(!0)
    }
    resize() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    transformAABB(t, e) {
        const n = Fw[0]
          , r = Fw[1]
          , i = Fw[2]
          , s = Fw[3];
        n.set(e.left, e.top),
        r.set(e.left, e.bottom),
        i.set(e.right, e.top),
        s.set(e.right, e.bottom),
        t.apply(n, n),
        t.apply(r, r),
        t.apply(i, i),
        t.apply(s, s);
        const o = Math.min(n.x, r.x, i.x, s.x)
          , a = Math.min(n.y, r.y, i.y, s.y)
          , l = Math.max(n.x, r.x, i.x, s.x)
          , c = Math.max(n.y, r.y, i.y, s.y);
        e.x = o,
        e.y = a,
        e.width = l - o,
        e.height = c - a
    }
    roundFrame(t, e, n, r, i) {
        if (!(t.width <= 0 || t.height <= 0 || n.width <= 0 || n.height <= 0)) {
            if (i) {
                const {a: t, b: e, c: n, d: r} = i;
                if ((Math.abs(e) > 1e-4 || Math.abs(n) > 1e-4) && (Math.abs(t) > 1e-4 || Math.abs(r) > 1e-4))
                    return
            }
            (i = i ? jw.copyFrom(i) : jw.identity()).translate(-n.x, -n.y).scale(r.width / n.width, r.height / n.height).translate(r.x, r.y),
            this.transformAABB(i, t),
            t.ceil(e),
            this.transformAABB(i.invert(), t)
        }
    }
}
Uw.extension = {
    type: Ub.RendererSystem,
    name: "filter"
},
Wb.add(Uw);
class zw {
    constructor(t) {
        this.framebuffer = t,
        this.stencil = null,
        this.dirtyId = -1,
        this.dirtyFormat = -1,
        this.dirtySize = -1,
        this.multisample = $m.NONE,
        this.msaaBuffer = null,
        this.blitFramebuffer = null,
        this.mipLevel = 0
    }
}
const Vw = new wv;
class Ww {
    constructor(t) {
        this.renderer = t,
        this.managedFramebuffers = [],
        this.unknownFramebuffer = new Sw(10,10),
        this.msaaSamples = null
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        this.current = this.unknownFramebuffer,
        this.viewport = new wv,
        this.hasMRT = !0,
        this.writeDepthTexture = !0,
        1 === this.renderer.context.webGLVersion) {
            let e = this.renderer.context.extensions.drawBuffers
              , n = this.renderer.context.extensions.depthTexture;
            Xm.PREFER_ENV === Mm.WEBGL_LEGACY && (e = null,
            n = null),
            e ? t.drawBuffers = t=>e.drawBuffersWEBGL(t) : (this.hasMRT = !1,
            t.drawBuffers = ()=>{}
            ),
            n || (this.writeDepthTexture = !1)
        } else
            this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
    }
    bind(t, e, n=0) {
        const {gl: r} = this;
        if (t) {
            const i = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
            this.current !== t && (this.current = t,
            r.bindFramebuffer(r.FRAMEBUFFER, i.framebuffer)),
            i.mipLevel !== n && (t.dirtyId++,
            t.dirtyFormat++,
            i.mipLevel = n),
            i.dirtyId !== t.dirtyId && (i.dirtyId = t.dirtyId,
            i.dirtyFormat !== t.dirtyFormat ? (i.dirtyFormat = t.dirtyFormat,
            i.dirtySize = t.dirtySize,
            this.updateFramebuffer(t, n)) : i.dirtySize !== t.dirtySize && (i.dirtySize = t.dirtySize,
            this.resizeFramebuffer(t)));
            for (let e = 0; e < t.colorTextures.length; e++) {
                const n = t.colorTextures[e];
                this.renderer.texture.unbind(n.parentTextureArray || n)
            }
            if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
            e) {
                const t = e.width >> n
                  , r = e.height >> n
                  , i = t / e.width;
                this.setViewport(e.x * i, e.y * i, t, r)
            } else {
                const e = t.width >> n
                  , r = t.height >> n;
                this.setViewport(0, 0, e, r)
            }
        } else
            this.current && (this.current = null,
            r.bindFramebuffer(r.FRAMEBUFFER, null)),
            e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
    }
    setViewport(t, e, n, r) {
        const i = this.viewport;
        t = Math.round(t),
        e = Math.round(e),
        n = Math.round(n),
        r = Math.round(r),
        i.width === n && i.height === r && i.x === t && i.y === e || (i.x = t,
        i.y = e,
        i.width = n,
        i.height = r,
        this.gl.viewport(t, e, n, r))
    }
    get size() {
        return this.current ? {
            x: 0,
            y: 0,
            width: this.current.width,
            height: this.current.height
        } : {
            x: 0,
            y: 0,
            width: this.renderer.width,
            height: this.renderer.height
        }
    }
    clear(t, e, n, r, i=Pm.COLOR | Pm.DEPTH) {
        const {gl: s} = this;
        s.clearColor(t, e, n, r),
        s.clear(i)
    }
    initFramebuffer(t) {
        const {gl: e} = this
          , n = new zw(e.createFramebuffer());
        return n.multisample = this.detectSamples(t.multisample),
        t.glFramebuffers[this.CONTEXT_UID] = n,
        this.managedFramebuffers.push(t),
        t.disposeRunner.add(this),
        n
    }
    resizeFramebuffer(t) {
        const {gl: e} = this
          , n = t.glFramebuffers[this.CONTEXT_UID];
        n.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, n.stencil),
        n.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, n.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
        const r = t.colorTextures;
        let i = r.length;
        e.drawBuffers || (i = Math.min(i, 1));
        for (let s = 0; s < i; s++) {
            const i = r[s]
              , o = i.parentTextureArray || i;
            this.renderer.texture.bind(o, 0),
            0 === s && n.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, n.msaaBuffer),
            e.renderbufferStorageMultisample(e.RENDERBUFFER, n.multisample, o._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height))
        }
        t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
    }
    updateFramebuffer(t, e) {
        const {gl: n} = this
          , r = t.glFramebuffers[this.CONTEXT_UID]
          , i = t.colorTextures;
        let s = i.length;
        n.drawBuffers || (s = Math.min(s, 1)),
        r.multisample > 1 && this.canMultisampleFramebuffer(t) ? r.msaaBuffer = r.msaaBuffer || n.createRenderbuffer() : r.msaaBuffer && (n.deleteRenderbuffer(r.msaaBuffer),
        r.msaaBuffer = null,
        r.blitFramebuffer && (r.blitFramebuffer.dispose(),
        r.blitFramebuffer = null));
        const o = [];
        for (let a = 0; a < s; a++) {
            const s = i[a]
              , l = s.parentTextureArray || s;
            this.renderer.texture.bind(l, 0),
            0 === a && r.msaaBuffer ? (n.bindRenderbuffer(n.RENDERBUFFER, r.msaaBuffer),
            n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, l._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, r.msaaBuffer)) : (n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + a, s.target, l._glTextures[this.CONTEXT_UID].texture, e),
            o.push(n.COLOR_ATTACHMENT0 + a))
        }
        if (o.length > 1 && n.drawBuffers(o),
        t.depthTexture) {
            if (this.writeDepthTexture) {
                const r = t.depthTexture;
                this.renderer.texture.bind(r, 0),
                n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, r._glTextures[this.CONTEXT_UID].texture, e)
            }
        }
        !t.stencil && !t.depth || t.depthTexture && this.writeDepthTexture ? r.stencil && (n.deleteRenderbuffer(r.stencil),
        r.stencil = null) : (r.stencil = r.stencil || n.createRenderbuffer(),
        n.bindRenderbuffer(n.RENDERBUFFER, r.stencil),
        r.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, n.DEPTH24_STENCIL8, t.width, t.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, t.width, t.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, r.stencil))
    }
    canMultisampleFramebuffer(t) {
        return 1 !== this.renderer.context.webGLVersion && t.colorTextures.length <= 1 && !t.depthTexture
    }
    detectSamples(t) {
        const {msaaSamples: e} = this;
        let n = $m.NONE;
        if (t <= 1 || null === e)
            return n;
        for (let r = 0; r < e.length; r++)
            if (e[r] <= t) {
                n = e[r];
                break
            }
        return 1 === n && (n = $m.NONE),
        n
    }
    blit(t, e, n) {
        const {current: r, renderer: i, gl: s, CONTEXT_UID: o} = this;
        if (2 !== i.context.webGLVersion)
            return;
        if (!r)
            return;
        const a = r.glFramebuffers[o];
        if (!a)
            return;
        if (!t) {
            if (!a.msaaBuffer)
                return;
            const e = r.colorTextures[0];
            if (!e)
                return;
            a.blitFramebuffer || (a.blitFramebuffer = new Sw(r.width,r.height),
            a.blitFramebuffer.addColorTexture(0, e)),
            (t = a.blitFramebuffer).colorTextures[0] !== e && (t.colorTextures[0] = e,
            t.dirtyId++,
            t.dirtyFormat++),
            t.width === r.width && t.height === r.height || (t.width = r.width,
            t.height = r.height,
            t.dirtyId++,
            t.dirtySize++)
        }
        e || ((e = Vw).width = r.width,
        e.height = r.height),
        n || (n = e);
        const l = e.width === n.width && e.height === n.height;
        this.bind(t),
        s.bindFramebuffer(s.READ_FRAMEBUFFER, a.framebuffer),
        s.blitFramebuffer(e.left, e.top, e.right, e.bottom, n.left, n.top, n.right, n.bottom, s.COLOR_BUFFER_BIT, l ? s.NEAREST : s.LINEAR),
        s.bindFramebuffer(s.READ_FRAMEBUFFER, t.glFramebuffers[this.CONTEXT_UID].framebuffer)
    }
    disposeFramebuffer(t, e) {
        const n = t.glFramebuffers[this.CONTEXT_UID]
          , r = this.gl;
        if (!n)
            return;
        delete t.glFramebuffers[this.CONTEXT_UID];
        const i = this.managedFramebuffers.indexOf(t);
        i >= 0 && this.managedFramebuffers.splice(i, 1),
        t.disposeRunner.remove(this),
        e || (r.deleteFramebuffer(n.framebuffer),
        n.msaaBuffer && r.deleteRenderbuffer(n.msaaBuffer),
        n.stencil && r.deleteRenderbuffer(n.stencil)),
        n.blitFramebuffer && this.disposeFramebuffer(n.blitFramebuffer, e)
    }
    disposeAll(t) {
        const e = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (let n = 0; n < e.length; n++)
            this.disposeFramebuffer(e[n], t)
    }
    forceStencil() {
        const t = this.current;
        if (!t)
            return;
        const e = t.glFramebuffers[this.CONTEXT_UID];
        if (!e || e.stencil)
            return;
        t.stencil = !0;
        const n = t.width
          , r = t.height
          , i = this.gl
          , s = i.createRenderbuffer();
        i.bindRenderbuffer(i.RENDERBUFFER, s),
        e.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, e.multisample, i.DEPTH24_STENCIL8, n, r) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, n, r),
        e.stencil = s,
        i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, s)
    }
    reset() {
        this.current = this.unknownFramebuffer,
        this.viewport = new wv
    }
    destroy() {
        this.renderer = null
    }
}
Ww.extension = {
    type: Ub.RendererSystem,
    name: "framebuffer"
},
Wb.add(Ww);
const Yw = {
    5126: 4,
    5123: 2,
    5121: 1
};
class Hw {
    constructor(t) {
        this.renderer = t,
        this._activeGeometry = null,
        this._activeVao = null,
        this.hasVao = !0,
        this.hasInstance = !0,
        this.canUseUInt32ElementIndex = !1,
        this.managedGeometries = {}
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl
          , e = this.renderer.context;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        2 !== e.webGLVersion) {
            let e = this.renderer.context.extensions.vertexArrayObject;
            Xm.PREFER_ENV === Mm.WEBGL_LEGACY && (e = null),
            e ? (t.createVertexArray = ()=>e.createVertexArrayOES(),
            t.bindVertexArray = t=>e.bindVertexArrayOES(t),
            t.deleteVertexArray = t=>e.deleteVertexArrayOES(t)) : (this.hasVao = !1,
            t.createVertexArray = ()=>null,
            t.bindVertexArray = ()=>null,
            t.deleteVertexArray = ()=>null)
        }
        if (2 !== e.webGLVersion) {
            const e = t.getExtension("ANGLE_instanced_arrays");
            e ? (t.vertexAttribDivisor = (t,n)=>e.vertexAttribDivisorANGLE(t, n),
            t.drawElementsInstanced = (t,n,r,i,s)=>e.drawElementsInstancedANGLE(t, n, r, i, s),
            t.drawArraysInstanced = (t,n,r,i)=>e.drawArraysInstancedANGLE(t, n, r, i)) : this.hasInstance = !1
        }
        this.canUseUInt32ElementIndex = 2 === e.webGLVersion || !!e.extensions.uint32ElementIndex
    }
    bind(t, e) {
        e = e || this.renderer.shader.shader;
        const {gl: n} = this;
        let r = t.glVertexArrayObjects[this.CONTEXT_UID]
          , i = !1;
        r || (this.managedGeometries[t.id] = t,
        t.disposeRunner.add(this),
        t.glVertexArrayObjects[this.CONTEXT_UID] = r = {},
        i = !0);
        const s = r[e.program.id] || this.initGeometryVao(t, e, i);
        this._activeGeometry = t,
        this._activeVao !== s && (this._activeVao = s,
        this.hasVao ? n.bindVertexArray(s) : this.activateVao(t, e.program)),
        this.updateBuffers()
    }
    reset() {
        this.unbind()
    }
    updateBuffers() {
        const t = this._activeGeometry
          , e = this.renderer.buffer;
        for (let n = 0; n < t.buffers.length; n++) {
            const r = t.buffers[n];
            e.update(r)
        }
    }
    checkCompatibility(t, e) {
        const n = t.attributes
          , r = e.attributeData;
        for (const t in r)
            if (!n[t])
                throw new Error(`shader and geometry incompatible, geometry missing the "${t}" attribute`)
    }
    getSignature(t, e) {
        const n = t.attributes
          , r = e.attributeData
          , i = ["g", t.id];
        for (const t in n)
            r[t] && i.push(t, r[t].location);
        return i.join("-")
    }
    initGeometryVao(t, e, n=!0) {
        const r = this.gl
          , i = this.CONTEXT_UID
          , s = this.renderer.buffer
          , o = e.program;
        o.glPrograms[i] || this.renderer.shader.generateProgram(e),
        this.checkCompatibility(t, o);
        const a = this.getSignature(t, o)
          , l = t.glVertexArrayObjects[this.CONTEXT_UID];
        let c = l[a];
        if (c)
            return l[o.id] = c,
            c;
        const u = t.buffers
          , h = t.attributes
          , d = {}
          , f = {};
        for (const t in u)
            d[t] = 0,
            f[t] = 0;
        for (const t in h)
            !h[t].size && o.attributeData[t] ? h[t].size = o.attributeData[t].size : h[t].size || console.warn(`PIXI Geometry attribute '${t}' size cannot be determined (likely the bound shader does not have the attribute)`),
            d[h[t].buffer] += h[t].size * Yw[h[t].type];
        for (const t in h) {
            const e = h[t]
              , n = e.size;
            void 0 === e.stride && (d[e.buffer] === n * Yw[e.type] ? e.stride = 0 : e.stride = d[e.buffer]),
            void 0 === e.start && (e.start = f[e.buffer],
            f[e.buffer] += n * Yw[e.type])
        }
        c = r.createVertexArray(),
        r.bindVertexArray(c);
        for (let t = 0; t < u.length; t++) {
            const e = u[t];
            s.bind(e),
            n && e._glBuffers[i].refCount++
        }
        return this.activateVao(t, o),
        l[o.id] = c,
        l[a] = c,
        r.bindVertexArray(null),
        s.unbind(Gm.ARRAY_BUFFER),
        c
    }
    disposeGeometry(t, e) {
        if (!this.managedGeometries[t.id])
            return;
        delete this.managedGeometries[t.id];
        const n = t.glVertexArrayObjects[this.CONTEXT_UID]
          , r = this.gl
          , i = t.buffers
          , s = this.renderer?.buffer;
        if (t.disposeRunner.remove(this),
        n) {
            if (s)
                for (let t = 0; t < i.length; t++) {
                    const n = i[t]._glBuffers[this.CONTEXT_UID];
                    n && (n.refCount--,
                    0 !== n.refCount || e || s.dispose(i[t], e))
                }
            if (!e)
                for (const t in n)
                    if ("g" === t[0]) {
                        const e = n[t];
                        this._activeVao === e && this.unbind(),
                        r.deleteVertexArray(e)
                    }
            delete t.glVertexArrayObjects[this.CONTEXT_UID]
        }
    }
    disposeAll(t) {
        const e = Object.keys(this.managedGeometries);
        for (let n = 0; n < e.length; n++)
            this.disposeGeometry(this.managedGeometries[e[n]], t)
    }
    activateVao(t, e) {
        const n = this.gl
          , r = this.CONTEXT_UID
          , i = this.renderer.buffer
          , s = t.buffers
          , o = t.attributes;
        t.indexBuffer && i.bind(t.indexBuffer);
        let a = null;
        for (const t in o) {
            const l = o[t]
              , c = s[l.buffer]
              , u = c._glBuffers[r];
            if (e.attributeData[t]) {
                a !== u && (i.bind(c),
                a = u);
                const r = e.attributeData[t].location;
                if (n.enableVertexAttribArray(r),
                n.vertexAttribPointer(r, l.size, l.type || n.FLOAT, l.normalized, l.stride, l.start),
                l.instance) {
                    if (!this.hasInstance)
                        throw new Error("geometry error, GPU Instancing is not supported on this device");
                    n.vertexAttribDivisor(r, l.divisor)
                }
            }
        }
    }
    draw(t, e, n, r) {
        const {gl: i} = this
          , s = this._activeGeometry;
        if (s.indexBuffer) {
            const o = s.indexBuffer.data.BYTES_PER_ELEMENT
              , a = 2 === o ? i.UNSIGNED_SHORT : i.UNSIGNED_INT;
            2 === o || 4 === o && this.canUseUInt32ElementIndex ? s.instanced ? i.drawElementsInstanced(t, e || s.indexBuffer.data.length, a, (n || 0) * o, r || 1) : i.drawElements(t, e || s.indexBuffer.data.length, a, (n || 0) * o) : console.warn("unsupported index buffer type: uint32")
        } else
            s.instanced ? i.drawArraysInstanced(t, n, e || s.getSize(), r || 1) : i.drawArrays(t, n, e || s.getSize());
        return this
    }
    unbind() {
        this.gl.bindVertexArray(null),
        this._activeVao = null,
        this._activeGeometry = null
    }
    destroy() {
        this.renderer = null
    }
}
Hw.extension = {
    type: Ub.RendererSystem,
    name: "geometry"
},
Wb.add(Hw);
const $w = new Sv;
class Gw {
    constructor(t, e) {
        this._texture = t,
        this.mapCoord = new Sv,
        this.uClampFrame = new Float32Array(4),
        this.uClampOffset = new Float32Array(2),
        this._textureID = -1,
        this._updateID = 0,
        this.clampOffset = 0,
        this.clampMargin = void 0 === e ? .5 : e,
        this.isSimple = !1
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture = t,
        this._textureID = -1
    }
    multiplyUvs(t, e) {
        void 0 === e && (e = t);
        const n = this.mapCoord;
        for (let r = 0; r < t.length; r += 2) {
            const i = t[r]
              , s = t[r + 1];
            e[r] = i * n.a + s * n.c + n.tx,
            e[r + 1] = i * n.b + s * n.d + n.ty
        }
        return e
    }
    update(t) {
        const e = this._texture;
        if (!e || !e.valid)
            return !1;
        if (!t && this._textureID === e._updateID)
            return !1;
        this._textureID = e._updateID,
        this._updateID++;
        const n = e._uvs;
        this.mapCoord.set(n.x1 - n.x0, n.y1 - n.y0, n.x3 - n.x0, n.y3 - n.y0, n.x0, n.y0);
        const r = e.orig
          , i = e.trim;
        i && ($w.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height),
        this.mapCoord.append($w));
        const s = e.baseTexture
          , o = this.uClampFrame
          , a = this.clampMargin / s.resolution
          , l = this.clampOffset;
        return o[0] = (e._frame.x + a + l) / s.width,
        o[1] = (e._frame.y + a + l) / s.height,
        o[2] = (e._frame.x + e._frame.width - a + l) / s.width,
        o[3] = (e._frame.y + e._frame.height - a + l) / s.height,
        this.uClampOffset[0] = l / s.realWidth,
        this.uClampOffset[1] = l / s.realHeight,
        this.isSimple = e._frame.width === s.width && e._frame.height === s.height && 0 === e.rotate,
        !0
    }
}
class Xw extends vw {
    constructor(t, e, n) {
        let r = null;
        "string" != typeof t && void 0 === e && void 0 === n && (r = t,
        t = void 0,
        e = void 0,
        n = void 0),
        super(t || "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", e || "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", n),
        this.maskSprite = r,
        this.maskMatrix = new Sv
    }
    get maskSprite() {
        return this._maskSprite
    }
    set maskSprite(t) {
        this._maskSprite = t,
        this._maskSprite && (this._maskSprite.renderable = !1)
    }
    apply(t, e, n, r) {
        const i = this._maskSprite
          , s = i._texture;
        s.valid && (s.uvMatrix || (s.uvMatrix = new Gw(s,0)),
        s.uvMatrix.update(),
        this.uniforms.npmAlpha = s.baseTexture.alphaMode ? 0 : 1,
        this.uniforms.mask = s,
        this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, i).prepend(s.uvMatrix.mapCoord),
        this.uniforms.alpha = i.worldAlpha,
        this.uniforms.maskClamp = s.uvMatrix.uClampFrame,
        t.applyFilter(this, e, n, r))
    }
}
class qw {
    constructor(t=null) {
        this.type = Hm.NONE,
        this.autoDetect = !0,
        this.maskObject = t || null,
        this.pooled = !1,
        this.isMaskData = !0,
        this.resolution = null,
        this.multisample = vw.defaultMultisample,
        this.enabled = !0,
        this.colorMask = 15,
        this._filters = null,
        this._stencilCounter = 0,
        this._scissorCounter = 0,
        this._scissorRect = null,
        this._scissorRectLocal = null,
        this._colorMask = 15,
        this._target = null
    }
    get filter() {
        return this._filters ? this._filters[0] : null
    }
    set filter(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
    }
    reset() {
        this.pooled && (this.maskObject = null,
        this.type = Hm.NONE,
        this.autoDetect = !0),
        this._target = null,
        this._scissorRectLocal = null
    }
    copyCountersOrReset(t) {
        t ? (this._stencilCounter = t._stencilCounter,
        this._scissorCounter = t._scissorCounter,
        this._scissorRect = t._scissorRect) : (this._stencilCounter = 0,
        this._scissorCounter = 0,
        this._scissorRect = null)
    }
}
class Kw {
    constructor(t) {
        this.renderer = t,
        this.enableScissor = !0,
        this.alphaMaskPool = [],
        this.maskDataPool = [],
        this.maskStack = [],
        this.alphaMaskIndex = 0
    }
    setMaskStack(t) {
        this.maskStack = t,
        this.renderer.scissor.setMaskStack(t),
        this.renderer.stencil.setMaskStack(t)
    }
    push(t, e) {
        let n = e;
        if (!n.isMaskData) {
            const t = this.maskDataPool.pop() || new qw;
            t.pooled = !0,
            t.maskObject = e,
            n = t
        }
        const r = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null;
        if (n.copyCountersOrReset(r),
        n._colorMask = r ? r._colorMask : 15,
        n.autoDetect && this.detect(n),
        n._target = t,
        n.type !== Hm.SPRITE && this.maskStack.push(n),
        n.enabled)
            switch (n.type) {
            case Hm.SCISSOR:
                this.renderer.scissor.push(n);
                break;
            case Hm.STENCIL:
                this.renderer.stencil.push(n);
                break;
            case Hm.SPRITE:
                n.copyCountersOrReset(null),
                this.pushSpriteMask(n);
                break;
            case Hm.COLOR:
                this.pushColorMask(n)
            }
        n.type === Hm.SPRITE && this.maskStack.push(n)
    }
    pop(t) {
        const e = this.maskStack.pop();
        if (e && e._target === t) {
            if (e.enabled)
                switch (e.type) {
                case Hm.SCISSOR:
                    this.renderer.scissor.pop(e);
                    break;
                case Hm.STENCIL:
                    this.renderer.stencil.pop(e.maskObject);
                    break;
                case Hm.SPRITE:
                    this.popSpriteMask(e);
                    break;
                case Hm.COLOR:
                    this.popColorMask(e)
                }
            if (e.reset(),
            e.pooled && this.maskDataPool.push(e),
            0 !== this.maskStack.length) {
                const t = this.maskStack[this.maskStack.length - 1];
                t.type === Hm.SPRITE && t._filters && (t._filters[0].maskSprite = t.maskObject)
            }
        }
    }
    detect(t) {
        const e = t.maskObject;
        e ? e.isSprite ? t.type = Hm.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = Hm.SCISSOR : t.type = Hm.STENCIL : t.type = Hm.COLOR
    }
    pushSpriteMask(t) {
        const {maskObject: e} = t
          , n = t._target;
        let r = t._filters;
        r || (r = this.alphaMaskPool[this.alphaMaskIndex],
        r || (r = this.alphaMaskPool[this.alphaMaskIndex] = [new Xw]));
        const i = this.renderer
          , s = i.renderTexture;
        let o, a;
        if (s.current) {
            const e = s.current;
            o = t.resolution || e.resolution,
            a = t.multisample ?? e.multisample
        } else
            o = t.resolution || i.resolution,
            a = t.multisample ?? i.multisample;
        r[0].resolution = o,
        r[0].multisample = a,
        r[0].maskSprite = e;
        const l = n.filterArea;
        n.filterArea = e.getBounds(!0),
        i.filter.push(n, r),
        n.filterArea = l,
        t._filters || this.alphaMaskIndex++
    }
    popSpriteMask(t) {
        this.renderer.filter.pop(),
        t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--,
        this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
    }
    pushColorMask(t) {
        const e = t._colorMask
          , n = t._colorMask = e & t.colorMask;
        n !== e && this.renderer.gl.colorMask(0 != (1 & n), 0 != (2 & n), 0 != (4 & n), 0 != (8 & n))
    }
    popColorMask(t) {
        const e = t._colorMask
          , n = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
        n !== e && this.renderer.gl.colorMask(0 != (1 & n), 0 != (2 & n), 0 != (4 & n), 0 != (8 & n))
    }
    destroy() {
        this.renderer = null
    }
}
Kw.extension = {
    type: Ub.RendererSystem,
    name: "mask"
},
Wb.add(Kw);
class Qw {
    constructor(t) {
        this.renderer = t,
        this.maskStack = [],
        this.glConst = 0
    }
    getStackLength() {
        return this.maskStack.length
    }
    setMaskStack(t) {
        const {gl: e} = this.renderer
          , n = this.getStackLength();
        this.maskStack = t;
        const r = this.getStackLength();
        r !== n && (0 === r ? e.disable(this.glConst) : (e.enable(this.glConst),
        this._useCurrent()))
    }
    _useCurrent() {}
    destroy() {
        this.renderer = null,
        this.maskStack = null
    }
}
const Zw = new Sv
  , Jw = []
  , tx = class extends Qw {
    constructor(t) {
        super(t),
        this.glConst = Xm.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._scissorCounter : 0
    }
    calcScissorRect(t) {
        if (t._scissorRectLocal)
            return;
        const e = t._scissorRect
          , {maskObject: n} = t
          , {renderer: r} = this
          , i = r.renderTexture
          , s = n.getBounds(!0, Jw.pop() ?? new wv);
        this.roundFrameToPixels(s, i.current ? i.current.resolution : r.resolution, i.sourceFrame, i.destinationFrame, r.projection.transform),
        e && s.fit(e),
        t._scissorRectLocal = s
    }
    static isMatrixRotated(t) {
        if (!t)
            return !1;
        const {a: e, b: n, c: r, d: i} = t;
        return (Math.abs(n) > 1e-4 || Math.abs(r) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(i) > 1e-4)
    }
    testScissor(t) {
        const {maskObject: e} = t;
        if (!e.isFastRect || !e.isFastRect())
            return !1;
        if (tx.isMatrixRotated(e.worldTransform))
            return !1;
        if (tx.isMatrixRotated(this.renderer.projection.transform))
            return !1;
        this.calcScissorRect(t);
        const n = t._scissorRectLocal;
        return n.width > 0 && n.height > 0
    }
    roundFrameToPixels(t, e, n, r, i) {
        tx.isMatrixRotated(i) || ((i = i ? Zw.copyFrom(i) : Zw.identity()).translate(-n.x, -n.y).scale(r.width / n.width, r.height / n.height).translate(r.x, r.y),
        this.renderer.filter.transformAABB(i, t),
        t.fit(r),
        t.x = Math.round(t.x * e),
        t.y = Math.round(t.y * e),
        t.width = Math.round(t.width * e),
        t.height = Math.round(t.height * e))
    }
    push(t) {
        t._scissorRectLocal || this.calcScissorRect(t);
        const {gl: e} = this.renderer;
        t._scissorRect || e.enable(e.SCISSOR_TEST),
        t._scissorCounter++,
        t._scissorRect = t._scissorRectLocal,
        this._useCurrent()
    }
    pop(t) {
        const {gl: e} = this.renderer;
        t && Jw.push(t._scissorRectLocal),
        this.getStackLength() > 0 ? this._useCurrent() : e.disable(e.SCISSOR_TEST)
    }
    _useCurrent() {
        const t = this.maskStack[this.maskStack.length - 1]._scissorRect;
        let e;
        e = this.renderer.renderTexture.current ? t.y : this.renderer.height - t.height - t.y,
        this.renderer.gl.scissor(t.x, e, t.width, t.height)
    }
}
;
let ex = tx;
ex.extension = {
    type: Ub.RendererSystem,
    name: "scissor"
},
Wb.add(ex);
class nx extends Qw {
    constructor(t) {
        super(t),
        this.glConst = Xm.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._stencilCounter : 0
    }
    push(t) {
        const e = t.maskObject
          , {gl: n} = this.renderer
          , r = t._stencilCounter;
        0 === r && (this.renderer.framebuffer.forceStencil(),
        n.clearStencil(0),
        n.clear(n.STENCIL_BUFFER_BIT),
        n.enable(n.STENCIL_TEST)),
        t._stencilCounter++;
        const i = t._colorMask;
        0 !== i && (t._colorMask = 0,
        n.colorMask(!1, !1, !1, !1)),
        n.stencilFunc(n.EQUAL, r, 4294967295),
        n.stencilOp(n.KEEP, n.KEEP, n.INCR),
        e.renderable = !0,
        e.render(this.renderer),
        this.renderer.batch.flush(),
        e.renderable = !1,
        0 !== i && (t._colorMask = i,
        n.colorMask(0 != (1 & i), 0 != (2 & i), 0 != (4 & i), 0 != (8 & i))),
        this._useCurrent()
    }
    pop(t) {
        const e = this.renderer.gl;
        if (0 === this.getStackLength())
            e.disable(e.STENCIL_TEST);
        else {
            const n = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null
              , r = n ? n._colorMask : 15;
            0 !== r && (n._colorMask = 0,
            e.colorMask(!1, !1, !1, !1)),
            e.stencilOp(e.KEEP, e.KEEP, e.DECR),
            t.renderable = !0,
            t.render(this.renderer),
            this.renderer.batch.flush(),
            t.renderable = !1,
            0 !== r && (n._colorMask = r,
            e.colorMask(0 != (1 & r), 0 != (2 & r), 0 != (4 & r), 0 != (8 & r))),
            this._useCurrent()
        }
    }
    _useCurrent() {
        const t = this.renderer.gl;
        t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
        t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
    }
}
nx.extension = {
    type: Ub.RendererSystem,
    name: "stencil"
},
Wb.add(nx);
class rx {
    constructor(t) {
        this.renderer = t,
        this.plugins = {},
        Object.defineProperties(this.plugins, {
            extract: {
                enumerable: !1,
                get: ()=>(xy("7.0.0", "renderer.plugins.extract has moved to renderer.extract"),
                t.extract)
            },
            prepare: {
                enumerable: !1,
                get: ()=>(xy("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"),
                t.prepare)
            },
            interaction: {
                enumerable: !1,
                get: ()=>(xy("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"),
                t.events)
            }
        })
    }
    init() {
        const t = this.rendererPlugins;
        for (const e in t)
            this.plugins[e] = new t[e](this.renderer)
    }
    destroy() {
        for (const t in this.plugins)
            this.plugins[t].destroy(),
            this.plugins[t] = null
    }
}
rx.extension = {
    type: [Ub.RendererSystem, Ub.CanvasRendererSystem],
    name: "_plugin"
},
Wb.add(rx);
class ix {
    constructor(t) {
        this.renderer = t,
        this.destinationFrame = null,
        this.sourceFrame = null,
        this.defaultFrame = null,
        this.projectionMatrix = new Sv,
        this.transform = null
    }
    update(t, e, n, r) {
        this.destinationFrame = t || this.destinationFrame || this.defaultFrame,
        this.sourceFrame = e || this.sourceFrame || t,
        this.calculateProjection(this.destinationFrame, this.sourceFrame, n, r),
        this.transform && this.projectionMatrix.append(this.transform);
        const i = this.renderer;
        i.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix,
        i.globalUniforms.update(),
        i.shader.shader && i.shader.syncUniformGroup(i.shader.shader.uniforms.globals)
    }
    calculateProjection(t, e, n, r) {
        const i = this.projectionMatrix
          , s = r ? -1 : 1;
        i.identity(),
        i.a = 1 / e.width * 2,
        i.d = s * (1 / e.height * 2),
        i.tx = -1 - e.x * i.a,
        i.ty = -s - e.y * i.d
    }
    setTransform(t) {}
    destroy() {
        this.renderer = null
    }
}
ix.extension = {
    type: Ub.RendererSystem,
    name: "projection"
},
Wb.add(ix);
const sx = new Bv;
class ox {
    constructor(t) {
        this.renderer = t,
        this._tempMatrix = new Sv
    }
    generateTexture(t, e) {
        const {region: n, ...r} = e || {}
          , i = n || t.getLocalBounds(null, !0);
        0 === i.width && (i.width = 1),
        0 === i.height && (i.height = 1);
        const s = Nw.create({
            width: i.width,
            height: i.height,
            ...r
        });
        this._tempMatrix.tx = -i.x,
        this._tempMatrix.ty = -i.y;
        const o = t.transform;
        return t.transform = sx,
        this.renderer.render(t, {
            renderTexture: s,
            transform: this._tempMatrix,
            skipUpdateTransform: !!t.parent,
            blit: !0
        }),
        t.transform = o,
        s
    }
    destroy() {}
}
ox.extension = {
    type: [Ub.RendererSystem, Ub.CanvasRendererSystem],
    name: "textureGenerator"
},
Wb.add(ox);
const ax = new wv
  , lx = new wv;
class cx {
    constructor(t) {
        this.renderer = t,
        this.defaultMaskStack = [],
        this.current = null,
        this.sourceFrame = new wv,
        this.destinationFrame = new wv,
        this.viewportFrame = new wv
    }
    contextChange() {
        const t = this.renderer?.gl.getContextAttributes();
        this._rendererPremultipliedAlpha = !!(t && t.alpha && t.premultipliedAlpha)
    }
    bind(t=null, e, n) {
        const r = this.renderer;
        let i, s, o;
        this.current = t,
        t ? (i = t.baseTexture,
        o = i.resolution,
        e || (ax.width = t.frame.width,
        ax.height = t.frame.height,
        e = ax),
        n || (lx.x = t.frame.x,
        lx.y = t.frame.y,
        lx.width = e.width,
        lx.height = e.height,
        n = lx),
        s = i.framebuffer) : (o = r.resolution,
        e || (ax.width = r._view.screen.width,
        ax.height = r._view.screen.height,
        e = ax),
        n || ((n = ax).width = e.width,
        n.height = e.height));
        const a = this.viewportFrame;
        a.x = n.x * o,
        a.y = n.y * o,
        a.width = n.width * o,
        a.height = n.height * o,
        t || (a.y = r.view.height - (a.y + a.height)),
        a.ceil(),
        this.renderer.framebuffer.bind(s, a),
        this.renderer.projection.update(n, e, o, !s),
        t ? this.renderer.mask.setMaskStack(i.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack),
        this.sourceFrame.copyFrom(e),
        this.destinationFrame.copyFrom(n)
    }
    clear(t, e) {
        const n = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor
          , r = nb.shared.setValue(t || n);
        (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && r.premultiply(r.alpha);
        const i = this.destinationFrame
          , s = this.current ? this.current.baseTexture : this.renderer._view.screen
          , o = i.width !== s.width || i.height !== s.height;
        if (o) {
            let {x: t, y: e, width: n, height: r} = this.viewportFrame;
            t = Math.round(t),
            e = Math.round(e),
            n = Math.round(n),
            r = Math.round(r),
            this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
            this.renderer.gl.scissor(t, e, n, r)
        }
        this.renderer.framebuffer.clear(r.red, r.green, r.blue, r.alpha, e),
        o && this.renderer.scissor.pop()
    }
    resize() {
        this.bind(null)
    }
    reset() {
        this.bind(null)
    }
    destroy() {
        this.renderer = null
    }
}
cx.extension = {
    type: Ub.RendererSystem,
    name: "renderTexture"
},
Wb.add(cx);
class ux {
    constructor(t, e) {
        this.program = t,
        this.uniformData = e,
        this.uniformGroups = {},
        this.uniformDirtyGroups = {},
        this.uniformBufferBindings = {}
    }
    destroy() {
        this.uniformData = null,
        this.uniformGroups = null,
        this.uniformDirtyGroups = null,
        this.uniformBufferBindings = null,
        this.program = null
    }
}
function hx(t, e) {
    const n = {}
      , r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < r; i++) {
        const r = e.getActiveAttrib(t, i);
        if (r.name.startsWith("gl_"))
            continue;
        const s = ew(e, r.type)
          , o = {
            type: s,
            name: r.name,
            size: Zv(s),
            location: e.getAttribLocation(t, r.name)
        };
        n[r.name] = o
    }
    return n
}
function dx(t, e) {
    const n = {}
      , r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; i++) {
        const r = e.getActiveUniform(t, i)
          , s = r.name.replace(/\[.*?\]$/, "")
          , o = !!r.name.match(/\[.*?\]$/)
          , a = ew(e, r.type);
        n[s] = {
            name: s,
            index: i,
            type: a,
            size: r.size,
            isArray: o,
            value: jv(a, r.size)
        }
    }
    return n
}
function fx(t, e) {
    const n = Lv(t, t.VERTEX_SHADER, e.vertexSrc)
      , r = Lv(t, t.FRAGMENT_SHADER, e.fragmentSrc)
      , i = t.createProgram();
    t.attachShader(i, n),
    t.attachShader(i, r);
    const s = e.extra?.transformFeedbackVaryings;
    if (s && ("function" != typeof t.transformFeedbackVaryings ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : t.transformFeedbackVaryings(i, s.names, "separate" === s.bufferMode ? t.SEPARATE_ATTRIBS : t.INTERLEAVED_ATTRIBS)),
    t.linkProgram(i),
    t.getProgramParameter(i, t.LINK_STATUS) || Kv(t, i, n, r),
    e.attributeData = hx(i, t),
    e.uniformData = dx(i, t),
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) {
        const n = Object.keys(e.attributeData);
        n.sort(((t,e)=>t > e ? 1 : -1));
        for (let r = 0; r < n.length; r++)
            e.attributeData[n[r]].location = r,
            t.bindAttribLocation(i, r, n[r]);
        t.linkProgram(i)
    }
    t.deleteShader(n),
    t.deleteShader(r);
    const o = {};
    for (const n in e.uniformData) {
        const r = e.uniformData[n];
        o[n] = {
            location: t.getUniformLocation(i, n),
            value: jv(r.type, r.size)
        }
    }
    return new ux(i,o)
}
function px(t, e, n, r, i) {
    n.buffer.update(i)
}
const mx = {
    float: "\n        data[offset] = v;\n    ",
    vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
    vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
    vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
    mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
    mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
    mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
}
  , gx = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 32,
    mat3: 48,
    mat4: 64
};
function yx(t, e) {
    if (!t.autoManage)
        return {
            size: 0,
            syncFunc: px
        };
    const n = function(t, e) {
        const n = [];
        for (const r in t)
            e[r] && n.push(e[r]);
        return n.sort(((t,e)=>t.index - e.index)),
        n
    }(t.uniforms, e)
      , {uboElements: r, size: i} = function(t) {
        const e = t.map((t=>({
            data: t,
            offset: 0,
            dataLen: 0,
            dirty: 0
        })));
        let n = 0
          , r = 0
          , i = 0;
        for (let t = 0; t < e.length; t++) {
            const s = e[t];
            if (n = gx[s.data.type],
            s.data.size > 1 && (n = Math.max(n, 16) * s.data.size),
            s.dataLen = n,
            r % n != 0 && r < 16) {
                const t = r % n % 16;
                r += t,
                i += t
            }
            r + n > 16 ? (i = 16 * Math.ceil(i / 16),
            s.offset = i,
            i += n,
            r = n) : (s.offset = i,
            r += n,
            i += n)
        }
        return i = 16 * Math.ceil(i / 16),
        {
            uboElements: e,
            size: i
        }
    }(n)
      , s = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
    for (let e = 0; e < r.length; e++) {
        const n = r[e]
          , i = t.uniforms[n.data.name]
          , o = n.data.name;
        let a = !1;
        for (let t = 0; t < Uv.length; t++) {
            const e = Uv[t];
            if (e.codeUbo && e.test(n.data, i)) {
                s.push(`offset = ${n.offset / 4};`, Uv[t].codeUbo(n.data.name, i)),
                a = !0;
                break
            }
        }
        if (!a)
            if (n.data.size > 1) {
                const t = Zv(n.data.type)
                  , e = Math.max(gx[n.data.type] / 16, 1)
                  , r = t / e
                  , i = (4 - r % 4) % 4;
                s.push(`\n                cv = ud.${o}.value;\n                v = uv.${o};\n                offset = ${n.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${n.data.size * e}; i++)\n                {\n                    for(var j = 0; j < ${r}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${i};\n                }\n\n                `)
            } else {
                const t = mx[n.data.type];
                s.push(`\n                cv = ud.${o}.value;\n                v = uv.${o};\n                offset = ${n.offset / 4};\n                ${t};\n                `)
            }
    }
    return s.push("\n       renderer.buffer.update(buffer);\n    "),
    {
        size: i,
        syncFunc: new Function("ud","uv","renderer","syncData","buffer",s.join("\n"))
    }
}
let bx = 0;
const vx = {
    textureCount: 0,
    uboCount: 0
};
class wx {
    constructor(t) {
        this.destroyed = !1,
        this.renderer = t,
        this.systemCheck(),
        this.gl = null,
        this.shader = null,
        this.program = null,
        this.cache = {},
        this._uboCache = {},
        this.id = bx++
    }
    systemCheck() {
        if (!iw())
            throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
    }
    contextChange(t) {
        this.gl = t,
        this.reset()
    }
    bind(t, e) {
        t.disposeRunner.add(this),
        t.uniforms.globals = this.renderer.globalUniforms;
        const n = t.program
          , r = n.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
        return this.shader = t,
        this.program !== n && (this.program = n,
        this.gl.useProgram(r.program)),
        e || (vx.textureCount = 0,
        vx.uboCount = 0,
        this.syncUniformGroup(t.uniformGroup, vx)),
        r
    }
    setUniforms(t) {
        const e = this.shader.program
          , n = e.glPrograms[this.renderer.CONTEXT_UID];
        e.syncUniforms(n.uniformData, t, this.renderer)
    }
    syncUniformGroup(t, e) {
        const n = this.getGlProgram();
        t.static && t.dirtyId === n.uniformDirtyGroups[t.id] || (n.uniformDirtyGroups[t.id] = t.dirtyId,
        this.syncUniforms(t, n, e))
    }
    syncUniforms(t, e, n) {
        (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, n)
    }
    createSyncGroups(t) {
        const e = this.getSignature(t, this.shader.program.uniformData, "u");
        return this.cache[e] || (this.cache[e] = Wv(t, this.shader.program.uniformData)),
        t.syncUniforms[this.shader.program.id] = this.cache[e],
        t.syncUniforms[this.shader.program.id]
    }
    syncUniformBufferGroup(t, e) {
        const n = this.getGlProgram();
        if (!t.static || 0 !== t.dirtyId || !n.uniformGroups[t.id]) {
            t.dirtyId = 0;
            const r = n.uniformGroups[t.id] || this.createSyncBufferGroup(t, n, e);
            t.buffer.update(),
            r(n.uniformData, t.uniforms, this.renderer, vx, t.buffer)
        }
        this.renderer.buffer.bindBufferBase(t.buffer, n.uniformBufferBindings[e])
    }
    createSyncBufferGroup(t, e, n) {
        const {gl: r} = this.renderer;
        this.renderer.buffer.bind(t.buffer);
        const i = this.gl.getUniformBlockIndex(e.program, n);
        e.uniformBufferBindings[n] = this.shader.uniformBindCount,
        r.uniformBlockBinding(e.program, i, this.shader.uniformBindCount),
        this.shader.uniformBindCount++;
        const s = this.getSignature(t, this.shader.program.uniformData, "ubo");
        let o = this._uboCache[s];
        if (o || (o = this._uboCache[s] = yx(t, this.shader.program.uniformData)),
        t.autoManage) {
            const e = new Float32Array(o.size / 4);
            t.buffer.update(e)
        }
        return e.uniformGroups[t.id] = o.syncFunc,
        e.uniformGroups[t.id]
    }
    getSignature(t, e, n) {
        const r = t.uniforms
          , i = [`${n}-`];
        for (const t in r)
            i.push(t),
            e[t] && i.push(e[t].type);
        return i.join("-")
    }
    getGlProgram() {
        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
    }
    generateProgram(t) {
        const e = this.gl
          , n = t.program
          , r = fx(e, n);
        return n.glPrograms[this.renderer.CONTEXT_UID] = r,
        r
    }
    reset() {
        this.program = null,
        this.shader = null
    }
    disposeShader(t) {
        this.shader === t && (this.shader = null)
    }
    destroy() {
        this.renderer = null,
        this.destroyed = !0
    }
}
wx.extension = {
    type: Ub.RendererSystem,
    name: "shader"
},
Wb.add(wx);
class xx {
    constructor(t) {
        this.renderer = t
    }
    run(t) {
        const {renderer: e} = this;
        e.runners.init.emit(e.options),
        t.hello && console.log(`PixiJS 7.2.4 - ${e.rendererLogId} - https://pixijs.com`),
        e.resize(e.screen.width, e.screen.height)
    }
    destroy() {}
}
function Ex(t, e=[]) {
    return e[Om.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.ADD] = [t.ONE, t.ONE],
    e[Om.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.NONE] = [0, 0],
    e[Om.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE],
    e[Om.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA],
    e[Om.SRC_IN] = [t.DST_ALPHA, t.ZERO],
    e[Om.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO],
    e[Om.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA],
    e[Om.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE],
    e[Om.DST_IN] = [t.ZERO, t.SRC_ALPHA],
    e[Om.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA],
    e[Om.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA],
    e[Om.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA],
    e[Om.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD],
    e
}
xx.defaultOptions = {
    hello: !1
},
xx.extension = {
    type: [Ub.RendererSystem, Ub.CanvasRendererSystem],
    name: "startup"
},
Wb.add(xx);
const _x = class {
    constructor() {
        this.gl = null,
        this.stateId = 0,
        this.polygonOffset = 0,
        this.blendMode = Om.NONE,
        this._blendEq = !1,
        this.map = [],
        this.map[0] = this.setBlend,
        this.map[1] = this.setOffset,
        this.map[2] = this.setCullFace,
        this.map[3] = this.setDepthTest,
        this.map[4] = this.setFrontFace,
        this.map[5] = this.setDepthMask,
        this.checks = [],
        this.defaultState = new Xb,
        this.defaultState.blend = !0
    }
    contextChange(t) {
        this.gl = t,
        this.blendModes = Ex(t),
        this.set(this.defaultState),
        this.reset()
    }
    set(t) {
        if (t = t || this.defaultState,
        this.stateId !== t.data) {
            let e = this.stateId ^ t.data
              , n = 0;
            for (; e; )
                1 & e && this.map[n].call(this, !!(t.data & 1 << n)),
                e >>= 1,
                n++;
            this.stateId = t.data
        }
        for (let e = 0; e < this.checks.length; e++)
            this.checks[e](this, t)
    }
    forceState(t) {
        t = t || this.defaultState;
        for (let e = 0; e < this.map.length; e++)
            this.map[e].call(this, !!(t.data & 1 << e));
        for (let e = 0; e < this.checks.length; e++)
            this.checks[e](this, t);
        this.stateId = t.data
    }
    setBlend(t) {
        this.updateCheck(_x.checkBlendMode, t),
        this.gl[t ? "enable" : "disable"](this.gl.BLEND)
    }
    setOffset(t) {
        this.updateCheck(_x.checkPolygonOffset, t),
        this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
    }
    setDepthTest(t) {
        this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
    }
    setDepthMask(t) {
        this.gl.depthMask(t)
    }
    setCullFace(t) {
        this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE)
    }
    setFrontFace(t) {
        this.gl.frontFace(this.gl[t ? "CW" : "CCW"])
    }
    setBlendMode(t) {
        if (t === this.blendMode)
            return;
        this.blendMode = t;
        const e = this.blendModes[t]
          , n = this.gl;
        2 === e.length ? n.blendFunc(e[0], e[1]) : n.blendFuncSeparate(e[0], e[1], e[2], e[3]),
        6 === e.length ? (this._blendEq = !0,
        n.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1,
        n.blendEquationSeparate(n.FUNC_ADD, n.FUNC_ADD))
    }
    setPolygonOffset(t, e) {
        this.gl.polygonOffset(t, e)
    }
    reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
        this.forceState(this.defaultState),
        this._blendEq = !0,
        this.blendMode = -1,
        this.setBlendMode(0)
    }
    updateCheck(t, e) {
        const n = this.checks.indexOf(t);
        e && -1 === n ? this.checks.push(t) : e || -1 === n || this.checks.splice(n, 1)
    }
    static checkBlendMode(t, e) {
        t.setBlendMode(e.blendMode)
    }
    static checkPolygonOffset(t, e) {
        t.setPolygonOffset(1, e.polygonOffset)
    }
    destroy() {
        this.gl = null
    }
}
;
let Ax = _x;
Ax.extension = {
    type: Ub.RendererSystem,
    name: "state"
},
Wb.add(Ax);
class Sx extends (e(pg)) {
    constructor() {
        super(...arguments),
        this.runners = {},
        this._systemsHash = {}
    }
    setup(t) {
        this.addRunners(...t.runners);
        const e = (t.priority ?? []).filter((e=>t.systems[e]))
          , n = [...e, ...Object.keys(t.systems).filter((t=>!e.includes(t)))];
        for (const e of n)
            this.addSystem(t.systems[e], e)
    }
    addRunners(...t) {
        t.forEach((t=>{
            this.runners[t] = new Qb(t)
        }
        ))
    }
    addSystem(t, e) {
        const n = new t(this);
        if (this[e])
            throw new Error(`Whoops! The name "${e}" is already in use`);
        this[e] = n,
        this._systemsHash[e] = n;
        for (const t in this.runners)
            this.runners[t].add(n);
        return this
    }
    emitWithCustomOptions(t, e) {
        const n = Object.keys(this._systemsHash);
        t.items.forEach((r=>{
            const i = n.find((t=>this._systemsHash[t] === r));
            r[t.name](e[i])
        }
        ))
    }
    destroy() {
        Object.values(this.runners).forEach((t=>{
            t.destroy()
        }
        )),
        this._systemsHash = {}
    }
}
const Tx = class {
    constructor(t) {
        this.renderer = t,
        this.count = 0,
        this.checkCount = 0,
        this.maxIdle = Tx.defaultMaxIdle,
        this.checkCountMax = Tx.defaultCheckCountMax,
        this.mode = Tx.defaultMode
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && (this.count++,
        this.mode !== Wm.MANUAL && (this.checkCount++,
        this.checkCount > this.checkCountMax && (this.checkCount = 0,
        this.run())))
    }
    run() {
        const t = this.renderer.texture
          , e = t.managedTextures;
        let n = !1;
        for (let r = 0; r < e.length; r++) {
            const i = e[r];
            !i.framebuffer && this.count - i.touched > this.maxIdle && (t.destroyTexture(i, !0),
            e[r] = null,
            n = !0)
        }
        if (n) {
            let t = 0;
            for (let n = 0; n < e.length; n++)
                null !== e[n] && (e[t++] = e[n]);
            e.length = t
        }
    }
    unload(t) {
        const e = this.renderer.texture
          , n = t._texture;
        n && !n.framebuffer && e.destroyTexture(n);
        for (let e = t.children.length - 1; e >= 0; e--)
            this.unload(t.children[e])
    }
    destroy() {
        this.renderer = null
    }
}
;
let kx = Tx;
kx.defaultMode = Wm.AUTO,
kx.defaultMaxIdle = 3600,
kx.defaultCheckCountMax = 600,
kx.extension = {
    type: Ub.RendererSystem,
    name: "textureGC"
},
Wb.add(kx);
class Ix {
    constructor(t) {
        this.texture = t,
        this.width = -1,
        this.height = -1,
        this.dirtyId = -1,
        this.dirtyStyleId = -1,
        this.mipmap = !1,
        this.wrapMode = 33071,
        this.type = Bm.UNSIGNED_BYTE,
        this.internalFormat = Rm.RGBA,
        this.samplerType = 0
    }
}
function Mx(t) {
    let e;
    return e = "WebGL2RenderingContext"in globalThis && t instanceof globalThis.WebGL2RenderingContext ? {
        [Bm.UNSIGNED_BYTE]: {
            [Rm.RGBA]: t.RGBA8,
            [Rm.RGB]: t.RGB8,
            [Rm.RG]: t.RG8,
            [Rm.RED]: t.R8,
            [Rm.RGBA_INTEGER]: t.RGBA8UI,
            [Rm.RGB_INTEGER]: t.RGB8UI,
            [Rm.RG_INTEGER]: t.RG8UI,
            [Rm.RED_INTEGER]: t.R8UI,
            [Rm.ALPHA]: t.ALPHA,
            [Rm.LUMINANCE]: t.LUMINANCE,
            [Rm.LUMINANCE_ALPHA]: t.LUMINANCE_ALPHA
        },
        [Bm.BYTE]: {
            [Rm.RGBA]: t.RGBA8_SNORM,
            [Rm.RGB]: t.RGB8_SNORM,
            [Rm.RG]: t.RG8_SNORM,
            [Rm.RED]: t.R8_SNORM,
            [Rm.RGBA_INTEGER]: t.RGBA8I,
            [Rm.RGB_INTEGER]: t.RGB8I,
            [Rm.RG_INTEGER]: t.RG8I,
            [Rm.RED_INTEGER]: t.R8I
        },
        [Bm.UNSIGNED_SHORT]: {
            [Rm.RGBA_INTEGER]: t.RGBA16UI,
            [Rm.RGB_INTEGER]: t.RGB16UI,
            [Rm.RG_INTEGER]: t.RG16UI,
            [Rm.RED_INTEGER]: t.R16UI,
            [Rm.DEPTH_COMPONENT]: t.DEPTH_COMPONENT16
        },
        [Bm.SHORT]: {
            [Rm.RGBA_INTEGER]: t.RGBA16I,
            [Rm.RGB_INTEGER]: t.RGB16I,
            [Rm.RG_INTEGER]: t.RG16I,
            [Rm.RED_INTEGER]: t.R16I
        },
        [Bm.UNSIGNED_INT]: {
            [Rm.RGBA_INTEGER]: t.RGBA32UI,
            [Rm.RGB_INTEGER]: t.RGB32UI,
            [Rm.RG_INTEGER]: t.RG32UI,
            [Rm.RED_INTEGER]: t.R32UI,
            [Rm.DEPTH_COMPONENT]: t.DEPTH_COMPONENT24
        },
        [Bm.INT]: {
            [Rm.RGBA_INTEGER]: t.RGBA32I,
            [Rm.RGB_INTEGER]: t.RGB32I,
            [Rm.RG_INTEGER]: t.RG32I,
            [Rm.RED_INTEGER]: t.R32I
        },
        [Bm.FLOAT]: {
            [Rm.RGBA]: t.RGBA32F,
            [Rm.RGB]: t.RGB32F,
            [Rm.RG]: t.RG32F,
            [Rm.RED]: t.R32F,
            [Rm.DEPTH_COMPONENT]: t.DEPTH_COMPONENT32F
        },
        [Bm.HALF_FLOAT]: {
            [Rm.RGBA]: t.RGBA16F,
            [Rm.RGB]: t.RGB16F,
            [Rm.RG]: t.RG16F,
            [Rm.RED]: t.R16F
        },
        [Bm.UNSIGNED_SHORT_5_6_5]: {
            [Rm.RGB]: t.RGB565
        },
        [Bm.UNSIGNED_SHORT_4_4_4_4]: {
            [Rm.RGBA]: t.RGBA4
        },
        [Bm.UNSIGNED_SHORT_5_5_5_1]: {
            [Rm.RGBA]: t.RGB5_A1
        },
        [Bm.UNSIGNED_INT_2_10_10_10_REV]: {
            [Rm.RGBA]: t.RGB10_A2,
            [Rm.RGBA_INTEGER]: t.RGB10_A2UI
        },
        [Bm.UNSIGNED_INT_10F_11F_11F_REV]: {
            [Rm.RGB]: t.R11F_G11F_B10F
        },
        [Bm.UNSIGNED_INT_5_9_9_9_REV]: {
            [Rm.RGB]: t.RGB9_E5
        },
        [Bm.UNSIGNED_INT_24_8]: {
            [Rm.DEPTH_STENCIL]: t.DEPTH24_STENCIL8
        },
        [Bm.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
            [Rm.DEPTH_STENCIL]: t.DEPTH32F_STENCIL8
        }
    } : {
        [Bm.UNSIGNED_BYTE]: {
            [Rm.RGBA]: t.RGBA,
            [Rm.RGB]: t.RGB,
            [Rm.ALPHA]: t.ALPHA,
            [Rm.LUMINANCE]: t.LUMINANCE,
            [Rm.LUMINANCE_ALPHA]: t.LUMINANCE_ALPHA
        },
        [Bm.UNSIGNED_SHORT_5_6_5]: {
            [Rm.RGB]: t.RGB
        },
        [Bm.UNSIGNED_SHORT_4_4_4_4]: {
            [Rm.RGBA]: t.RGBA
        },
        [Bm.UNSIGNED_SHORT_5_5_5_1]: {
            [Rm.RGBA]: t.RGBA
        }
    },
    e
}
class Cx {
    constructor(t) {
        this.renderer = t,
        this.boundTextures = [],
        this.currentLocation = -1,
        this.managedTextures = [],
        this._unknownBoundTextures = !1,
        this.unknownTexture = new nv,
        this.hasIntegerTextures = !1
    }
    contextChange() {
        const t = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        this.webGLVersion = this.renderer.context.webGLVersion,
        this.internalFormats = Mx(t);
        const e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = e;
        for (let t = 0; t < e; t++)
            this.boundTextures[t] = null;
        this.emptyTextures = {};
        const n = new Ix(t.createTexture());
        t.bindTexture(t.TEXTURE_2D, n.texture),
        t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)),
        this.emptyTextures[t.TEXTURE_2D] = n,
        this.emptyTextures[t.TEXTURE_CUBE_MAP] = new Ix(t.createTexture()),
        t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
        for (let e = 0; e < 6; e++)
            t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
        for (let t = 0; t < this.boundTextures.length; t++)
            this.bind(null, t)
    }
    bind(t, e=0) {
        const {gl: n} = this;
        if (t = t?.castToBaseTexture(),
        t?.valid && !t.parentTextureArray) {
            t.touched = this.renderer.textureGC.count;
            const r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
            this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e,
            n.activeTexture(n.TEXTURE0 + e)),
            n.bindTexture(t.target, r.texture)),
            r.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e,
            n.activeTexture(n.TEXTURE0 + e)),
            this.updateTexture(t)) : r.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t),
            this.boundTextures[e] = t
        } else
            this.currentLocation !== e && (this.currentLocation = e,
            n.activeTexture(n.TEXTURE0 + e)),
            n.bindTexture(n.TEXTURE_2D, this.emptyTextures[n.TEXTURE_2D].texture),
            this.boundTextures[e] = null
    }
    reset() {
        this._unknownBoundTextures = !0,
        this.hasIntegerTextures = !1,
        this.currentLocation = -1;
        for (let t = 0; t < this.boundTextures.length; t++)
            this.boundTextures[t] = this.unknownTexture
    }
    unbind(t) {
        const {gl: e, boundTextures: n} = this;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1;
            for (let t = 0; t < n.length; t++)
                n[t] === this.unknownTexture && this.bind(null, t)
        }
        for (let r = 0; r < n.length; r++)
            n[r] === t && (this.currentLocation !== r && (e.activeTexture(e.TEXTURE0 + r),
            this.currentLocation = r),
            e.bindTexture(t.target, this.emptyTextures[t.target].texture),
            n[r] = null)
    }
    ensureSamplerType(t) {
        const {boundTextures: e, hasIntegerTextures: n, CONTEXT_UID: r} = this;
        if (n)
            for (let n = t - 1; n >= 0; --n) {
                const t = e[n];
                if (t) {
                    t._glTextures[r].samplerType !== Lm.FLOAT && this.renderer.texture.unbind(t)
                }
            }
    }
    initTexture(t) {
        const e = new Ix(this.gl.createTexture());
        return e.dirtyId = -1,
        t._glTextures[this.CONTEXT_UID] = e,
        this.managedTextures.push(t),
        t.on("dispose", this.destroyTexture, this),
        e
    }
    initTextureType(t, e) {
        e.internalFormat = this.internalFormats[t.type]?.[t.format] ?? t.format,
        2 === this.webGLVersion && t.type === Bm.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type
    }
    updateTexture(t) {
        const e = t._glTextures[this.CONTEXT_UID];
        if (!e)
            return;
        const n = this.renderer;
        if (this.initTextureType(t, e),
        t.resource?.upload(n, t, e))
            e.samplerType !== Lm.FLOAT && (this.hasIntegerTextures = !0);
        else {
            const r = t.realWidth
              , i = t.realHeight
              , s = n.gl;
            (e.width !== r || e.height !== i || e.dirtyId < 0) && (e.width = r,
            e.height = i,
            s.texImage2D(t.target, 0, e.internalFormat, r, i, 0, t.format, e.type, null))
        }
        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t),
        e.dirtyId = t.dirtyId
    }
    destroyTexture(t, e) {
        const {gl: n} = this;
        if ((t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t),
        n.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
        t.off("dispose", this.destroyTexture, this),
        delete t._glTextures[this.CONTEXT_UID],
        !e)) {
            const e = this.managedTextures.indexOf(t);
            -1 !== e && wb(this.managedTextures, e, 1)
        }
    }
    updateTextureStyle(t) {
        const e = t._glTextures[this.CONTEXT_UID];
        e && (t.mipmap !== Um.POW2 && 2 === this.webGLVersion || t.isPowerOfTwo ? e.mipmap = t.mipmap >= 1 : e.mipmap = !1,
        2 === this.webGLVersion || t.isPowerOfTwo ? e.wrapMode = t.wrapMode : e.wrapMode = jm.CLAMP,
        t.resource?.style(this.renderer, t, e) || this.setStyle(t, e),
        e.dirtyStyleId = t.dirtyStyleId)
    }
    setStyle(t, e) {
        const n = this.gl;
        if (e.mipmap && t.mipmap !== Um.ON_MANUAL && n.generateMipmap(t.target),
        n.texParameteri(t.target, n.TEXTURE_WRAP_S, e.wrapMode),
        n.texParameteri(t.target, n.TEXTURE_WRAP_T, e.wrapMode),
        e.mipmap) {
            n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === Fm.LINEAR ? n.LINEAR_MIPMAP_LINEAR : n.NEAREST_MIPMAP_NEAREST);
            const e = this.renderer.context.extensions.anisotropicFiltering;
            if (e && t.anisotropicLevel > 0 && t.scaleMode === Fm.LINEAR) {
                const r = Math.min(t.anisotropicLevel, n.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                n.texParameterf(t.target, e.TEXTURE_MAX_ANISOTROPY_EXT, r)
            }
        } else
            n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === Fm.LINEAR ? n.LINEAR : n.NEAREST);
        n.texParameteri(t.target, n.TEXTURE_MAG_FILTER, t.scaleMode === Fm.LINEAR ? n.LINEAR : n.NEAREST)
    }
    destroy() {
        this.renderer = null
    }
}
Cx.extension = {
    type: Ub.RendererSystem,
    name: "texture"
},
Wb.add(Cx);
class Px {
    constructor(t) {
        this.renderer = t
    }
    contextChange() {
        this.gl = this.renderer.gl,
        this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {gl: e, CONTEXT_UID: n} = this
          , r = t._glTransformFeedbacks[n] || this.createGLTransformFeedback(t);
        e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, r)
    }
    unbind() {
        const {gl: t} = this;
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
    }
    beginTransformFeedback(t, e) {
        const {gl: n, renderer: r} = this;
        e && r.shader.bind(e),
        n.beginTransformFeedback(t)
    }
    endTransformFeedback() {
        const {gl: t} = this;
        t.endTransformFeedback()
    }
    createGLTransformFeedback(t) {
        const {gl: e, renderer: n, CONTEXT_UID: r} = this
          , i = e.createTransformFeedback();
        t._glTransformFeedbacks[r] = i,
        e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, i);
        for (let i = 0; i < t.buffers.length; i++) {
            const s = t.buffers[i];
            s && (n.buffer.update(s),
            s._glBuffers[r].refCount++,
            e.bindBufferBase(e.TRANSFORM_FEEDBACK_BUFFER, i, s._glBuffers[r].buffer || null))
        }
        return e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null),
        t.disposeRunner.add(this),
        i
    }
    disposeTransformFeedback(t, e) {
        const n = t._glTransformFeedbacks[this.CONTEXT_UID]
          , r = this.gl;
        t.disposeRunner.remove(this);
        const i = this.renderer.buffer;
        if (i)
            for (let n = 0; n < t.buffers.length; n++) {
                const r = t.buffers[n];
                if (!r)
                    continue;
                const s = r._glBuffers[this.CONTEXT_UID];
                s && (s.refCount--,
                0 !== s.refCount || e || i.dispose(r, e))
            }
        n && (e || r.deleteTransformFeedback(n),
        delete t._glTransformFeedbacks[this.CONTEXT_UID])
    }
    destroy() {
        this.renderer = null
    }
}
Px.extension = {
    type: Ub.RendererSystem,
    name: "transformFeedback"
},
Wb.add(Px);
class Ox {
    constructor(t) {
        this.renderer = t
    }
    init(t) {
        this.screen = new wv(0,0,t.width,t.height),
        this.element = t.view || Xm.ADAPTER.createCanvas(),
        this.resolution = t.resolution || Xm.RESOLUTION,
        this.autoDensity = !!t.autoDensity
    }
    resizeView(t, e) {
        this.element.width = Math.round(t * this.resolution),
        this.element.height = Math.round(e * this.resolution);
        const n = this.element.width / this.resolution
          , r = this.element.height / this.resolution;
        this.screen.width = n,
        this.screen.height = r,
        this.autoDensity && (this.element.style.width = `${n}px`,
        this.element.style.height = `${r}px`),
        this.renderer.emit("resize", n, r),
        this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
    }
    destroy(t) {
        t && this.element.parentNode?.removeChild(this.element),
        this.renderer = null,
        this.element = null,
        this.screen = null
    }
}
Ox.defaultOptions = {
    width: 800,
    height: 600,
    resolution: Xm.RESOLUTION,
    autoDensity: !1
},
Ox.extension = {
    type: [Ub.RendererSystem, Ub.CanvasRendererSystem],
    name: "_view"
},
Wb.add(Ox),
Xm.PREFER_ENV = Mm.WEBGL2,
Xm.STRICT_TEXTURE_CACHE = !1,
Xm.RENDER_OPTIONS = {
    ..._w.defaultOptions,
    ...ww.defaultOptions,
    ...Ox.defaultOptions,
    ...xx.defaultOptions
},
Object.defineProperties(Xm, {
    WRAP_MODE: {
        get: ()=>nv.defaultOptions.wrapMode,
        set(t) {
            xy("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"),
            nv.defaultOptions.wrapMode = t
        }
    },
    SCALE_MODE: {
        get: ()=>nv.defaultOptions.scaleMode,
        set(t) {
            xy("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"),
            nv.defaultOptions.scaleMode = t
        }
    },
    MIPMAP_TEXTURES: {
        get: ()=>nv.defaultOptions.mipmap,
        set(t) {
            xy("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"),
            nv.defaultOptions.mipmap = t
        }
    },
    ANISOTROPIC_LEVEL: {
        get: ()=>nv.defaultOptions.anisotropicLevel,
        set(t) {
            xy("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"),
            nv.defaultOptions.anisotropicLevel = t
        }
    },
    FILTER_RESOLUTION: {
        get: ()=>(xy("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"),
        vw.defaultResolution),
        set(t) {
            vw.defaultResolution = t
        }
    },
    FILTER_MULTISAMPLE: {
        get: ()=>(xy("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"),
        vw.defaultMultisample),
        set(t) {
            vw.defaultMultisample = t
        }
    },
    SPRITE_MAX_TEXTURES: {
        get: ()=>yw.defaultMaxTextures,
        set(t) {
            xy("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"),
            yw.defaultMaxTextures = t
        }
    },
    SPRITE_BATCH_SIZE: {
        get: ()=>yw.defaultBatchSize,
        set(t) {
            xy("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"),
            yw.defaultBatchSize = t
        }
    },
    CAN_UPLOAD_SAME_BUFFER: {
        get: ()=>yw.canUploadSameBuffer,
        set(t) {
            xy("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"),
            yw.canUploadSameBuffer = t
        }
    },
    GC_MODE: {
        get: ()=>kx.defaultMode,
        set(t) {
            xy("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"),
            kx.defaultMode = t
        }
    },
    GC_MAX_IDLE: {
        get: ()=>kx.defaultMaxIdle,
        set(t) {
            xy("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"),
            kx.defaultMaxIdle = t
        }
    },
    GC_MAX_CHECK_COUNT: {
        get: ()=>kx.defaultCheckCountMax,
        set(t) {
            xy("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"),
            kx.defaultCheckCountMax = t
        }
    },
    PRECISION_VERTEX: {
        get: ()=>lw.defaultVertexPrecision,
        set(t) {
            xy("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"),
            lw.defaultVertexPrecision = t
        }
    },
    PRECISION_FRAGMENT: {
        get: ()=>lw.defaultFragmentPrecision,
        set(t) {
            xy("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"),
            lw.defaultFragmentPrecision = t
        }
    }
});
var Nx = (t=>(t[t.INTERACTION = 50] = "INTERACTION",
t[t.HIGH = 25] = "HIGH",
t[t.NORMAL = 0] = "NORMAL",
t[t.LOW = -25] = "LOW",
t[t.UTILITY = -50] = "UTILITY",
t))(Nx || {});
class Rx {
    constructor(t, e=null, n=0, r=!1) {
        this.next = null,
        this.previous = null,
        this._destroyed = !1,
        this.fn = t,
        this.context = e,
        this.priority = n,
        this.once = r
    }
    match(t, e=null) {
        return this.fn === t && this.context === e
    }
    emit(t) {
        this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
        const e = this.next;
        return this.once && this.destroy(!0),
        this._destroyed && (this.next = null),
        e
    }
    connect(t) {
        this.previous = t,
        t.next && (t.next.previous = this),
        this.next = t.next,
        t.next = this
    }
    destroy(t=!1) {
        this._destroyed = !0,
        this.fn = null,
        this.context = null,
        this.previous && (this.previous.next = this.next),
        this.next && (this.next.previous = this.previous);
        const e = this.next;
        return this.next = t ? null : e,
        this.previous = null,
        e
    }
}
const Dx = class {
    constructor() {
        this.autoStart = !1,
        this.deltaTime = 1,
        this.lastTime = -1,
        this.speed = 1,
        this.started = !1,
        this._requestId = null,
        this._maxElapsedMS = 100,
        this._minElapsedMS = 0,
        this._protected = !1,
        this._lastFrame = -1,
        this._head = new Rx(null,null,1 / 0),
        this.deltaMS = 1 / Dx.targetFPMS,
        this.elapsedMS = 1 / Dx.targetFPMS,
        this._tick = t=>{
            this._requestId = null,
            this.started && (this.update(t),
            this.started && null === this._requestId && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
        }
    }
    _requestIfNeeded() {
        null === this._requestId && this._head.next && (this.lastTime = performance.now(),
        this._lastFrame = this.lastTime,
        this._requestId = requestAnimationFrame(this._tick))
    }
    _cancelIfNeeded() {
        null !== this._requestId && (cancelAnimationFrame(this._requestId),
        this._requestId = null)
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(t, e, n=Nx.NORMAL) {
        return this._addListener(new Rx(t,e,n))
    }
    addOnce(t, e, n=Nx.NORMAL) {
        return this._addListener(new Rx(t,e,n,!0))
    }
    _addListener(t) {
        let e = this._head.next
          , n = this._head;
        if (e) {
            for (; e; ) {
                if (t.priority > e.priority) {
                    t.connect(n);
                    break
                }
                n = e,
                e = e.next
            }
            t.previous || t.connect(n)
        } else
            t.connect(n);
        return this._startIfPossible(),
        this
    }
    remove(t, e) {
        let n = this._head.next;
        for (; n; )
            n = n.match(t, e) ? n.destroy() : n.next;
        return this._head.next || this._cancelIfNeeded(),
        this
    }
    get count() {
        if (!this._head)
            return 0;
        let t = 0
          , e = this._head;
        for (; e = e.next; )
            t++;
        return t
    }
    start() {
        this.started || (this.started = !0,
        this._requestIfNeeded())
    }
    stop() {
        this.started && (this.started = !1,
        this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let t = this._head.next;
            for (; t; )
                t = t.destroy(!0);
            this._head.destroy(),
            this._head = null
        }
    }
    update(t=performance.now()) {
        let e;
        if (t > this.lastTime) {
            if (e = this.elapsedMS = t - this.lastTime,
            e > this._maxElapsedMS && (e = this._maxElapsedMS),
            e *= this.speed,
            this._minElapsedMS) {
                const e = t - this._lastFrame | 0;
                if (e < this._minElapsedMS)
                    return;
                this._lastFrame = t - e % this._minElapsedMS
            }
            this.deltaMS = e,
            this.deltaTime = this.deltaMS * Dx.targetFPMS;
            const n = this._head;
            let r = n.next;
            for (; r; )
                r = r.emit(this.deltaTime);
            n.next || this._cancelIfNeeded()
        } else
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = t
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(t) {
        const e = Math.min(this.maxFPS, t)
          , n = Math.min(Math.max(0, e) / 1e3, Dx.targetFPMS);
        this._maxElapsedMS = 1 / n
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(t) {
        if (0 === t)
            this._minElapsedMS = 0;
        else {
            const e = Math.max(this.minFPS, t);
            this._minElapsedMS = 1 / (e / 1e3)
        }
    }
    static get shared() {
        if (!Dx._shared) {
            const t = Dx._shared = new Dx;
            t.autoStart = !0,
            t._protected = !0
        }
        return Dx._shared
    }
    static get system() {
        if (!Dx._system) {
            const t = Dx._system = new Dx;
            t.autoStart = !0,
            t._protected = !0
        }
        return Dx._system
    }
}
;
let Bx = Dx;
Bx.targetFPMS = .06,
Object.defineProperties(Xm, {
    TARGET_FPMS: {
        get: ()=>Bx.targetFPMS,
        set(t) {
            xy("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"),
            Bx.targetFPMS = t
        }
    }
});
class Lx {
    static init(t) {
        t = Object.assign({
            autoStart: !0,
            sharedTicker: !1
        }, t),
        Object.defineProperty(this, "ticker", {
            set(t) {
                this._ticker && this._ticker.remove(this.render, this),
                this._ticker = t,
                t && t.add(this.render, this, Nx.LOW)
            },
            get() {
                return this._ticker
            }
        }),
        this.stop = ()=>{
            this._ticker.stop()
        }
        ,
        this.start = ()=>{
            this._ticker.start()
        }
        ,
        this._ticker = null,
        this.ticker = t.sharedTicker ? Bx.shared : new Bx,
        t.autoStart && this.start()
    }
    static destroy() {
        if (this._ticker) {
            const t = this._ticker;
            this.ticker = null,
            t.destroy()
        }
    }
}
Lx.extension = Ub.Application,
Wb.add(Lx);
const Fx = [];
function jx(t) {
    for (const e of Fx)
        if (e.test(t))
            return new e(t);
    throw new Error("Unable to auto-detect a suitable renderer.")
}
Wb.handleByList(Ub.Renderer, Fx);
const Ux = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
class zx {
    constructor(t) {
        this.renderer = t
    }
    contextChange(t) {
        let e;
        if (1 === this.renderer.context.webGLVersion) {
            const n = t.getParameter(t.FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            e = t.getParameter(t.SAMPLES),
            t.bindFramebuffer(t.FRAMEBUFFER, n)
        } else {
            const n = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
            e = t.getParameter(t.SAMPLES),
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, n)
        }
        e >= $m.HIGH ? this.multisample = $m.HIGH : e >= $m.MEDIUM ? this.multisample = $m.MEDIUM : e >= $m.LOW ? this.multisample = $m.LOW : this.multisample = $m.NONE
    }
    destroy() {}
}
zx.extension = {
    type: Ub.RendererSystem,
    name: "_multisample"
},
Wb.add(zx);
class Vx {
    constructor(t) {
        this.buffer = t || null,
        this.updateID = -1,
        this.byteLength = -1,
        this.refCount = 0
    }
}
class Wx {
    constructor(t) {
        this.renderer = t,
        this.managedBuffers = {},
        this.boundBufferBases = {}
    }
    destroy() {
        this.renderer = null
    }
    contextChange() {
        this.disposeAll(!0),
        this.gl = this.renderer.gl,
        this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {gl: e, CONTEXT_UID: n} = this
          , r = t._glBuffers[n] || this.createGLBuffer(t);
        e.bindBuffer(t.type, r.buffer)
    }
    unbind(t) {
        const {gl: e} = this;
        e.bindBuffer(t, null)
    }
    bindBufferBase(t, e) {
        const {gl: n, CONTEXT_UID: r} = this;
        if (this.boundBufferBases[e] !== t) {
            const i = t._glBuffers[r] || this.createGLBuffer(t);
            this.boundBufferBases[e] = t,
            n.bindBufferBase(n.UNIFORM_BUFFER, e, i.buffer)
        }
    }
    bindBufferRange(t, e, n) {
        const {gl: r, CONTEXT_UID: i} = this;
        n = n || 0;
        const s = t._glBuffers[i] || this.createGLBuffer(t);
        r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, s.buffer, 256 * n, 256)
    }
    update(t) {
        const {gl: e, CONTEXT_UID: n} = this
          , r = t._glBuffers[n] || this.createGLBuffer(t);
        if (t._updateID !== r.updateID)
            if (r.updateID = t._updateID,
            e.bindBuffer(t.type, r.buffer),
            r.byteLength >= t.data.byteLength)
                e.bufferSubData(t.type, 0, t.data);
            else {
                const n = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
                r.byteLength = t.data.byteLength,
                e.bufferData(t.type, t.data, n)
            }
    }
    dispose(t, e) {
        if (!this.managedBuffers[t.id])
            return;
        delete this.managedBuffers[t.id];
        const n = t._glBuffers[this.CONTEXT_UID]
          , r = this.gl;
        t.disposeRunner.remove(this),
        n && (e || r.deleteBuffer(n.buffer),
        delete t._glBuffers[this.CONTEXT_UID])
    }
    disposeAll(t) {
        const e = Object.keys(this.managedBuffers);
        for (let n = 0; n < e.length; n++)
            this.dispose(this.managedBuffers[e[n]], t)
    }
    createGLBuffer(t) {
        const {CONTEXT_UID: e, gl: n} = this;
        return t._glBuffers[e] = new Vx(n.createBuffer()),
        this.managedBuffers[t.id] = t,
        t.disposeRunner.add(this),
        t._glBuffers[e]
    }
}
Wx.extension = {
    type: Ub.RendererSystem,
    name: "buffer"
},
Wb.add(Wx);
class Yx {
    constructor(t) {
        this.renderer = t
    }
    render(t, e) {
        const n = this.renderer;
        let r, i, s, o;
        if (e && (r = e.renderTexture,
        i = e.clear,
        s = e.transform,
        o = e.skipUpdateTransform),
        this.renderingToScreen = !r,
        n.runners.prerender.emit(),
        n.emit("prerender"),
        n.projection.transform = s,
        !n.context.isLost) {
            if (r || (this.lastObjectRendered = t),
            !o) {
                const e = t.enableTempParent();
                t.updateTransform(),
                t.disableTempParent(e)
            }
            n.renderTexture.bind(r),
            n.batch.currentRenderer.start(),
            (i ?? n.background.clearBeforeRender) && n.renderTexture.clear(),
            t.render(n),
            n.batch.currentRenderer.flush(),
            r && (e.blit && n.framebuffer.blit(),
            r.baseTexture.update()),
            n.runners.postrender.emit(),
            n.projection.transform = null,
            n.emit("postrender")
        }
    }
    destroy() {
        this.renderer = null,
        this.lastObjectRendered = null
    }
}
Yx.extension = {
    type: Ub.RendererSystem,
    name: "objectRenderer"
},
Wb.add(Yx);
const Hx = class extends Sx {
    constructor(t) {
        super(),
        this.type = Cm.WEBGL,
        t = Object.assign({}, Xm.RENDER_OPTIONS, t),
        this.gl = null,
        this.CONTEXT_UID = 0,
        this.globalUniforms = new uw({
            projectionMatrix: new Sv
        },!0);
        const e = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: Hx.__systems,
            priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
        };
        this.setup(e),
        "useContextAlpha"in t && (xy("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"),
        t.premultipliedAlpha = t.useContextAlpha && "notMultiplied" !== t.useContextAlpha,
        t.backgroundAlpha = !1 === t.useContextAlpha ? 1 : t.backgroundAlpha),
        this._plugin.rendererPlugins = Hx.__plugins,
        this.options = t,
        this.startup.run(this.options)
    }
    static test(t) {
        return !t?.forceCanvas && Sy()
    }
    render(t, e) {
        this.objectRenderer.render(t, e)
    }
    resize(t, e) {
        this._view.resizeView(t, e)
    }
    reset() {
        return this.runners.reset.emit(),
        this
    }
    clear() {
        this.renderTexture.bind(),
        this.renderTexture.clear()
    }
    destroy(t=!1) {
        this.runners.destroy.items.reverse(),
        this.emitWithCustomOptions(this.runners.destroy, {
            _view: t
        }),
        super.destroy()
    }
    get plugins() {
        return this._plugin.plugins
    }
    get multisample() {
        return this._multisample.multisample
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(t) {
        this._view.resolution = t,
        this.runners.resolutionChange.emit(t)
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get rendererLogId() {
        return `WebGL ${this.context.webGLVersion}`
    }
    get clearBeforeRender() {
        return xy("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."),
        this.background.clearBeforeRender
    }
    get useContextAlpha() {
        return xy("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."),
        this.context.useContextAlpha
    }
    get preserveDrawingBuffer() {
        return xy("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"),
        this.context.preserveDrawingBuffer
    }
    get backgroundColor() {
        return xy("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color
    }
    set backgroundColor(t) {
        xy("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color = t
    }
    get backgroundAlpha() {
        return xy("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.alpha
    }
    set backgroundAlpha(t) {
        xy("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.alpha = t
    }
    get powerPreference() {
        return xy("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"),
        this.context.powerPreference
    }
    generateTexture(t, e) {
        return this.textureGenerator.generateTexture(t, e)
    }
}
;
let $x = Hx;
$x.extension = {
    type: Ub.Renderer,
    priority: 1
},
$x.__plugins = {},
$x.__systems = {},
Wb.handleByMap(Ub.RendererPlugin, $x.__plugins),
Wb.handleByMap(Ub.RendererSystem, $x.__systems),
Wb.add($x);
class Gx extends Zb {
    constructor(t, e) {
        const {width: n, height: r} = e || {};
        super(n, r),
        this.items = [],
        this.itemDirtyIds = [];
        for (let e = 0; e < t; e++) {
            const t = new nv;
            this.items.push(t),
            this.itemDirtyIds.push(-2)
        }
        this.length = t,
        this._load = null,
        this.baseTexture = null
    }
    initFromArray(t, e) {
        for (let n = 0; n < this.length; n++)
            t[n] && (t[n].castToBaseTexture ? this.addBaseTextureAt(t[n].castToBaseTexture(), n) : t[n]instanceof Zb ? this.addResourceAt(t[n], n) : this.addResourceAt(Kb(t[n], e), n))
    }
    dispose() {
        for (let t = 0, e = this.length; t < e; t++)
            this.items[t].destroy();
        this.items = null,
        this.itemDirtyIds = null,
        this._load = null
    }
    addResourceAt(t, e) {
        if (!this.items[e])
            throw new Error(`Index ${e} is out of bounds`);
        return t.valid && !this.valid && this.resize(t.width, t.height),
        this.items[e].setResource(t),
        this
    }
    bind(t) {
        if (null !== this.baseTexture)
            throw new Error("Only one base texture per TextureArray is allowed");
        super.bind(t);
        for (let e = 0; e < this.length; e++)
            this.items[e].parentTextureArray = t,
            this.items[e].on("update", t.update, t)
    }
    unbind(t) {
        super.unbind(t);
        for (let e = 0; e < this.length; e++)
            this.items[e].parentTextureArray = null,
            this.items[e].off("update", t.update, t)
    }
    load() {
        if (this._load)
            return this._load;
        const t = this.items.map((t=>t.resource)).filter((t=>t)).map((t=>t.load()));
        return this._load = Promise.all(t).then((()=>{
            const {realWidth: t, realHeight: e} = this.items[0];
            return this.resize(t, e),
            Promise.resolve(this)
        }
        )),
        this._load
    }
}
const Xx = class extends Gx {
    constructor(t, e) {
        const {width: n, height: r, autoLoad: i, linkBaseTexture: s} = e || {};
        if (t && t.length !== Xx.SIDES)
            throw new Error(`Invalid length. Got ${t.length}, expected 6`);
        super(6, {
            width: n,
            height: r
        });
        for (let t = 0; t < Xx.SIDES; t++)
            this.items[t].target = Dm.TEXTURE_CUBE_MAP_POSITIVE_X + t;
        this.linkBaseTexture = !1 !== s,
        t && this.initFromArray(t, e),
        !1 !== i && this.load()
    }
    bind(t) {
        super.bind(t),
        t.target = Dm.TEXTURE_CUBE_MAP
    }
    addBaseTextureAt(t, e, n) {
        if (void 0 === n && (n = this.linkBaseTexture),
        !this.items[e])
            throw new Error(`Index ${e} is out of bounds`);
        if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0) {
            if (!t.resource)
                throw new Error("CubeResource does not support copying of renderTexture.");
            this.addResourceAt(t.resource, e)
        } else
            t.target = Dm.TEXTURE_CUBE_MAP_POSITIVE_X + e,
            t.parentTextureArray = this.baseTexture,
            this.items[e] = t;
        return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
        this.items[e] = t,
        this
    }
    upload(t, e, n) {
        const r = this.itemDirtyIds;
        for (let i = 0; i < Xx.SIDES; i++) {
            const s = this.items[i];
            (r[i] < s.dirtyId || n.dirtyId < e.dirtyId) && (s.valid && s.resource ? (s.resource.upload(t, s, n),
            r[i] = s.dirtyId) : r[i] < -1 && (t.gl.texImage2D(s.target, 0, n.internalFormat, e.realWidth, e.realHeight, 0, e.format, n.type, null),
            r[i] = -1))
        }
        return !0
    }
    static test(t) {
        return Array.isArray(t) && t.length === Xx.SIDES
    }
}
;
let qx = Xx;
qx.SIDES = 6;
class Kx extends kw {
    constructor(t, e) {
        let n, r;
        e = e || {},
        "string" == typeof t ? (n = Kx.EMPTY,
        r = t) : (n = t,
        r = null),
        super(n),
        this.url = r,
        this.crossOrigin = e.crossOrigin ?? !0,
        this.alphaMode = "number" == typeof e.alphaMode ? e.alphaMode : null,
        this._load = null,
        !1 !== e.autoLoad && this.load()
    }
    load() {
        return this._load || (this._load = new Promise((async(t,e)=>{
            if (null !== this.url)
                try {
                    const e = await Xm.ADAPTER.fetch(this.url, {
                        mode: this.crossOrigin ? "cors" : "no-cors"
                    });
                    if (this.destroyed)
                        return;
                    const n = await e.blob();
                    if (this.destroyed)
                        return;
                    const r = await createImageBitmap(n, {
                        premultiplyAlpha: null === this.alphaMode || this.alphaMode === zm.UNPACK ? "premultiply" : "none"
                    });
                    if (this.destroyed)
                        return;
                    this.source = r,
                    this.update(),
                    t(this)
                } catch (t) {
                    if (this.destroyed)
                        return;
                    e(t),
                    this.onError.emit(t)
                }
            else
                t(this)
        }
        ))),
        this._load
    }
    upload(t, e, n) {
        return this.source instanceof ImageBitmap ? ("number" == typeof this.alphaMode && (e.alphaMode = this.alphaMode),
        super.upload(t, e, n)) : (this.load(),
        !1)
    }
    dispose() {
        this.source instanceof ImageBitmap && this.source.close(),
        super.dispose(),
        this._load = null
    }
    static test(t) {
        return !!globalThis.createImageBitmap && "undefined" != typeof ImageBitmap && ("string" == typeof t || t instanceof ImageBitmap)
    }
    static get EMPTY() {
        return Kx._EMPTY = Kx._EMPTY ?? Xm.ADAPTER.createCanvas(0, 0),
        Kx._EMPTY
    }
}
const Qx = class extends kw {
    constructor(t, e) {
        e = e || {},
        super(Xm.ADAPTER.createCanvas()),
        this._width = 0,
        this._height = 0,
        this.svg = t,
        this.scale = e.scale || 1,
        this._overrideWidth = e.width,
        this._overrideHeight = e.height,
        this._resolve = null,
        this._crossorigin = e.crossorigin,
        this._load = null,
        !1 !== e.autoLoad && this.load()
    }
    load() {
        return this._load || (this._load = new Promise((t=>{
            if (this._resolve = ()=>{
                this.resize(this.source.width, this.source.height),
                t(this)
            }
            ,
            Qx.SVG_XML.test(this.svg.trim())) {
                if (!btoa)
                    throw new Error("Your browser doesn't support base64 conversions.");
                this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
            }
            this._loadSvg()
        }
        ))),
        this._load
    }
    _loadSvg() {
        const t = new Image;
        kw.crossOrigin(t, this.svg, this._crossorigin),
        t.src = this.svg,
        t.onerror = e=>{
            this._resolve && (t.onerror = null,
            this.onError.emit(e))
        }
        ,
        t.onload = ()=>{
            if (!this._resolve)
                return;
            const e = t.width
              , n = t.height;
            if (!e || !n)
                throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
            let r = e * this.scale
              , i = n * this.scale;
            (this._overrideWidth || this._overrideHeight) && (r = this._overrideWidth || this._overrideHeight / n * e,
            i = this._overrideHeight || this._overrideWidth / e * n),
            r = Math.round(r),
            i = Math.round(i);
            const s = this.source;
            s.width = r,
            s.height = i,
            s._pixiId = `canvas_${_b()}`,
            s.getContext("2d").drawImage(t, 0, 0, e, n, 0, 0, r, i),
            this._resolve(),
            this._resolve = null
        }
    }
    static getSize(t) {
        const e = Qx.SVG_SIZE.exec(t)
          , n = {};
        return e && (n[e[1]] = Math.round(parseFloat(e[3])),
        n[e[5]] = Math.round(parseFloat(e[7]))),
        n
    }
    dispose() {
        super.dispose(),
        this._resolve = null,
        this._crossorigin = null
    }
    static test(t, e) {
        return "svg" === e || "string" == typeof t && t.startsWith("data:image/svg+xml") || "string" == typeof t && Qx.SVG_XML.test(t)
    }
}
;
let Zx = Qx;
Zx.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,
Zx.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
const Jx = class extends kw {
    constructor(t, e) {
        if (e = e || {},
        !(t instanceof HTMLVideoElement)) {
            const n = document.createElement("video");
            n.setAttribute("preload", "auto"),
            n.setAttribute("webkit-playsinline", ""),
            n.setAttribute("playsinline", ""),
            "string" == typeof t && (t = [t]);
            const r = t[0].src || t[0];
            kw.crossOrigin(n, r, e.crossorigin);
            for (let e = 0; e < t.length; ++e) {
                const r = document.createElement("source");
                let {src: i, mime: s} = t[e];
                i = i || t[e];
                const o = i.split("?").shift().toLowerCase()
                  , a = o.slice(o.lastIndexOf(".") + 1);
                s = s || Jx.MIME_TYPES[a] || `video/${a}`,
                r.src = i,
                r.type = s,
                n.appendChild(r)
            }
            t = n
        }
        super(t),
        this.noSubImage = !0,
        this._autoUpdate = !0,
        this._isConnectedToTicker = !1,
        this._updateFPS = e.updateFPS || 0,
        this._msToNextUpdate = 0,
        this.autoPlay = !1 !== e.autoPlay,
        this._load = null,
        this._resolve = null,
        this._onCanPlay = this._onCanPlay.bind(this),
        this._onError = this._onError.bind(this),
        !1 !== e.autoLoad && this.load()
    }
    update(t=0) {
        if (!this.destroyed) {
            const t = Bx.shared.elapsedMS * this.source.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - t),
            (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(),
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
        }
    }
    load() {
        if (this._load)
            return this._load;
        const t = this.source;
        return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0),
        t.addEventListener("play", this._onPlayStart.bind(this)),
        t.addEventListener("pause", this._onPlayStop.bind(this)),
        this._isSourceReady() ? this._onCanPlay() : (t.addEventListener("canplay", this._onCanPlay),
        t.addEventListener("canplaythrough", this._onCanPlay),
        t.addEventListener("error", this._onError, !0)),
        this._load = new Promise((e=>{
            this.valid ? e(this) : (this._resolve = e,
            t.load())
        }
        )),
        this._load
    }
    _onError(t) {
        this.source.removeEventListener("error", this._onError, !0),
        this.onError.emit(t)
    }
    _isSourcePlaying() {
        const t = this.source;
        return !t.paused && !t.ended && this._isSourceReady()
    }
    _isSourceReady() {
        return this.source.readyState > 2
    }
    _onPlayStart() {
        this.valid || this._onCanPlay(),
        this.autoUpdate && !this._isConnectedToTicker && (Bx.shared.add(this.update, this),
        this._isConnectedToTicker = !0)
    }
    _onPlayStop() {
        this._isConnectedToTicker && (Bx.shared.remove(this.update, this),
        this._isConnectedToTicker = !1)
    }
    _onCanPlay() {
        const t = this.source;
        t.removeEventListener("canplay", this._onCanPlay),
        t.removeEventListener("canplaythrough", this._onCanPlay);
        const e = this.valid;
        this.resize(t.videoWidth, t.videoHeight),
        !e && this._resolve && (this._resolve(this),
        this._resolve = null),
        this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
    }
    dispose() {
        this._isConnectedToTicker && (Bx.shared.remove(this.update, this),
        this._isConnectedToTicker = !1);
        const t = this.source;
        t && (t.removeEventListener("error", this._onError, !0),
        t.pause(),
        t.src = "",
        t.load()),
        super.dispose()
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        t !== this._autoUpdate && (this._autoUpdate = t,
        !this._autoUpdate && this._isConnectedToTicker ? (Bx.shared.remove(this.update, this),
        this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Bx.shared.add(this.update, this),
        this._isConnectedToTicker = !0))
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(t) {
        t !== this._updateFPS && (this._updateFPS = t)
    }
    static test(t, e) {
        return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || Jx.TYPES.includes(e)
    }
}
;
let tE = Jx;
tE.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"],
tE.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
},
qb.push(Kx, Iw, class extends kw {
    constructor(t) {
        super(t)
    }
    static test(t) {
        const {OffscreenCanvas: e} = globalThis;
        return !!(e && t instanceof e) || globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
    }
}
, tE, Zx, Jb, qx, class extends Gx {
    constructor(t, e) {
        const {width: n, height: r} = e || {};
        let i, s;
        Array.isArray(t) ? (i = t,
        s = t.length) : s = t,
        super(s, {
            width: n,
            height: r
        }),
        i && this.initFromArray(i, e)
    }
    addBaseTextureAt(t, e) {
        if (!t.resource)
            throw new Error("ArrayResource does not support RenderTexture");
        return this.addResourceAt(t.resource, e),
        this
    }
    bind(t) {
        super.bind(t),
        t.target = Dm.TEXTURE_2D_ARRAY
    }
    upload(t, e, n) {
        const {length: r, itemDirtyIds: i, items: s} = this
          , {gl: o} = t;
        n.dirtyId < 0 && o.texImage3D(o.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, r, 0, e.format, n.type, null);
        for (let t = 0; t < r; t++) {
            const r = s[t];
            i[t] < r.dirtyId && (i[t] = r.dirtyId,
            r.valid && o.texSubImage3D(o.TEXTURE_2D_ARRAY, 0, 0, 0, t, r.resource.width, r.resource.height, 1, e.format, n.type, r.resource.source))
        }
        return !0
    }
}
);
let eE = 0;
const nE = class extends fg.EventEmitter {
    constructor(t) {
        super(),
        this.id = eE++,
        this.init(t)
    }
    set(t, e) {
        if (void 0 === this[t])
            throw new Error(`Property with name ${t} does not exist.`);
        switch (t) {
        case "speed":
            this.speed = e;
            break;
        case "volume":
            this.volume = e;
            break;
        case "paused":
            this.paused = e;
            break;
        case "loop":
            this.loop = e;
            break;
        case "muted":
            this.muted = e
        }
        return this
    }
    get progress() {
        const {currentTime: t} = this._source;
        return t / this._duration
    }
    get paused() {
        return this._paused
    }
    set paused(t) {
        this._paused = t,
        this.refreshPaused()
    }
    _onPlay() {
        this._playing = !0
    }
    _onPause() {
        this._playing = !1
    }
    init(t) {
        this._playing = !1,
        this._duration = t.source.duration;
        const e = this._source = t.source.cloneNode(!1);
        e.src = t.parent.url,
        e.onplay = this._onPlay.bind(this),
        e.onpause = this._onPause.bind(this),
        t.context.on("refresh", this.refresh, this),
        t.context.on("refreshPaused", this.refreshPaused, this),
        this._media = t
    }
    _internalStop() {
        this._source && this._playing && (this._source.onended = null,
        this._source.pause())
    }
    stop() {
        this._internalStop(),
        this._source && this.emit("stop")
    }
    get speed() {
        return this._speed
    }
    set speed(t) {
        this._speed = t,
        this.refresh()
    }
    get volume() {
        return this._volume
    }
    set volume(t) {
        this._volume = t,
        this.refresh()
    }
    get loop() {
        return this._loop
    }
    set loop(t) {
        this._loop = t,
        this.refresh()
    }
    get muted() {
        return this._muted
    }
    set muted(t) {
        this._muted = t,
        this.refresh()
    }
    get filters() {
        return console.warn("HTML Audio does not support filters"),
        null
    }
    set filters(t) {
        console.warn("HTML Audio does not support filters")
    }
    refresh() {
        const t = this._media.context
          , e = this._media.parent;
        this._source.loop = this._loop || e.loop;
        const n = t.volume * (t.muted ? 0 : 1)
          , r = e.volume * (e.muted ? 0 : 1)
          , i = this._volume * (this._muted ? 0 : 1);
        this._source.volume = i * n * r,
        this._source.playbackRate = this._speed * t.speed * e.speed
    }
    refreshPaused() {
        const t = this._media.context
          , e = this._media.parent
          , n = this._paused || e.paused || t.paused;
        n !== this._pausedReal && (this._pausedReal = n,
        n ? (this._internalStop(),
        this.emit("paused")) : (this.emit("resumed"),
        this.play({
            start: this._source.currentTime,
            end: this._end,
            volume: this._volume,
            speed: this._speed,
            loop: this._loop
        })),
        this.emit("pause", n))
    }
    play(t) {
        const {start: e, end: n, speed: r, loop: i, volume: s, muted: o} = t;
        n && console.assert(n > e, "End time is before start time"),
        this._speed = r,
        this._volume = s,
        this._loop = !!i,
        this._muted = o,
        this.refresh(),
        this.loop && null !== n && (console.warn('Looping not support when specifying an "end" time'),
        this.loop = !1),
        this._start = e,
        this._end = n || this._duration,
        this._start = Math.max(0, this._start - nE.PADDING),
        this._end = Math.min(this._end + nE.PADDING, this._duration),
        this._source.onloadedmetadata = ()=>{
            this._source && (this._source.currentTime = e,
            this._source.onloadedmetadata = null,
            this.emit("progress", e, this._duration),
            Bx.shared.add(this._onUpdate, this))
        }
        ,
        this._source.onended = this._onComplete.bind(this),
        this._source.play(),
        this.emit("start")
    }
    _onUpdate() {
        this.emit("progress", this.progress, this._duration),
        this._source.currentTime >= this._end && !this._source.loop && this._onComplete()
    }
    _onComplete() {
        Bx.shared.remove(this._onUpdate, this),
        this._internalStop(),
        this.emit("progress", 1, this._duration),
        this.emit("end", this)
    }
    destroy() {
        Bx.shared.remove(this._onUpdate, this),
        this.removeAllListeners();
        const t = this._source;
        t && (t.onended = null,
        t.onplay = null,
        t.onpause = null,
        this._internalStop()),
        this._source = null,
        this._speed = 1,
        this._volume = 1,
        this._loop = !1,
        this._end = null,
        this._start = 0,
        this._duration = 0,
        this._playing = !1,
        this._pausedReal = !1,
        this._paused = !1,
        this._muted = !1,
        this._media && (this._media.context.off("refresh", this.refresh, this),
        this._media.context.off("refreshPaused", this.refreshPaused, this),
        this._media = null)
    }
    toString() {
        return `[HTMLAudioInstance id=${this.id}]`
    }
}
;
let rE = nE;
rE.PADDING = .1;
class iE extends fg.EventEmitter {
    init(t) {
        this.parent = t,
        this._source = t.options.source || new Audio,
        t.url && (this._source.src = t.url)
    }
    create() {
        return new rE(this)
    }
    get isPlayable() {
        return !!this._source && 4 === this._source.readyState
    }
    get duration() {
        return this._source.duration
    }
    get context() {
        return this.parent.context
    }
    get filters() {
        return null
    }
    set filters(t) {
        console.warn("HTML Audio does not support filters")
    }
    destroy() {
        this.removeAllListeners(),
        this.parent = null,
        this._source && (this._source.src = "",
        this._source.load(),
        this._source = null)
    }
    get source() {
        return this._source
    }
    load(t) {
        const e = this._source
          , n = this.parent;
        if (4 === e.readyState) {
            n.isLoaded = !0;
            const e = n.autoPlayStart();
            return void (t && setTimeout((()=>{
                t(null, n, e)
            }
            ), 0))
        }
        if (!n.url)
            return void t(new Error("sound.url or sound.source must be set"));
        e.src = n.url;
        const r = ()=>{
            o(),
            n.isLoaded = !0;
            const e = n.autoPlayStart();
            t && t(null, n, e)
        }
          , i = ()=>{
            o(),
            t && t(new Error("Sound loading has been aborted"))
        }
          , s = ()=>{
            o();
            const n = `Failed to load audio element (code: ${e.error.code})`;
            t ? t(new Error(n)) : console.error(n)
        }
          , o = ()=>{
            e.removeEventListener("canplaythrough", r),
            e.removeEventListener("load", r),
            e.removeEventListener("abort", i),
            e.removeEventListener("error", s)
        }
        ;
        e.addEventListener("canplaythrough", r, !1),
        e.addEventListener("load", r, !1),
        e.addEventListener("abort", i, !1),
        e.addEventListener("error", s, !1),
        e.load()
    }
}
class sE {
    constructor(t, e) {
        this.parent = t,
        Object.assign(this, e),
        this.duration = this.end - this.start,
        console.assert(this.duration > 0, "End time must be after start time")
    }
    play(t) {
        return this.parent.play({
            complete: t,
            speed: this.speed || this.parent.speed,
            end: this.end,
            start: this.start,
            loop: this.loop
        })
    }
    destroy() {
        this.parent = null
    }
}
const oE = ["ogg", "oga", "opus", "m4a", "mp3", "mpeg", "wav", "aiff", "wma", "mid", "caf"]
  , aE = {};
!function(t) {
    const e = {
        m4a: "audio/mp4",
        oga: "audio/ogg",
        opus: 'audio/ogg; codecs="opus"',
        caf: 'audio/x-caf; codecs="opus"',
        ...t || {}
    }
      , n = document.createElement("audio")
      , r = {}
      , i = /^no$/;
    oE.forEach((t=>{
        const s = n.canPlayType(`audio/${t}`).replace(i, "")
          , o = e[t] ? n.canPlayType(e[t]).replace(i, "") : "";
        r[t] = !!s || !!o
    }
    )),
    Object.assign(aE, r)
}();
class lE {
    static setParamValue(t, e) {
        if (t.setValueAtTime) {
            const n = Im().context;
            t.setValueAtTime(e, n.audioContext.currentTime)
        } else
            t.value = e;
        return e
    }
}
let cE = 0;
class uE extends fg.EventEmitter {
    constructor(t) {
        super(),
        this.id = cE++,
        this._media = null,
        this._paused = !1,
        this._muted = !1,
        this._elapsed = 0,
        this.init(t)
    }
    set(t, e) {
        if (void 0 === this[t])
            throw new Error(`Property with name ${t} does not exist.`);
        switch (t) {
        case "speed":
            this.speed = e;
            break;
        case "volume":
            this.volume = e;
            break;
        case "muted":
            this.muted = e;
            break;
        case "loop":
            this.loop = e;
            break;
        case "paused":
            this.paused = e
        }
        return this
    }
    stop() {
        this._source && (this._internalStop(),
        this.emit("stop"))
    }
    get speed() {
        return this._speed
    }
    set speed(t) {
        this._speed = t,
        this.refresh(),
        this._update(!0)
    }
    get volume() {
        return this._volume
    }
    set volume(t) {
        this._volume = t,
        this.refresh()
    }
    get muted() {
        return this._muted
    }
    set muted(t) {
        this._muted = t,
        this.refresh()
    }
    get loop() {
        return this._loop
    }
    set loop(t) {
        this._loop = t,
        this.refresh()
    }
    get filters() {
        return this._filters
    }
    set filters(t) {
        this._filters && (this._filters?.filter((t=>t)).forEach((t=>t.disconnect())),
        this._filters = null,
        this._source.connect(this._gain)),
        this._filters = t?.length ? t.slice(0) : null,
        this.refresh()
    }
    refresh() {
        if (!this._source)
            return;
        const t = this._media.context
          , e = this._media.parent;
        this._source.loop = this._loop || e.loop;
        const n = t.volume * (t.muted ? 0 : 1)
          , r = e.volume * (e.muted ? 0 : 1)
          , i = this._volume * (this._muted ? 0 : 1);
        lE.setParamValue(this._gain.gain, i * r * n),
        lE.setParamValue(this._source.playbackRate, this._speed * e.speed * t.speed),
        this.applyFilters()
    }
    applyFilters() {
        if (this._filters?.length) {
            this._source.disconnect();
            let t = this._source;
            this._filters.forEach((e=>{
                t.connect(e.destination),
                t = e
            }
            )),
            t.connect(this._gain)
        }
    }
    refreshPaused() {
        const t = this._media.context
          , e = this._media.parent
          , n = this._paused || e.paused || t.paused;
        n !== this._pausedReal && (this._pausedReal = n,
        n ? (this._internalStop(),
        this.emit("paused")) : (this.emit("resumed"),
        this.play({
            start: this._elapsed % this._duration,
            end: this._end,
            speed: this._speed,
            loop: this._loop,
            volume: this._volume
        })),
        this.emit("pause", n))
    }
    play(t) {
        const {start: e, end: n, speed: r, loop: i, volume: s, muted: o, filters: a} = t;
        n && console.assert(n > e, "End time is before start time"),
        this._paused = !1;
        const {source: l, gain: c} = this._media.nodes.cloneBufferSource();
        this._source = l,
        this._gain = c,
        this._speed = r,
        this._volume = s,
        this._loop = !!i,
        this._muted = o,
        this._filters = a,
        this.refresh();
        const u = this._source.buffer.duration;
        this._duration = u,
        this._end = n,
        this._lastUpdate = this._now(),
        this._elapsed = e,
        this._source.onended = this._onComplete.bind(this),
        this._loop ? (this._source.loopEnd = n,
        this._source.loopStart = e,
        this._source.start(0, e)) : n ? this._source.start(0, e, n - e) : this._source.start(0, e),
        this.emit("start"),
        this._update(!0),
        this.enableTicker(!0)
    }
    enableTicker(t) {
        Bx.shared.remove(this._updateListener, this),
        t && Bx.shared.add(this._updateListener, this)
    }
    get progress() {
        return this._progress
    }
    get paused() {
        return this._paused
    }
    set paused(t) {
        this._paused = t,
        this.refreshPaused()
    }
    destroy() {
        this.removeAllListeners(),
        this._internalStop(),
        this._gain && (this._gain.disconnect(),
        this._gain = null),
        this._media && (this._media.context.events.off("refresh", this.refresh, this),
        this._media.context.events.off("refreshPaused", this.refreshPaused, this),
        this._media = null),
        this._filters?.forEach((t=>t.disconnect())),
        this._filters = null,
        this._end = null,
        this._speed = 1,
        this._volume = 1,
        this._loop = !1,
        this._elapsed = 0,
        this._duration = 0,
        this._paused = !1,
        this._muted = !1,
        this._pausedReal = !1
    }
    toString() {
        return `[WebAudioInstance id=${this.id}]`
    }
    _now() {
        return this._media.context.audioContext.currentTime
    }
    _updateListener() {
        this._update()
    }
    _update(t=!1) {
        if (this._source) {
            const e = this._now()
              , n = e - this._lastUpdate;
            if (n > 0 || t) {
                const t = this._source.playbackRate.value;
                this._elapsed += n * t,
                this._lastUpdate = e;
                const r = this._duration;
                let i;
                if (this._source.loopStart) {
                    const t = this._source.loopEnd - this._source.loopStart;
                    i = (this._source.loopStart + this._elapsed % t) / r
                } else
                    i = this._elapsed % r / r;
                this._progress = i,
                this.emit("progress", this._progress, r)
            }
        }
    }
    init(t) {
        this._media = t,
        t.context.events.on("refresh", this.refresh, this),
        t.context.events.on("refreshPaused", this.refreshPaused, this)
    }
    _internalStop() {
        if (this._source) {
            this.enableTicker(!1),
            this._source.onended = null,
            this._source.stop(0),
            this._source.disconnect();
            try {
                this._source.buffer = null
            } catch (t) {
                console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t)
            }
            this._source = null
        }
    }
    _onComplete() {
        if (this._source) {
            this.enableTicker(!1),
            this._source.onended = null,
            this._source.disconnect();
            try {
                this._source.buffer = null
            } catch (t) {
                console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t)
            }
        }
        this._source = null,
        this._progress = 1,
        this.emit("progress", 1, this._duration),
        this.emit("end", this)
    }
}
class hE {
    constructor(t, e) {
        this._output = e,
        this._input = t
    }
    get destination() {
        return this._input
    }
    get filters() {
        return this._filters
    }
    set filters(t) {
        if (this._filters && (this._filters.forEach((t=>{
            t && t.disconnect()
        }
        )),
        this._filters = null,
        this._input.connect(this._output)),
        t && t.length) {
            this._filters = t.slice(0),
            this._input.disconnect();
            let e = null;
            t.forEach((t=>{
                null === e ? this._input.connect(t.destination) : e.connect(t.destination),
                e = t
            }
            )),
            e.connect(this._output)
        }
    }
    destroy() {
        this.filters = null,
        this._input = null,
        this._output = null
    }
}
const dE = class extends hE {
    constructor(t) {
        const e = t.audioContext
          , n = e.createBufferSource()
          , r = e.createGain()
          , i = e.createAnalyser();
        n.connect(i),
        i.connect(r),
        r.connect(t.destination),
        super(i, r),
        this.context = t,
        this.bufferSource = n,
        this.gain = r,
        this.analyser = i
    }
    get script() {
        return this._script || (this._script = this.context.audioContext.createScriptProcessor(dE.BUFFER_SIZE),
        this._script.connect(this.context.destination)),
        this._script
    }
    destroy() {
        super.destroy(),
        this.bufferSource.disconnect(),
        this._script && this._script.disconnect(),
        this.gain.disconnect(),
        this.analyser.disconnect(),
        this.bufferSource = null,
        this._script = null,
        this.gain = null,
        this.analyser = null,
        this.context = null
    }
    cloneBufferSource() {
        const t = this.bufferSource
          , e = this.context.audioContext.createBufferSource();
        e.buffer = t.buffer,
        lE.setParamValue(e.playbackRate, t.playbackRate.value),
        e.loop = t.loop;
        const n = this.context.audioContext.createGain();
        return e.connect(n),
        n.connect(this.destination),
        {
            source: e,
            gain: n
        }
    }
    get bufferSize() {
        return this.script.bufferSize
    }
}
;
let fE = dE;
fE.BUFFER_SIZE = 0;
class pE {
    init(t) {
        this.parent = t,
        this._nodes = new fE(this.context),
        this._source = this._nodes.bufferSource,
        this.source = t.options.source
    }
    destroy() {
        this.parent = null,
        this._nodes.destroy(),
        this._nodes = null;
        try {
            this._source.buffer = null
        } catch (t) {
            console.warn("Failed to set AudioBufferSourceNode.buffer to null:", t)
        }
        this._source = null,
        this.source = null
    }
    create() {
        return new uE(this)
    }
    get context() {
        return this.parent.context
    }
    get isPlayable() {
        return !!this._source && !!this._source.buffer
    }
    get filters() {
        return this._nodes.filters
    }
    set filters(t) {
        this._nodes.filters = t
    }
    get duration() {
        return console.assert(this.isPlayable, "Sound not yet playable, no duration"),
        this._source.buffer.duration
    }
    get buffer() {
        return this._source.buffer
    }
    set buffer(t) {
        this._source.buffer = t
    }
    get nodes() {
        return this._nodes
    }
    load(t) {
        this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t ? t(new Error("sound.url or sound.source must be set")) : console.error("sound.url or sound.source must be set")
    }
    async _loadUrl(t) {
        const e = this.parent.url
          , n = await Xm.ADAPTER.fetch(e);
        this._decode(await n.arrayBuffer(), t)
    }
    _decode(t, e) {
        const n = (t,n)=>{
            if (t)
                e && e(t);
            else {
                this.parent.isLoaded = !0,
                this.buffer = n;
                const t = this.parent.autoPlayStart();
                e && e(null, this.parent, t)
            }
        }
        ;
        if (t instanceof AudioBuffer)
            n(null, t);
        else {
            this.parent.context.decode(t, n)
        }
    }
}
const mE = class {
    static from(t) {
        let e = {};
        "string" == typeof t ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : Array.isArray(t) ? e.url = t : e = t,
        e = {
            autoPlay: !1,
            singleInstance: !1,
            url: null,
            source: null,
            preload: !1,
            volume: 1,
            speed: 1,
            complete: null,
            loaded: null,
            loop: !1,
            ...e
        },
        Object.freeze(e);
        const n = Im().useLegacy ? new iE : new pE;
        return new mE(n,e)
    }
    constructor(t, e) {
        this.media = t,
        this.options = e,
        this._instances = [],
        this._sprites = {},
        this.media.init(this);
        const n = e.complete;
        this._autoPlayOptions = n ? {
            complete: n
        } : null,
        this.isLoaded = !1,
        this._preloadQueue = null,
        this.isPlaying = !1,
        this.autoPlay = e.autoPlay,
        this.singleInstance = e.singleInstance,
        this.preload = e.preload || this.autoPlay,
        this.url = Array.isArray(e.url) ? this.preferUrl(e.url) : e.url,
        this.speed = e.speed,
        this.volume = e.volume,
        this.loop = e.loop,
        e.sprites && this.addSprites(e.sprites),
        this.preload && this._preload(e.loaded)
    }
    preferUrl(t) {
        const [{url: e}] = t.map((t=>({
            url: t,
            ext: fg.path.extname(t).slice(1)
        }))).sort(((t,e)=>oE.indexOf(t.ext) - oE.indexOf(e.ext)));
        return e
    }
    get context() {
        return Im().context
    }
    pause() {
        return this.isPlaying = !1,
        this.paused = !0,
        this
    }
    resume() {
        return this.isPlaying = this._instances.length > 0,
        this.paused = !1,
        this
    }
    get paused() {
        return this._paused
    }
    set paused(t) {
        this._paused = t,
        this.refreshPaused()
    }
    get speed() {
        return this._speed
    }
    set speed(t) {
        this._speed = t,
        this.refresh()
    }
    get filters() {
        return this.media.filters
    }
    set filters(t) {
        this.media.filters = t
    }
    addSprites(t, e) {
        if ("object" == typeof t) {
            const e = {};
            for (const n in t)
                e[n] = this.addSprites(n, t[n]);
            return e
        }
        console.assert(!this._sprites[t], `Alias ${t} is already taken`);
        const n = new sE(this,e);
        return this._sprites[t] = n,
        n
    }
    destroy() {
        this._removeInstances(),
        this.removeSprites(),
        this.media.destroy(),
        this.media = null,
        this._sprites = null,
        this._instances = null
    }
    removeSprites(t) {
        if (t) {
            const e = this._sprites[t];
            void 0 !== e && (e.destroy(),
            delete this._sprites[t])
        } else
            for (const t in this._sprites)
                this.removeSprites(t);
        return this
    }
    get isPlayable() {
        return this.isLoaded && this.media && this.media.isPlayable
    }
    stop() {
        if (!this.isPlayable)
            return this.autoPlay = !1,
            this._autoPlayOptions = null,
            this;
        this.isPlaying = !1;
        for (let t = this._instances.length - 1; t >= 0; t--)
            this._instances[t].stop();
        return this
    }
    play(t, e) {
        let n;
        if ("string" == typeof t) {
            n = {
                sprite: t,
                loop: this.loop,
                complete: e
            }
        } else
            "function" == typeof t ? (n = {},
            n.complete = t) : n = t;
        if (n = {
            complete: null,
            loaded: null,
            sprite: null,
            end: null,
            start: 0,
            volume: 1,
            speed: 1,
            muted: !1,
            loop: !1,
            ...n || {}
        },
        n.sprite) {
            const t = n.sprite;
            console.assert(!!this._sprites[t], `Alias ${t} is not available`);
            const e = this._sprites[t];
            n.start = e.start + (n.start || 0),
            n.end = e.end,
            n.speed = e.speed || 1,
            n.loop = e.loop || n.loop,
            delete n.sprite
        }
        if (n.offset && (n.start = n.offset),
        !this.isLoaded)
            return this._preloadQueue ? new Promise((t=>{
                this._preloadQueue.push((()=>{
                    t(this.play(n))
                }
                ))
            }
            )) : (this._preloadQueue = [],
            this.autoPlay = !0,
            this._autoPlayOptions = n,
            new Promise(((t,e)=>{
                this._preload(((r,i,s)=>{
                    this._preloadQueue.forEach((t=>t())),
                    this._preloadQueue = null,
                    r ? e(r) : (n.loaded && n.loaded(r, i, s),
                    t(s))
                }
                ))
            }
            )));
        (this.singleInstance || n.singleInstance) && this._removeInstances();
        const r = this._createInstance();
        return this._instances.push(r),
        this.isPlaying = !0,
        r.once("end", (()=>{
            n.complete && n.complete(this),
            this._onComplete(r)
        }
        )),
        r.once("stop", (()=>{
            this._onComplete(r)
        }
        )),
        r.play(n),
        r
    }
    refresh() {
        const t = this._instances.length;
        for (let e = 0; e < t; e++)
            this._instances[e].refresh()
    }
    refreshPaused() {
        const t = this._instances.length;
        for (let e = 0; e < t; e++)
            this._instances[e].refreshPaused()
    }
    get volume() {
        return this._volume
    }
    set volume(t) {
        this._volume = t,
        this.refresh()
    }
    get muted() {
        return this._muted
    }
    set muted(t) {
        this._muted = t,
        this.refresh()
    }
    get loop() {
        return this._loop
    }
    set loop(t) {
        this._loop = t,
        this.refresh()
    }
    _preload(t) {
        this.media.load(t)
    }
    get instances() {
        return this._instances
    }
    get sprites() {
        return this._sprites
    }
    get duration() {
        return this.media.duration
    }
    autoPlayStart() {
        let t;
        return this.autoPlay && (t = this.play(this._autoPlayOptions)),
        t
    }
    _removeInstances() {
        for (let t = this._instances.length - 1; t >= 0; t--)
            this._poolInstance(this._instances[t]);
        this._instances.length = 0
    }
    _onComplete(t) {
        if (this._instances) {
            const e = this._instances.indexOf(t);
            e > -1 && this._instances.splice(e, 1),
            this.isPlaying = this._instances.length > 0
        }
        this._poolInstance(t)
    }
    _createInstance() {
        if (mE._pool.length > 0) {
            const t = mE._pool.pop();
            return t.init(this.media),
            t
        }
        return this.media.create()
    }
    _poolInstance(t) {
        t.destroy(),
        mE._pool.indexOf(t) < 0 && mE._pool.push(t)
    }
}
;
let gE = mE;
gE._pool = [];
class yE extends fg.EventEmitter {
    constructor() {
        super(...arguments),
        this.speed = 1,
        this.muted = !1,
        this.volume = 1,
        this.paused = !1
    }
    refresh() {
        this.emit("refresh")
    }
    refreshPaused() {
        this.emit("refreshPaused")
    }
    get filters() {
        return console.warn("HTML Audio does not support filters"),
        null
    }
    set filters(t) {
        console.warn("HTML Audio does not support filters")
    }
    get audioContext() {
        return console.warn("HTML Audio does not support audioContext"),
        null
    }
    toggleMute() {
        return this.muted = !this.muted,
        this.refresh(),
        this.muted
    }
    togglePause() {
        return this.paused = !this.paused,
        this.refreshPaused(),
        this.paused
    }
    destroy() {
        this.removeAllListeners()
    }
}
class bE extends hE {
    constructor() {
        const t = window
          , e = new bE.AudioContext
          , n = e.createDynamicsCompressor()
          , r = e.createAnalyser();
        r.connect(n),
        n.connect(e.destination),
        super(r, n),
        this._ctx = e,
        this._offlineCtx = new bE.OfflineAudioContext(1,2,t.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, e.sampleRate)) : 44100),
        this.compressor = n,
        this.analyser = r,
        this.events = new fg.EventEmitter,
        this.volume = 1,
        this.speed = 1,
        this.muted = !1,
        this.paused = !1,
        this._locked = "suspended" === e.state && ("ontouchstart"in globalThis || "onclick"in globalThis),
        this._locked && (this._unlock(),
        this._unlock = this._unlock.bind(this),
        document.addEventListener("mousedown", this._unlock, !0),
        document.addEventListener("touchstart", this._unlock, !0),
        document.addEventListener("touchend", this._unlock, !0)),
        this.onFocus = this.onFocus.bind(this),
        this.onBlur = this.onBlur.bind(this),
        globalThis.addEventListener("focus", this.onFocus),
        globalThis.addEventListener("blur", this.onBlur)
    }
    onFocus() {
        const t = this._ctx.state;
        "suspended" !== t && "interrupted" !== t && this._locked || this._ctx.resume()
    }
    onBlur() {
        this._locked || this._ctx.suspend()
    }
    _unlock() {
        this._locked && (this.playEmptySound(),
        "running" === this._ctx.state && (document.removeEventListener("mousedown", this._unlock, !0),
        document.removeEventListener("touchend", this._unlock, !0),
        document.removeEventListener("touchstart", this._unlock, !0),
        this._locked = !1))
    }
    playEmptySound() {
        const t = this._ctx.createBufferSource();
        t.buffer = this._ctx.createBuffer(1, 1, 22050),
        t.connect(this._ctx.destination),
        t.start(0, 0, 0),
        "suspended" === t.context.state && t.context.resume()
    }
    static get AudioContext() {
        const t = window;
        return t.AudioContext || t.webkitAudioContext || null
    }
    static get OfflineAudioContext() {
        const t = window;
        return t.OfflineAudioContext || t.webkitOfflineAudioContext || null
    }
    destroy() {
        super.destroy();
        const t = this._ctx;
        void 0 !== t.close && t.close(),
        globalThis.removeEventListener("focus", this.onFocus),
        globalThis.removeEventListener("blur", this.onBlur),
        this.events.removeAllListeners(),
        this.analyser.disconnect(),
        this.compressor.disconnect(),
        this.analyser = null,
        this.compressor = null,
        this.events = null,
        this._offlineCtx = null,
        this._ctx = null
    }
    get audioContext() {
        return this._ctx
    }
    get offlineContext() {
        return this._offlineCtx
    }
    set paused(t) {
        t && "running" === this._ctx.state ? this._ctx.suspend() : t || "suspended" !== this._ctx.state || this._ctx.resume(),
        this._paused = t
    }
    get paused() {
        return this._paused
    }
    refresh() {
        this.events.emit("refresh")
    }
    refreshPaused() {
        this.events.emit("refreshPaused")
    }
    toggleMute() {
        return this.muted = !this.muted,
        this.refresh(),
        this.muted
    }
    togglePause() {
        return this.paused = !this.paused,
        this.refreshPaused(),
        this._paused
    }
    decode(t, e) {
        const n = t=>{
            e(new Error(t?.message || "Unable to decode file"))
        }
          , r = this._offlineCtx.decodeAudioData(t, (t=>{
            e(null, t)
        }
        ), n);
        r && r.catch(n)
    }
}
class vE {
    constructor(t, e) {
        this.init(t, e)
    }
    init(t, e) {
        this.destination = t,
        this.source = e || t
    }
    connect(t) {
        this.source?.connect(t)
    }
    disconnect() {
        this.source?.disconnect()
    }
    destroy() {
        this.disconnect(),
        this.destination = null,
        this.source = null
    }
}
const wE = class extends vE {
    constructor(t=0, e=0, n=0, r=0, i=0, s=0, o=0, a=0, l=0, c=0) {
        let u = [];
        const h = [{
            f: wE.F32,
            type: "lowshelf",
            gain: t
        }, {
            f: wE.F64,
            type: "peaking",
            gain: e
        }, {
            f: wE.F125,
            type: "peaking",
            gain: n
        }, {
            f: wE.F250,
            type: "peaking",
            gain: r
        }, {
            f: wE.F500,
            type: "peaking",
            gain: i
        }, {
            f: wE.F1K,
            type: "peaking",
            gain: s
        }, {
            f: wE.F2K,
            type: "peaking",
            gain: o
        }, {
            f: wE.F4K,
            type: "peaking",
            gain: a
        }, {
            f: wE.F8K,
            type: "peaking",
            gain: l
        }, {
            f: wE.F16K,
            type: "highshelf",
            gain: c
        }];
        Im().useLegacy || (u = h.map((t=>{
            const e = Im().context.audioContext.createBiquadFilter();
            return e.type = t.type,
            lE.setParamValue(e.Q, 1),
            e.frequency.value = t.f,
            lE.setParamValue(e.gain, t.gain),
            e
        }
        ))),
        super(u[0], u[u.length - 1]),
        this.bands = u,
        this.bandsMap = {};
        for (let t = 0; t < this.bands.length; t++) {
            const e = this.bands[t];
            t > 0 && this.bands[t - 1].connect(e),
            this.bandsMap[e.frequency.value] = e
        }
    }
    setGain(t, e=0) {
        if (!this.bandsMap[t])
            throw new Error(`No band found for frequency ${t}`);
        lE.setParamValue(this.bandsMap[t].gain, e)
    }
    getGain(t) {
        if (!this.bandsMap[t])
            throw new Error(`No band found for frequency ${t}`);
        return this.bandsMap[t].gain.value
    }
    set f32(t) {
        this.setGain(wE.F32, t)
    }
    get f32() {
        return this.getGain(wE.F32)
    }
    set f64(t) {
        this.setGain(wE.F64, t)
    }
    get f64() {
        return this.getGain(wE.F64)
    }
    set f125(t) {
        this.setGain(wE.F125, t)
    }
    get f125() {
        return this.getGain(wE.F125)
    }
    set f250(t) {
        this.setGain(wE.F250, t)
    }
    get f250() {
        return this.getGain(wE.F250)
    }
    set f500(t) {
        this.setGain(wE.F500, t)
    }
    get f500() {
        return this.getGain(wE.F500)
    }
    set f1k(t) {
        this.setGain(wE.F1K, t)
    }
    get f1k() {
        return this.getGain(wE.F1K)
    }
    set f2k(t) {
        this.setGain(wE.F2K, t)
    }
    get f2k() {
        return this.getGain(wE.F2K)
    }
    set f4k(t) {
        this.setGain(wE.F4K, t)
    }
    get f4k() {
        return this.getGain(wE.F4K)
    }
    set f8k(t) {
        this.setGain(wE.F8K, t)
    }
    get f8k() {
        return this.getGain(wE.F8K)
    }
    set f16k(t) {
        this.setGain(wE.F16K, t)
    }
    get f16k() {
        return this.getGain(wE.F16K)
    }
    reset() {
        this.bands.forEach((t=>{
            lE.setParamValue(t.gain, 0)
        }
        ))
    }
    destroy() {
        this.bands.forEach((t=>{
            t.disconnect()
        }
        )),
        this.bands = null,
        this.bandsMap = null
    }
}
;
let xE = wE;
xE.F32 = 32,
xE.F64 = 64,
xE.F125 = 125,
xE.F250 = 250,
xE.F500 = 500,
xE.F1K = 1e3,
xE.F2K = 2e3,
xE.F4K = 4e3,
xE.F8K = 8e3,
xE.F16K = 16e3;
const EE = {
    loader: Ub.LoadParser,
    resolver: Ub.ResolveParser,
    cache: Ub.CacheParser,
    detection: Ub.DetectionParser
};
Wb.handle(Ub.Asset, (t=>{
    const e = t.ref;
    Object.entries(EE).filter((([t])=>!!e[t])).forEach((([t,n])=>Wb.add(Object.assign(e[t], {
        extension: e[t].extension ?? n
    }))))
}
), (t=>{
    const e = t.ref;
    Object.keys(EE).filter((t=>!!e[t])).forEach((t=>Wb.remove(e[t])))
}
));
class _E {
    constructor(t, e=!1) {
        this._loader = t,
        this._assetList = [],
        this._isLoading = !1,
        this._maxConcurrent = 1,
        this.verbose = e
    }
    add(t) {
        t.forEach((t=>{
            this._assetList.push(t)
        }
        )),
        this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList),
        this._isActive && !this._isLoading && this._next()
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const t = []
              , e = Math.min(this._assetList.length, this._maxConcurrent);
            for (let n = 0; n < e; n++)
                t.push(this._assetList.pop());
            await this._loader.load(t),
            this._isLoading = !1,
            this._next()
        }
    }
    get active() {
        return this._isActive
    }
    set active(t) {
        this._isActive !== t && (this._isActive = t,
        t && !this._isLoading && this._next())
    }
}
function AE(t, e) {
    if (Array.isArray(e)) {
        for (const n of e)
            if (t.startsWith(`data:${n}`))
                return !0;
        return !1
    }
    return t.startsWith(`data:${e}`)
}
function SE(t, e) {
    const n = t.split("?")[0]
      , r = fg.path.extname(n).toLowerCase();
    return Array.isArray(e) ? e.includes(r) : r === e
}
const TE = (t,e)=>(Array.isArray(t) || (t = [t]),
e ? t.map((t=>"string" == typeof t ? e(t) : t)) : t)
  , kE = (t,e)=>{
    const n = e.split("?")[1];
    return n && (t += `?${n}`),
    t
}
;
function IE(t, e, n, r, i) {
    const s = e[n];
    for (let o = 0; o < s.length; o++) {
        const a = s[o];
        n < e.length - 1 ? IE(t.replace(r[n], a), e, n + 1, r, i) : i.push(t.replace(r[n], a))
    }
}
function ME(t) {
    const e = t.match(/\{(.*?)\}/g)
      , n = [];
    if (e) {
        const r = [];
        e.forEach((t=>{
            const e = t.substring(1, t.length - 1).split(",");
            r.push(e)
        }
        )),
        IE(t, r, 0, e, n)
    } else
        n.push(t);
    return n
}
const CE = t=>!Array.isArray(t);
const PE = new class {
    constructor() {
        this._parsers = [],
        this._cache = new Map,
        this._cacheMap = new Map
    }
    reset() {
        this._cacheMap.clear(),
        this._cache.clear()
    }
    has(t) {
        return this._cache.has(t)
    }
    get(t) {
        const e = this._cache.get(t);
        return e || console.warn(`[Assets] Asset id ${t} was not found in the Cache`),
        e
    }
    set(t, e) {
        const n = TE(t);
        let r;
        for (let t = 0; t < this.parsers.length; t++) {
            const i = this.parsers[t];
            if (i.test(e)) {
                r = i.getCacheableAssets(n, e);
                break
            }
        }
        r || (r = {},
        n.forEach((t=>{
            r[t] = e
        }
        )));
        const i = Object.keys(r)
          , s = {
            cacheKeys: i,
            keys: n
        };
        if (n.forEach((t=>{
            this._cacheMap.set(t, s)
        }
        )),
        i.forEach((t=>{
            this._cache.has(t) && this._cache.get(t) !== e && console.warn("[Cache] already has key:", t),
            this._cache.set(t, r[t])
        }
        )),
        e instanceof Ow) {
            const t = e;
            n.forEach((e=>{
                t.baseTexture !== Ow.EMPTY.baseTexture && nv.addToCache(t.baseTexture, e),
                Ow.addToCache(t, e)
            }
            ))
        }
    }
    remove(t) {
        if (this._cacheMap.get(t),
        !this._cacheMap.has(t))
            return void console.warn(`[Assets] Asset id ${t} was not found in the Cache`);
        const e = this._cacheMap.get(t);
        e.cacheKeys.forEach((t=>{
            this._cache.delete(t)
        }
        )),
        e.keys.forEach((t=>{
            this._cacheMap.delete(t)
        }
        ))
    }
    get parsers() {
        return this._parsers
    }
}
;
class OE {
    constructor() {
        this._parsers = [],
        this._parsersValidated = !1,
        this.parsers = new Proxy(this._parsers,{
            set: (t,e,n)=>(this._parsersValidated = !1,
            t[e] = n,
            !0)
        }),
        this.promiseCache = {}
    }
    reset() {
        this._parsersValidated = !1,
        this.promiseCache = {}
    }
    _getLoadPromiseAndParser(t, e) {
        const n = {
            promise: null,
            parser: null
        };
        return n.promise = (async()=>{
            let r = null
              , i = null;
            if (e.loadParser && (i = this._parserHash[e.loadParser],
            i || console.warn(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)),
            !i) {
                for (let n = 0; n < this.parsers.length; n++) {
                    const r = this.parsers[n];
                    if (r.load && r.test?.(t, e, this)) {
                        i = r;
                        break
                    }
                }
                if (!i)
                    return console.warn(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),
                    null
            }
            r = await i.load(t, e, this),
            n.parser = i;
            for (let t = 0; t < this.parsers.length; t++) {
                const i = this.parsers[t];
                i.parse && i.parse && await (i.testParse?.(r, e, this)) && (r = await i.parse(r, e, this) || r,
                n.parser = i)
            }
            return r
        }
        )(),
        n
    }
    async load(t, e) {
        this._parsersValidated || this._validateParsers();
        let n = 0;
        const r = {}
          , i = CE(t)
          , s = TE(t, (t=>({
            src: t
        })))
          , o = s.length
          , a = s.map((async t=>{
            const i = fg.path.toAbsolute(t.src);
            if (!r[t.src])
                try {
                    this.promiseCache[i] || (this.promiseCache[i] = this._getLoadPromiseAndParser(i, t)),
                    r[t.src] = await this.promiseCache[i].promise,
                    e && e(++n / o)
                } catch (e) {
                    throw delete this.promiseCache[i],
                    delete r[t.src],
                    new Error(`[Loader.load] Failed to load ${i}.\n${e}`)
                }
        }
        ));
        return await Promise.all(a),
        i ? r[s[0].src] : r
    }
    async unload(t) {
        const e = TE(t, (t=>({
            src: t
        }))).map((async t=>{
            const e = fg.path.toAbsolute(t.src)
              , n = this.promiseCache[e];
            if (n) {
                const r = await n.promise;
                n.parser?.unload?.(r, t, this),
                delete this.promiseCache[e]
            }
        }
        ));
        await Promise.all(e)
    }
    _validateParsers() {
        this._parsersValidated = !0,
        this._parserHash = this._parsers.filter((t=>t.name)).reduce(((t,e)=>(t[e.name] && console.warn(`[Assets] loadParser name conflict "${e.name}"`),
        {
            ...t,
            [e.name]: e
        })), {})
    }
}
var NE = (t=>(t[t.Low = 0] = "Low",
t[t.Normal = 1] = "Normal",
t[t.High = 2] = "High",
t))(NE || {});
const RE = {
    extension: {
        type: Ub.LoadParser,
        priority: NE.Low
    },
    name: "loadJson",
    test: t=>AE(t, "application/json") || SE(t, ".json"),
    async load(t) {
        const e = await Xm.ADAPTER.fetch(t);
        return await e.json()
    }
};
Wb.add(RE);
const DE = {
    name: "loadTxt",
    extension: {
        type: Ub.LoadParser,
        priority: NE.Low
    },
    test: t=>AE(t, "text/plain") || SE(t, ".txt"),
    async load(t) {
        const e = await Xm.ADAPTER.fetch(t);
        return await e.text()
    }
};
Wb.add(DE);
const BE = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
  , LE = [".ttf", ".otf", ".woff", ".woff2"]
  , FE = ["font/ttf", "font/otf", "font/woff", "font/woff2"]
  , jE = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
const UE = {
    extension: {
        type: Ub.LoadParser,
        priority: NE.Low
    },
    name: "loadWebFont",
    test: t=>AE(t, FE) || SE(t, LE),
    async load(t, e) {
        const n = Xm.ADAPTER.getFontFaceSet();
        if (n) {
            const r = []
              , i = e.data?.family ?? function(t) {
                const e = fg.path.extname(t)
                  , n = fg.path.basename(t, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((t=>t.charAt(0).toUpperCase() + t.slice(1)));
                let r = n.length > 0;
                for (const t of n)
                    if (!t.match(jE)) {
                        r = !1;
                        break
                    }
                let i = n.join(" ");
                return r || (i = `"${i.replace(/[\\"]/g, "\\$&")}"`),
                i
            }(t)
              , s = e.data?.weights?.filter((t=>BE.includes(t))) ?? ["normal"]
              , o = e.data ?? {};
            for (let e = 0; e < s.length; e++) {
                const a = s[e]
                  , l = new FontFace(i,`url(${encodeURI(t)})`,{
                    ...o,
                    weight: a
                });
                await l.load(),
                n.add(l),
                r.push(l)
            }
            return 1 === r.length ? r[0] : r
        }
        return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),
        null
    },
    unload(t) {
        (Array.isArray(t) ? t : [t]).forEach((t=>Xm.ADAPTER.getFontFaceSet().delete(t)))
    }
};
Wb.add(UE);
let zE, VE = 0;
const WE = {
    id: "checkImageBitmap",
    code: "\n    async function checkImageBitmap()\n    {\n        try\n        {\n            if (typeof createImageBitmap !== 'function') return false;\n\n            const response = await fetch('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=');\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n\n            return imageBitmap.width === 1 && imageBitmap.height === 1;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    }\n    checkImageBitmap().then((result) => { self.postMessage(result); });\n    "
}
  , YE = {
    id: "loadImageBitmap",
    code: "\n    async function loadImageBitmap(url)\n    {\n        const response = await fetch(url);\n\n        if (!response.ok)\n        {\n            throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: `\n                + `${response.status} ${response.statusText}`);\n        }\n\n        const imageBlob =  await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n\n        return imageBitmap;\n    }\n    self.onmessage = async (event) =>\n    {\n        try\n        {\n            const imageBitmap = await loadImageBitmap(event.data.data[0]);\n\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }\n        catch(e)\n        {\n            self.postMessage({\n                error: e,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        }\n    };"
};
let HE;
const $E = new class {
    constructor() {
        this._initialized = !1,
        this._createdWorkers = 0,
        this.workerPool = [],
        this.queue = [],
        this.resolveHash = {}
    }
    isImageBitmapSupported() {
        return void 0 !== this._isImageBitmapSupported || (this._isImageBitmapSupported = new Promise((t=>{
            const e = URL.createObjectURL(new Blob([WE.code],{
                type: "application/javascript"
            }))
              , n = new Worker(e);
            n.addEventListener("message", (r=>{
                n.terminate(),
                URL.revokeObjectURL(e),
                t(r.data)
            }
            ))
        }
        ))),
        this._isImageBitmapSupported
    }
    loadImageBitmap(t) {
        return this._run("loadImageBitmap", [t])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    getWorker() {
        void 0 === zE && (zE = navigator.hardwareConcurrency || 4);
        let t = this.workerPool.pop();
        return !t && this._createdWorkers < zE && (HE || (HE = URL.createObjectURL(new Blob([YE.code],{
            type: "application/javascript"
        }))),
        this._createdWorkers++,
        t = new Worker(HE),
        t.addEventListener("message", (t=>{
            this.complete(t.data),
            this.returnWorker(t.target),
            this.next()
        }
        ))),
        t
    }
    returnWorker(t) {
        this.workerPool.push(t)
    }
    complete(t) {
        void 0 !== t.error ? this.resolveHash[t.uuid].reject(t.error) : this.resolveHash[t.uuid].resolve(t.data),
        this.resolveHash[t.uuid] = null
    }
    async _run(t, e) {
        await this._initWorkers();
        const n = new Promise(((n,r)=>{
            this.queue.push({
                id: t,
                arguments: e,
                resolve: n,
                reject: r
            })
        }
        ));
        return this.next(),
        n
    }
    next() {
        if (!this.queue.length)
            return;
        const t = this.getWorker();
        if (!t)
            return;
        const e = this.queue.pop()
          , n = e.id;
        this.resolveHash[VE] = {
            resolve: e.resolve,
            reject: e.reject
        },
        t.postMessage({
            data: e.arguments,
            uuid: VE++,
            id: n
        })
    }
}
;
function GE(t, e, n) {
    const r = new Ow(t);
    return r.baseTexture.on("dispose", (()=>{
        delete e.promiseCache[n]
    }
    )),
    r
}
const XE = [".jpeg", ".jpg", ".png", ".webp", ".avif"]
  , qE = ["image/jpeg", "image/png", "image/webp", "image/avif"];
const KE = {
    name: "loadTextures",
    extension: {
        type: Ub.LoadParser,
        priority: NE.High
    },
    config: {
        preferWorkers: !0,
        preferCreateImageBitmap: !0,
        crossOrigin: "anonymous"
    },
    test: t=>AE(t, qE) || SE(t, XE),
    async load(t, e, n) {
        let r = null;
        r = globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await $E.isImageBitmapSupported() ? await $E.loadImageBitmap(t) : await async function(t) {
            const e = await Xm.ADAPTER.fetch(t);
            if (!e.ok)
                throw new Error(`[loadImageBitmap] Failed to fetch ${t}: ${e.status} ${e.statusText}`);
            const n = await e.blob();
            return await createImageBitmap(n)
        }(t) : await new Promise((e=>{
            r = new Image,
            r.crossOrigin = this.config.crossOrigin,
            r.src = t,
            r.complete ? e(r) : r.onload = ()=>{
                e(r)
            }
        }
        ));
        const i = new nv(r,{
            resolution: fg.getResolutionOfUrl(t),
            ...e.data
        });
        return i.resource.src = t,
        GE(i, n, t)
    },
    unload(t) {
        t.destroy(!0)
    }
};
Wb.add(KE);
const QE = {
    extension: {
        type: Ub.LoadParser,
        priority: NE.High
    },
    name: "loadSVG",
    test: t=>AE(t, "image/svg+xml") || SE(t, ".svg"),
    testParse: async t=>Zx.test(t),
    async parse(t, e, n) {
        const r = new Zx(t,e?.data?.resourceOptions);
        await r.load();
        const i = new nv(r,{
            resolution: fg.getResolutionOfUrl(t),
            ...e?.data
        });
        i.resource.src = t;
        return GE(i, n, t)
    },
    load: async(t,e)=>(await Xm.ADAPTER.fetch(t)).text(),
    unload: KE.unload
};
Wb.add(QE);
class ZE {
    constructor() {
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (t,e)=>`${t}${this._bundleIdConnector}${e}`,
            extractAssetIdFromBundle: (t,e)=>e.replace(`${t}${this._bundleIdConnector}`, "")
        },
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector,
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId,
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,
        this._assetMap = {},
        this._preferredOrder = [],
        this._parsers = [],
        this._resolverHash = {},
        this._bundles = {}
    }
    setBundleIdentifier(t) {
        if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector,
        this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId,
        this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle,
        "bar" !== this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")))
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }
    prefer(...t) {
        t.forEach((t=>{
            this._preferredOrder.push(t),
            t.priority || (t.priority = Object.keys(t.params))
        }
        )),
        this._resolverHash = {}
    }
    set basePath(t) {
        this._basePath = t
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(t) {
        this._rootPath = t
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
        this._assetMap = {},
        this._preferredOrder = [],
        this._resolverHash = {},
        this._rootPath = null,
        this._basePath = null,
        this._manifest = null,
        this._bundles = {},
        this._defaultSearchParams = null
    }
    setDefaultSearchParams(t) {
        if ("string" == typeof t)
            this._defaultSearchParams = t;
        else {
            const e = t;
            this._defaultSearchParams = Object.keys(e).map((t=>`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`)).join("&")
        }
    }
    addManifest(t) {
        this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"),
        this._manifest = t,
        t.bundles.forEach((t=>{
            this.addBundle(t.name, t.assets)
        }
        ))
    }
    addBundle(t, e) {
        const n = [];
        Array.isArray(e) ? e.forEach((e=>{
            if ("string" == typeof e.name) {
                const r = this._createBundleAssetId(t, e.name);
                n.push(r),
                this.add([e.name, r], e.srcs, e.data)
            } else {
                const r = e.name.map((e=>this._createBundleAssetId(t, e)));
                r.forEach((t=>{
                    n.push(t)
                }
                )),
                this.add([...e.name, ...r], e.srcs)
            }
        }
        )) : Object.keys(e).forEach((r=>{
            n.push(this._createBundleAssetId(t, r)),
            this.add([r, this._createBundleAssetId(t, r)], e[r])
        }
        )),
        this._bundles[t] = n
    }
    add(t, e, n) {
        const r = TE(t);
        r.forEach((t=>{
            this.hasKey(t) && console.warn(`[Resolver] already has key: ${t} overwriting`)
        }
        )),
        Array.isArray(e) || (e = "string" == typeof e ? ME(e) : [e]);
        const i = e.map((t=>{
            let e = t;
            if ("string" == typeof t) {
                let n = !1;
                for (let r = 0; r < this._parsers.length; r++) {
                    const i = this._parsers[r];
                    if (i.test(t)) {
                        e = i.parse(t),
                        n = !0;
                        break
                    }
                }
                n || (e = {
                    src: t
                })
            }
            return e.format || (e.format = e.src.split(".").pop()),
            e.alias || (e.alias = r),
            (this._basePath || this._rootPath) && (e.src = fg.path.toAbsolute(e.src, this._basePath, this._rootPath)),
            e.src = this._appendDefaultSearchParams(e.src),
            e.data = e.data ?? n,
            e
        }
        ));
        r.forEach((t=>{
            this._assetMap[t] = i
        }
        ))
    }
    resolveBundle(t) {
        const e = CE(t);
        t = TE(t);
        const n = {};
        return t.forEach((t=>{
            const e = this._bundles[t];
            if (e) {
                const r = this.resolve(e)
                  , i = {};
                for (const e in r) {
                    const n = r[e];
                    i[this._extractAssetIdFromBundle(t, e)] = n
                }
                n[t] = i
            }
        }
        )),
        e ? n[t[0]] : n
    }
    resolveUrl(t) {
        const e = this.resolve(t);
        if ("string" != typeof t) {
            const t = {};
            for (const n in e)
                t[n] = e[n].src;
            return t
        }
        return e.src
    }
    resolve(t) {
        const e = CE(t);
        t = TE(t);
        const n = {};
        return t.forEach((t=>{
            if (!this._resolverHash[t])
                if (this._assetMap[t]) {
                    let e = this._assetMap[t];
                    const n = this._getPreferredOrder(e)
                      , r = e[0];
                    n?.priority.forEach((t=>{
                        n.params[t].forEach((n=>{
                            const r = e.filter((e=>!!e[t] && e[t] === n));
                            r.length && (e = r)
                        }
                        ))
                    }
                    )),
                    this._resolverHash[t] = e[0] ?? r
                } else {
                    let e = t;
                    (this._basePath || this._rootPath) && (e = fg.path.toAbsolute(e, this._basePath, this._rootPath)),
                    e = this._appendDefaultSearchParams(e),
                    this._resolverHash[t] = {
                        src: e
                    }
                }
            n[t] = this._resolverHash[t]
        }
        )),
        e ? n[t[0]] : n
    }
    hasKey(t) {
        return !!this._assetMap[t]
    }
    hasBundle(t) {
        return !!this._bundles[t]
    }
    _getPreferredOrder(t) {
        for (let e = 0; e < t.length; e++) {
            const e = t[0]
              , n = this._preferredOrder.find((t=>t.params.format.includes(e.format)));
            if (n)
                return n
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(t) {
        if (!this._defaultSearchParams)
            return t;
        return `${t}${/\?/.test(t) ? "&" : "?"}${this._defaultSearchParams}`
    }
}
const JE = new class {
    constructor() {
        this._detections = [],
        this._initialized = !1,
        this.resolver = new ZE,
        this.loader = new OE,
        this.cache = PE,
        this._backgroundLoader = new _E(this.loader),
        this._backgroundLoader.active = !0,
        this.reset()
    }
    async init(t={}) {
        if (this._initialized)
            return void console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
        if (this._initialized = !0,
        t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams),
        t.basePath && (this.resolver.basePath = t.basePath),
        t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier),
        t.manifest) {
            let e = t.manifest;
            "string" == typeof e && (e = await this.load(e)),
            this.resolver.addManifest(e)
        }
        const e = t.texturePreference?.resolution ?? 1
          , n = "number" == typeof e ? [e] : e;
        let r = [];
        if (t.texturePreference?.format) {
            const e = t.texturePreference?.format;
            r = "string" == typeof e ? [e] : e;
            for (const t of this._detections)
                await t.test() || (r = await t.remove(r))
        } else
            for (const t of this._detections)
                await t.test() && (r = await t.add(r));
        this.resolver.prefer({
            params: {
                format: r,
                resolution: n
            }
        }),
        t.preferences && this.setPreferences(t.preferences)
    }
    add(t, e, n) {
        this.resolver.add(t, e, n)
    }
    async load(t, e) {
        this._initialized || await this.init();
        const n = CE(t)
          , r = TE(t).map((t=>"string" != typeof t ? (this.resolver.add(t.src, t),
        t.src) : (this.resolver.hasKey(t) || this.resolver.add(t, t),
        t)))
          , i = this.resolver.resolve(r)
          , s = await this._mapLoadToResolve(i, e);
        return n ? s[r[0]] : s
    }
    addBundle(t, e) {
        this.resolver.addBundle(t, e)
    }
    async loadBundle(t, e) {
        this._initialized || await this.init();
        let n = !1;
        "string" == typeof t && (n = !0,
        t = [t]);
        const r = this.resolver.resolveBundle(t)
          , i = {}
          , s = Object.keys(r);
        let o = 0
          , a = 0;
        const l = ()=>{
            e?.(++o / a)
        }
          , c = s.map((t=>{
            const e = r[t];
            return a += Object.keys(e).length,
            this._mapLoadToResolve(e, l).then((e=>{
                i[t] = e
            }
            ))
        }
        ));
        return await Promise.all(c),
        n ? i[t[0]] : i
    }
    async backgroundLoad(t) {
        this._initialized || await this.init(),
        "string" == typeof t && (t = [t]);
        const e = this.resolver.resolve(t);
        this._backgroundLoader.add(Object.values(e))
    }
    async backgroundLoadBundle(t) {
        this._initialized || await this.init(),
        "string" == typeof t && (t = [t]);
        const e = this.resolver.resolveBundle(t);
        Object.values(e).forEach((t=>{
            this._backgroundLoader.add(Object.values(t))
        }
        ))
    }
    reset() {
        this.resolver.reset(),
        this.loader.reset(),
        this.cache.reset(),
        this._initialized = !1
    }
    get(t) {
        if ("string" == typeof t)
            return PE.get(t);
        const e = {};
        for (let n = 0; n < t.length; n++)
            e[n] = PE.get(t[n]);
        return e
    }
    async _mapLoadToResolve(t, e) {
        const n = Object.values(t)
          , r = Object.keys(t);
        this._backgroundLoader.active = !1;
        const i = await this.loader.load(n, e);
        this._backgroundLoader.active = !0;
        const s = {};
        return n.forEach(((t,e)=>{
            const n = i[t.src]
              , o = [t.src];
            t.alias && o.push(...t.alias),
            s[r[e]] = n,
            PE.set(o, n)
        }
        )),
        s
    }
    async unload(t) {
        this._initialized || await this.init();
        const e = TE(t).map((t=>"string" != typeof t ? t.src : t))
          , n = this.resolver.resolve(e);
        await this._unloadFromResolved(n)
    }
    async unloadBundle(t) {
        this._initialized || await this.init(),
        t = TE(t);
        const e = this.resolver.resolveBundle(t)
          , n = Object.keys(e).map((t=>this._unloadFromResolved(e[t])));
        await Promise.all(n)
    }
    async _unloadFromResolved(t) {
        const e = Object.values(t);
        e.forEach((t=>{
            PE.remove(t.src)
        }
        )),
        await this.loader.unload(e)
    }
    get detections() {
        return this._detections
    }
    get preferWorkers() {
        return KE.config.preferWorkers
    }
    set preferWorkers(t) {
        fg.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."),
        this.setPreferences({
            preferWorkers: t
        })
    }
    setPreferences(t) {
        this.loader.parsers.forEach((e=>{
            e.config && Object.keys(e.config).filter((e=>e in t)).forEach((n=>{
                e.config[n] = t[n]
            }
            ))
        }
        ))
    }
}
;
Wb.handleByList(Ub.LoadParser, JE.loader.parsers).handleByList(Ub.ResolveParser, JE.resolver.parsers).handleByList(Ub.CacheParser, JE.cache.parsers).handleByList(Ub.DetectionParser, JE.detections);
const t_ = {
    extension: Ub.CacheParser,
    test: t=>Array.isArray(t) && t.every((t=>t instanceof Ow)),
    getCacheableAssets: (t,e)=>{
        const n = {};
        return t.forEach((t=>{
            e.forEach(((e,r)=>{
                n[t + (0 === r ? "" : r + 1)] = e
            }
            ))
        }
        )),
        n
    }
};
Wb.add(t_);
const e_ = {
    extension: {
        type: Ub.DetectionParser,
        priority: 1
    },
    test: async()=>{
        if (!globalThis.createImageBitmap)
            return !1;
        const t = await Xm.ADAPTER.fetch("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=").then((t=>t.blob()));
        return createImageBitmap(t).then((()=>!0), (()=>!1))
    }
    ,
    add: async t=>[...t, "avif"],
    remove: async t=>t.filter((t=>"avif" !== t))
};
Wb.add(e_);
const n_ = {
    extension: {
        type: Ub.DetectionParser,
        priority: 0
    },
    test: async()=>{
        if (!globalThis.createImageBitmap)
            return !1;
        const t = await Xm.ADAPTER.fetch("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=").then((t=>t.blob()));
        return createImageBitmap(t).then((()=>!0), (()=>!1))
    }
    ,
    add: async t=>[...t, "webp"],
    remove: async t=>t.filter((t=>"webp" !== t))
};
Wb.add(n_);
const r_ = ["png", "jpg", "jpeg"]
  , i_ = {
    extension: {
        type: Ub.DetectionParser,
        priority: -1
    },
    test: ()=>Promise.resolve(!0),
    add: async t=>[...t, ...r_],
    remove: async t=>t.filter((t=>!r_.includes(t)))
};
Wb.add(i_);
const s_ = {
    extension: Ub.ResolveParser,
    test: KE.test,
    parse: t=>({
        resolution: parseFloat(Xm.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
        format: t.split(".").pop(),
        src: t
    })
};
Wb.add(s_);
const o_ = t=>{
    const e = t.src;
    return t?.alias?.[0] ?? fg.path.basename(e, fg.path.extname(e))
}
  , a_ = {
    extension: Ub.Asset,
    detection: {
        test: async()=>!0,
        add: async t=>[...t, ...oE.filter((t=>aE[t]))],
        remove: async t=>t.filter((e=>t.includes(e)))
    },
    loader: {
        extension: {
            type: [Ub.LoadParser],
            priority: NE.High
        },
        test(t) {
            const e = fg.path.extname(t).slice(1);
            return !!aE[e]
        },
        async load(t, e) {
            const n = await new Promise(((n,r)=>gE.from({
                ...e.data,
                url: t,
                preload: !0,
                loaded(t, i) {
                    t ? r(t) : n(i),
                    e.data?.loaded?.(t, i)
                }
            })));
            return Im().add(o_(e), n),
            n
        },
        async unload(t, e) {
            Im().remove(o_(e))
        }
    }
};
Wb.add(a_);
const l_ = (c_ = new class {
    constructor() {
        this.init()
    }
    init() {
        return this.supported && (this._webAudioContext = new bE),
        this._htmlAudioContext = new yE,
        this._sounds = {},
        this.useLegacy = !this.supported,
        this
    }
    get context() {
        return this._context
    }
    get filtersAll() {
        return this.useLegacy ? [] : this._context.filters
    }
    set filtersAll(t) {
        this.useLegacy || (this._context.filters = t)
    }
    get supported() {
        return null !== bE.AudioContext
    }
    add(t, e) {
        if ("object" == typeof t) {
            const n = {};
            for (const r in t) {
                const i = this._getOptions(t[r], e);
                n[r] = this.add(r, i)
            }
            return n
        }
        if (console.assert(!this._sounds[t], `Sound with alias ${t} already exists.`),
        e instanceof gE)
            return this._sounds[t] = e,
            e;
        const n = this._getOptions(e)
          , r = gE.from(n);
        return this._sounds[t] = r,
        r
    }
    _getOptions(t, e) {
        let n;
        return n = "string" == typeof t || Array.isArray(t) ? {
            url: t
        } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? {
            source: t
        } : t,
        n = {
            ...n,
            ...e || {}
        },
        n
    }
    get useLegacy() {
        return this._useLegacy
    }
    set useLegacy(t) {
        this._useLegacy = t,
        this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext
    }
    remove(t) {
        return this.exists(t, !0),
        this._sounds[t].destroy(),
        delete this._sounds[t],
        this
    }
    get volumeAll() {
        return this._context.volume
    }
    set volumeAll(t) {
        this._context.volume = t,
        this._context.refresh()
    }
    get speedAll() {
        return this._context.speed
    }
    set speedAll(t) {
        this._context.speed = t,
        this._context.refresh()
    }
    togglePauseAll() {
        return this._context.togglePause()
    }
    pauseAll() {
        return this._context.paused = !0,
        this._context.refreshPaused(),
        this
    }
    resumeAll() {
        return this._context.paused = !1,
        this._context.refreshPaused(),
        this
    }
    toggleMuteAll() {
        return this._context.toggleMute()
    }
    muteAll() {
        return this._context.muted = !0,
        this._context.refresh(),
        this
    }
    unmuteAll() {
        return this._context.muted = !1,
        this._context.refresh(),
        this
    }
    removeAll() {
        for (const t in this._sounds)
            this._sounds[t].destroy(),
            delete this._sounds[t];
        return this
    }
    stopAll() {
        for (const t in this._sounds)
            this._sounds[t].stop();
        return this
    }
    exists(t, e=!1) {
        const n = !!this._sounds[t];
        return e && console.assert(n, `No sound matching alias '${t}'.`),
        n
    }
    isPlaying() {
        for (const t in this._sounds)
            if (this._sounds[t].isPlaying)
                return !0;
        return !1
    }
    find(t) {
        return this.exists(t, !0),
        this._sounds[t]
    }
    play(t, e) {
        return this.find(t).play(e)
    }
    stop(t) {
        return this.find(t).stop()
    }
    pause(t) {
        return this.find(t).pause()
    }
    resume(t) {
        return this.find(t).resume()
    }
    volume(t, e) {
        const n = this.find(t);
        return void 0 !== e && (n.volume = e),
        n.volume
    }
    speed(t, e) {
        const n = this.find(t);
        return void 0 !== e && (n.speed = e),
        n.speed
    }
    duration(t) {
        return this.find(t).duration
    }
    close() {
        return this.removeAll(),
        this._sounds = null,
        this._webAudioContext && (this._webAudioContext.destroy(),
        this._webAudioContext = null),
        this._htmlAudioContext && (this._htmlAudioContext.destroy(),
        this._htmlAudioContext = null),
        this._context = null,
        this
    }
}
,
km = c_,
c_);
var c_, u_ = {};
!function(t) {
    /*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   */
    var e, n, r, i, s = 9e15, o = 1e9, a = "0123456789abcdef", l = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", c = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", u = {
        precision: 20,
        rounding: 4,
        modulo: 1,
        toExpNeg: -7,
        toExpPos: 21,
        minE: -s,
        maxE: s,
        crypto: !1
    }, h = !0, d = "[DecimalError] ", f = d + "Invalid argument: ", p = d + "Precision limit exceeded", m = d + "crypto unavailable", g = "[object Decimal]", y = Math.floor, b = Math.pow, v = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, w = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, x = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, E = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, _ = 1e7, A = 7, S = l.length - 1, T = c.length - 1, k = {
        toStringTag: g
    };
    function I(t) {
        var e, n, r, i = t.length - 1, s = "", o = t[0];
        if (i > 0) {
            for (s += o,
            e = 1; e < i; e++)
                r = t[e] + "",
                (n = A - r.length) && (s += j(n)),
                s += r;
            o = t[e],
            (n = A - (r = o + "").length) && (s += j(n))
        } else if (0 === o)
            return "0";
        for (; o % 10 == 0; )
            o /= 10;
        return s + o
    }
    function M(t, e, n) {
        if (t !== ~~t || t < e || t > n)
            throw Error(f + t)
    }
    function C(t, e, n, r) {
        var i, s, o, a;
        for (s = t[0]; s >= 10; s /= 10)
            --e;
        return --e < 0 ? (e += A,
        i = 0) : (i = Math.ceil((e + 1) / A),
        e %= A),
        s = b(10, A - e),
        a = t[i] % s | 0,
        null == r ? e < 3 ? (0 == e ? a = a / 100 | 0 : 1 == e && (a = a / 10 | 0),
        o = n < 4 && 99999 == a || n > 3 && 49999 == a || 5e4 == a || 0 == a) : o = (n < 4 && a + 1 == s || n > 3 && a + 1 == s / 2) && (t[i + 1] / s / 100 | 0) == b(10, e - 2) - 1 || (a == s / 2 || 0 == a) && 0 == (t[i + 1] / s / 100 | 0) : e < 4 ? (0 == e ? a = a / 1e3 | 0 : 1 == e ? a = a / 100 | 0 : 2 == e && (a = a / 10 | 0),
        o = (r || n < 4) && 9999 == a || !r && n > 3 && 4999 == a) : o = ((r || n < 4) && a + 1 == s || !r && n > 3 && a + 1 == s / 2) && (t[i + 1] / s / 1e3 | 0) == b(10, e - 3) - 1,
        o
    }
    function P(t, e, n) {
        for (var r, i, s = [0], o = 0, l = t.length; o < l; ) {
            for (i = s.length; i--; )
                s[i] *= e;
            for (s[0] += a.indexOf(t.charAt(o++)),
            r = 0; r < s.length; r++)
                s[r] > n - 1 && (void 0 === s[r + 1] && (s[r + 1] = 0),
                s[r + 1] += s[r] / n | 0,
                s[r] %= n)
        }
        return s.reverse()
    }
    k.absoluteValue = k.abs = function() {
        var t = new this.constructor(this);
        return t.s < 0 && (t.s = 1),
        N(t)
    }
    ,
    k.ceil = function() {
        return N(new this.constructor(this), this.e + 1, 2)
    }
    ,
    k.clampedTo = k.clamp = function(t, e) {
        var n = this
          , r = n.constructor;
        if (t = new r(t),
        e = new r(e),
        !t.s || !e.s)
            return new r(NaN);
        if (t.gt(e))
            throw Error(f + e);
        return n.cmp(t) < 0 ? t : n.cmp(e) > 0 ? e : new r(n)
    }
    ,
    k.comparedTo = k.cmp = function(t) {
        var e, n, r, i, s = this, o = s.d, a = (t = new s.constructor(t)).d, l = s.s, c = t.s;
        if (!o || !a)
            return l && c ? l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1 : NaN;
        if (!o[0] || !a[0])
            return o[0] ? l : a[0] ? -c : 0;
        if (l !== c)
            return l;
        if (s.e !== t.e)
            return s.e > t.e ^ l < 0 ? 1 : -1;
        for (e = 0,
        n = (r = o.length) < (i = a.length) ? r : i; e < n; ++e)
            if (o[e] !== a[e])
                return o[e] > a[e] ^ l < 0 ? 1 : -1;
        return r === i ? 0 : r > i ^ l < 0 ? 1 : -1
    }
    ,
    k.cosine = k.cos = function() {
        var t, e, n = this, r = n.constructor;
        return n.d ? n.d[0] ? (t = r.precision,
        e = r.rounding,
        r.precision = t + Math.max(n.e, n.sd()) + A,
        r.rounding = 1,
        n = function(t, e) {
            var n, r, i;
            if (e.isZero())
                return e;
            r = e.d.length,
            r < 32 ? i = (1 / q(4, n = Math.ceil(r / 3))).toString() : (n = 16,
            i = "2.3283064365386962890625e-10");
            t.precision += n,
            e = X(t, 1, e.times(i), new t(1));
            for (var s = n; s--; ) {
                var o = e.times(e);
                e = o.times(o).minus(o).times(8).plus(1)
            }
            return t.precision -= n,
            e
        }(r, K(r, n)),
        r.precision = t,
        r.rounding = e,
        N(2 == i || 3 == i ? n.neg() : n, t, e, !0)) : new r(1) : new r(NaN)
    }
    ,
    k.cubeRoot = k.cbrt = function() {
        var t, e, n, r, i, s, o, a, l, c, u = this, d = u.constructor;
        if (!u.isFinite() || u.isZero())
            return new d(u);
        for (h = !1,
        (s = u.s * b(u.s * u, 1 / 3)) && Math.abs(s) != 1 / 0 ? r = new d(s.toString()) : (n = I(u.d),
        (s = ((t = u.e) - n.length + 1) % 3) && (n += 1 == s || -2 == s ? "0" : "00"),
        s = b(n, 1 / 3),
        t = y((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)),
        (r = new d(n = s == 1 / 0 ? "5e" + t : (n = s.toExponential()).slice(0, n.indexOf("e") + 1) + t)).s = u.s),
        o = (t = d.precision) + 3; ; )
            if (c = (l = (a = r).times(a).times(a)).plus(u),
            r = O(c.plus(u).times(a), c.plus(l), o + 2, 1),
            I(a.d).slice(0, o) === (n = I(r.d)).slice(0, o)) {
                if ("9999" != (n = n.slice(o - 3, o + 1)) && (i || "4999" != n)) {
                    +n && (+n.slice(1) || "5" != n.charAt(0)) || (N(r, t + 1, 1),
                    e = !r.times(r).times(r).eq(u));
                    break
                }
                if (!i && (N(a, t + 1, 0),
                a.times(a).times(a).eq(u))) {
                    r = a;
                    break
                }
                o += 4,
                i = 1
            }
        return h = !0,
        N(r, t, d.rounding, e)
    }
    ,
    k.decimalPlaces = k.dp = function() {
        var t, e = this.d, n = NaN;
        if (e) {
            if (n = ((t = e.length - 1) - y(this.e / A)) * A,
            t = e[t])
                for (; t % 10 == 0; t /= 10)
                    n--;
            n < 0 && (n = 0)
        }
        return n
    }
    ,
    k.dividedBy = k.div = function(t) {
        return O(this, new this.constructor(t))
    }
    ,
    k.dividedToIntegerBy = k.divToInt = function(t) {
        var e = this.constructor;
        return N(O(this, new e(t), 0, 1, 1), e.precision, e.rounding)
    }
    ,
    k.equals = k.eq = function(t) {
        return 0 === this.cmp(t)
    }
    ,
    k.floor = function() {
        return N(new this.constructor(this), this.e + 1, 3)
    }
    ,
    k.greaterThan = k.gt = function(t) {
        return this.cmp(t) > 0
    }
    ,
    k.greaterThanOrEqualTo = k.gte = function(t) {
        var e = this.cmp(t);
        return 1 == e || 0 === e
    }
    ,
    k.hyperbolicCosine = k.cosh = function() {
        var t, e, n, r, i, s = this, o = s.constructor, a = new o(1);
        if (!s.isFinite())
            return new o(s.s ? 1 / 0 : NaN);
        if (s.isZero())
            return a;
        n = o.precision,
        r = o.rounding,
        o.precision = n + Math.max(s.e, s.sd()) + 4,
        o.rounding = 1,
        (i = s.d.length) < 32 ? e = (1 / q(4, t = Math.ceil(i / 3))).toString() : (t = 16,
        e = "2.3283064365386962890625e-10"),
        s = X(o, 1, s.times(e), new o(1), !0);
        for (var l, c = t, u = new o(8); c--; )
            l = s.times(s),
            s = a.minus(l.times(u.minus(l.times(u))));
        return N(s, o.precision = n, o.rounding = r, !0)
    }
    ,
    k.hyperbolicSine = k.sinh = function() {
        var t, e, n, r, i = this, s = i.constructor;
        if (!i.isFinite() || i.isZero())
            return new s(i);
        if (e = s.precision,
        n = s.rounding,
        s.precision = e + Math.max(i.e, i.sd()) + 4,
        s.rounding = 1,
        (r = i.d.length) < 3)
            i = X(s, 2, i, i, !0);
        else {
            t = (t = 1.4 * Math.sqrt(r)) > 16 ? 16 : 0 | t,
            i = X(s, 2, i = i.times(1 / q(5, t)), i, !0);
            for (var o, a = new s(5), l = new s(16), c = new s(20); t--; )
                o = i.times(i),
                i = i.times(a.plus(o.times(l.times(o).plus(c))))
        }
        return s.precision = e,
        s.rounding = n,
        N(i, e, n, !0)
    }
    ,
    k.hyperbolicTangent = k.tanh = function() {
        var t, e, n = this, r = n.constructor;
        return n.isFinite() ? n.isZero() ? new r(n) : (t = r.precision,
        e = r.rounding,
        r.precision = t + 7,
        r.rounding = 1,
        O(n.sinh(), n.cosh(), r.precision = t, r.rounding = e)) : new r(n.s)
    }
    ,
    k.inverseCosine = k.acos = function() {
        var t, e = this, n = e.constructor, r = e.abs().cmp(1), i = n.precision, s = n.rounding;
        return -1 !== r ? 0 === r ? e.isNeg() ? L(n, i, s) : new n(0) : new n(NaN) : e.isZero() ? L(n, i + 4, s).times(.5) : (n.precision = i + 6,
        n.rounding = 1,
        e = e.asin(),
        t = L(n, i + 4, s).times(.5),
        n.precision = i,
        n.rounding = s,
        t.minus(e))
    }
    ,
    k.inverseHyperbolicCosine = k.acosh = function() {
        var t, e, n = this, r = n.constructor;
        return n.lte(1) ? new r(n.eq(1) ? 0 : NaN) : n.isFinite() ? (t = r.precision,
        e = r.rounding,
        r.precision = t + Math.max(Math.abs(n.e), n.sd()) + 4,
        r.rounding = 1,
        h = !1,
        n = n.times(n).minus(1).sqrt().plus(n),
        h = !0,
        r.precision = t,
        r.rounding = e,
        n.ln()) : new r(n)
    }
    ,
    k.inverseHyperbolicSine = k.asinh = function() {
        var t, e, n = this, r = n.constructor;
        return !n.isFinite() || n.isZero() ? new r(n) : (t = r.precision,
        e = r.rounding,
        r.precision = t + 2 * Math.max(Math.abs(n.e), n.sd()) + 6,
        r.rounding = 1,
        h = !1,
        n = n.times(n).plus(1).sqrt().plus(n),
        h = !0,
        r.precision = t,
        r.rounding = e,
        n.ln())
    }
    ,
    k.inverseHyperbolicTangent = k.atanh = function() {
        var t, e, n, r, i = this, s = i.constructor;
        return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (t = s.precision,
        e = s.rounding,
        r = i.sd(),
        Math.max(r, t) < 2 * -i.e - 1 ? N(new s(i), t, e, !0) : (s.precision = n = r - i.e,
        i = O(i.plus(1), new s(1).minus(i), n + t, 1),
        s.precision = t + 4,
        s.rounding = 1,
        i = i.ln(),
        s.precision = t,
        s.rounding = e,
        i.times(.5))) : new s(NaN)
    }
    ,
    k.inverseSine = k.asin = function() {
        var t, e, n, r, i = this, s = i.constructor;
        return i.isZero() ? new s(i) : (e = i.abs().cmp(1),
        n = s.precision,
        r = s.rounding,
        -1 !== e ? 0 === e ? ((t = L(s, n + 4, r).times(.5)).s = i.s,
        t) : new s(NaN) : (s.precision = n + 6,
        s.rounding = 1,
        i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(),
        s.precision = n,
        s.rounding = r,
        i.times(2)))
    }
    ,
    k.inverseTangent = k.atan = function() {
        var t, e, n, r, i, s, o, a, l, c = this, u = c.constructor, d = u.precision, f = u.rounding;
        if (c.isFinite()) {
            if (c.isZero())
                return new u(c);
            if (c.abs().eq(1) && d + 4 <= T)
                return (o = L(u, d + 4, f).times(.25)).s = c.s,
                o
        } else {
            if (!c.s)
                return new u(NaN);
            if (d + 4 <= T)
                return (o = L(u, d + 4, f).times(.5)).s = c.s,
                o
        }
        for (u.precision = a = d + 10,
        u.rounding = 1,
        t = n = Math.min(28, a / A + 2 | 0); t; --t)
            c = c.div(c.times(c).plus(1).sqrt().plus(1));
        for (h = !1,
        e = Math.ceil(a / A),
        r = 1,
        l = c.times(c),
        o = new u(c),
        i = c; -1 !== t; )
            if (i = i.times(l),
            s = o.minus(i.div(r += 2)),
            i = i.times(l),
            void 0 !== (o = s.plus(i.div(r += 2))).d[e])
                for (t = e; o.d[t] === s.d[t] && t--; )
                    ;
        return n && (o = o.times(2 << n - 1)),
        h = !0,
        N(o, u.precision = d, u.rounding = f, !0)
    }
    ,
    k.isFinite = function() {
        return !!this.d
    }
    ,
    k.isInteger = k.isInt = function() {
        return !!this.d && y(this.e / A) > this.d.length - 2
    }
    ,
    k.isNaN = function() {
        return !this.s
    }
    ,
    k.isNegative = k.isNeg = function() {
        return this.s < 0
    }
    ,
    k.isPositive = k.isPos = function() {
        return this.s > 0
    }
    ,
    k.isZero = function() {
        return !!this.d && 0 === this.d[0]
    }
    ,
    k.lessThan = k.lt = function(t) {
        return this.cmp(t) < 0
    }
    ,
    k.lessThanOrEqualTo = k.lte = function(t) {
        return this.cmp(t) < 1
    }
    ,
    k.logarithm = k.log = function(t) {
        var e, n, r, i, s, o, a, l, c = this, u = c.constructor, d = u.precision, f = u.rounding;
        if (null == t)
            t = new u(10),
            e = !0;
        else {
            if (n = (t = new u(t)).d,
            t.s < 0 || !n || !n[0] || t.eq(1))
                return new u(NaN);
            e = t.eq(10)
        }
        if (n = c.d,
        c.s < 0 || !n || !n[0] || c.eq(1))
            return new u(n && !n[0] ? -1 / 0 : 1 != c.s ? NaN : n ? 0 : 1 / 0);
        if (e)
            if (n.length > 1)
                s = !0;
            else {
                for (i = n[0]; i % 10 == 0; )
                    i /= 10;
                s = 1 !== i
            }
        if (h = !1,
        o = Y(c, a = d + 5),
        r = e ? B(u, a + 10) : Y(t, a),
        C((l = O(o, r, a, 1)).d, i = d, f))
            do {
                if (o = Y(c, a += 10),
                r = e ? B(u, a + 10) : Y(t, a),
                l = O(o, r, a, 1),
                !s) {
                    +I(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = N(l, d + 1, 0));
                    break
                }
            } while (C(l.d, i += 10, f));
        return h = !0,
        N(l, d, f)
    }
    ,
    k.minus = k.sub = function(t) {
        var e, n, r, i, s, o, a, l, c, u, d, f, p = this, m = p.constructor;
        if (t = new m(t),
        !p.d || !t.d)
            return p.s && t.s ? p.d ? t.s = -t.s : t = new m(t.d || p.s !== t.s ? p : NaN) : t = new m(NaN),
            t;
        if (p.s != t.s)
            return t.s = -t.s,
            p.plus(t);
        if (c = p.d,
        f = t.d,
        a = m.precision,
        l = m.rounding,
        !c[0] || !f[0]) {
            if (f[0])
                t.s = -t.s;
            else {
                if (!c[0])
                    return new m(3 === l ? -0 : 0);
                t = new m(p)
            }
            return h ? N(t, a, l) : t
        }
        if (n = y(t.e / A),
        u = y(p.e / A),
        c = c.slice(),
        s = u - n) {
            for ((d = s < 0) ? (e = c,
            s = -s,
            o = f.length) : (e = f,
            n = u,
            o = c.length),
            s > (r = Math.max(Math.ceil(a / A), o) + 2) && (s = r,
            e.length = 1),
            e.reverse(),
            r = s; r--; )
                e.push(0);
            e.reverse()
        } else {
            for ((d = (r = c.length) < (o = f.length)) && (o = r),
            r = 0; r < o; r++)
                if (c[r] != f[r]) {
                    d = c[r] < f[r];
                    break
                }
            s = 0
        }
        for (d && (e = c,
        c = f,
        f = e,
        t.s = -t.s),
        o = c.length,
        r = f.length - o; r > 0; --r)
            c[o++] = 0;
        for (r = f.length; r > s; ) {
            if (c[--r] < f[r]) {
                for (i = r; i && 0 === c[--i]; )
                    c[i] = _ - 1;
                --c[i],
                c[r] += _
            }
            c[r] -= f[r]
        }
        for (; 0 === c[--o]; )
            c.pop();
        for (; 0 === c[0]; c.shift())
            --n;
        return c[0] ? (t.d = c,
        t.e = D(c, n),
        h ? N(t, a, l) : t) : new m(3 === l ? -0 : 0)
    }
    ,
    k.modulo = k.mod = function(t) {
        var e, n = this, r = n.constructor;
        return t = new r(t),
        !n.d || !t.s || t.d && !t.d[0] ? new r(NaN) : !t.d || n.d && !n.d[0] ? N(new r(n), r.precision, r.rounding) : (h = !1,
        9 == r.modulo ? (e = O(n, t.abs(), 0, 3, 1)).s *= t.s : e = O(n, t, 0, r.modulo, 1),
        e = e.times(t),
        h = !0,
        n.minus(e))
    }
    ,
    k.naturalExponential = k.exp = function() {
        return W(this)
    }
    ,
    k.naturalLogarithm = k.ln = function() {
        return Y(this)
    }
    ,
    k.negated = k.neg = function() {
        var t = new this.constructor(this);
        return t.s = -t.s,
        N(t)
    }
    ,
    k.plus = k.add = function(t) {
        var e, n, r, i, s, o, a, l, c, u, d = this, f = d.constructor;
        if (t = new f(t),
        !d.d || !t.d)
            return d.s && t.s ? d.d || (t = new f(t.d || d.s === t.s ? d : NaN)) : t = new f(NaN),
            t;
        if (d.s != t.s)
            return t.s = -t.s,
            d.minus(t);
        if (c = d.d,
        u = t.d,
        a = f.precision,
        l = f.rounding,
        !c[0] || !u[0])
            return u[0] || (t = new f(d)),
            h ? N(t, a, l) : t;
        if (s = y(d.e / A),
        r = y(t.e / A),
        c = c.slice(),
        i = s - r) {
            for (i < 0 ? (n = c,
            i = -i,
            o = u.length) : (n = u,
            r = s,
            o = c.length),
            i > (o = (s = Math.ceil(a / A)) > o ? s + 1 : o + 1) && (i = o,
            n.length = 1),
            n.reverse(); i--; )
                n.push(0);
            n.reverse()
        }
        for ((o = c.length) - (i = u.length) < 0 && (i = o,
        n = u,
        u = c,
        c = n),
        e = 0; i; )
            e = (c[--i] = c[i] + u[i] + e) / _ | 0,
            c[i] %= _;
        for (e && (c.unshift(e),
        ++r),
        o = c.length; 0 == c[--o]; )
            c.pop();
        return t.d = c,
        t.e = D(c, r),
        h ? N(t, a, l) : t
    }
    ,
    k.precision = k.sd = function(t) {
        var e, n = this;
        if (void 0 !== t && t !== !!t && 1 !== t && 0 !== t)
            throw Error(f + t);
        return n.d ? (e = F(n.d),
        t && n.e + 1 > e && (e = n.e + 1)) : e = NaN,
        e
    }
    ,
    k.round = function() {
        var t = this
          , e = t.constructor;
        return N(new e(t), t.e + 1, e.rounding)
    }
    ,
    k.sine = k.sin = function() {
        var t, e, n = this, r = n.constructor;
        return n.isFinite() ? n.isZero() ? new r(n) : (t = r.precision,
        e = r.rounding,
        r.precision = t + Math.max(n.e, n.sd()) + A,
        r.rounding = 1,
        n = function(t, e) {
            var n, r = e.d.length;
            if (r < 3)
                return e.isZero() ? e : X(t, 2, e, e);
            n = (n = 1.4 * Math.sqrt(r)) > 16 ? 16 : 0 | n,
            e = e.times(1 / q(5, n)),
            e = X(t, 2, e, e);
            for (var i, s = new t(5), o = new t(16), a = new t(20); n--; )
                i = e.times(e),
                e = e.times(s.plus(i.times(o.times(i).minus(a))));
            return e
        }(r, K(r, n)),
        r.precision = t,
        r.rounding = e,
        N(i > 2 ? n.neg() : n, t, e, !0)) : new r(NaN)
    }
    ,
    k.squareRoot = k.sqrt = function() {
        var t, e, n, r, i, s, o = this, a = o.d, l = o.e, c = o.s, u = o.constructor;
        if (1 !== c || !a || !a[0])
            return new u(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
        for (h = !1,
        0 == (c = Math.sqrt(+o)) || c == 1 / 0 ? (((e = I(a)).length + l) % 2 == 0 && (e += "0"),
        c = Math.sqrt(e),
        l = y((l + 1) / 2) - (l < 0 || l % 2),
        r = new u(e = c == 1 / 0 ? "5e" + l : (e = c.toExponential()).slice(0, e.indexOf("e") + 1) + l)) : r = new u(c.toString()),
        n = (l = u.precision) + 3; ; )
            if (r = (s = r).plus(O(o, s, n + 2, 1)).times(.5),
            I(s.d).slice(0, n) === (e = I(r.d)).slice(0, n)) {
                if ("9999" != (e = e.slice(n - 3, n + 1)) && (i || "4999" != e)) {
                    +e && (+e.slice(1) || "5" != e.charAt(0)) || (N(r, l + 1, 1),
                    t = !r.times(r).eq(o));
                    break
                }
                if (!i && (N(s, l + 1, 0),
                s.times(s).eq(o))) {
                    r = s;
                    break
                }
                n += 4,
                i = 1
            }
        return h = !0,
        N(r, l, u.rounding, t)
    }
    ,
    k.tangent = k.tan = function() {
        var t, e, n = this, r = n.constructor;
        return n.isFinite() ? n.isZero() ? new r(n) : (t = r.precision,
        e = r.rounding,
        r.precision = t + 10,
        r.rounding = 1,
        (n = n.sin()).s = 1,
        n = O(n, new r(1).minus(n.times(n)).sqrt(), t + 10, 0),
        r.precision = t,
        r.rounding = e,
        N(2 == i || 4 == i ? n.neg() : n, t, e, !0)) : new r(NaN)
    }
    ,
    k.times = k.mul = function(t) {
        var e, n, r, i, s, o, a, l, c, u = this, d = u.constructor, f = u.d, p = (t = new d(t)).d;
        if (t.s *= u.s,
        !(f && f[0] && p && p[0]))
            return new d(!t.s || f && !f[0] && !p || p && !p[0] && !f ? NaN : f && p ? 0 * t.s : t.s / 0);
        for (n = y(u.e / A) + y(t.e / A),
        (l = f.length) < (c = p.length) && (s = f,
        f = p,
        p = s,
        o = l,
        l = c,
        c = o),
        s = [],
        r = o = l + c; r--; )
            s.push(0);
        for (r = c; --r >= 0; ) {
            for (e = 0,
            i = l + r; i > r; )
                a = s[i] + p[r] * f[i - r - 1] + e,
                s[i--] = a % _ | 0,
                e = a / _ | 0;
            s[i] = (s[i] + e) % _ | 0
        }
        for (; !s[--o]; )
            s.pop();
        return e ? ++n : s.shift(),
        t.d = s,
        t.e = D(s, n),
        h ? N(t, d.precision, d.rounding) : t
    }
    ,
    k.toBinary = function(t, e) {
        return Q(this, 2, t, e)
    }
    ,
    k.toDecimalPlaces = k.toDP = function(t, e) {
        var n = this
          , r = n.constructor;
        return n = new r(n),
        void 0 === t ? n : (M(t, 0, o),
        void 0 === e ? e = r.rounding : M(e, 0, 8),
        N(n, t + n.e + 1, e))
    }
    ,
    k.toExponential = function(t, e) {
        var n, r = this, i = r.constructor;
        return void 0 === t ? n = R(r, !0) : (M(t, 0, o),
        void 0 === e ? e = i.rounding : M(e, 0, 8),
        n = R(r = N(new i(r), t + 1, e), !0, t + 1)),
        r.isNeg() && !r.isZero() ? "-" + n : n
    }
    ,
    k.toFixed = function(t, e) {
        var n, r, i = this, s = i.constructor;
        return void 0 === t ? n = R(i) : (M(t, 0, o),
        void 0 === e ? e = s.rounding : M(e, 0, 8),
        n = R(r = N(new s(i), t + i.e + 1, e), !1, t + r.e + 1)),
        i.isNeg() && !i.isZero() ? "-" + n : n
    }
    ,
    k.toFraction = function(t) {
        var e, n, r, i, s, o, a, l, c, u, d, p, m = this, g = m.d, y = m.constructor;
        if (!g)
            return new y(m);
        if (c = n = new y(1),
        r = l = new y(0),
        o = (s = (e = new y(r)).e = F(g) - m.e - 1) % A,
        e.d[0] = b(10, o < 0 ? A + o : o),
        null == t)
            t = s > 0 ? e : c;
        else {
            if (!(a = new y(t)).isInt() || a.lt(c))
                throw Error(f + a);
            t = a.gt(e) ? s > 0 ? e : c : a
        }
        for (h = !1,
        a = new y(I(g)),
        u = y.precision,
        y.precision = s = g.length * A * 2; d = O(a, e, 0, 1, 1),
        1 != (i = n.plus(d.times(r))).cmp(t); )
            n = r,
            r = i,
            i = c,
            c = l.plus(d.times(i)),
            l = i,
            i = e,
            e = a.minus(d.times(i)),
            a = i;
        return i = O(t.minus(n), r, 0, 1, 1),
        l = l.plus(i.times(c)),
        n = n.plus(i.times(r)),
        l.s = c.s = m.s,
        p = O(c, r, s, 1).minus(m).abs().cmp(O(l, n, s, 1).minus(m).abs()) < 1 ? [c, r] : [l, n],
        y.precision = u,
        h = !0,
        p
    }
    ,
    k.toHexadecimal = k.toHex = function(t, e) {
        return Q(this, 16, t, e)
    }
    ,
    k.toNearest = function(t, e) {
        var n = this
          , r = n.constructor;
        if (n = new r(n),
        null == t) {
            if (!n.d)
                return n;
            t = new r(1),
            e = r.rounding
        } else {
            if (t = new r(t),
            void 0 === e ? e = r.rounding : M(e, 0, 8),
            !n.d)
                return t.s ? n : t;
            if (!t.d)
                return t.s && (t.s = n.s),
                t
        }
        return t.d[0] ? (h = !1,
        n = O(n, t, 0, e, 1).times(t),
        h = !0,
        N(n)) : (t.s = n.s,
        n = t),
        n
    }
    ,
    k.toNumber = function() {
        return +this
    }
    ,
    k.toOctal = function(t, e) {
        return Q(this, 8, t, e)
    }
    ,
    k.toPower = k.pow = function(t) {
        var e, n, r, i, s, o, a = this, l = a.constructor, c = +(t = new l(t));
        if (!(a.d && t.d && a.d[0] && t.d[0]))
            return new l(b(+a, c));
        if ((a = new l(a)).eq(1))
            return a;
        if (r = l.precision,
        s = l.rounding,
        t.eq(1))
            return N(a, r, s);
        if ((e = y(t.e / A)) >= t.d.length - 1 && (n = c < 0 ? -c : c) <= 9007199254740991)
            return i = U(l, a, n, r),
            t.s < 0 ? new l(1).div(i) : N(i, r, s);
        if ((o = a.s) < 0) {
            if (e < t.d.length - 1)
                return new l(NaN);
            if (0 == (1 & t.d[e]) && (o = 1),
            0 == a.e && 1 == a.d[0] && 1 == a.d.length)
                return a.s = o,
                a
        }
        return (e = 0 != (n = b(+a, c)) && isFinite(n) ? new l(n + "").e : y(c * (Math.log("0." + I(a.d)) / Math.LN10 + a.e + 1))) > l.maxE + 1 || e < l.minE - 1 ? new l(e > 0 ? o / 0 : 0) : (h = !1,
        l.rounding = a.s = 1,
        n = Math.min(12, (e + "").length),
        (i = W(t.times(Y(a, r + n)), r)).d && C((i = N(i, r + 5, 1)).d, r, s) && (e = r + 10,
        +I((i = N(W(t.times(Y(a, e + n)), e), e + 5, 1)).d).slice(r + 1, r + 15) + 1 == 1e14 && (i = N(i, r + 1, 0))),
        i.s = o,
        h = !0,
        l.rounding = s,
        N(i, r, s))
    }
    ,
    k.toPrecision = function(t, e) {
        var n, r = this, i = r.constructor;
        return void 0 === t ? n = R(r, r.e <= i.toExpNeg || r.e >= i.toExpPos) : (M(t, 1, o),
        void 0 === e ? e = i.rounding : M(e, 0, 8),
        n = R(r = N(new i(r), t, e), t <= r.e || r.e <= i.toExpNeg, t)),
        r.isNeg() && !r.isZero() ? "-" + n : n
    }
    ,
    k.toSignificantDigits = k.toSD = function(t, e) {
        var n = this.constructor;
        return void 0 === t ? (t = n.precision,
        e = n.rounding) : (M(t, 1, o),
        void 0 === e ? e = n.rounding : M(e, 0, 8)),
        N(new n(this), t, e)
    }
    ,
    k.toString = function() {
        var t = this
          , e = t.constructor
          , n = R(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
        return t.isNeg() && !t.isZero() ? "-" + n : n
    }
    ,
    k.truncated = k.trunc = function() {
        return N(new this.constructor(this), this.e + 1, 1)
    }
    ,
    k.valueOf = k.toJSON = function() {
        var t = this
          , e = t.constructor
          , n = R(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
        return t.isNeg() ? "-" + n : n
    }
    ;
    var O = function() {
        function t(t, e, n) {
            var r, i = 0, s = t.length;
            for (t = t.slice(); s--; )
                r = t[s] * e + i,
                t[s] = r % n | 0,
                i = r / n | 0;
            return i && t.unshift(i),
            t
        }
        function e(t, e, n, r) {
            var i, s;
            if (n != r)
                s = n > r ? 1 : -1;
            else
                for (i = s = 0; i < n; i++)
                    if (t[i] != e[i]) {
                        s = t[i] > e[i] ? 1 : -1;
                        break
                    }
            return s
        }
        function r(t, e, n, r) {
            for (var i = 0; n--; )
                t[n] -= i,
                i = t[n] < e[n] ? 1 : 0,
                t[n] = i * r + t[n] - e[n];
            for (; !t[0] && t.length > 1; )
                t.shift()
        }
        return function(i, s, o, a, l, c) {
            var u, h, d, f, p, m, g, b, v, w, x, E, S, T, k, I, M, C, P, O, R = i.constructor, D = i.s == s.s ? 1 : -1, B = i.d, L = s.d;
            if (!(B && B[0] && L && L[0]))
                return new R(i.s && s.s && (B ? !L || B[0] != L[0] : L) ? B && 0 == B[0] || !L ? 0 * D : D / 0 : NaN);
            for (c ? (p = 1,
            h = i.e - s.e) : (c = _,
            p = A,
            h = y(i.e / p) - y(s.e / p)),
            P = L.length,
            M = B.length,
            w = (v = new R(D)).d = [],
            d = 0; L[d] == (B[d] || 0); d++)
                ;
            if (L[d] > (B[d] || 0) && h--,
            null == o ? (T = o = R.precision,
            a = R.rounding) : T = l ? o + (i.e - s.e) + 1 : o,
            T < 0)
                w.push(1),
                m = !0;
            else {
                if (T = T / p + 2 | 0,
                d = 0,
                1 == P) {
                    for (f = 0,
                    L = L[0],
                    T++; (d < M || f) && T--; d++)
                        k = f * c + (B[d] || 0),
                        w[d] = k / L | 0,
                        f = k % L | 0;
                    m = f || d < M
                } else {
                    for ((f = c / (L[0] + 1) | 0) > 1 && (L = t(L, f, c),
                    B = t(B, f, c),
                    P = L.length,
                    M = B.length),
                    I = P,
                    E = (x = B.slice(0, P)).length; E < P; )
                        x[E++] = 0;
                    (O = L.slice()).unshift(0),
                    C = L[0],
                    L[1] >= c / 2 && ++C;
                    do {
                        f = 0,
                        (u = e(L, x, P, E)) < 0 ? (S = x[0],
                        P != E && (S = S * c + (x[1] || 0)),
                        (f = S / C | 0) > 1 ? (f >= c && (f = c - 1),
                        1 == (u = e(g = t(L, f, c), x, b = g.length, E = x.length)) && (f--,
                        r(g, P < b ? O : L, b, c))) : (0 == f && (u = f = 1),
                        g = L.slice()),
                        (b = g.length) < E && g.unshift(0),
                        r(x, g, E, c),
                        -1 == u && (u = e(L, x, P, E = x.length)) < 1 && (f++,
                        r(x, P < E ? O : L, E, c)),
                        E = x.length) : 0 === u && (f++,
                        x = [0]),
                        w[d++] = f,
                        u && x[0] ? x[E++] = B[I] || 0 : (x = [B[I]],
                        E = 1)
                    } while ((I++ < M || void 0 !== x[0]) && T--);
                    m = void 0 !== x[0]
                }
                w[0] || w.shift()
            }
            if (1 == p)
                v.e = h,
                n = m;
            else {
                for (d = 1,
                f = w[0]; f >= 10; f /= 10)
                    d++;
                v.e = d + h * p - 1,
                N(v, l ? o + v.e + 1 : o, a, m)
            }
            return v
        }
    }();
    function N(t, e, n, r) {
        var i, s, o, a, l, c, u, d, f, p = t.constructor;
        t: if (null != e) {
            if (!(d = t.d))
                return t;
            for (i = 1,
            a = d[0]; a >= 10; a /= 10)
                i++;
            if ((s = e - i) < 0)
                s += A,
                o = e,
                l = (u = d[f = 0]) / b(10, i - o - 1) % 10 | 0;
            else if ((f = Math.ceil((s + 1) / A)) >= (a = d.length)) {
                if (!r)
                    break t;
                for (; a++ <= f; )
                    d.push(0);
                u = l = 0,
                i = 1,
                o = (s %= A) - A + 1
            } else {
                for (u = a = d[f],
                i = 1; a >= 10; a /= 10)
                    i++;
                l = (o = (s %= A) - A + i) < 0 ? 0 : u / b(10, i - o - 1) % 10 | 0
            }
            if (r = r || e < 0 || void 0 !== d[f + 1] || (o < 0 ? u : u % b(10, i - o - 1)),
            c = n < 4 ? (l || r) && (0 == n || n == (t.s < 0 ? 3 : 2)) : l > 5 || 5 == l && (4 == n || r || 6 == n && (s > 0 ? o > 0 ? u / b(10, i - o) : 0 : d[f - 1]) % 10 & 1 || n == (t.s < 0 ? 8 : 7)),
            e < 1 || !d[0])
                return d.length = 0,
                c ? (e -= t.e + 1,
                d[0] = b(10, (A - e % A) % A),
                t.e = -e || 0) : d[0] = t.e = 0,
                t;
            if (0 == s ? (d.length = f,
            a = 1,
            f--) : (d.length = f + 1,
            a = b(10, A - s),
            d[f] = o > 0 ? (u / b(10, i - o) % b(10, o) | 0) * a : 0),
            c)
                for (; ; ) {
                    if (0 == f) {
                        for (s = 1,
                        o = d[0]; o >= 10; o /= 10)
                            s++;
                        for (o = d[0] += a,
                        a = 1; o >= 10; o /= 10)
                            a++;
                        s != a && (t.e++,
                        d[0] == _ && (d[0] = 1));
                        break
                    }
                    if (d[f] += a,
                    d[f] != _)
                        break;
                    d[f--] = 0,
                    a = 1
                }
            for (s = d.length; 0 === d[--s]; )
                d.pop()
        }
        return h && (t.e > p.maxE ? (t.d = null,
        t.e = NaN) : t.e < p.minE && (t.e = 0,
        t.d = [0])),
        t
    }
    function R(t, e, n) {
        if (!t.isFinite())
            return H(t);
        var r, i = t.e, s = I(t.d), o = s.length;
        return e ? (n && (r = n - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + j(r) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)),
        s = s + (t.e < 0 ? "e" : "e+") + t.e) : i < 0 ? (s = "0." + j(-i - 1) + s,
        n && (r = n - o) > 0 && (s += j(r))) : i >= o ? (s += j(i + 1 - o),
        n && (r = n - i - 1) > 0 && (s = s + "." + j(r))) : ((r = i + 1) < o && (s = s.slice(0, r) + "." + s.slice(r)),
        n && (r = n - o) > 0 && (i + 1 === o && (s += "."),
        s += j(r))),
        s
    }
    function D(t, e) {
        var n = t[0];
        for (e *= A; n >= 10; n /= 10)
            e++;
        return e
    }
    function B(t, e, n) {
        if (e > S)
            throw h = !0,
            n && (t.precision = n),
            Error(p);
        return N(new t(l), e, 1, !0)
    }
    function L(t, e, n) {
        if (e > T)
            throw Error(p);
        return N(new t(c), e, n, !0)
    }
    function F(t) {
        var e = t.length - 1
          , n = e * A + 1;
        if (e = t[e]) {
            for (; e % 10 == 0; e /= 10)
                n--;
            for (e = t[0]; e >= 10; e /= 10)
                n++
        }
        return n
    }
    function j(t) {
        for (var e = ""; t--; )
            e += "0";
        return e
    }
    function U(t, e, n, r) {
        var i, s = new t(1), o = Math.ceil(r / A + 4);
        for (h = !1; ; ) {
            if (n % 2 && Z((s = s.times(e)).d, o) && (i = !0),
            0 === (n = y(n / 2))) {
                n = s.d.length - 1,
                i && 0 === s.d[n] && ++s.d[n];
                break
            }
            Z((e = e.times(e)).d, o)
        }
        return h = !0,
        s
    }
    function z(t) {
        return 1 & t.d[t.d.length - 1]
    }
    function V(t, e, n) {
        for (var r, i = new t(e[0]), s = 0; ++s < e.length; ) {
            if (!(r = new t(e[s])).s) {
                i = r;
                break
            }
            i[n](r) && (i = r)
        }
        return i
    }
    function W(t, e) {
        var n, r, i, s, o, a, l, c = 0, u = 0, d = 0, f = t.constructor, p = f.rounding, m = f.precision;
        if (!t.d || !t.d[0] || t.e > 17)
            return new f(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
        for (null == e ? (h = !1,
        l = m) : l = e,
        a = new f(.03125); t.e > -2; )
            t = t.times(a),
            d += 5;
        for (l += r = Math.log(b(2, d)) / Math.LN10 * 2 + 5 | 0,
        n = s = o = new f(1),
        f.precision = l; ; ) {
            if (s = N(s.times(t), l, 1),
            n = n.times(++u),
            I((a = o.plus(O(s, n, l, 1))).d).slice(0, l) === I(o.d).slice(0, l)) {
                for (i = d; i--; )
                    o = N(o.times(o), l, 1);
                if (null != e)
                    return f.precision = m,
                    o;
                if (!(c < 3 && C(o.d, l - r, p, c)))
                    return N(o, f.precision = m, p, h = !0);
                f.precision = l += 10,
                n = s = a = new f(1),
                u = 0,
                c++
            }
            o = a
        }
    }
    function Y(t, e) {
        var n, r, i, s, o, a, l, c, u, d, f, p = 1, m = t, g = m.d, y = m.constructor, b = y.rounding, v = y.precision;
        if (m.s < 0 || !g || !g[0] || !m.e && 1 == g[0] && 1 == g.length)
            return new y(g && !g[0] ? -1 / 0 : 1 != m.s ? NaN : g ? 0 : m);
        if (null == e ? (h = !1,
        u = v) : u = e,
        y.precision = u += 10,
        r = (n = I(g)).charAt(0),
        !(Math.abs(s = m.e) < 15e14))
            return c = B(y, u + 2, v).times(s + ""),
            m = Y(new y(r + "." + n.slice(1)), u - 10).plus(c),
            y.precision = v,
            null == e ? N(m, v, b, h = !0) : m;
        for (; r < 7 && 1 != r || 1 == r && n.charAt(1) > 3; )
            r = (n = I((m = m.times(t)).d)).charAt(0),
            p++;
        for (s = m.e,
        r > 1 ? (m = new y("0." + n),
        s++) : m = new y(r + "." + n.slice(1)),
        d = m,
        l = o = m = O(m.minus(1), m.plus(1), u, 1),
        f = N(m.times(m), u, 1),
        i = 3; ; ) {
            if (o = N(o.times(f), u, 1),
            I((c = l.plus(O(o, new y(i), u, 1))).d).slice(0, u) === I(l.d).slice(0, u)) {
                if (l = l.times(2),
                0 !== s && (l = l.plus(B(y, u + 2, v).times(s + ""))),
                l = O(l, new y(p), u, 1),
                null != e)
                    return y.precision = v,
                    l;
                if (!C(l.d, u - 10, b, a))
                    return N(l, y.precision = v, b, h = !0);
                y.precision = u += 10,
                c = o = m = O(d.minus(1), d.plus(1), u, 1),
                f = N(m.times(m), u, 1),
                i = a = 1
            }
            l = c,
            i += 2
        }
    }
    function H(t) {
        return String(t.s * t.s / 0)
    }
    function $(t, e) {
        var n, r, i;
        for ((n = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
        (r = e.search(/e/i)) > 0 ? (n < 0 && (n = r),
        n += +e.slice(r + 1),
        e = e.substring(0, r)) : n < 0 && (n = e.length),
        r = 0; 48 === e.charCodeAt(r); r++)
            ;
        for (i = e.length; 48 === e.charCodeAt(i - 1); --i)
            ;
        if (e = e.slice(r, i)) {
            if (i -= r,
            t.e = n = n - r - 1,
            t.d = [],
            r = (n + 1) % A,
            n < 0 && (r += A),
            r < i) {
                for (r && t.d.push(+e.slice(0, r)),
                i -= A; r < i; )
                    t.d.push(+e.slice(r, r += A));
                e = e.slice(r),
                r = A - e.length
            } else
                r -= i;
            for (; r--; )
                e += "0";
            t.d.push(+e),
            h && (t.e > t.constructor.maxE ? (t.d = null,
            t.e = NaN) : t.e < t.constructor.minE && (t.e = 0,
            t.d = [0]))
        } else
            t.e = 0,
            t.d = [0];
        return t
    }
    function G(t, n) {
        var r, i, s, o, a, l, c, u, d;
        if (n.indexOf("_") > -1) {
            if (n = n.replace(/(\d)_(?=\d)/g, "$1"),
            E.test(n))
                return $(t, n)
        } else if ("Infinity" === n || "NaN" === n)
            return +n || (t.s = NaN),
            t.e = NaN,
            t.d = null,
            t;
        if (w.test(n))
            r = 16,
            n = n.toLowerCase();
        else if (v.test(n))
            r = 2;
        else {
            if (!x.test(n))
                throw Error(f + n);
            r = 8
        }
        for ((o = n.search(/p/i)) > 0 ? (c = +n.slice(o + 1),
        n = n.substring(2, o)) : n = n.slice(2),
        a = (o = n.indexOf(".")) >= 0,
        i = t.constructor,
        a && (o = (l = (n = n.replace(".", "")).length) - o,
        s = U(i, new i(r), o, 2 * o)),
        o = d = (u = P(n, r, _)).length - 1; 0 === u[o]; --o)
            u.pop();
        return o < 0 ? new i(0 * t.s) : (t.e = D(u, d),
        t.d = u,
        h = !1,
        a && (t = O(t, s, 4 * l)),
        c && (t = t.times(Math.abs(c) < 54 ? b(2, c) : e.pow(2, c))),
        h = !0,
        t)
    }
    function X(t, e, n, r, i) {
        var s, o, a, l, c = t.precision, u = Math.ceil(c / A);
        for (h = !1,
        l = n.times(n),
        a = new t(r); ; ) {
            if (o = O(a.times(l), new t(e++ * e++), c, 1),
            a = i ? r.plus(o) : r.minus(o),
            r = O(o.times(l), new t(e++ * e++), c, 1),
            void 0 !== (o = a.plus(r)).d[u]) {
                for (s = u; o.d[s] === a.d[s] && s--; )
                    ;
                if (-1 == s)
                    break
            }
            s = a,
            a = r,
            r = o,
            o = s
        }
        return h = !0,
        o.d.length = u + 1,
        o
    }
    function q(t, e) {
        for (var n = t; --e; )
            n *= t;
        return n
    }
    function K(t, e) {
        var n, r = e.s < 0, s = L(t, t.precision, 1), o = s.times(.5);
        if ((e = e.abs()).lte(o))
            return i = r ? 4 : 1,
            e;
        if ((n = e.divToInt(s)).isZero())
            i = r ? 3 : 2;
        else {
            if ((e = e.minus(n.times(s))).lte(o))
                return i = z(n) ? r ? 2 : 3 : r ? 4 : 1,
                e;
            i = z(n) ? r ? 1 : 4 : r ? 3 : 2
        }
        return e.minus(s).abs()
    }
    function Q(t, e, r, i) {
        var s, l, c, u, h, d, f, p, m, g = t.constructor, y = void 0 !== r;
        if (y ? (M(r, 1, o),
        void 0 === i ? i = g.rounding : M(i, 0, 8)) : (r = g.precision,
        i = g.rounding),
        t.isFinite()) {
            for (y ? (s = 2,
            16 == e ? r = 4 * r - 3 : 8 == e && (r = 3 * r - 2)) : s = e,
            (c = (f = R(t)).indexOf(".")) >= 0 && (f = f.replace(".", ""),
            (m = new g(1)).e = f.length - c,
            m.d = P(R(m), 10, s),
            m.e = m.d.length),
            l = h = (p = P(f, 10, s)).length; 0 == p[--h]; )
                p.pop();
            if (p[0]) {
                if (c < 0 ? l-- : ((t = new g(t)).d = p,
                t.e = l,
                p = (t = O(t, m, r, i, 0, s)).d,
                l = t.e,
                d = n),
                c = p[r],
                u = s / 2,
                d = d || void 0 !== p[r + 1],
                d = i < 4 ? (void 0 !== c || d) && (0 === i || i === (t.s < 0 ? 3 : 2)) : c > u || c === u && (4 === i || d || 6 === i && 1 & p[r - 1] || i === (t.s < 0 ? 8 : 7)),
                p.length = r,
                d)
                    for (; ++p[--r] > s - 1; )
                        p[r] = 0,
                        r || (++l,
                        p.unshift(1));
                for (h = p.length; !p[h - 1]; --h)
                    ;
                for (c = 0,
                f = ""; c < h; c++)
                    f += a.charAt(p[c]);
                if (y) {
                    if (h > 1)
                        if (16 == e || 8 == e) {
                            for (c = 16 == e ? 4 : 3,
                            --h; h % c; h++)
                                f += "0";
                            for (h = (p = P(f, s, e)).length; !p[h - 1]; --h)
                                ;
                            for (c = 1,
                            f = "1."; c < h; c++)
                                f += a.charAt(p[c])
                        } else
                            f = f.charAt(0) + "." + f.slice(1);
                    f = f + (l < 0 ? "p" : "p+") + l
                } else if (l < 0) {
                    for (; ++l; )
                        f = "0" + f;
                    f = "0." + f
                } else if (++l > h)
                    for (l -= h; l--; )
                        f += "0";
                else
                    l < h && (f = f.slice(0, l) + "." + f.slice(l))
            } else
                f = y ? "0p+0" : "0";
            f = (16 == e ? "0x" : 2 == e ? "0b" : 8 == e ? "0o" : "") + f
        } else
            f = H(t);
        return t.s < 0 ? "-" + f : f
    }
    function Z(t, e) {
        if (t.length > e)
            return t.length = e,
            !0
    }
    function J(t) {
        return new this(t).abs()
    }
    function tt(t) {
        return new this(t).acos()
    }
    function et(t) {
        return new this(t).acosh()
    }
    function nt(t, e) {
        return new this(t).plus(e)
    }
    function rt(t) {
        return new this(t).asin()
    }
    function it(t) {
        return new this(t).asinh()
    }
    function st(t) {
        return new this(t).atan()
    }
    function ot(t) {
        return new this(t).atanh()
    }
    function at(t, e) {
        t = new this(t),
        e = new this(e);
        var n, r = this.precision, i = this.rounding, s = r + 4;
        return t.s && e.s ? t.d || e.d ? !e.d || t.isZero() ? (n = e.s < 0 ? L(this, r, i) : new this(0)).s = t.s : !t.d || e.isZero() ? (n = L(this, s, 1).times(.5)).s = t.s : e.s < 0 ? (this.precision = s,
        this.rounding = 1,
        n = this.atan(O(t, e, s, 1)),
        e = L(this, s, 1),
        this.precision = r,
        this.rounding = i,
        n = t.s < 0 ? n.minus(e) : n.plus(e)) : n = this.atan(O(t, e, s, 1)) : (n = L(this, s, 1).times(e.s > 0 ? .25 : .75)).s = t.s : n = new this(NaN),
        n
    }
    function lt(t) {
        return new this(t).cbrt()
    }
    function ct(t) {
        return N(t = new this(t), t.e + 1, 2)
    }
    function ut(t, e, n) {
        return new this(t).clamp(e, n)
    }
    function ht(t) {
        if (!t || "object" != typeof t)
            throw Error(d + "Object expected");
        var e, n, r, i = !0 === t.defaults, a = ["precision", 1, o, "rounding", 0, 8, "toExpNeg", -s, 0, "toExpPos", 0, s, "maxE", 0, s, "minE", -s, 0, "modulo", 0, 9];
        for (e = 0; e < a.length; e += 3)
            if (n = a[e],
            i && (this[n] = u[n]),
            void 0 !== (r = t[n])) {
                if (!(y(r) === r && r >= a[e + 1] && r <= a[e + 2]))
                    throw Error(f + n + ": " + r);
                this[n] = r
            }
        if (n = "crypto",
        i && (this[n] = u[n]),
        void 0 !== (r = t[n])) {
            if (!0 !== r && !1 !== r && 0 !== r && 1 !== r)
                throw Error(f + n + ": " + r);
            if (r) {
                if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                    throw Error(m);
                this[n] = !0
            } else
                this[n] = !1
        }
        return this
    }
    function dt(t) {
        return new this(t).cos()
    }
    function ft(t) {
        return new this(t).cosh()
    }
    function pt(t, e) {
        return new this(t).div(e)
    }
    function mt(t) {
        return new this(t).exp()
    }
    function gt(t) {
        return N(t = new this(t), t.e + 1, 3)
    }
    function yt() {
        var t, e, n = new this(0);
        for (h = !1,
        t = 0; t < arguments.length; )
            if ((e = new this(arguments[t++])).d)
                n.d && (n = n.plus(e.times(e)));
            else {
                if (e.s)
                    return h = !0,
                    new this(1 / 0);
                n = e
            }
        return h = !0,
        n.sqrt()
    }
    function bt(t) {
        return t instanceof e || t && t.toStringTag === g || !1
    }
    function vt(t) {
        return new this(t).ln()
    }
    function wt(t, e) {
        return new this(t).log(e)
    }
    function xt(t) {
        return new this(t).log(2)
    }
    function Et(t) {
        return new this(t).log(10)
    }
    function _t() {
        return V(this, arguments, "lt")
    }
    function At() {
        return V(this, arguments, "gt")
    }
    function St(t, e) {
        return new this(t).mod(e)
    }
    function Tt(t, e) {
        return new this(t).mul(e)
    }
    function kt(t, e) {
        return new this(t).pow(e)
    }
    function It(t) {
        var e, n, r, i, s = 0, a = new this(1), l = [];
        if (void 0 === t ? t = this.precision : M(t, 1, o),
        r = Math.ceil(t / A),
        this.crypto)
            if (crypto.getRandomValues)
                for (e = crypto.getRandomValues(new Uint32Array(r)); s < r; )
                    (i = e[s]) >= 429e7 ? e[s] = crypto.getRandomValues(new Uint32Array(1))[0] : l[s++] = i % 1e7;
            else {
                if (!crypto.randomBytes)
                    throw Error(m);
                for (e = crypto.randomBytes(r *= 4); s < r; )
                    (i = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((127 & e[s + 3]) << 24)) >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (l.push(i % 1e7),
                    s += 4);
                s = r / 4
            }
        else
            for (; s < r; )
                l[s++] = 1e7 * Math.random() | 0;
        for (r = l[--s],
        t %= A,
        r && t && (i = b(10, A - t),
        l[s] = (r / i | 0) * i); 0 === l[s]; s--)
            l.pop();
        if (s < 0)
            n = 0,
            l = [0];
        else {
            for (n = -1; 0 === l[0]; n -= A)
                l.shift();
            for (r = 1,
            i = l[0]; i >= 10; i /= 10)
                r++;
            r < A && (n -= A - r)
        }
        return a.e = n,
        a.d = l,
        a
    }
    function Mt(t) {
        return N(t = new this(t), t.e + 1, this.rounding)
    }
    function Ct(t) {
        return (t = new this(t)).d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN
    }
    function Pt(t) {
        return new this(t).sin()
    }
    function Ot(t) {
        return new this(t).sinh()
    }
    function Nt(t) {
        return new this(t).sqrt()
    }
    function Rt(t, e) {
        return new this(t).sub(e)
    }
    function Dt() {
        var t = 0
          , e = arguments
          , n = new this(e[t]);
        for (h = !1; n.s && ++t < e.length; )
            n = n.plus(e[t]);
        return h = !0,
        N(n, this.precision, this.rounding)
    }
    function Bt(t) {
        return new this(t).tan()
    }
    function Lt(t) {
        return new this(t).tanh()
    }
    function Ft(t) {
        return N(t = new this(t), t.e + 1, 1)
    }
    e = function t(e) {
        var n, r, i;
        function s(t) {
            var e, n, r, i = this;
            if (!(i instanceof s))
                return new s(t);
            if (i.constructor = s,
            bt(t))
                return i.s = t.s,
                void (h ? !t.d || t.e > s.maxE ? (i.e = NaN,
                i.d = null) : t.e < s.minE ? (i.e = 0,
                i.d = [0]) : (i.e = t.e,
                i.d = t.d.slice()) : (i.e = t.e,
                i.d = t.d ? t.d.slice() : t.d));
            if ("number" === (r = typeof t)) {
                if (0 === t)
                    return i.s = 1 / t < 0 ? -1 : 1,
                    i.e = 0,
                    void (i.d = [0]);
                if (t < 0 ? (t = -t,
                i.s = -1) : i.s = 1,
                t === ~~t && t < 1e7) {
                    for (e = 0,
                    n = t; n >= 10; n /= 10)
                        e++;
                    return void (h ? e > s.maxE ? (i.e = NaN,
                    i.d = null) : e < s.minE ? (i.e = 0,
                    i.d = [0]) : (i.e = e,
                    i.d = [t]) : (i.e = e,
                    i.d = [t]))
                }
                return 0 * t != 0 ? (t || (i.s = NaN),
                i.e = NaN,
                void (i.d = null)) : $(i, t.toString())
            }
            if ("string" !== r)
                throw Error(f + t);
            return 45 === (n = t.charCodeAt(0)) ? (t = t.slice(1),
            i.s = -1) : (43 === n && (t = t.slice(1)),
            i.s = 1),
            E.test(t) ? $(i, t) : G(i, t)
        }
        if (s.prototype = k,
        s.ROUND_UP = 0,
        s.ROUND_DOWN = 1,
        s.ROUND_CEIL = 2,
        s.ROUND_FLOOR = 3,
        s.ROUND_HALF_UP = 4,
        s.ROUND_HALF_DOWN = 5,
        s.ROUND_HALF_EVEN = 6,
        s.ROUND_HALF_CEIL = 7,
        s.ROUND_HALF_FLOOR = 8,
        s.EUCLID = 9,
        s.config = s.set = ht,
        s.clone = t,
        s.isDecimal = bt,
        s.abs = J,
        s.acos = tt,
        s.acosh = et,
        s.add = nt,
        s.asin = rt,
        s.asinh = it,
        s.atan = st,
        s.atanh = ot,
        s.atan2 = at,
        s.cbrt = lt,
        s.ceil = ct,
        s.clamp = ut,
        s.cos = dt,
        s.cosh = ft,
        s.div = pt,
        s.exp = mt,
        s.floor = gt,
        s.hypot = yt,
        s.ln = vt,
        s.log = wt,
        s.log10 = Et,
        s.log2 = xt,
        s.max = _t,
        s.min = At,
        s.mod = St,
        s.mul = Tt,
        s.pow = kt,
        s.random = It,
        s.round = Mt,
        s.sign = Ct,
        s.sin = Pt,
        s.sinh = Ot,
        s.sqrt = Nt,
        s.sub = Rt,
        s.sum = Dt,
        s.tan = Bt,
        s.tanh = Lt,
        s.trunc = Ft,
        void 0 === e && (e = {}),
        e && !0 !== e.defaults)
            for (i = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"],
            n = 0; n < i.length; )
                e.hasOwnProperty(r = i[n++]) || (e[r] = this[r]);
        return s.config(e),
        s
    }(u),
    e.prototype.constructor = e,
    e.default = e.Decimal = e,
    l = new e(l),
    c = new e(c),
    "function" == typeof define && define.amd ? define((function() {
        return e
    }
    )) : u_ ? ("function" == typeof Symbol && "symbol" == typeof Symbol.iterator && (k[Symbol.for("nodejs.util.inspect.custom")] = k.toString,
    k[Symbol.toStringTag] = "Decimal"),
    u_ = e) : (t || (t = "undefined" != typeof self && self && self.self == self ? self : window),
    r = t.Decimal,
    e.noConflict = function() {
        return t.Decimal = r,
        e
    }
    ,
    t.Decimal = e)
}(u_);
var h_ = {};
function d_(t) {
    if (void 0 === t)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}
function f_(t, e) {
    t.prototype = Object.create(e.prototype),
    t.prototype.constructor = t,
    t.__proto__ = e
}
/*!
 * GSAP 3.11.5
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
!function() {
    function t(t, e) {
        document.addEventListener ? t.addEventListener("scroll", e, !1) : t.attachEvent("scroll", e)
    }
    function e(t) {
        this.g = document.createElement("div"),
        this.g.setAttribute("aria-hidden", "true"),
        this.g.appendChild(document.createTextNode(t)),
        this.h = document.createElement("span"),
        this.i = document.createElement("span"),
        this.m = document.createElement("span"),
        this.j = document.createElement("span"),
        this.l = -1,
        this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
        this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
        this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",
        this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;",
        this.h.appendChild(this.m),
        this.i.appendChild(this.j),
        this.g.appendChild(this.h),
        this.g.appendChild(this.i)
    }
    function n(t, e) {
        t.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + e + ";"
    }
    function r(t) {
        var e = t.g.offsetWidth
          , n = e + 100;
        return t.j.style.width = n + "px",
        t.i.scrollLeft = n,
        t.h.scrollLeft = t.h.scrollWidth + 100,
        t.l !== e && (t.l = e,
        !0)
    }
    function i(e, n) {
        function i() {
            var t = s;
            r(t) && null !== t.g.parentNode && n(t.l)
        }
        var s = e;
        t(e.h, i),
        t(e.i, i),
        r(e)
    }
    function s(t, e, n) {
        e = e || {},
        n = n || window,
        this.family = t,
        this.style = e.style || "normal",
        this.weight = e.weight || "normal",
        this.stretch = e.stretch || "normal",
        this.context = n
    }
    var o = null
      , a = null
      , l = null
      , c = null;
    function u(t) {
        return null === c && (c = !!t.document.fonts),
        c
    }
    function h(t, e) {
        var n = t.style
          , r = t.weight;
        if (null === l) {
            var i = document.createElement("div");
            try {
                i.style.font = "condensed 100px sans-serif"
            } catch (t) {}
            l = "" !== i.style.font
        }
        return [n, r, l ? t.stretch : "", "100px", e].join(" ")
    }
    s.prototype.load = function(t, r) {
        var s = this
          , l = t || "BESbswy"
          , c = 0
          , d = r || 3e3
          , f = (new Date).getTime();
        return new Promise((function(t, r) {
            if (u(s.context) && !function(t) {
                return null === a && (u(t) && /Apple/.test(window.navigator.vendor) ? (t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent),
                a = !!t && 603 > parseInt(t[1], 10)) : a = !1),
                a
            }(s.context)) {
                var p = new Promise((function(t, e) {
                    !function n() {
                        (new Date).getTime() - f >= d ? e(Error(d + "ms timeout exceeded")) : s.context.document.fonts.load(h(s, '"' + s.family + '"'), l).then((function(e) {
                            1 <= e.length ? t() : setTimeout(n, 25)
                        }
                        ), e)
                    }()
                }
                ))
                  , m = new Promise((function(t, e) {
                    c = setTimeout((function() {
                        e(Error(d + "ms timeout exceeded"))
                    }
                    ), d)
                }
                ));
                Promise.race([m, p]).then((function() {
                    clearTimeout(c),
                    t(s)
                }
                ), r)
            } else
                !function(t) {
                    document.body ? t() : document.addEventListener ? document.addEventListener("DOMContentLoaded", (function e() {
                        document.removeEventListener("DOMContentLoaded", e),
                        t()
                    }
                    )) : document.attachEvent("onreadystatechange", (function e() {
                        "interactive" != document.readyState && "complete" != document.readyState || (document.detachEvent("onreadystatechange", e),
                        t())
                    }
                    ))
                }((function() {
                    function a() {
                        var e;
                        (e = -1 != g && -1 != y || -1 != g && -1 != b || -1 != y && -1 != b) && ((e = g != y && g != b && y != b) || (null === o && (e = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent),
                        o = !!e && (536 > parseInt(e[1], 10) || 536 === parseInt(e[1], 10) && 11 >= parseInt(e[2], 10))),
                        e = o && (g == v && y == v && b == v || g == w && y == w && b == w || g == x && y == x && b == x)),
                        e = !e),
                        e && (null !== E.parentNode && E.parentNode.removeChild(E),
                        clearTimeout(c),
                        t(s))
                    }
                    var u = new e(l)
                      , p = new e(l)
                      , m = new e(l)
                      , g = -1
                      , y = -1
                      , b = -1
                      , v = -1
                      , w = -1
                      , x = -1
                      , E = document.createElement("div");
                    E.dir = "ltr",
                    n(u, h(s, "sans-serif")),
                    n(p, h(s, "serif")),
                    n(m, h(s, "monospace")),
                    E.appendChild(u.g),
                    E.appendChild(p.g),
                    E.appendChild(m.g),
                    s.context.document.body.appendChild(E),
                    v = u.g.offsetWidth,
                    w = p.g.offsetWidth,
                    x = m.g.offsetWidth,
                    function t() {
                        if ((new Date).getTime() - f >= d)
                            null !== E.parentNode && E.parentNode.removeChild(E),
                            r(Error(d + "ms timeout exceeded"));
                        else {
                            var e = s.context.document.hidden;
                            !0 !== e && void 0 !== e || (g = u.g.offsetWidth,
                            y = p.g.offsetWidth,
                            b = m.g.offsetWidth,
                            a()),
                            c = setTimeout(t, 50)
                        }
                    }(),
                    i(u, (function(t) {
                        g = t,
                        a()
                    }
                    )),
                    n(u, h(s, '"' + s.family + '",sans-serif')),
                    i(p, (function(t) {
                        y = t,
                        a()
                    }
                    )),
                    n(p, h(s, '"' + s.family + '",serif')),
                    i(m, (function(t) {
                        b = t,
                        a()
                    }
                    )),
                    n(m, h(s, '"' + s.family + '",monospace'))
                }
                ))
        }
        ))
    }
    ,
    h_ = s
}();
var p_, m_, g_, y_, b_, v_, w_, x_, E_, __, A_, S_, T_, k_, I_, M_, C_, P_, O_, N_, R_, D_, B_, L_, F_, j_, U_, z_, V_, W_, Y_ = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, H_ = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, $_ = 1e8, G_ = 1e-8, X_ = 2 * Math.PI, q_ = X_ / 4, K_ = 0, Q_ = Math.sqrt, Z_ = Math.cos, J_ = Math.sin, tA = function(t) {
    return "string" == typeof t
}, eA = function(t) {
    return "function" == typeof t
}, nA = function(t) {
    return "number" == typeof t
}, rA = function(t) {
    return void 0 === t
}, iA = function(t) {
    return "object" == typeof t
}, sA = function(t) {
    return !1 !== t
}, oA = function() {
    return "undefined" != typeof window
}, aA = function(t) {
    return eA(t) || tA(t)
}, lA = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
, cA = Array.isArray, uA = /(?:-?\.?\d|\.)+/gi, hA = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, dA = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, fA = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, pA = /[+-]=-?[.\d]+/, mA = /[^,'"\[\]\s]+/gi, gA = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, yA = {}, bA = {}, vA = function(t) {
    return (bA = XA(t, yA)) && GT
}, wA = function(t, e) {
    return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
}, xA = function(t, e) {
    return !e && console.warn(t)
}, EA = function(t, e) {
    return t && (yA[t] = e) && bA && (bA[t] = e) || yA
}, _A = function() {
    return 0
}, AA = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, SA = {
    suppressEvents: !0,
    kill: !1
}, TA = {
    suppressEvents: !0
}, kA = {}, IA = [], MA = {}, CA = {}, PA = {}, OA = 30, NA = [], RA = "", DA = function(t) {
    var e, n, r = t[0];
    if (iA(r) || eA(r) || (t = [t]),
    !(e = (r._gsap || {}).harness)) {
        for (n = NA.length; n-- && !NA[n].targetTest(r); )
            ;
        e = NA[n]
    }
    for (n = t.length; n--; )
        t[n] && (t[n]._gsap || (t[n]._gsap = new lT(t[n],e))) || t.splice(n, 1);
    return t
}, BA = function(t) {
    return t._gsap || DA(SS(t))[0]._gsap
}, LA = function(t, e, n) {
    return (n = t[e]) && eA(n) ? t[e]() : rA(n) && t.getAttribute && t.getAttribute(e) || n
}, FA = function(t, e) {
    return (t = t.split(",")).forEach(e) || t
}, jA = function(t) {
    return Math.round(1e5 * t) / 1e5 || 0
}, UA = function(t) {
    return Math.round(1e7 * t) / 1e7 || 0
}, zA = function(t, e) {
    var n = e.charAt(0)
      , r = parseFloat(e.substr(2));
    return t = parseFloat(t),
    "+" === n ? t + r : "-" === n ? t - r : "*" === n ? t * r : t / r
}, VA = function(t, e) {
    for (var n = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < n; )
        ;
    return r < n
}, WA = function() {
    var t, e, n = IA.length, r = IA.slice(0);
    for (MA = {},
    IA.length = 0,
    t = 0; t < n; t++)
        (e = r[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
}, YA = function(t, e, n, r) {
    IA.length && !m_ && WA(),
    t.render(e, n, r || m_ && e < 0 && (t._initted || t._startAt)),
    IA.length && !m_ && WA()
}, HA = function(t) {
    var e = parseFloat(t);
    return (e || 0 === e) && (t + "").match(mA).length < 2 ? e : tA(t) ? t.trim() : t
}, $A = function(t) {
    return t
}, GA = function(t, e) {
    for (var n in e)
        n in t || (t[n] = e[n]);
    return t
}, XA = function(t, e) {
    for (var n in e)
        t[n] = e[n];
    return t
}, qA = function t(e, n) {
    for (var r in n)
        "__proto__" !== r && "constructor" !== r && "prototype" !== r && (e[r] = iA(n[r]) ? t(e[r] || (e[r] = {}), n[r]) : n[r]);
    return e
}, KA = function(t, e) {
    var n, r = {};
    for (n in t)
        n in e || (r[n] = t[n]);
    return r
}, QA = function(t) {
    var e, n = t.parent || y_, r = t.keyframes ? (e = cA(t.keyframes),
    function(t, n) {
        for (var r in n)
            r in t || "duration" === r && e || "ease" === r || (t[r] = n[r])
    }
    ) : GA;
    if (sA(t.inherit))
        for (; n; )
            r(t, n.vars.defaults),
            n = n.parent || n._dp;
    return t
}, ZA = function(t, e, n, r, i) {
    void 0 === n && (n = "_first"),
    void 0 === r && (r = "_last");
    var s, o = t[r];
    if (i)
        for (s = e[i]; o && o[i] > s; )
            o = o._prev;
    return o ? (e._next = o._next,
    o._next = e) : (e._next = t[n],
    t[n] = e),
    e._next ? e._next._prev = e : t[r] = e,
    e._prev = o,
    e.parent = e._dp = t,
    e
}, JA = function(t, e, n, r) {
    void 0 === n && (n = "_first"),
    void 0 === r && (r = "_last");
    var i = e._prev
      , s = e._next;
    i ? i._next = s : t[n] === e && (t[n] = s),
    s ? s._prev = i : t[r] === e && (t[r] = i),
    e._next = e._prev = e.parent = null
}, tS = function(t, e) {
    t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t),
    t._act = 0
}, eS = function(t, e) {
    if (t && (!e || e._end > t._dur || e._start < 0))
        for (var n = t; n; )
            n._dirty = 1,
            n = n.parent;
    return t
}, nS = function(t, e, n, r) {
    return t._startAt && (m_ ? t._startAt.revert(SA) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, r))
}, rS = function t(e) {
    return !e || e._ts && t(e.parent)
}, iS = function(t) {
    return t._repeat ? sS(t._tTime, t = t.duration() + t._rDelay) * t : 0
}, sS = function(t, e) {
    var n = Math.floor(t /= e);
    return t && n === t ? n - 1 : n
}, oS = function(t, e) {
    return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
}, aS = function(t) {
    return t._end = UA(t._start + (t._tDur / Math.abs(t._ts || t._rts || G_) || 0))
}, lS = function(t, e) {
    var n = t._dp;
    return n && n.smoothChildTiming && t._ts && (t._start = UA(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)),
    aS(t),
    n._dirty || eS(n, t)),
    t
}, cS = function(t, e) {
    var n;
    if ((e._time || e._initted && !e._dur) && (n = oS(t.rawTime(), e),
    (!e._dur || xS(0, e.totalDuration(), n) - e._tTime > G_) && e.render(n, !0)),
    eS(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
        if (t._dur < t.duration())
            for (n = t; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime),
                n = n._dp;
        t._zTime = -1e-8
    }
}, uS = function(t, e, n, r) {
    return e.parent && tS(e),
    e._start = UA((nA(n) ? n : n || t !== y_ ? bS(t, n, e) : t._time) + e._delay),
    e._end = UA(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
    ZA(t, e, "_first", "_last", t._sort ? "_start" : 0),
    pS(e) || (t._recent = e),
    r || cS(t, e),
    t._ts < 0 && lS(t, t._tTime),
    t
}, hS = function(t, e) {
    return (yA.ScrollTrigger || wA("scrollTrigger", e)) && yA.ScrollTrigger.create(e, t)
}, dS = function(t, e, n, r, i) {
    return gT(t, e, i),
    t._initted ? !n && t._pt && !m_ && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && E_ !== qS.frame ? (IA.push(t),
    t._lazy = [i, r],
    1) : void 0 : 1
}, fS = function t(e) {
    var n = e.parent;
    return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
}, pS = function(t) {
    var e = t.data;
    return "isFromStart" === e || "isStart" === e
}, mS = function(t, e, n, r) {
    var i = t._repeat
      , s = UA(e) || 0
      , o = t._tTime / t._tDur;
    return o && !r && (t._time *= s / t._dur),
    t._dur = s,
    t._tDur = i ? i < 0 ? 1e10 : UA(s * (i + 1) + t._rDelay * i) : s,
    o > 0 && !r && lS(t, t._tTime = t._tDur * o),
    t.parent && aS(t),
    n || eS(t.parent, t),
    t
}, gS = function(t) {
    return t instanceof uT ? eS(t) : mS(t, t._dur)
}, yS = {
    _start: 0,
    endTime: _A,
    totalDuration: _A
}, bS = function t(e, n, r) {
    var i, s, o, a = e.labels, l = e._recent || yS, c = e.duration() >= $_ ? l.endTime(!1) : e._dur;
    return tA(n) && (isNaN(n) || n in a) ? (s = n.charAt(0),
    o = "%" === n.substr(-1),
    i = n.indexOf("="),
    "<" === s || ">" === s ? (i >= 0 && (n = n.replace(/=/, "")),
    ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (o ? (i < 0 ? l : r).totalDuration() / 100 : 1)) : i < 0 ? (n in a || (a[n] = c),
    a[n]) : (s = parseFloat(n.charAt(i - 1) + n.substr(i + 1)),
    o && r && (s = s / 100 * (cA(r) ? r[0] : r).totalDuration()),
    i > 1 ? t(e, n.substr(0, i - 1), r) + s : c + s)) : null == n ? c : +n
}, vS = function(t, e, n) {
    var r, i, s = nA(e[1]), o = (s ? 2 : 1) + (t < 2 ? 0 : 1), a = e[o];
    if (s && (a.duration = e[1]),
    a.parent = n,
    t) {
        for (r = a,
        i = n; i && !("immediateRender"in r); )
            r = i.vars.defaults || {},
            i = sA(i.vars.inherit) && i.parent;
        a.immediateRender = sA(r.immediateRender),
        t < 2 ? a.runBackwards = 1 : a.startAt = e[o - 1]
    }
    return new xT(e[0],a,e[o + 1])
}, wS = function(t, e) {
    return t || 0 === t ? e(t) : e
}, xS = function(t, e, n) {
    return n < t ? t : n > e ? e : n
}, ES = function(t, e) {
    return tA(t) && (e = gA.exec(t)) ? e[1] : ""
}, _S = [].slice, AS = function(t, e) {
    return t && iA(t) && "length"in t && (!e && !t.length || t.length - 1 in t && iA(t[0])) && !t.nodeType && t !== b_
}, SS = function(t, e, n) {
    return g_ && !e && g_.selector ? g_.selector(t) : !tA(t) || n || !v_ && KS() ? cA(t) ? function(t, e, n) {
        return void 0 === n && (n = []),
        t.forEach((function(t) {
            var r;
            return tA(t) && !e || AS(t, 1) ? (r = n).push.apply(r, SS(t)) : n.push(t)
        }
        )) || n
    }(t, n) : AS(t) ? _S.call(t, 0) : t ? [t] : [] : _S.call((e || w_).querySelectorAll(t), 0)
}, TS = function(t) {
    return t = SS(t)[0] || xA("Invalid scope") || {},
    function(e) {
        var n = t.current || t.nativeElement || t;
        return SS(e, n.querySelectorAll ? n : n === t ? xA("Invalid scope") || w_.createElement("div") : t)
    }
}, kS = function(t) {
    return t.sort((function() {
        return .5 - Math.random()
    }
    ))
}, IS = function(t) {
    if (eA(t))
        return t;
    var e = iA(t) ? t : {
        each: t
    }
      , n = rT(e.ease)
      , r = e.from || 0
      , i = parseFloat(e.base) || 0
      , s = {}
      , o = r > 0 && r < 1
      , a = isNaN(r) || o
      , l = e.axis
      , c = r
      , u = r;
    return tA(r) ? c = u = {
        center: .5,
        edges: .5,
        end: 1
    }[r] || 0 : !o && a && (c = r[0],
    u = r[1]),
    function(t, o, h) {
        var d, f, p, m, g, y, b, v, w, x = (h || e).length, E = s[x];
        if (!E) {
            if (!(w = "auto" === e.grid ? 0 : (e.grid || [1, $_])[1])) {
                for (b = -1e8; b < (b = h[w++].getBoundingClientRect().left) && w < x; )
                    ;
                w--
            }
            for (E = s[x] = [],
            d = a ? Math.min(w, x) * c - .5 : r % w,
            f = w === $_ ? 0 : a ? x * u / w - .5 : r / w | 0,
            b = 0,
            v = $_,
            y = 0; y < x; y++)
                p = y % w - d,
                m = f - (y / w | 0),
                E[y] = g = l ? Math.abs("y" === l ? m : p) : Q_(p * p + m * m),
                g > b && (b = g),
                g < v && (v = g);
            "random" === r && kS(E),
            E.max = b - v,
            E.min = v,
            E.v = x = (parseFloat(e.amount) || parseFloat(e.each) * (w > x ? x - 1 : l ? "y" === l ? x / w : w : Math.max(w, x / w)) || 0) * ("edges" === r ? -1 : 1),
            E.b = x < 0 ? i - x : i,
            E.u = ES(e.amount || e.each) || 0,
            n = n && x < 0 ? eT(n) : n
        }
        return x = (E[t] - E.min) / E.max || 0,
        UA(E.b + (n ? n(x) : x) * E.v) + E.u
    }
}, MS = function(t) {
    var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
    return function(n) {
        var r = UA(Math.round(parseFloat(n) / t) * t * e);
        return (r - r % 1) / e + (nA(n) ? 0 : ES(n))
    }
}, CS = function(t, e) {
    var n, r, i = cA(t);
    return !i && iA(t) && (n = i = t.radius || $_,
    t.values ? (t = SS(t.values),
    (r = !nA(t[0])) && (n *= n)) : t = MS(t.increment)),
    wS(e, i ? eA(t) ? function(e) {
        return r = t(e),
        Math.abs(r - e) <= n ? r : e
    }
    : function(e) {
        for (var i, s, o = parseFloat(r ? e.x : e), a = parseFloat(r ? e.y : 0), l = $_, c = 0, u = t.length; u--; )
            (i = r ? (i = t[u].x - o) * i + (s = t[u].y - a) * s : Math.abs(t[u] - o)) < l && (l = i,
            c = u);
        return c = !n || l <= n ? t[c] : e,
        r || c === e || nA(e) ? c : c + ES(e)
    }
    : MS(t))
}, PS = function(t, e, n, r) {
    return wS(cA(t) ? !e : !0 === n ? (n = 0,
    !1) : !r, (function() {
        return cA(t) ? t[~~(Math.random() * t.length)] : (r = (n = n || 1e-5) < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * r) / r
    }
    ))
}, OS = function(t, e, n) {
    return wS(n, (function(n) {
        return t[~~e(n)]
    }
    ))
}, NS = function(t) {
    for (var e, n, r, i, s = 0, o = ""; ~(e = t.indexOf("random(", s)); )
        r = t.indexOf(")", e),
        i = "[" === t.charAt(e + 7),
        n = t.substr(e + 7, r - e - 7).match(i ? mA : uA),
        o += t.substr(s, e - s) + PS(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5),
        s = r + 1;
    return o + t.substr(s, t.length - s)
}, RS = function(t, e, n, r, i) {
    var s = e - t
      , o = r - n;
    return wS(i, (function(e) {
        return n + ((e - t) / s * o || 0)
    }
    ))
}, DS = function(t, e, n) {
    var r, i, s, o = t.labels, a = $_;
    for (r in o)
        (i = o[r] - e) < 0 == !!n && i && a > (i = Math.abs(i)) && (s = r,
        a = i);
    return s
}, BS = function(t, e, n) {
    var r, i, s, o = t.vars, a = o[e], l = g_, c = t._ctx;
    if (a)
        return r = o[e + "Params"],
        i = o.callbackScope || t,
        n && IA.length && WA(),
        c && (g_ = c),
        s = r ? a.apply(i, r) : a.call(i),
        g_ = l,
        s
}, LS = function(t) {
    return tS(t),
    t.scrollTrigger && t.scrollTrigger.kill(!!m_),
    t.progress() < 1 && BS(t, "onInterrupt"),
    t
}, FS = [], jS = function(t) {
    if (oA()) {
        var e = (t = !t.name && t.default || t).name
          , n = eA(t)
          , r = e && !n && t.init ? function() {
            this._props = []
        }
        : t
          , i = {
            init: _A,
            render: CT,
            add: pT,
            kill: OT,
            modifier: PT,
            rawVars: 0
        }
          , s = {
            targetTest: 0,
            get: 0,
            getSetter: TT,
            aliases: {},
            register: 0
        };
        if (KS(),
        t !== r) {
            if (CA[e])
                return;
            GA(r, GA(KA(t, i), s)),
            XA(r.prototype, XA(i, KA(t, s))),
            CA[r.prop = e] = r,
            t.targetTest && (NA.push(r),
            kA[e] = 1),
            e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
        }
        EA(e, r),
        t.register && t.register(GT, r, DT)
    } else
        FS.push(t)
}, US = 255, zS = {
    aqua: [0, US, US],
    lime: [0, US, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, US],
    navy: [0, 0, 128],
    white: [US, US, US],
    olive: [128, 128, 0],
    yellow: [US, US, 0],
    orange: [US, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [US, 0, 0],
    pink: [US, 192, 203],
    cyan: [0, US, US],
    transparent: [US, US, US, 0]
}, VS = function(t, e, n) {
    return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * US + .5 | 0
}, WS = function(t, e, n) {
    var r, i, s, o, a, l, c, u, h, d, f = t ? nA(t) ? [t >> 16, t >> 8 & US, t & US] : 0 : zS.black;
    if (!f) {
        if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)),
        zS[t])
            f = zS[t];
        else if ("#" === t.charAt(0)) {
            if (t.length < 6 && (r = t.charAt(1),
            i = t.charAt(2),
            s = t.charAt(3),
            t = "#" + r + r + i + i + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")),
            9 === t.length)
                return [(f = parseInt(t.substr(1, 6), 16)) >> 16, f >> 8 & US, f & US, parseInt(t.substr(7), 16) / 255];
            f = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & US, t & US]
        } else if ("hsl" === t.substr(0, 3))
            if (f = d = t.match(uA),
            e) {
                if (~t.indexOf("="))
                    return f = t.match(hA),
                    n && f.length < 4 && (f[3] = 1),
                    f
            } else
                o = +f[0] % 360 / 360,
                a = +f[1] / 100,
                r = 2 * (l = +f[2] / 100) - (i = l <= .5 ? l * (a + 1) : l + a - l * a),
                f.length > 3 && (f[3] *= 1),
                f[0] = VS(o + 1 / 3, r, i),
                f[1] = VS(o, r, i),
                f[2] = VS(o - 1 / 3, r, i);
        else
            f = t.match(uA) || zS.transparent;
        f = f.map(Number)
    }
    return e && !d && (r = f[0] / US,
    i = f[1] / US,
    s = f[2] / US,
    l = ((c = Math.max(r, i, s)) + (u = Math.min(r, i, s))) / 2,
    c === u ? o = a = 0 : (h = c - u,
    a = l > .5 ? h / (2 - c - u) : h / (c + u),
    o = c === r ? (i - s) / h + (i < s ? 6 : 0) : c === i ? (s - r) / h + 2 : (r - i) / h + 4,
    o *= 60),
    f[0] = ~~(o + .5),
    f[1] = ~~(100 * a + .5),
    f[2] = ~~(100 * l + .5)),
    n && f.length < 4 && (f[3] = 1),
    f
}, YS = function(t) {
    var e = []
      , n = []
      , r = -1;
    return t.split($S).forEach((function(t) {
        var i = t.match(dA) || [];
        e.push.apply(e, i),
        n.push(r += i.length + 1)
    }
    )),
    e.c = n,
    e
}, HS = function(t, e, n) {
    var r, i, s, o, a = "", l = (t + a).match($S), c = e ? "hsla(" : "rgba(", u = 0;
    if (!l)
        return t;
    if (l = l.map((function(t) {
        return (t = WS(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
    }
    )),
    n && (s = YS(t),
    (r = n.c).join(a) !== s.c.join(a)))
        for (o = (i = t.replace($S, "1").split(dA)).length - 1; u < o; u++)
            a += i[u] + (~r.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
    if (!i)
        for (o = (i = t.split($S)).length - 1; u < o; u++)
            a += i[u] + l[u];
    return a + i[o]
}, $S = function() {
    var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
    for (t in zS)
        e += "|" + t + "\\b";
    return new RegExp(e + ")","gi")
}(), GS = /hsl[a]?\(/, XS = function(t) {
    var e, n = t.join(" ");
    if ($S.lastIndex = 0,
    $S.test(n))
        return e = GS.test(n),
        t[1] = HS(t[1], e),
        t[0] = HS(t[0], e, YS(t[1])),
        !0
}, qS = (P_ = Date.now,
O_ = 500,
N_ = 33,
R_ = P_(),
D_ = R_,
L_ = B_ = 1e3 / 240,
j_ = function t(e) {
    var n, r, i, s, o = P_() - D_, a = !0 === e;
    if (o > O_ && (R_ += o - N_),
    ((n = (i = (D_ += o) - R_) - L_) > 0 || a) && (s = ++I_.frame,
    M_ = i - 1e3 * I_.time,
    I_.time = i /= 1e3,
    L_ += n + (n >= B_ ? 4 : B_ - n),
    r = 1),
    a || (S_ = T_(t)),
    r)
        for (C_ = 0; C_ < F_.length; C_++)
            F_[C_](i, M_, s, e)
}
,
I_ = {
    time: 0,
    frame: 0,
    tick: function() {
        j_(!0)
    },
    deltaRatio: function(t) {
        return M_ / (1e3 / (t || 60))
    },
    wake: function() {
        x_ && (!v_ && oA() && (b_ = v_ = window,
        w_ = b_.document || {},
        yA.gsap = GT,
        (b_.gsapVersions || (b_.gsapVersions = [])).push(GT.version),
        vA(bA || b_.GreenSockGlobals || !b_.gsap && b_ || {}),
        k_ = b_.requestAnimationFrame,
        FS.forEach(jS)),
        S_ && I_.sleep(),
        T_ = k_ || function(t) {
            return setTimeout(t, L_ - 1e3 * I_.time + 1 | 0)
        }
        ,
        A_ = 1,
        j_(2))
    },
    sleep: function() {
        (k_ ? b_.cancelAnimationFrame : clearTimeout)(S_),
        A_ = 0,
        T_ = _A
    },
    lagSmoothing: function(t, e) {
        O_ = t || 1 / 0,
        N_ = Math.min(e || 33, O_)
    },
    fps: function(t) {
        B_ = 1e3 / (t || 240),
        L_ = 1e3 * I_.time + B_
    },
    add: function(t, e, n) {
        var r = e ? function(e, n, i, s) {
            t(e, n, i, s),
            I_.remove(r)
        }
        : t;
        return I_.remove(t),
        F_[n ? "unshift" : "push"](r),
        KS(),
        r
    },
    remove: function(t, e) {
        ~(e = F_.indexOf(t)) && F_.splice(e, 1) && C_ >= e && C_--
    },
    _listeners: F_ = []
}), KS = function() {
    return !A_ && qS.wake()
}, QS = {}, ZS = /^[\d.\-M][\d.\-,\s]/, JS = /["']/g, tT = function(t) {
    for (var e, n, r, i = {}, s = t.substr(1, t.length - 3).split(":"), o = s[0], a = 1, l = s.length; a < l; a++)
        n = s[a],
        e = a !== l - 1 ? n.lastIndexOf(",") : n.length,
        r = n.substr(0, e),
        i[o] = isNaN(r) ? r.replace(JS, "").trim() : +r,
        o = n.substr(e + 1).trim();
    return i
}, eT = function(t) {
    return function(e) {
        return 1 - t(1 - e)
    }
}, nT = function t(e, n) {
    for (var r, i = e._first; i; )
        i instanceof uT ? t(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? t(i.timeline, n) : (r = i._ease,
        i._ease = i._yEase,
        i._yEase = r,
        i._yoyo = n)),
        i = i._next
}, rT = function(t, e) {
    return t && (eA(t) ? t : QS[t] || function(t) {
        var e, n, r, i, s = (t + "").split("("), o = QS[s[0]];
        return o && s.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [tT(s[1])] : (e = t,
        n = e.indexOf("(") + 1,
        r = e.indexOf(")"),
        i = e.indexOf("(", n),
        e.substring(n, ~i && i < r ? e.indexOf(")", r + 1) : r)).split(",").map(HA)) : QS._CE && ZS.test(t) ? QS._CE("", t) : o
    }(t)) || e
}, iT = function(t, e, n, r) {
    void 0 === n && (n = function(t) {
        return 1 - e(1 - t)
    }
    ),
    void 0 === r && (r = function(t) {
        return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
    }
    );
    var i, s = {
        easeIn: e,
        easeOut: n,
        easeInOut: r
    };
    return FA(t, (function(t) {
        for (var e in QS[t] = yA[t] = s,
        QS[i = t.toLowerCase()] = n,
        s)
            QS[i + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = QS[t + "." + e] = s[e]
    }
    )),
    s
}, sT = function(t) {
    return function(e) {
        return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
    }
}, oT = function t(e, n, r) {
    var i = n >= 1 ? n : 1
      , s = (r || (e ? .3 : .45)) / (n < 1 ? n : 1)
      , o = s / X_ * (Math.asin(1 / i) || 0)
      , a = function(t) {
        return 1 === t ? 1 : i * Math.pow(2, -10 * t) * J_((t - o) * s) + 1
    }
      , l = "out" === e ? a : "in" === e ? function(t) {
        return 1 - a(1 - t)
    }
    : sT(a);
    return s = X_ / s,
    l.config = function(n, r) {
        return t(e, n, r)
    }
    ,
    l
}, aT = function t(e, n) {
    void 0 === n && (n = 1.70158);
    var r = function(t) {
        return t ? --t * t * ((n + 1) * t + n) + 1 : 0
    }
      , i = "out" === e ? r : "in" === e ? function(t) {
        return 1 - r(1 - t)
    }
    : sT(r);
    return i.config = function(n) {
        return t(e, n)
    }
    ,
    i
};
FA("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
    var n = e < 5 ? e + 1 : e;
    iT(t + ",Power" + (n - 1), e ? function(t) {
        return Math.pow(t, n)
    }
    : function(t) {
        return t
    }
    , (function(t) {
        return 1 - Math.pow(1 - t, n)
    }
    ), (function(t) {
        return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
    }
    ))
}
)),
QS.Linear.easeNone = QS.none = QS.Linear.easeIn,
iT("Elastic", oT("in"), oT("out"), oT()),
U_ = 7.5625,
V_ = 1 / (z_ = 2.75),
iT("Bounce", (function(t) {
    return 1 - W_(1 - t)
}
), W_ = function(t) {
    return t < V_ ? U_ * t * t : t < .7272727272727273 ? U_ * Math.pow(t - 1.5 / z_, 2) + .75 : t < .9090909090909092 ? U_ * (t -= 2.25 / z_) * t + .9375 : U_ * Math.pow(t - 2.625 / z_, 2) + .984375
}
),
iT("Expo", (function(t) {
    return t ? Math.pow(2, 10 * (t - 1)) : 0
}
)),
iT("Circ", (function(t) {
    return -(Q_(1 - t * t) - 1)
}
)),
iT("Sine", (function(t) {
    return 1 === t ? 1 : 1 - Z_(t * q_)
}
)),
iT("Back", aT("in"), aT("out"), aT()),
QS.SteppedEase = QS.steps = yA.SteppedEase = {
    config: function(t, e) {
        void 0 === t && (t = 1);
        var n = 1 / t
          , r = t + (e ? 0 : 1)
          , i = e ? 1 : 0;
        return function(t) {
            return ((r * xS(0, .99999999, t) | 0) + i) * n
        }
    }
},
H_.ease = QS["quad.out"],
FA("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
    return RA += t + "," + t + "Params,"
}
));
var lT = function(t, e) {
    this.id = K_++,
    t._gsap = this,
    this.target = t,
    this.harness = e,
    this.get = e ? e.get : LA,
    this.set = e ? e.getSetter : TT
}
  , cT = function() {
    function t(t) {
        this.vars = t,
        this._delay = +t.delay || 0,
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
        this._yoyo = !!t.yoyo || !!t.yoyoEase),
        this._ts = 1,
        mS(this, +t.duration, 1, 1),
        this.data = t.data,
        g_ && (this._ctx = g_,
        g_.data.push(this)),
        A_ || qS.wake()
    }
    var e = t.prototype;
    return e.delay = function(t) {
        return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay),
        this._delay = t,
        this) : this._delay
    }
    ,
    e.duration = function(t) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
    }
    ,
    e.totalDuration = function(t) {
        return arguments.length ? (this._dirty = 0,
        mS(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    e.totalTime = function(t, e) {
        if (KS(),
        !arguments.length)
            return this._tTime;
        var n = this._dp;
        if (n && n.smoothChildTiming && this._ts) {
            for (lS(this, t),
            !n._dp || n.parent || cS(n, this); n && n.parent; )
                n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0),
                n = n.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && uS(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === G_ || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t),
        YA(this, t, e)),
        this
    }
    ,
    e.time = function(t, e) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + iS(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
    }
    ,
    e.totalProgress = function(t, e) {
        return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
    }
    ,
    e.progress = function(t, e) {
        return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + iS(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
    }
    ,
    e.iteration = function(t, e) {
        var n = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? sS(this._tTime, n) + 1 : 1
    }
    ,
    e.timeScale = function(t) {
        if (!arguments.length)
            return -1e-8 === this._rts ? 0 : this._rts;
        if (this._rts === t)
            return this;
        var e = this.parent && this._ts ? oS(this.parent._time, this) : this._tTime;
        return this._rts = +t || 0,
        this._ts = this._ps || -1e-8 === t ? 0 : this._rts,
        this.totalTime(xS(-Math.abs(this._delay), this._tDur, e), !0),
        aS(this),
        function(t) {
            for (var e = t.parent; e && e.parent; )
                e._dirty = 1,
                e.totalDuration(),
                e = e.parent;
            return t
        }(this)
    }
    ,
    e.paused = function(t) {
        return arguments.length ? (this._ps !== t && (this._ps = t,
        t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (KS(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== G_ && (this._tTime -= G_)))),
        this) : this._ps
    }
    ,
    e.startTime = function(t) {
        if (arguments.length) {
            this._start = t;
            var e = this.parent || this._dp;
            return e && (e._sort || !this.parent) && uS(e, this, t - this._delay),
            this
        }
        return this._start
    }
    ,
    e.endTime = function(t) {
        return this._start + (sA(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    e.rawTime = function(t) {
        var e = this.parent || this._dp;
        return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? oS(e.rawTime(t), this) : this._tTime : this._tTime
    }
    ,
    e.revert = function(t) {
        void 0 === t && (t = TA);
        var e = m_;
        return m_ = t,
        (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t),
        this.totalTime(-.01, t.suppressEvents)),
        "nested" !== this.data && !1 !== t.kill && this.kill(),
        m_ = e,
        this
    }
    ,
    e.globalTime = function(t) {
        for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
            n = e._start + n / (e._ts || 1),
            e = e._dp;
        return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(t) : n
    }
    ,
    e.repeat = function(t) {
        return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t,
        gS(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
    }
    ,
    e.repeatDelay = function(t) {
        if (arguments.length) {
            var e = this._time;
            return this._rDelay = t,
            gS(this),
            e ? this.time(e) : this
        }
        return this._rDelay
    }
    ,
    e.yoyo = function(t) {
        return arguments.length ? (this._yoyo = t,
        this) : this._yoyo
    }
    ,
    e.seek = function(t, e) {
        return this.totalTime(bS(this, t), sA(e))
    }
    ,
    e.restart = function(t, e) {
        return this.play().totalTime(t ? -this._delay : 0, sA(e))
    }
    ,
    e.play = function(t, e) {
        return null != t && this.seek(t, e),
        this.reversed(!1).paused(!1)
    }
    ,
    e.reverse = function(t, e) {
        return null != t && this.seek(t || this.totalDuration(), e),
        this.reversed(!0).paused(!1)
    }
    ,
    e.pause = function(t, e) {
        return null != t && this.seek(t, e),
        this.paused(!0)
    }
    ,
    e.resume = function() {
        return this.paused(!1)
    }
    ,
    e.reversed = function(t) {
        return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)),
        this) : this._rts < 0
    }
    ,
    e.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -1e-8,
        this
    }
    ,
    e.isActive = function() {
        var t, e = this.parent || this._dp, n = this._start;
        return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - G_))
    }
    ,
    e.eventCallback = function(t, e, n) {
        var r = this.vars;
        return arguments.length > 1 ? (e ? (r[t] = e,
        n && (r[t + "Params"] = n),
        "onUpdate" === t && (this._onUpdate = e)) : delete r[t],
        this) : r[t]
    }
    ,
    e.then = function(t) {
        var e = this;
        return new Promise((function(n) {
            var r = eA(t) ? t : $A
              , i = function() {
                var t = e.then;
                e.then = null,
                eA(r) && (r = r(e)) && (r.then || r === e) && (e.then = t),
                n(r),
                e.then = t
            };
            e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? i() : e._prom = i
        }
        ))
    }
    ,
    e.kill = function() {
        LS(this)
    }
    ,
    t
}();
GA(cT.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var uT = function(t) {
    function e(e, n) {
        var r;
        return void 0 === e && (e = {}),
        (r = t.call(this, e) || this).labels = {},
        r.smoothChildTiming = !!e.smoothChildTiming,
        r.autoRemoveChildren = !!e.autoRemoveChildren,
        r._sort = sA(e.sortChildren),
        y_ && uS(e.parent || y_, d_(r), n),
        e.reversed && r.reverse(),
        e.paused && r.paused(!0),
        e.scrollTrigger && hS(d_(r), e.scrollTrigger),
        r
    }
    f_(e, t);
    var n = e.prototype;
    return n.to = function(t, e, n) {
        return vS(0, arguments, this),
        this
    }
    ,
    n.from = function(t, e, n) {
        return vS(1, arguments, this),
        this
    }
    ,
    n.fromTo = function(t, e, n, r) {
        return vS(2, arguments, this),
        this
    }
    ,
    n.set = function(t, e, n) {
        return e.duration = 0,
        e.parent = this,
        QA(e).repeatDelay || (e.repeat = 0),
        e.immediateRender = !!e.immediateRender,
        new xT(t,e,bS(this, n),1),
        this
    }
    ,
    n.call = function(t, e, n) {
        return uS(this, xT.delayedCall(0, t, e), n)
    }
    ,
    n.staggerTo = function(t, e, n, r, i, s, o) {
        return n.duration = e,
        n.stagger = n.stagger || r,
        n.onComplete = s,
        n.onCompleteParams = o,
        n.parent = this,
        new xT(t,n,bS(this, i)),
        this
    }
    ,
    n.staggerFrom = function(t, e, n, r, i, s, o) {
        return n.runBackwards = 1,
        QA(n).immediateRender = sA(n.immediateRender),
        this.staggerTo(t, e, n, r, i, s, o)
    }
    ,
    n.staggerFromTo = function(t, e, n, r, i, s, o, a) {
        return r.startAt = n,
        QA(r).immediateRender = sA(r.immediateRender),
        this.staggerTo(t, e, r, i, s, o, a)
    }
    ,
    n.render = function(t, e, n) {
        var r, i, s, o, a, l, c, u, h, d, f, p, m = this._time, g = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, b = t <= 0 ? 0 : UA(t), v = this._zTime < 0 != t < 0 && (this._initted || !y);
        if (this !== y_ && b > g && t >= 0 && (b = g),
        b !== this._tTime || n || v) {
            if (m !== this._time && y && (b += this._time - m,
            t += this._time - m),
            r = b,
            h = this._start,
            l = !(u = this._ts),
            v && (y || (m = this._zTime),
            (t || !e) && (this._zTime = t)),
            this._repeat) {
                if (f = this._yoyo,
                a = y + this._rDelay,
                this._repeat < -1 && t < 0)
                    return this.totalTime(100 * a + t, e, n);
                if (r = UA(b % a),
                b === g ? (o = this._repeat,
                r = y) : ((o = ~~(b / a)) && o === b / a && (r = y,
                o--),
                r > y && (r = y)),
                d = sS(this._tTime, a),
                !m && this._tTime && d !== o && this._tTime - d * a - this._dur <= 0 && (d = o),
                f && 1 & o && (r = y - r,
                p = 1),
                o !== d && !this._lock) {
                    var w = f && 1 & d
                      , x = w === (f && 1 & o);
                    if (o < d && (w = !w),
                    m = w ? 0 : y,
                    this._lock = 1,
                    this.render(m || (p ? 0 : UA(o * a)), e, !y)._lock = 0,
                    this._tTime = b,
                    !e && this.parent && BS(this, "onRepeat"),
                    this.vars.repeatRefresh && !p && (this.invalidate()._lock = 1),
                    m && m !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (y = this._dur,
                    g = this._tDur,
                    x && (this._lock = 2,
                    m = w ? y : -1e-4,
                    this.render(m, !0),
                    this.vars.repeatRefresh && !p && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !l)
                        return this;
                    nT(this, p)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(t, e, n) {
                var r;
                if (n > e)
                    for (r = t._first; r && r._start <= n; ) {
                        if ("isPause" === r.data && r._start > e)
                            return r;
                        r = r._next
                    }
                else
                    for (r = t._last; r && r._start >= n; ) {
                        if ("isPause" === r.data && r._start < e)
                            return r;
                        r = r._prev
                    }
            }(this, UA(m), UA(r)),
            c && (b -= r - (r = c._start))),
            this._tTime = b,
            this._time = r,
            this._act = !u,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = t,
            m = 0),
            !m && r && !e && !o && (BS(this, "onStart"),
            this._tTime !== b))
                return this;
            if (r >= m && t >= 0)
                for (i = this._first; i; ) {
                    if (s = i._next,
                    (i._act || r >= i._start) && i._ts && c !== i) {
                        if (i.parent !== this)
                            return this.render(t, e, n);
                        if (i.render(i._ts > 0 ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, e, n),
                        r !== this._time || !this._ts && !l) {
                            c = 0,
                            s && (b += this._zTime = -1e-8);
                            break
                        }
                    }
                    i = s
                }
            else {
                i = this._last;
                for (var E = t < 0 ? t : r; i; ) {
                    if (s = i._prev,
                    (i._act || E <= i._end) && i._ts && c !== i) {
                        if (i.parent !== this)
                            return this.render(t, e, n);
                        if (i.render(i._ts > 0 ? (E - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (E - i._start) * i._ts, e, n || m_ && (i._initted || i._startAt)),
                        r !== this._time || !this._ts && !l) {
                            c = 0,
                            s && (b += this._zTime = E ? -1e-8 : G_);
                            break
                        }
                    }
                    i = s
                }
            }
            if (c && !e && (this.pause(),
            c.render(r >= m ? 0 : -1e-8)._zTime = r >= m ? 1 : -1,
            this._ts))
                return this._start = h,
                aS(this),
                this.render(t, e, n);
            this._onUpdate && !e && BS(this, "onUpdate", !0),
            (b === g && this._tTime >= this.totalDuration() || !b && m) && (h !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((t || !y) && (b === g && this._ts > 0 || !b && this._ts < 0) && tS(this, 1),
            e || t < 0 && !m || !b && !m && g || (BS(this, b === g && t >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(b < g && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    n.add = function(t, e) {
        var n = this;
        if (nA(e) || (e = bS(this, e, t)),
        !(t instanceof cT)) {
            if (cA(t))
                return t.forEach((function(t) {
                    return n.add(t, e)
                }
                )),
                this;
            if (tA(t))
                return this.addLabel(t, e);
            if (!eA(t))
                return this;
            t = xT.delayedCall(0, t)
        }
        return this !== t ? uS(this, t, e) : this
    }
    ,
    n.getChildren = function(t, e, n, r) {
        void 0 === t && (t = !0),
        void 0 === e && (e = !0),
        void 0 === n && (n = !0),
        void 0 === r && (r = -1e8);
        for (var i = [], s = this._first; s; )
            s._start >= r && (s instanceof xT ? e && i.push(s) : (n && i.push(s),
            t && i.push.apply(i, s.getChildren(!0, e, n)))),
            s = s._next;
        return i
    }
    ,
    n.getById = function(t) {
        for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
            if (e[n].vars.id === t)
                return e[n]
    }
    ,
    n.remove = function(t) {
        return tA(t) ? this.removeLabel(t) : eA(t) ? this.killTweensOf(t) : (JA(this, t),
        t === this._recent && (this._recent = this._last),
        eS(this))
    }
    ,
    n.totalTime = function(e, n) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = UA(qS.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))),
        t.prototype.totalTime.call(this, e, n),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    n.addLabel = function(t, e) {
        return this.labels[t] = bS(this, e),
        this
    }
    ,
    n.removeLabel = function(t) {
        return delete this.labels[t],
        this
    }
    ,
    n.addPause = function(t, e, n) {
        var r = xT.delayedCall(0, e || _A, n);
        return r.data = "isPause",
        this._hasPause = 1,
        uS(this, r, bS(this, t))
    }
    ,
    n.removePause = function(t) {
        var e = this._first;
        for (t = bS(this, t); e; )
            e._start === t && "isPause" === e.data && tS(e),
            e = e._next
    }
    ,
    n.killTweensOf = function(t, e, n) {
        for (var r = this.getTweensOf(t, n), i = r.length; i--; )
            hT !== r[i] && r[i].kill(t, e);
        return this
    }
    ,
    n.getTweensOf = function(t, e) {
        for (var n, r = [], i = SS(t), s = this._first, o = nA(e); s; )
            s instanceof xT ? VA(s._targets, i) && (o ? (!hT || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && r.push(s) : (n = s.getTweensOf(i, e)).length && r.push.apply(r, n),
            s = s._next;
        return r
    }
    ,
    n.tweenTo = function(t, e) {
        e = e || {};
        var n, r = this, i = bS(r, t), s = e, o = s.startAt, a = s.onStart, l = s.onStartParams, c = s.immediateRender, u = xT.to(r, GA({
            ease: e.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: i,
            overwrite: "auto",
            duration: e.duration || Math.abs((i - (o && "time"in o ? o.time : r._time)) / r.timeScale()) || G_,
            onStart: function() {
                if (r.pause(),
                !n) {
                    var t = e.duration || Math.abs((i - (o && "time"in o ? o.time : r._time)) / r.timeScale());
                    u._dur !== t && mS(u, t, 0, 1).render(u._time, !0, !0),
                    n = 1
                }
                a && a.apply(u, l || [])
            }
        }, e));
        return c ? u.render(0) : u
    }
    ,
    n.tweenFromTo = function(t, e, n) {
        return this.tweenTo(e, GA({
            startAt: {
                time: bS(this, t)
            }
        }, n))
    }
    ,
    n.recent = function() {
        return this._recent
    }
    ,
    n.nextLabel = function(t) {
        return void 0 === t && (t = this._time),
        DS(this, bS(this, t))
    }
    ,
    n.previousLabel = function(t) {
        return void 0 === t && (t = this._time),
        DS(this, bS(this, t), 1)
    }
    ,
    n.currentLabel = function(t) {
        return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + G_)
    }
    ,
    n.shiftChildren = function(t, e, n) {
        void 0 === n && (n = 0);
        for (var r, i = this._first, s = this.labels; i; )
            i._start >= n && (i._start += t,
            i._end += t),
            i = i._next;
        if (e)
            for (r in s)
                s[r] >= n && (s[r] += t);
        return eS(this)
    }
    ,
    n.invalidate = function(e) {
        var n = this._first;
        for (this._lock = 0; n; )
            n.invalidate(e),
            n = n._next;
        return t.prototype.invalidate.call(this, e)
    }
    ,
    n.clear = function(t) {
        void 0 === t && (t = !0);
        for (var e, n = this._first; n; )
            e = n._next,
            this.remove(n),
            n = e;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        t && (this.labels = {}),
        eS(this)
    }
    ,
    n.totalDuration = function(t) {
        var e, n, r, i = 0, s = this, o = s._last, a = $_;
        if (arguments.length)
            return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -t : t));
        if (s._dirty) {
            for (r = s.parent; o; )
                e = o._prev,
                o._dirty && o.totalDuration(),
                (n = o._start) > a && s._sort && o._ts && !s._lock ? (s._lock = 1,
                uS(s, o, n - o._delay, 1)._lock = 0) : a = n,
                n < 0 && o._ts && (i -= n,
                (!r && !s._dp || r && r.smoothChildTiming) && (s._start += n / s._ts,
                s._time -= n,
                s._tTime -= n),
                s.shiftChildren(-n, !1, -1 / 0),
                a = 0),
                o._end > i && o._ts && (i = o._end),
                o = e;
            mS(s, s === y_ && s._time > i ? s._time : i, 1, 1),
            s._dirty = 0
        }
        return s._tDur
    }
    ,
    e.updateRoot = function(t) {
        if (y_._ts && (YA(y_, oS(t, y_)),
        E_ = qS.frame),
        qS.frame >= OA) {
            OA += Y_.autoSleep || 120;
            var e = y_._first;
            if ((!e || !e._ts) && Y_.autoSleep && qS._listeners.length < 2) {
                for (; e && !e._ts; )
                    e = e._next;
                e || qS.sleep()
            }
        }
    }
    ,
    e
}(cT);
GA(uT.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var hT, dT, fT = function(t, e, n, r, i, s, o) {
    var a, l, c, u, h, d, f, p, m = new DT(this._pt,t,e,0,1,MT,null,i), g = 0, y = 0;
    for (m.b = n,
    m.e = r,
    n += "",
    (f = ~(r += "").indexOf("random(")) && (r = NS(r)),
    s && (s(p = [n, r], t, e),
    n = p[0],
    r = p[1]),
    l = n.match(fA) || []; a = fA.exec(r); )
        u = a[0],
        h = r.substring(g, a.index),
        c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1),
        u !== l[y++] && (d = parseFloat(l[y - 1]) || 0,
        m._pt = {
            _next: m._pt,
            p: h || 1 === y ? h : ",",
            s: d,
            c: "=" === u.charAt(1) ? zA(d, u) - d : parseFloat(u) - d,
            m: c && c < 4 ? Math.round : 0
        },
        g = fA.lastIndex);
    return m.c = g < r.length ? r.substring(g, r.length) : "",
    m.fp = o,
    (pA.test(r) || f) && (m.e = 0),
    this._pt = m,
    m
}, pT = function(t, e, n, r, i, s, o, a, l, c) {
    eA(r) && (r = r(i || 0, t, s));
    var u, h = t[e], d = "get" !== n ? n : eA(h) ? l ? t[e.indexOf("set") || !eA(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : h, f = eA(h) ? l ? AT : _T : ET;
    if (tA(r) && (~r.indexOf("random(") && (r = NS(r)),
    "=" === r.charAt(1) && ((u = zA(d, r) + (ES(d) || 0)) || 0 === u) && (r = u)),
    !c || d !== r || dT)
        return isNaN(d * r) || "" === r ? (!h && !(e in t) && wA(e, r),
        fT.call(this, t, e, d, r, f, a || Y_.stringFilter, l)) : (u = new DT(this._pt,t,e,+d || 0,r - (d || 0),"boolean" == typeof h ? IT : kT,0,f),
        l && (u.fp = l),
        o && u.modifier(o, this, t),
        this._pt = u)
}, mT = function(t, e, n, r, i, s) {
    var o, a, l, c;
    if (CA[t] && !1 !== (o = new CA[t]).init(i, o.rawVars ? e[t] : function(t, e, n, r, i) {
        if (eA(t) && (t = bT(t, i, e, n, r)),
        !iA(t) || t.style && t.nodeType || cA(t) || lA(t))
            return tA(t) ? bT(t, i, e, n, r) : t;
        var s, o = {};
        for (s in t)
            o[s] = bT(t[s], i, e, n, r);
        return o
    }(e[t], r, i, s, n), n, r, s) && (n._pt = a = new DT(n._pt,i,t,0,1,o.render,o,0,o.priority),
    n !== __))
        for (l = n._ptLookup[n._targets.indexOf(i)],
        c = o._props.length; c--; )
            l[o._props[c]] = a;
    return o
}, gT = function t(e, n, r) {
    var i, s, o, a, l, c, u, h, d, f, p, m, g, y = e.vars, b = y.ease, v = y.startAt, w = y.immediateRender, x = y.lazy, E = y.onUpdate, _ = y.onUpdateParams, A = y.callbackScope, S = y.runBackwards, T = y.yoyoEase, k = y.keyframes, I = y.autoRevert, M = e._dur, C = e._startAt, P = e._targets, O = e.parent, N = O && "nested" === O.data ? O.vars.targets : P, R = "auto" === e._overwrite && !p_, D = e.timeline;
    if (D && (!k || !b) && (b = "none"),
    e._ease = rT(b, H_.ease),
    e._yEase = T ? eT(rT(!0 === T ? b : T, H_.ease)) : 0,
    T && e._yoyo && !e._repeat && (T = e._yEase,
    e._yEase = e._ease,
    e._ease = T),
    e._from = !D && !!y.runBackwards,
    !D || k && !y.stagger) {
        if (m = (h = P[0] ? BA(P[0]).harness : 0) && y[h.prop],
        i = KA(y, kA),
        C && (C._zTime < 0 && C.progress(1),
        n < 0 && S && w && !I ? C.render(-1, !0) : C.revert(S && M ? SA : AA),
        C._lazy = 0),
        v) {
            if (tS(e._startAt = xT.set(P, GA({
                data: "isStart",
                overwrite: !1,
                parent: O,
                immediateRender: !0,
                lazy: !C && sA(x),
                startAt: null,
                delay: 0,
                onUpdate: E,
                onUpdateParams: _,
                callbackScope: A,
                stagger: 0
            }, v))),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            n < 0 && (m_ || !w && !I) && e._startAt.revert(SA),
            w && M && n <= 0 && r <= 0)
                return void (n && (e._zTime = n))
        } else if (S && M && !C)
            if (n && (w = !1),
            o = GA({
                overwrite: !1,
                data: "isFromStart",
                lazy: w && !C && sA(x),
                immediateRender: w,
                stagger: 0,
                parent: O
            }, i),
            m && (o[h.prop] = m),
            tS(e._startAt = xT.set(P, o)),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            n < 0 && (m_ ? e._startAt.revert(SA) : e._startAt.render(-1, !0)),
            e._zTime = n,
            w) {
                if (!n)
                    return
            } else
                t(e._startAt, G_, G_);
        for (e._pt = e._ptCache = 0,
        x = M && sA(x) || x && !M,
        s = 0; s < P.length; s++) {
            if (u = (l = P[s])._gsap || DA(P)[s]._gsap,
            e._ptLookup[s] = f = {},
            MA[u.id] && IA.length && WA(),
            p = N === P ? s : N.indexOf(l),
            h && !1 !== (d = new h).init(l, m || i, e, p, N) && (e._pt = a = new DT(e._pt,l,d.name,0,1,d.render,d,0,d.priority),
            d._props.forEach((function(t) {
                f[t] = a
            }
            )),
            d.priority && (c = 1)),
            !h || m)
                for (o in i)
                    CA[o] && (d = mT(o, i, e, p, l, N)) ? d.priority && (c = 1) : f[o] = a = pT.call(e, l, o, "get", i[o], p, N, 0, y.stringFilter);
            e._op && e._op[s] && e.kill(l, e._op[s]),
            R && e._pt && (hT = e,
            y_.killTweensOf(l, f, e.globalTime(n)),
            g = !e.parent,
            hT = 0),
            e._pt && x && (MA[u.id] = 1)
        }
        c && RT(e),
        e._onInit && e._onInit(e)
    }
    e._onUpdate = E,
    e._initted = (!e._op || e._pt) && !g,
    k && n <= 0 && D.render($_, !0, !0)
}, yT = function(t, e, n, r) {
    var i, s, o = e.ease || r || "power1.inOut";
    if (cA(e))
        s = n[t] || (n[t] = []),
        e.forEach((function(t, n) {
            return s.push({
                t: n / (e.length - 1) * 100,
                v: t,
                e: o
            })
        }
        ));
    else
        for (i in e)
            s = n[i] || (n[i] = []),
            "ease" === i || s.push({
                t: parseFloat(t),
                v: e[i],
                e: o
            })
}, bT = function(t, e, n, r, i) {
    return eA(t) ? t.call(e, n, r, i) : tA(t) && ~t.indexOf("random(") ? NS(t) : t
}, vT = RA + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", wT = {};
FA(vT + ",id,stagger,delay,duration,paused,scrollTrigger", (function(t) {
    return wT[t] = 1
}
));
var xT = function(t) {
    function e(e, n, r, i) {
        var s;
        "number" == typeof n && (r.duration = n,
        n = r,
        r = null);
        var o, a, l, c, u, h, d, f, p = (s = t.call(this, i ? n : QA(n)) || this).vars, m = p.duration, g = p.delay, y = p.immediateRender, b = p.stagger, v = p.overwrite, w = p.keyframes, x = p.defaults, E = p.scrollTrigger, _ = p.yoyoEase, A = n.parent || y_, S = (cA(e) || lA(e) ? nA(e[0]) : "length"in n) ? [e] : SS(e);
        if (s._targets = S.length ? DA(S) : xA("GSAP target " + e + " not found. https://greensock.com", !Y_.nullTargetWarn) || [],
        s._ptLookup = [],
        s._overwrite = v,
        w || b || aA(m) || aA(g)) {
            if (n = s.vars,
            (o = s.timeline = new uT({
                data: "nested",
                defaults: x || {},
                targets: A && "nested" === A.data ? A.vars.targets : S
            })).kill(),
            o.parent = o._dp = d_(s),
            o._start = 0,
            b || aA(m) || aA(g)) {
                if (c = S.length,
                d = b && IS(b),
                iA(b))
                    for (u in b)
                        ~vT.indexOf(u) && (f || (f = {}),
                        f[u] = b[u]);
                for (a = 0; a < c; a++)
                    (l = KA(n, wT)).stagger = 0,
                    _ && (l.yoyoEase = _),
                    f && XA(l, f),
                    h = S[a],
                    l.duration = +bT(m, d_(s), a, h, S),
                    l.delay = (+bT(g, d_(s), a, h, S) || 0) - s._delay,
                    !b && 1 === c && l.delay && (s._delay = g = l.delay,
                    s._start += g,
                    l.delay = 0),
                    o.to(h, l, d ? d(a, h, S) : 0),
                    o._ease = QS.none;
                o.duration() ? m = g = 0 : s.timeline = 0
            } else if (w) {
                QA(GA(o.vars.defaults, {
                    ease: "none"
                })),
                o._ease = rT(w.ease || n.ease || "none");
                var T, k, I, M = 0;
                if (cA(w))
                    w.forEach((function(t) {
                        return o.to(S, t, ">")
                    }
                    )),
                    o.duration();
                else {
                    for (u in l = {},
                    w)
                        "ease" === u || "easeEach" === u || yT(u, w[u], l, w.easeEach);
                    for (u in l)
                        for (T = l[u].sort((function(t, e) {
                            return t.t - e.t
                        }
                        )),
                        M = 0,
                        a = 0; a < T.length; a++)
                            (I = {
                                ease: (k = T[a]).e,
                                duration: (k.t - (a ? T[a - 1].t : 0)) / 100 * m
                            })[u] = k.v,
                            o.to(S, I, M),
                            M += I.duration;
                    o.duration() < m && o.to({}, {
                        duration: m - o.duration()
                    })
                }
            }
            m || s.duration(m = o.duration())
        } else
            s.timeline = 0;
        return !0 !== v || p_ || (hT = d_(s),
        y_.killTweensOf(S),
        hT = 0),
        uS(A, d_(s), r),
        n.reversed && s.reverse(),
        n.paused && s.paused(!0),
        (y || !m && !w && s._start === UA(A._time) && sA(y) && rS(d_(s)) && "nested" !== A.data) && (s._tTime = -1e-8,
        s.render(Math.max(0, -g) || 0)),
        E && hS(d_(s), E),
        s
    }
    f_(e, t);
    var n = e.prototype;
    return n.render = function(t, e, n) {
        var r, i, s, o, a, l, c, u, h, d = this._time, f = this._tDur, p = this._dur, m = t < 0, g = t > f - G_ && !m ? f : t < G_ ? 0 : t;
        if (p) {
            if (g !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== m) {
                if (r = g,
                u = this.timeline,
                this._repeat) {
                    if (o = p + this._rDelay,
                    this._repeat < -1 && m)
                        return this.totalTime(100 * o + t, e, n);
                    if (r = UA(g % o),
                    g === f ? (s = this._repeat,
                    r = p) : ((s = ~~(g / o)) && s === g / o && (r = p,
                    s--),
                    r > p && (r = p)),
                    (l = this._yoyo && 1 & s) && (h = this._yEase,
                    r = p - r),
                    a = sS(this._tTime, o),
                    r === d && !n && this._initted)
                        return this._tTime = g,
                        this;
                    s !== a && (u && this._yEase && nT(u, l),
                    !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1,
                    this.render(UA(o * s), !0).invalidate()._lock = 0))
                }
                if (!this._initted) {
                    if (dS(this, m ? t : r, n, e, g))
                        return this._tTime = 0,
                        this;
                    if (d !== this._time)
                        return this;
                    if (p !== this._dur)
                        return this.render(t, e, n)
                }
                if (this._tTime = g,
                this._time = r,
                !this._act && this._ts && (this._act = 1,
                this._lazy = 0),
                this.ratio = c = (h || this._ease)(r / p),
                this._from && (this.ratio = c = 1 - c),
                r && !d && !e && !s && (BS(this, "onStart"),
                this._tTime !== g))
                    return this;
                for (i = this._pt; i; )
                    i.r(c, i.d),
                    i = i._next;
                u && u.render(t < 0 ? t : !r && l ? -1e-8 : u._dur * u._ease(r / this._dur), e, n) || this._startAt && (this._zTime = t),
                this._onUpdate && !e && (m && nS(this, t, 0, n),
                BS(this, "onUpdate")),
                this._repeat && s !== a && this.vars.onRepeat && !e && this.parent && BS(this, "onRepeat"),
                g !== this._tDur && g || this._tTime !== g || (m && !this._onUpdate && nS(this, t, 0, !0),
                (t || !p) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && tS(this, 1),
                e || m && !d || !(g || d || l) || (BS(this, g === f ? "onComplete" : "onReverseComplete", !0),
                this._prom && !(g < f && this.timeScale() > 0) && this._prom()))
            }
        } else
            !function(t, e, n, r) {
                var i, s, o, a = t.ratio, l = e < 0 || !e && (!t._start && fS(t) && (t._initted || !pS(t)) || (t._ts < 0 || t._dp._ts < 0) && !pS(t)) ? 0 : 1, c = t._rDelay, u = 0;
                if (c && t._repeat && (u = xS(0, t._tDur, e),
                s = sS(u, c),
                t._yoyo && 1 & s && (l = 1 - l),
                s !== sS(t._tTime, c) && (a = 1 - l,
                t.vars.repeatRefresh && t._initted && t.invalidate())),
                l !== a || m_ || r || t._zTime === G_ || !e && t._zTime) {
                    if (!t._initted && dS(t, e, r, n, u))
                        return;
                    for (o = t._zTime,
                    t._zTime = e || (n ? G_ : 0),
                    n || (n = e && !o),
                    t.ratio = l,
                    t._from && (l = 1 - l),
                    t._time = 0,
                    t._tTime = u,
                    i = t._pt; i; )
                        i.r(l, i.d),
                        i = i._next;
                    e < 0 && nS(t, e, 0, !0),
                    t._onUpdate && !n && BS(t, "onUpdate"),
                    u && t._repeat && !n && t.parent && BS(t, "onRepeat"),
                    (e >= t._tDur || e < 0) && t.ratio === l && (l && tS(t, 1),
                    n || m_ || (BS(t, l ? "onComplete" : "onReverseComplete", !0),
                    t._prom && t._prom()))
                } else
                    t._zTime || (t._zTime = e)
            }(this, t, e, n);
        return this
    }
    ,
    n.targets = function() {
        return this._targets
    }
    ,
    n.invalidate = function(e) {
        return (!e || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(e),
        t.prototype.invalidate.call(this, e)
    }
    ,
    n.resetTo = function(t, e, n, r) {
        A_ || qS.wake(),
        this._ts || this.play();
        var i = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
        return this._initted || gT(this, i),
        function(t, e, n, r, i, s, o) {
            var a, l, c, u, h = (t._pt && t._ptCache || (t._ptCache = {}))[e];
            if (!h)
                for (h = t._ptCache[e] = [],
                c = t._ptLookup,
                u = t._targets.length; u--; ) {
                    if ((a = c[u][e]) && a.d && a.d._pt)
                        for (a = a.d._pt; a && a.p !== e && a.fp !== e; )
                            a = a._next;
                    if (!a)
                        return dT = 1,
                        t.vars[e] = "+=0",
                        gT(t, o),
                        dT = 0,
                        1;
                    h.push(a)
                }
            for (u = h.length; u--; )
                (a = (l = h[u])._pt || l).s = !r && 0 !== r || i ? a.s + (r || 0) + s * a.c : r,
                a.c = n - a.s,
                l.e && (l.e = jA(n) + ES(l.e)),
                l.b && (l.b = a.s + ES(l.b))
        }(this, t, e, n, r, this._ease(i / this._dur), i) ? this.resetTo(t, e, n, r) : (lS(this, 0),
        this.parent || ZA(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    n.kill = function(t, e) {
        if (void 0 === e && (e = "all"),
        !(t || e && "all" !== e))
            return this._lazy = this._pt = 0,
            this.parent ? LS(this) : this;
        if (this.timeline) {
            var n = this.timeline.totalDuration();
            return this.timeline.killTweensOf(t, e, hT && !0 !== hT.vars.overwrite)._first || LS(this),
            this.parent && n !== this.timeline.totalDuration() && mS(this, this._dur * this.timeline._tDur / n, 0, 1),
            this
        }
        var r, i, s, o, a, l, c, u = this._targets, h = t ? SS(t) : u, d = this._ptLookup, f = this._pt;
        if ((!e || "all" === e) && function(t, e) {
            for (var n = t.length, r = n === e.length; r && n-- && t[n] === e[n]; )
                ;
            return n < 0
        }(u, h))
            return "all" === e && (this._pt = 0),
            LS(this);
        for (r = this._op = this._op || [],
        "all" !== e && (tA(e) && (a = {},
        FA(e, (function(t) {
            return a[t] = 1
        }
        )),
        e = a),
        e = function(t, e) {
            var n, r, i, s, o = t[0] ? BA(t[0]).harness : 0, a = o && o.aliases;
            if (!a)
                return e;
            for (r in n = XA({}, e),
            a)
                if (r in n)
                    for (i = (s = a[r].split(",")).length; i--; )
                        n[s[i]] = n[r];
            return n
        }(u, e)),
        c = u.length; c--; )
            if (~h.indexOf(u[c]))
                for (a in i = d[c],
                "all" === e ? (r[c] = e,
                o = i,
                s = {}) : (s = r[c] = r[c] || {},
                o = e),
                o)
                    (l = i && i[a]) && ("kill"in l.d && !0 !== l.d.kill(a) || JA(this, l, "_pt"),
                    delete i[a]),
                    "all" !== s && (s[a] = 1);
        return this._initted && !this._pt && f && LS(this),
        this
    }
    ,
    e.to = function(t, n) {
        return new e(t,n,arguments[2])
    }
    ,
    e.from = function(t, e) {
        return vS(1, arguments)
    }
    ,
    e.delayedCall = function(t, n, r, i) {
        return new e(n,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: t,
            onComplete: n,
            onReverseComplete: n,
            onCompleteParams: r,
            onReverseCompleteParams: r,
            callbackScope: i
        })
    }
    ,
    e.fromTo = function(t, e, n) {
        return vS(2, arguments)
    }
    ,
    e.set = function(t, n) {
        return n.duration = 0,
        n.repeatDelay || (n.repeat = 0),
        new e(t,n)
    }
    ,
    e.killTweensOf = function(t, e, n) {
        return y_.killTweensOf(t, e, n)
    }
    ,
    e
}(cT);
GA(xT.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
}),
FA("staggerTo,staggerFrom,staggerFromTo", (function(t) {
    xT[t] = function() {
        var e = new uT
          , n = _S.call(arguments, 0);
        return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0),
        e[t].apply(e, n)
    }
}
));
var ET = function(t, e, n) {
    return t[e] = n
}
  , _T = function(t, e, n) {
    return t[e](n)
}
  , AT = function(t, e, n, r) {
    return t[e](r.fp, n)
}
  , ST = function(t, e, n) {
    return t.setAttribute(e, n)
}
  , TT = function(t, e) {
    return eA(t[e]) ? _T : rA(t[e]) && t.setAttribute ? ST : ET
}
  , kT = function(t, e) {
    return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
}
  , IT = function(t, e) {
    return e.set(e.t, e.p, !!(e.s + e.c * t), e)
}
  , MT = function(t, e) {
    var n = e._pt
      , r = "";
    if (!t && e.b)
        r = e.b;
    else if (1 === t && e.e)
        r = e.e;
    else {
        for (; n; )
            r = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + r,
            n = n._next;
        r += e.c
    }
    e.set(e.t, e.p, r, e)
}
  , CT = function(t, e) {
    for (var n = e._pt; n; )
        n.r(t, n.d),
        n = n._next
}
  , PT = function(t, e, n, r) {
    for (var i, s = this._pt; s; )
        i = s._next,
        s.p === r && s.modifier(t, e, n),
        s = i
}
  , OT = function(t) {
    for (var e, n, r = this._pt; r; )
        n = r._next,
        r.p === t && !r.op || r.op === t ? JA(this, r, "_pt") : r.dep || (e = 1),
        r = n;
    return !e
}
  , NT = function(t, e, n, r) {
    r.mSet(t, e, r.m.call(r.tween, n, r.mt), r)
}
  , RT = function(t) {
    for (var e, n, r, i, s = t._pt; s; ) {
        for (e = s._next,
        n = r; n && n.pr > s.pr; )
            n = n._next;
        (s._prev = n ? n._prev : i) ? s._prev._next = s : r = s,
        (s._next = n) ? n._prev = s : i = s,
        s = e
    }
    t._pt = r
}
  , DT = function() {
    function t(t, e, n, r, i, s, o, a, l) {
        this.t = e,
        this.s = r,
        this.c = i,
        this.p = n,
        this.r = s || kT,
        this.d = o || this,
        this.set = a || ET,
        this.pr = l || 0,
        this._next = t,
        t && (t._prev = this)
    }
    return t.prototype.modifier = function(t, e, n) {
        this.mSet = this.mSet || this.set,
        this.set = NT,
        this.m = t,
        this.mt = n,
        this.tween = e
    }
    ,
    t
}();
FA(RA + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
    return kA[t] = 1
}
)),
yA.TweenMax = yA.TweenLite = xT,
yA.TimelineLite = yA.TimelineMax = uT,
y_ = new uT({
    sortChildren: !1,
    defaults: H_,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
}),
Y_.stringFilter = XS;
var BT = []
  , LT = {}
  , FT = []
  , jT = 0
  , UT = function(t) {
    return (LT[t] || FT).map((function(t) {
        return t()
    }
    ))
}
  , zT = function() {
    var t = Date.now()
      , e = [];
    t - jT > 2 && (UT("matchMediaInit"),
    BT.forEach((function(t) {
        var n, r, i, s, o = t.queries, a = t.conditions;
        for (r in o)
            (n = b_.matchMedia(o[r]).matches) && (i = 1),
            n !== a[r] && (a[r] = n,
            s = 1);
        s && (t.revert(),
        i && e.push(t))
    }
    )),
    UT("matchMediaRevert"),
    e.forEach((function(t) {
        return t.onMatch(t)
    }
    )),
    jT = t,
    UT("matchMedia"))
}
  , VT = function() {
    function t(t, e) {
        this.selector = e && TS(e),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        t && this.add(t)
    }
    var e = t.prototype;
    return e.add = function(t, e, n) {
        eA(t) && (n = e,
        e = t,
        t = eA);
        var r = this
          , i = function() {
            var t, i = g_, s = r.selector;
            return i && i !== r && i.data.push(r),
            n && (r.selector = TS(n)),
            g_ = r,
            t = e.apply(r, arguments),
            eA(t) && r._r.push(t),
            g_ = i,
            r.selector = s,
            r.isReverted = !1,
            t
        };
        return r.last = i,
        t === eA ? i(r) : t ? r[t] = i : i
    }
    ,
    e.ignore = function(t) {
        var e = g_;
        g_ = null,
        t(this),
        g_ = e
    }
    ,
    e.getTweens = function() {
        var e = [];
        return this.data.forEach((function(n) {
            return n instanceof t ? e.push.apply(e, n.getTweens()) : n instanceof xT && !(n.parent && "nested" === n.parent.data) && e.push(n)
        }
        )),
        e
    }
    ,
    e.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    e.kill = function(t, e) {
        var n = this;
        if (t) {
            var r = this.getTweens();
            this.data.forEach((function(t) {
                "isFlip" === t.data && (t.revert(),
                t.getChildren(!0, !0, !1).forEach((function(t) {
                    return r.splice(r.indexOf(t), 1)
                }
                )))
            }
            )),
            r.map((function(t) {
                return {
                    g: t.globalTime(0),
                    t: t
                }
            }
            )).sort((function(t, e) {
                return e.g - t.g || -1
            }
            )).forEach((function(e) {
                return e.t.revert(t)
            }
            )),
            this.data.forEach((function(e) {
                return !(e instanceof cT) && e.revert && e.revert(t)
            }
            )),
            this._r.forEach((function(e) {
                return e(t, n)
            }
            )),
            this.isReverted = !0
        } else
            this.data.forEach((function(t) {
                return t.kill && t.kill()
            }
            ));
        if (this.clear(),
        e) {
            var i = BT.indexOf(this);
            ~i && BT.splice(i, 1)
        }
    }
    ,
    e.revert = function(t) {
        this.kill(t || {})
    }
    ,
    t
}()
  , WT = function() {
    function t(t) {
        this.contexts = [],
        this.scope = t
    }
    var e = t.prototype;
    return e.add = function(t, e, n) {
        iA(t) || (t = {
            matches: t
        });
        var r, i, s, o = new VT(0,n || this.scope), a = o.conditions = {};
        for (i in this.contexts.push(o),
        e = o.add("onMatch", e),
        o.queries = t,
        t)
            "all" === i ? s = 1 : (r = b_.matchMedia(t[i])) && (BT.indexOf(o) < 0 && BT.push(o),
            (a[i] = r.matches) && (s = 1),
            r.addListener ? r.addListener(zT) : r.addEventListener("change", zT));
        return s && e(o),
        this
    }
    ,
    e.revert = function(t) {
        this.kill(t || {})
    }
    ,
    e.kill = function(t) {
        this.contexts.forEach((function(e) {
            return e.kill(t, !0)
        }
        ))
    }
    ,
    t
}()
  , YT = {
    registerPlugin: function() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
        e.forEach((function(t) {
            return jS(t)
        }
        ))
    },
    timeline: function(t) {
        return new uT(t)
    },
    getTweensOf: function(t, e) {
        return y_.getTweensOf(t, e)
    },
    getProperty: function(t, e, n, r) {
        tA(t) && (t = SS(t)[0]);
        var i = BA(t || {}).get
          , s = n ? $A : HA;
        return "native" === n && (n = ""),
        t ? e ? s((CA[e] && CA[e].get || i)(t, e, n, r)) : function(e, n, r) {
            return s((CA[e] && CA[e].get || i)(t, e, n, r))
        }
        : t
    },
    quickSetter: function(t, e, n) {
        if ((t = SS(t)).length > 1) {
            var r = t.map((function(t) {
                return GT.quickSetter(t, e, n)
            }
            ))
              , i = r.length;
            return function(t) {
                for (var e = i; e--; )
                    r[e](t)
            }
        }
        t = t[0] || {};
        var s = CA[e]
          , o = BA(t)
          , a = o.harness && (o.harness.aliases || {})[e] || e
          , l = s ? function(e) {
            var r = new s;
            __._pt = 0,
            r.init(t, n ? e + n : e, __, 0, [t]),
            r.render(1, r),
            __._pt && CT(1, __)
        }
        : o.set(t, a);
        return s ? l : function(e) {
            return l(t, a, n ? e + n : e, o, 1)
        }
    },
    quickTo: function(t, e, n) {
        var r, i = GT.to(t, XA(((r = {})[e] = "+=0.1",
        r.paused = !0,
        r), n || {})), s = function(t, n, r) {
            return i.resetTo(e, t, n, r)
        };
        return s.tween = i,
        s
    },
    isTweening: function(t) {
        return y_.getTweensOf(t, !0).length > 0
    },
    defaults: function(t) {
        return t && t.ease && (t.ease = rT(t.ease, H_.ease)),
        qA(H_, t || {})
    },
    config: function(t) {
        return qA(Y_, t || {})
    },
    registerEffect: function(t) {
        var e = t.name
          , n = t.effect
          , r = t.plugins
          , i = t.defaults
          , s = t.extendTimeline;
        (r || "").split(",").forEach((function(t) {
            return t && !CA[t] && !yA[t] && xA(e + " effect requires " + t + " plugin.")
        }
        )),
        PA[e] = function(t, e, r) {
            return n(SS(t), GA(e || {}, i), r)
        }
        ,
        s && (uT.prototype[e] = function(t, n, r) {
            return this.add(PA[e](t, iA(n) ? n : (r = n) && {}, this), r)
        }
        )
    },
    registerEase: function(t, e) {
        QS[t] = rT(e)
    },
    parseEase: function(t, e) {
        return arguments.length ? rT(t, e) : QS
    },
    getById: function(t) {
        return y_.getById(t)
    },
    exportRoot: function(t, e) {
        void 0 === t && (t = {});
        var n, r, i = new uT(t);
        for (i.smoothChildTiming = sA(t.smoothChildTiming),
        y_.remove(i),
        i._dp = 0,
        i._time = i._tTime = y_._time,
        n = y_._first; n; )
            r = n._next,
            !e && !n._dur && n instanceof xT && n.vars.onComplete === n._targets[0] || uS(i, n, n._start - n._delay),
            n = r;
        return uS(y_, i, 0),
        i
    },
    context: function(t, e) {
        return t ? new VT(t,e) : g_
    },
    matchMedia: function(t) {
        return new WT(t)
    },
    matchMediaRefresh: function() {
        return BT.forEach((function(t) {
            var e, n, r = t.conditions;
            for (n in r)
                r[n] && (r[n] = !1,
                e = 1);
            e && t.revert()
        }
        )) || zT()
    },
    addEventListener: function(t, e) {
        var n = LT[t] || (LT[t] = []);
        ~n.indexOf(e) || n.push(e)
    },
    removeEventListener: function(t, e) {
        var n = LT[t]
          , r = n && n.indexOf(e);
        r >= 0 && n.splice(r, 1)
    },
    utils: {
        wrap: function t(e, n, r) {
            var i = n - e;
            return cA(e) ? OS(e, t(0, e.length), n) : wS(r, (function(t) {
                return (i + (t - e) % i) % i + e
            }
            ))
        },
        wrapYoyo: function t(e, n, r) {
            var i = n - e
              , s = 2 * i;
            return cA(e) ? OS(e, t(0, e.length - 1), n) : wS(r, (function(t) {
                return e + ((t = (s + (t - e) % s) % s || 0) > i ? s - t : t)
            }
            ))
        },
        distribute: IS,
        random: PS,
        snap: CS,
        normalize: function(t, e, n) {
            return RS(t, e, 0, 1, n)
        },
        getUnit: ES,
        clamp: function(t, e, n) {
            return wS(n, (function(n) {
                return xS(t, e, n)
            }
            ))
        },
        splitColor: WS,
        toArray: SS,
        selector: TS,
        mapRange: RS,
        pipe: function() {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                e[n] = arguments[n];
            return function(t) {
                return e.reduce((function(t, e) {
                    return e(t)
                }
                ), t)
            }
        },
        unitize: function(t, e) {
            return function(n) {
                return t(parseFloat(n)) + (e || ES(n))
            }
        },
        interpolate: function t(e, n, r, i) {
            var s = isNaN(e + n) ? 0 : function(t) {
                return (1 - t) * e + t * n
            }
            ;
            if (!s) {
                var o, a, l, c, u, h = tA(e), d = {};
                if (!0 === r && (i = 1) && (r = null),
                h)
                    e = {
                        p: e
                    },
                    n = {
                        p: n
                    };
                else if (cA(e) && !cA(n)) {
                    for (l = [],
                    c = e.length,
                    u = c - 2,
                    a = 1; a < c; a++)
                        l.push(t(e[a - 1], e[a]));
                    c--,
                    s = function(t) {
                        t *= c;
                        var e = Math.min(u, ~~t);
                        return l[e](t - e)
                    }
                    ,
                    r = n
                } else
                    i || (e = XA(cA(e) ? [] : {}, e));
                if (!l) {
                    for (o in n)
                        pT.call(d, e, o, "get", n[o]);
                    s = function(t) {
                        return CT(t, d) || (h ? e.p : e)
                    }
                }
            }
            return wS(r, s)
        },
        shuffle: kS
    },
    install: vA,
    effects: PA,
    ticker: qS,
    updateRoot: uT.updateRoot,
    plugins: CA,
    globalTimeline: y_,
    core: {
        PropTween: DT,
        globals: EA,
        Tween: xT,
        Timeline: uT,
        Animation: cT,
        getCache: BA,
        _removeLinkedListItem: JA,
        reverting: function() {
            return m_
        },
        context: function(t) {
            return t && g_ && (g_.data.push(t),
            t._ctx = g_),
            g_
        },
        suppressOverwrites: function(t) {
            return p_ = t
        }
    }
};
FA("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
    return YT[t] = xT[t]
}
)),
qS.add(uT.updateRoot),
__ = YT.to({}, {
    duration: 0
});
var HT = function(t, e) {
    for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
        n = n._next;
    return n
}
  , $T = function(t, e) {
    return {
        name: t,
        rawVars: 1,
        init: function(t, n, r) {
            r._onInit = function(t) {
                var r, i;
                if (tA(n) && (r = {},
                FA(n, (function(t) {
                    return r[t] = 1
                }
                )),
                n = r),
                e) {
                    for (i in r = {},
                    n)
                        r[i] = e(n[i]);
                    n = r
                }
                !function(t, e) {
                    var n, r, i, s = t._targets;
                    for (n in e)
                        for (r = s.length; r--; )
                            (i = t._ptLookup[r][n]) && (i = i.d) && (i._pt && (i = HT(i, n)),
                            i && i.modifier && i.modifier(e[n], t, s[r], n))
                }(t, n)
            }
        }
    }
}
  , GT = YT.registerPlugin({
    name: "attr",
    init: function(t, e, n, r, i) {
        var s, o, a;
        for (s in this.tween = n,
        e)
            a = t.getAttribute(s) || "",
            (o = this.add(t, "setAttribute", (a || 0) + "", e[s], r, i, 0, 0, s)).op = s,
            o.b = a,
            this._props.push(s)
    },
    render: function(t, e) {
        for (var n = e._pt; n; )
            m_ ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d),
            n = n._next
    }
}, {
    name: "endArray",
    init: function(t, e) {
        for (var n = e.length; n--; )
            this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1)
    }
}, $T("roundProps", MS), $T("modifiers"), $T("snap", CS)) || YT;
xT.version = uT.version = GT.version = "3.11.5",
x_ = 1,
oA() && KS();
QS.Power0,
QS.Power1,
QS.Power2,
QS.Power3,
QS.Power4,
QS.Linear,
QS.Quad,
QS.Cubic,
QS.Quart,
QS.Quint,
QS.Strong,
QS.Elastic,
QS.Back,
QS.SteppedEase,
QS.Bounce,
QS.Sine,
QS.Expo,
QS.Circ /*!
 * CSSPlugin 3.11.5
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
;
var XT, qT, KT, QT, ZT, JT, tk, ek, nk = {}, rk = 180 / Math.PI, ik = Math.PI / 180, sk = Math.atan2, ok = /([A-Z])/g, ak = /(left|right|width|margin|padding|x)/i, lk = /[\s,\(]\S/, ck = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, uk = function(t, e) {
    return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
}, hk = function(t, e) {
    return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
}, dk = function(t, e) {
    return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
}, fk = function(t, e) {
    var n = e.s + e.c * t;
    e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
}, pk = function(t, e) {
    return e.set(e.t, e.p, t ? e.e : e.b, e)
}, mk = function(t, e) {
    return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
}, gk = function(t, e, n) {
    return t.style[e] = n
}, yk = function(t, e, n) {
    return t.style.setProperty(e, n)
}, bk = function(t, e, n) {
    return t._gsap[e] = n
}, vk = function(t, e, n) {
    return t._gsap.scaleX = t._gsap.scaleY = n
}, wk = function(t, e, n, r, i) {
    var s = t._gsap;
    s.scaleX = s.scaleY = n,
    s.renderTransform(i, s)
}, xk = function(t, e, n, r, i) {
    var s = t._gsap;
    s[e] = n,
    s.renderTransform(i, s)
}, Ek = "transform", _k = Ek + "Origin", Ak = function t(e, n) {
    var r = this
      , i = this.target
      , s = i.style;
    if (e in nk) {
        if (this.tfm = this.tfm || {},
        "transform" === e)
            return ck.transform.split(",").forEach((function(e) {
                return t.call(r, e, n)
            }
            ));
        if (~(e = ck[e] || e).indexOf(",") ? e.split(",").forEach((function(t) {
            return r.tfm[t] = Vk(i, t)
        }
        )) : this.tfm[e] = i._gsap.x ? i._gsap[e] : Vk(i, e),
        this.props.indexOf(Ek) >= 0)
            return;
        i._gsap.svg && (this.svgo = i.getAttribute("data-svg-origin"),
        this.props.push(_k, n, "")),
        e = Ek
    }
    (s || n) && this.props.push(e, n, s[e])
}, Sk = function(t) {
    t.translate && (t.removeProperty("translate"),
    t.removeProperty("scale"),
    t.removeProperty("rotate"))
}, Tk = function() {
    var t, e, n = this.props, r = this.target, i = r.style, s = r._gsap;
    for (t = 0; t < n.length; t += 3)
        n[t + 1] ? r[n[t]] = n[t + 2] : n[t + 2] ? i[n[t]] = n[t + 2] : i.removeProperty("--" === n[t].substr(0, 2) ? n[t] : n[t].replace(ok, "-$1").toLowerCase());
    if (this.tfm) {
        for (e in this.tfm)
            s[e] = this.tfm[e];
        s.svg && (s.renderTransform(),
        r.setAttribute("data-svg-origin", this.svgo || "")),
        (t = tk()) && t.isStart || i[Ek] || (Sk(i),
        s.uncache = 1)
    }
}, kk = function(t, e) {
    var n = {
        target: t,
        props: [],
        revert: Tk,
        save: Ak
    };
    return t._gsap || GT.core.getCache(t),
    e && e.split(",").forEach((function(t) {
        return n.save(t)
    }
    )),
    n
}, Ik = function(t, e) {
    var n = qT.createElementNS ? qT.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : qT.createElement(t);
    return n.style ? n : qT.createElement(t)
}, Mk = function t(e, n, r) {
    var i = getComputedStyle(e);
    return i[n] || i.getPropertyValue(n.replace(ok, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && t(e, Pk(n) || n, 1) || ""
}, Ck = "O,Moz,ms,Ms,Webkit".split(","), Pk = function(t, e, n) {
    var r = (e || ZT).style
      , i = 5;
    if (t in r && !n)
        return t;
    for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(Ck[i] + t in r); )
        ;
    return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? Ck[i] : "") + t
}, Ok = function() {
    "undefined" != typeof window && window.document && (XT = window,
    qT = XT.document,
    KT = qT.documentElement,
    ZT = Ik("div") || {
        style: {}
    },
    Ik("div"),
    Ek = Pk(Ek),
    _k = Ek + "Origin",
    ZT.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    ek = !!Pk("perspective"),
    tk = GT.core.reverting,
    QT = 1)
}, Nk = function t(e) {
    var n, r = Ik("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, s = this.nextSibling, o = this.style.cssText;
    if (KT.appendChild(r),
    r.appendChild(this),
    this.style.display = "block",
    e)
        try {
            n = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = t
        } catch (t) {}
    else
        this._gsapBBox && (n = this._gsapBBox());
    return i && (s ? i.insertBefore(this, s) : i.appendChild(this)),
    KT.removeChild(r),
    this.style.cssText = o,
    n
}, Rk = function(t, e) {
    for (var n = e.length; n--; )
        if (t.hasAttribute(e[n]))
            return t.getAttribute(e[n])
}, Dk = function(t) {
    var e;
    try {
        e = t.getBBox()
    } catch (n) {
        e = Nk.call(t, !0)
    }
    return e && (e.width || e.height) || t.getBBox === Nk || (e = Nk.call(t, !0)),
    !e || e.width || e.x || e.y ? e : {
        x: +Rk(t, ["x", "cx", "x1"]) || 0,
        y: +Rk(t, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    }
}, Bk = function(t) {
    return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Dk(t))
}, Lk = function(t, e) {
    if (e) {
        var n = t.style;
        e in nk && e !== _k && (e = Ek),
        n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e),
        n.removeProperty(e.replace(ok, "-$1").toLowerCase())) : n.removeAttribute(e)
    }
}, Fk = function(t, e, n, r, i, s) {
    var o = new DT(t._pt,e,n,0,1,s ? mk : pk);
    return t._pt = o,
    o.b = r,
    o.e = i,
    t._props.push(n),
    o
}, jk = {
    deg: 1,
    rad: 1,
    turn: 1
}, Uk = {
    grid: 1,
    flex: 1
}, zk = function t(e, n, r, i) {
    var s, o, a, l, c = parseFloat(r) || 0, u = (r + "").trim().substr((c + "").length) || "px", h = ZT.style, d = ak.test(n), f = "svg" === e.tagName.toLowerCase(), p = (f ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === i, y = "%" === i;
    return i === u || !c || jk[i] || jk[u] ? c : ("px" !== u && !g && (c = t(e, n, r, "px")),
    l = e.getCTM && Bk(e),
    !y && "%" !== u || !nk[n] && !~n.indexOf("adius") ? (h[d ? "width" : "height"] = m + (g ? u : i),
    o = ~n.indexOf("adius") || "em" === i && e.appendChild && !f ? e : e.parentNode,
    l && (o = (e.ownerSVGElement || {}).parentNode),
    o && o !== qT && o.appendChild || (o = qT.body),
    (a = o._gsap) && y && a.width && d && a.time === qS.time && !a.uncache ? jA(c / a.width * m) : ((y || "%" === u) && !Uk[Mk(o, "display")] && (h.position = Mk(e, "position")),
    o === e && (h.position = "static"),
    o.appendChild(ZT),
    s = ZT[p],
    o.removeChild(ZT),
    h.position = "absolute",
    d && y && ((a = BA(o)).time = qS.time,
    a.width = o[p]),
    jA(g ? s * c / m : s && c ? m / s * c : 0))) : (s = l ? e.getBBox()[d ? "width" : "height"] : e[p],
    jA(y ? c / s * m : c / 100 * s)))
}, Vk = function(t, e, n, r) {
    var i;
    return QT || Ok(),
    e in ck && "transform" !== e && ~(e = ck[e]).indexOf(",") && (e = e.split(",")[0]),
    nk[e] && "transform" !== e ? (i = Jk(t, r),
    i = "transformOrigin" !== e ? i[e] : i.svg ? i.origin : tI(Mk(t, _k)) + " " + i.zOrigin + "px") : (!(i = t.style[e]) || "auto" === i || r || ~(i + "").indexOf("calc(")) && (i = $k[e] && $k[e](t, e, n) || Mk(t, e) || LA(t, e) || ("opacity" === e ? 1 : 0)),
    n && !~(i + "").trim().indexOf(" ") ? zk(t, e, i, n) + n : i
}, Wk = function(t, e, n, r) {
    if (!n || "none" === n) {
        var i = Pk(e, t, 1)
          , s = i && Mk(t, i, 1);
        s && s !== n ? (e = i,
        n = s) : "borderColor" === e && (n = Mk(t, "borderTopColor"))
    }
    var o, a, l, c, u, h, d, f, p, m, g, y = new DT(this._pt,t.style,e,0,1,MT), b = 0, v = 0;
    if (y.b = n,
    y.e = r,
    n += "",
    "auto" === (r += "") && (t.style[e] = r,
    r = Mk(t, e) || r,
    t.style[e] = n),
    XS(o = [n, r]),
    r = o[1],
    l = (n = o[0]).match(dA) || [],
    (r.match(dA) || []).length) {
        for (; a = dA.exec(r); )
            d = a[0],
            p = r.substring(b, a.index),
            u ? u = (u + 1) % 5 : "rgba(" !== p.substr(-5) && "hsla(" !== p.substr(-5) || (u = 1),
            d !== (h = l[v++] || "") && (c = parseFloat(h) || 0,
            g = h.substr((c + "").length),
            "=" === d.charAt(1) && (d = zA(c, d) + g),
            f = parseFloat(d),
            m = d.substr((f + "").length),
            b = dA.lastIndex - m.length,
            m || (m = m || Y_.units[e] || g,
            b === r.length && (r += m,
            y.e += m)),
            g !== m && (c = zk(t, e, h, m) || 0),
            y._pt = {
                _next: y._pt,
                p: p || 1 === v ? p : ",",
                s: c,
                c: f - c,
                m: u && u < 4 || "zIndex" === e ? Math.round : 0
            });
        y.c = b < r.length ? r.substring(b, r.length) : ""
    } else
        y.r = "display" === e && "none" === r ? mk : pk;
    return pA.test(r) && (y.e = 0),
    this._pt = y,
    y
}, Yk = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, Hk = function(t, e) {
    if (e.tween && e.tween._time === e.tween._dur) {
        var n, r, i, s = e.t, o = s.style, a = e.u, l = s._gsap;
        if ("all" === a || !0 === a)
            o.cssText = "",
            r = 1;
        else
            for (i = (a = a.split(",")).length; --i > -1; )
                n = a[i],
                nk[n] && (r = 1,
                n = "transformOrigin" === n ? _k : Ek),
                Lk(s, n);
        r && (Lk(s, Ek),
        l && (l.svg && s.removeAttribute("transform"),
        Jk(s, 1),
        l.uncache = 1,
        Sk(o)))
    }
}, $k = {
    clearProps: function(t, e, n, r, i) {
        if ("isFromStart" !== i.data) {
            var s = t._pt = new DT(t._pt,e,n,0,0,Hk);
            return s.u = r,
            s.pr = -10,
            s.tween = i,
            t._props.push(n),
            1
        }
    }
}, Gk = [1, 0, 0, 1, 0, 0], Xk = {}, qk = function(t) {
    return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
}, Kk = function(t) {
    var e = Mk(t, Ek);
    return qk(e) ? Gk : e.substr(7).match(hA).map(jA)
}, Qk = function(t, e) {
    var n, r, i, s, o = t._gsap || BA(t), a = t.style, l = Kk(t);
    return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(i = t.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? Gk : l : (l !== Gk || t.offsetParent || t === KT || o.svg || (i = a.display,
    a.display = "block",
    (n = t.parentNode) && t.offsetParent || (s = 1,
    r = t.nextElementSibling,
    KT.appendChild(t)),
    l = Kk(t),
    i ? a.display = i : Lk(t, "display"),
    s && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : KT.removeChild(t))),
    e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
}, Zk = function(t, e, n, r, i, s) {
    var o, a, l, c = t._gsap, u = i || Qk(t, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, f = c.xOffset || 0, p = c.yOffset || 0, m = u[0], g = u[1], y = u[2], b = u[3], v = u[4], w = u[5], x = e.split(" "), E = parseFloat(x[0]) || 0, _ = parseFloat(x[1]) || 0;
    n ? u !== Gk && (a = m * b - g * y) && (l = E * (-g / a) + _ * (m / a) - (m * w - g * v) / a,
    E = E * (b / a) + _ * (-y / a) + (y * w - b * v) / a,
    _ = l) : (E = (o = Dk(t)).x + (~x[0].indexOf("%") ? E / 100 * o.width : E),
    _ = o.y + (~(x[1] || x[0]).indexOf("%") ? _ / 100 * o.height : _)),
    r || !1 !== r && c.smooth ? (v = E - h,
    w = _ - d,
    c.xOffset = f + (v * m + w * y) - v,
    c.yOffset = p + (v * g + w * b) - w) : c.xOffset = c.yOffset = 0,
    c.xOrigin = E,
    c.yOrigin = _,
    c.smooth = !!r,
    c.origin = e,
    c.originIsAbsolute = !!n,
    t.style[_k] = "0px 0px",
    s && (Fk(s, c, "xOrigin", h, E),
    Fk(s, c, "yOrigin", d, _),
    Fk(s, c, "xOffset", f, c.xOffset),
    Fk(s, c, "yOffset", p, c.yOffset)),
    t.setAttribute("data-svg-origin", E + " " + _)
}, Jk = function(t, e) {
    var n = t._gsap || new lT(t);
    if ("x"in n && !e && !n.uncache)
        return n;
    var r, i, s, o, a, l, c, u, h, d, f, p, m, g, y, b, v, w, x, E, _, A, S, T, k, I, M, C, P, O, N, R, D = t.style, B = n.scaleX < 0, L = "px", F = "deg", j = getComputedStyle(t), U = Mk(t, _k) || "0";
    return r = i = s = l = c = u = h = d = f = 0,
    o = a = 1,
    n.svg = !(!t.getCTM || !Bk(t)),
    j.translate && ("none" === j.translate && "none" === j.scale && "none" === j.rotate || (D[Ek] = ("none" !== j.translate ? "translate3d(" + (j.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== j.rotate ? "rotate(" + j.rotate + ") " : "") + ("none" !== j.scale ? "scale(" + j.scale.split(" ").join(",") + ") " : "") + ("none" !== j[Ek] ? j[Ek] : "")),
    D.scale = D.rotate = D.translate = "none"),
    g = Qk(t, n.svg),
    n.svg && (n.uncache ? (k = t.getBBox(),
    U = n.xOrigin - k.x + "px " + (n.yOrigin - k.y) + "px",
    T = "") : T = !e && t.getAttribute("data-svg-origin"),
    Zk(t, T || U, !!T || n.originIsAbsolute, !1 !== n.smooth, g)),
    p = n.xOrigin || 0,
    m = n.yOrigin || 0,
    g !== Gk && (w = g[0],
    x = g[1],
    E = g[2],
    _ = g[3],
    r = A = g[4],
    i = S = g[5],
    6 === g.length ? (o = Math.sqrt(w * w + x * x),
    a = Math.sqrt(_ * _ + E * E),
    l = w || x ? sk(x, w) * rk : 0,
    (h = E || _ ? sk(E, _) * rk + l : 0) && (a *= Math.abs(Math.cos(h * ik))),
    n.svg && (r -= p - (p * w + m * E),
    i -= m - (p * x + m * _))) : (R = g[6],
    O = g[7],
    M = g[8],
    C = g[9],
    P = g[10],
    N = g[11],
    r = g[12],
    i = g[13],
    s = g[14],
    c = (y = sk(R, P)) * rk,
    y && (T = A * (b = Math.cos(-y)) + M * (v = Math.sin(-y)),
    k = S * b + C * v,
    I = R * b + P * v,
    M = A * -v + M * b,
    C = S * -v + C * b,
    P = R * -v + P * b,
    N = O * -v + N * b,
    A = T,
    S = k,
    R = I),
    u = (y = sk(-E, P)) * rk,
    y && (b = Math.cos(-y),
    N = _ * (v = Math.sin(-y)) + N * b,
    w = T = w * b - M * v,
    x = k = x * b - C * v,
    E = I = E * b - P * v),
    l = (y = sk(x, w)) * rk,
    y && (T = w * (b = Math.cos(y)) + x * (v = Math.sin(y)),
    k = A * b + S * v,
    x = x * b - w * v,
    S = S * b - A * v,
    w = T,
    A = k),
    c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0,
    u = 180 - u),
    o = jA(Math.sqrt(w * w + x * x + E * E)),
    a = jA(Math.sqrt(S * S + R * R)),
    y = sk(A, S),
    h = Math.abs(y) > 2e-4 ? y * rk : 0,
    f = N ? 1 / (N < 0 ? -N : N) : 0),
    n.svg && (T = t.getAttribute("transform"),
    n.forceCSS = t.setAttribute("transform", "") || !qk(Mk(t, Ek)),
    T && t.setAttribute("transform", T))),
    Math.abs(h) > 90 && Math.abs(h) < 270 && (B ? (o *= -1,
    h += l <= 0 ? 180 : -180,
    l += l <= 0 ? 180 : -180) : (a *= -1,
    h += h <= 0 ? 180 : -180)),
    e = e || n.uncache,
    n.x = r - ((n.xPercent = r && (!e && n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + L,
    n.y = i - ((n.yPercent = i && (!e && n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + L,
    n.z = s + L,
    n.scaleX = jA(o),
    n.scaleY = jA(a),
    n.rotation = jA(l) + F,
    n.rotationX = jA(c) + F,
    n.rotationY = jA(u) + F,
    n.skewX = h + F,
    n.skewY = d + F,
    n.transformPerspective = f + L,
    (n.zOrigin = parseFloat(U.split(" ")[2]) || 0) && (D[_k] = tI(U)),
    n.xOffset = n.yOffset = 0,
    n.force3D = Y_.force3D,
    n.renderTransform = n.svg ? aI : ek ? oI : nI,
    n.uncache = 0,
    n
}, tI = function(t) {
    return (t = t.split(" "))[0] + " " + t[1]
}, eI = function(t, e, n) {
    var r = ES(e);
    return jA(parseFloat(e) + parseFloat(zk(t, "x", n + "px", r))) + r
}, nI = function(t, e) {
    e.z = "0px",
    e.rotationY = e.rotationX = "0deg",
    e.force3D = 0,
    oI(t, e)
}, rI = "0deg", iI = "0px", sI = ") ", oI = function(t, e) {
    var n = e || this
      , r = n.xPercent
      , i = n.yPercent
      , s = n.x
      , o = n.y
      , a = n.z
      , l = n.rotation
      , c = n.rotationY
      , u = n.rotationX
      , h = n.skewX
      , d = n.skewY
      , f = n.scaleX
      , p = n.scaleY
      , m = n.transformPerspective
      , g = n.force3D
      , y = n.target
      , b = n.zOrigin
      , v = ""
      , w = "auto" === g && t && 1 !== t || !0 === g;
    if (b && (u !== rI || c !== rI)) {
        var x, E = parseFloat(c) * ik, _ = Math.sin(E), A = Math.cos(E);
        E = parseFloat(u) * ik,
        x = Math.cos(E),
        s = eI(y, s, _ * x * -b),
        o = eI(y, o, -Math.sin(E) * -b),
        a = eI(y, a, A * x * -b + b)
    }
    m !== iI && (v += "perspective(" + m + sI),
    (r || i) && (v += "translate(" + r + "%, " + i + "%) "),
    (w || s !== iI || o !== iI || a !== iI) && (v += a !== iI || w ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + sI),
    l !== rI && (v += "rotate(" + l + sI),
    c !== rI && (v += "rotateY(" + c + sI),
    u !== rI && (v += "rotateX(" + u + sI),
    h === rI && d === rI || (v += "skew(" + h + ", " + d + sI),
    1 === f && 1 === p || (v += "scale(" + f + ", " + p + sI),
    y.style[Ek] = v || "translate(0, 0)"
}, aI = function(t, e) {
    var n, r, i, s, o, a = e || this, l = a.xPercent, c = a.yPercent, u = a.x, h = a.y, d = a.rotation, f = a.skewX, p = a.skewY, m = a.scaleX, g = a.scaleY, y = a.target, b = a.xOrigin, v = a.yOrigin, w = a.xOffset, x = a.yOffset, E = a.forceCSS, _ = parseFloat(u), A = parseFloat(h);
    d = parseFloat(d),
    f = parseFloat(f),
    (p = parseFloat(p)) && (f += p = parseFloat(p),
    d += p),
    d || f ? (d *= ik,
    f *= ik,
    n = Math.cos(d) * m,
    r = Math.sin(d) * m,
    i = Math.sin(d - f) * -g,
    s = Math.cos(d - f) * g,
    f && (p *= ik,
    o = Math.tan(f - p),
    i *= o = Math.sqrt(1 + o * o),
    s *= o,
    p && (o = Math.tan(p),
    n *= o = Math.sqrt(1 + o * o),
    r *= o)),
    n = jA(n),
    r = jA(r),
    i = jA(i),
    s = jA(s)) : (n = m,
    s = g,
    r = i = 0),
    (_ && !~(u + "").indexOf("px") || A && !~(h + "").indexOf("px")) && (_ = zk(y, "x", u, "px"),
    A = zk(y, "y", h, "px")),
    (b || v || w || x) && (_ = jA(_ + b - (b * n + v * i) + w),
    A = jA(A + v - (b * r + v * s) + x)),
    (l || c) && (o = y.getBBox(),
    _ = jA(_ + l / 100 * o.width),
    A = jA(A + c / 100 * o.height)),
    o = "matrix(" + n + "," + r + "," + i + "," + s + "," + _ + "," + A + ")",
    y.setAttribute("transform", o),
    E && (y.style[Ek] = o)
}, lI = function(t, e, n, r, i) {
    var s, o, a = 360, l = tA(i), c = parseFloat(i) * (l && ~i.indexOf("rad") ? rk : 1) - r, u = r + c + "deg";
    return l && ("short" === (s = i.split("_")[1]) && (c %= a) !== c % 180 && (c += c < 0 ? a : -360),
    "cw" === s && c < 0 ? c = (c + 36e9) % a - ~~(c / a) * a : "ccw" === s && c > 0 && (c = (c - 36e9) % a - ~~(c / a) * a)),
    t._pt = o = new DT(t._pt,e,n,r,c,hk),
    o.e = u,
    o.u = "deg",
    t._props.push(n),
    o
}, cI = function(t, e) {
    for (var n in e)
        t[n] = e[n];
    return t
}, uI = function(t, e, n) {
    var r, i, s, o, a, l, c, u = cI({}, n._gsap), h = n.style;
    for (i in u.svg ? (s = n.getAttribute("transform"),
    n.setAttribute("transform", ""),
    h[Ek] = e,
    r = Jk(n, 1),
    Lk(n, Ek),
    n.setAttribute("transform", s)) : (s = getComputedStyle(n)[Ek],
    h[Ek] = e,
    r = Jk(n, 1),
    h[Ek] = s),
    nk)
        (s = u[i]) !== (o = r[i]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(i) < 0 && (a = ES(s) !== (c = ES(o)) ? zk(n, i, s, c) : parseFloat(s),
        l = parseFloat(o),
        t._pt = new DT(t._pt,r,i,a,l - a,uk),
        t._pt.u = c || 0,
        t._props.push(i));
    cI(r, u)
};
FA("padding,margin,Width,Radius", (function(t, e) {
    var n = "Top"
      , r = "Right"
      , i = "Bottom"
      , s = "Left"
      , o = (e < 3 ? [n, r, i, s] : [n + s, n + r, i + r, i + s]).map((function(n) {
        return e < 2 ? t + n : "border" + n + t
    }
    ));
    $k[e > 1 ? "border" + t : t] = function(t, e, n, r, i) {
        var s, a;
        if (arguments.length < 4)
            return s = o.map((function(e) {
                return Vk(t, e, n)
            }
            )),
            5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a;
        s = (r + "").split(" "),
        a = {},
        o.forEach((function(t, e) {
            return a[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
        }
        )),
        t.init(e, a, i)
    }
}
));
var hI, dI, fI, pI = {
    name: "css",
    register: Ok,
    targetTest: function(t) {
        return t.style && t.nodeType
    },
    init: function(t, e, n, r, i) {
        var s, o, a, l, c, u, h, d, f, p, m, g, y, b, v, w, x, E, _, A, S = this._props, T = t.style, k = n.vars.startAt;
        for (h in QT || Ok(),
        this.styles = this.styles || kk(t),
        w = this.styles.props,
        this.tween = n,
        e)
            if ("autoRound" !== h && (o = e[h],
            !CA[h] || !mT(h, e, n, r, t, i)))
                if (c = typeof o,
                u = $k[h],
                "function" === c && (c = typeof (o = o.call(n, r, t, i))),
                "string" === c && ~o.indexOf("random(") && (o = NS(o)),
                u)
                    u(this, t, h, o, n) && (v = 1);
                else if ("--" === h.substr(0, 2))
                    s = (getComputedStyle(t).getPropertyValue(h) + "").trim(),
                    o += "",
                    $S.lastIndex = 0,
                    $S.test(s) || (d = ES(s),
                    f = ES(o)),
                    f ? d !== f && (s = zk(t, h, s, f) + f) : d && (o += d),
                    this.add(T, "setProperty", s, o, r, i, 0, 0, h),
                    S.push(h),
                    w.push(h, 0, T[h]);
                else if ("undefined" !== c) {
                    if (k && h in k ? (s = "function" == typeof k[h] ? k[h].call(n, r, t, i) : k[h],
                    tA(s) && ~s.indexOf("random(") && (s = NS(s)),
                    ES(s + "") || (s += Y_.units[h] || ES(Vk(t, h)) || ""),
                    "=" === (s + "").charAt(1) && (s = Vk(t, h))) : s = Vk(t, h),
                    l = parseFloat(s),
                    (p = "string" === c && "=" === o.charAt(1) && o.substr(0, 2)) && (o = o.substr(2)),
                    a = parseFloat(o),
                    h in ck && ("autoAlpha" === h && (1 === l && "hidden" === Vk(t, "visibility") && a && (l = 0),
                    w.push("visibility", 0, T.visibility),
                    Fk(this, T, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)),
                    "scale" !== h && "transform" !== h && ~(h = ck[h]).indexOf(",") && (h = h.split(",")[0])),
                    m = h in nk)
                        if (this.styles.save(h),
                        g || ((y = t._gsap).renderTransform && !e.parseTransform || Jk(t, e.parseTransform),
                        b = !1 !== e.smoothOrigin && y.smooth,
                        (g = this._pt = new DT(this._pt,T,Ek,0,1,y.renderTransform,y,0,-1)).dep = 1),
                        "scale" === h)
                            this._pt = new DT(this._pt,y,"scaleY",y.scaleY,(p ? zA(y.scaleY, p + a) : a) - y.scaleY || 0,uk),
                            this._pt.u = 0,
                            S.push("scaleY", h),
                            h += "X";
                        else {
                            if ("transformOrigin" === h) {
                                w.push(_k, 0, T[_k]),
                                E = void 0,
                                _ = void 0,
                                A = void 0,
                                E = (x = o).split(" "),
                                _ = E[0],
                                A = E[1] || "50%",
                                "top" !== _ && "bottom" !== _ && "left" !== A && "right" !== A || (x = _,
                                _ = A,
                                A = x),
                                E[0] = Yk[_] || _,
                                E[1] = Yk[A] || A,
                                o = E.join(" "),
                                y.svg ? Zk(t, o, 0, b, 0, this) : ((f = parseFloat(o.split(" ")[2]) || 0) !== y.zOrigin && Fk(this, y, "zOrigin", y.zOrigin, f),
                                Fk(this, T, h, tI(s), tI(o)));
                                continue
                            }
                            if ("svgOrigin" === h) {
                                Zk(t, o, 1, b, 0, this);
                                continue
                            }
                            if (h in Xk) {
                                lI(this, y, h, l, p ? zA(l, p + o) : o);
                                continue
                            }
                            if ("smoothOrigin" === h) {
                                Fk(this, y, "smooth", y.smooth, o);
                                continue
                            }
                            if ("force3D" === h) {
                                y[h] = o;
                                continue
                            }
                            if ("transform" === h) {
                                uI(this, o, t);
                                continue
                            }
                        }
                    else
                        h in T || (h = Pk(h) || h);
                    if (m || (a || 0 === a) && (l || 0 === l) && !lk.test(o) && h in T)
                        a || (a = 0),
                        (d = (s + "").substr((l + "").length)) !== (f = ES(o) || (h in Y_.units ? Y_.units[h] : d)) && (l = zk(t, h, s, f)),
                        this._pt = new DT(this._pt,m ? y : T,h,l,(p ? zA(l, p + a) : a) - l,m || "px" !== f && "zIndex" !== h || !1 === e.autoRound ? uk : fk),
                        this._pt.u = f || 0,
                        d !== f && "%" !== f && (this._pt.b = s,
                        this._pt.r = dk);
                    else if (h in T)
                        Wk.call(this, t, h, s, p ? p + o : o);
                    else if (h in t)
                        this.add(t, h, s || t[h], p ? p + o : o, r, i);
                    else if ("parseTransform" !== h) {
                        wA(h, o);
                        continue
                    }
                    m || (h in T ? w.push(h, 0, T[h]) : w.push(h, 1, s || t[h])),
                    S.push(h)
                }
        v && RT(this)
    },
    render: function(t, e) {
        if (e.tween._time || !tk())
            for (var n = e._pt; n; )
                n.r(t, n.d),
                n = n._next;
        else
            e.styles.revert()
    },
    get: Vk,
    aliases: ck,
    getSetter: function(t, e, n) {
        var r = ck[e];
        return r && r.indexOf(",") < 0 && (e = r),
        e in nk && e !== _k && (t._gsap.x || Vk(t, "x")) ? n && JT === n ? "scale" === e ? vk : bk : (JT = n || {},
        "scale" === e ? wk : xk) : t.style && !rA(t.style[e]) ? gk : ~e.indexOf("-") ? yk : TT(t, e)
    },
    core: {
        _removeProperty: Lk,
        _getMatrix: Qk
    }
};
GT.utils.checkPrefix = Pk,
GT.core.getStyleSaver = kk,
fI = FA((hI = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (dI = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
    nk[t] = 1
}
)),
FA(dI, (function(t) {
    Y_.units[t] = "deg",
    Xk[t] = 1
}
)),
ck[fI[13]] = hI + "," + dI,
FA("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
    var e = t.split(":");
    ck[e[1]] = fI[e[0]]
}
)),
FA("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
    Y_.units[t] = "px"
}
)),
GT.registerPlugin(pI);
var mI = GT.registerPlugin(pI) || GT;
mI.core.Tween;
class gI {
    constructor() {
        this.minX = 1 / 0,
        this.minY = 1 / 0,
        this.maxX = -1 / 0,
        this.maxY = -1 / 0,
        this.rect = null,
        this.updateID = -1
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    clear() {
        this.minX = 1 / 0,
        this.minY = 1 / 0,
        this.maxX = -1 / 0,
        this.maxY = -1 / 0
    }
    getRectangle(t) {
        return this.minX > this.maxX || this.minY > this.maxY ? wv.EMPTY : ((t = t || new wv(0,0,1,1)).x = this.minX,
        t.y = this.minY,
        t.width = this.maxX - this.minX,
        t.height = this.maxY - this.minY,
        t)
    }
    addPoint(t) {
        this.minX = Math.min(this.minX, t.x),
        this.maxX = Math.max(this.maxX, t.x),
        this.minY = Math.min(this.minY, t.y),
        this.maxY = Math.max(this.maxY, t.y)
    }
    addPointMatrix(t, e) {
        const {a: n, b: r, c: i, d: s, tx: o, ty: a} = t
          , l = n * e.x + i * e.y + o
          , c = r * e.x + s * e.y + a;
        this.minX = Math.min(this.minX, l),
        this.maxX = Math.max(this.maxX, l),
        this.minY = Math.min(this.minY, c),
        this.maxY = Math.max(this.maxY, c)
    }
    addQuad(t) {
        let e = this.minX
          , n = this.minY
          , r = this.maxX
          , i = this.maxY
          , s = t[0]
          , o = t[1];
        e = s < e ? s : e,
        n = o < n ? o : n,
        r = s > r ? s : r,
        i = o > i ? o : i,
        s = t[2],
        o = t[3],
        e = s < e ? s : e,
        n = o < n ? o : n,
        r = s > r ? s : r,
        i = o > i ? o : i,
        s = t[4],
        o = t[5],
        e = s < e ? s : e,
        n = o < n ? o : n,
        r = s > r ? s : r,
        i = o > i ? o : i,
        s = t[6],
        o = t[7],
        e = s < e ? s : e,
        n = o < n ? o : n,
        r = s > r ? s : r,
        i = o > i ? o : i,
        this.minX = e,
        this.minY = n,
        this.maxX = r,
        this.maxY = i
    }
    addFrame(t, e, n, r, i) {
        this.addFrameMatrix(t.worldTransform, e, n, r, i)
    }
    addFrameMatrix(t, e, n, r, i) {
        const s = t.a
          , o = t.b
          , a = t.c
          , l = t.d
          , c = t.tx
          , u = t.ty;
        let h = this.minX
          , d = this.minY
          , f = this.maxX
          , p = this.maxY
          , m = s * e + a * n + c
          , g = o * e + l * n + u;
        h = m < h ? m : h,
        d = g < d ? g : d,
        f = m > f ? m : f,
        p = g > p ? g : p,
        m = s * r + a * n + c,
        g = o * r + l * n + u,
        h = m < h ? m : h,
        d = g < d ? g : d,
        f = m > f ? m : f,
        p = g > p ? g : p,
        m = s * e + a * i + c,
        g = o * e + l * i + u,
        h = m < h ? m : h,
        d = g < d ? g : d,
        f = m > f ? m : f,
        p = g > p ? g : p,
        m = s * r + a * i + c,
        g = o * r + l * i + u,
        h = m < h ? m : h,
        d = g < d ? g : d,
        f = m > f ? m : f,
        p = g > p ? g : p,
        this.minX = h,
        this.minY = d,
        this.maxX = f,
        this.maxY = p
    }
    addVertexData(t, e, n) {
        let r = this.minX
          , i = this.minY
          , s = this.maxX
          , o = this.maxY;
        for (let a = e; a < n; a += 2) {
            const e = t[a]
              , n = t[a + 1];
            r = e < r ? e : r,
            i = n < i ? n : i,
            s = e > s ? e : s,
            o = n > o ? n : o
        }
        this.minX = r,
        this.minY = i,
        this.maxX = s,
        this.maxY = o
    }
    addVertices(t, e, n, r) {
        this.addVerticesMatrix(t.worldTransform, e, n, r)
    }
    addVerticesMatrix(t, e, n, r, i=0, s=i) {
        const o = t.a
          , a = t.b
          , l = t.c
          , c = t.d
          , u = t.tx
          , h = t.ty;
        let d = this.minX
          , f = this.minY
          , p = this.maxX
          , m = this.maxY;
        for (let t = n; t < r; t += 2) {
            const n = e[t]
              , r = e[t + 1]
              , g = o * n + l * r + u
              , y = c * r + a * n + h;
            d = Math.min(d, g - i),
            p = Math.max(p, g + i),
            f = Math.min(f, y - s),
            m = Math.max(m, y + s)
        }
        this.minX = d,
        this.minY = f,
        this.maxX = p,
        this.maxY = m
    }
    addBounds(t) {
        const e = this.minX
          , n = this.minY
          , r = this.maxX
          , i = this.maxY;
        this.minX = t.minX < e ? t.minX : e,
        this.minY = t.minY < n ? t.minY : n,
        this.maxX = t.maxX > r ? t.maxX : r,
        this.maxY = t.maxY > i ? t.maxY : i
    }
    addBoundsMask(t, e) {
        const n = t.minX > e.minX ? t.minX : e.minX
          , r = t.minY > e.minY ? t.minY : e.minY
          , i = t.maxX < e.maxX ? t.maxX : e.maxX
          , s = t.maxY < e.maxY ? t.maxY : e.maxY;
        if (n <= i && r <= s) {
            const t = this.minX
              , e = this.minY
              , o = this.maxX
              , a = this.maxY;
            this.minX = n < t ? n : t,
            this.minY = r < e ? r : e,
            this.maxX = i > o ? i : o,
            this.maxY = s > a ? s : a
        }
    }
    addBoundsMatrix(t, e) {
        this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
    }
    addBoundsArea(t, e) {
        const n = t.minX > e.x ? t.minX : e.x
          , r = t.minY > e.y ? t.minY : e.y
          , i = t.maxX < e.x + e.width ? t.maxX : e.x + e.width
          , s = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
        if (n <= i && r <= s) {
            const t = this.minX
              , e = this.minY
              , o = this.maxX
              , a = this.maxY;
            this.minX = n < t ? n : t,
            this.minY = r < e ? r : e,
            this.maxX = i > o ? i : o,
            this.maxY = s > a ? s : a
        }
    }
    pad(t=0, e=t) {
        this.isEmpty() || (this.minX -= t,
        this.maxX += t,
        this.minY -= e,
        this.maxY += e)
    }
    addFramePad(t, e, n, r, i, s) {
        t -= i,
        e -= s,
        n += i,
        r += s,
        this.minX = this.minX < t ? this.minX : t,
        this.maxX = this.maxX > n ? this.maxX : n,
        this.minY = this.minY < e ? this.minY : e,
        this.maxY = this.maxY > r ? this.maxY : r
    }
}
class yI extends fg.EventEmitter {
    constructor() {
        super(),
        this.tempDisplayObjectParent = null,
        this.transform = new Bv,
        this.alpha = 1,
        this.visible = !0,
        this.renderable = !0,
        this.cullable = !1,
        this.cullArea = null,
        this.parent = null,
        this.worldAlpha = 1,
        this._lastSortedIndex = 0,
        this._zIndex = 0,
        this.filterArea = null,
        this.filters = null,
        this._enabledFilters = null,
        this._bounds = new gI,
        this._localBounds = null,
        this._boundsID = 0,
        this._boundsRect = null,
        this._localBoundsRect = null,
        this._mask = null,
        this._maskRefCount = 0,
        this._destroyed = !1,
        this.isSprite = !1,
        this.isMask = !1
    }
    static mixin(t) {
        const e = Object.keys(t);
        for (let n = 0; n < e.length; ++n) {
            const r = e[n];
            Object.defineProperty(yI.prototype, r, Object.getOwnPropertyDescriptor(t, r))
        }
    }
    get destroyed() {
        return this._destroyed
    }
    _recursivePostUpdateTransform() {
        this.parent ? (this.parent._recursivePostUpdateTransform(),
        this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
    }
    updateTransform() {
        this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        this.worldAlpha = this.alpha * this.parent.worldAlpha
    }
    getBounds(t, e) {
        return t || (this.parent ? (this._recursivePostUpdateTransform(),
        this.updateTransform()) : (this.parent = this._tempDisplayObjectParent,
        this.updateTransform(),
        this.parent = null)),
        this._bounds.updateID !== this._boundsID && (this.calculateBounds(),
        this._bounds.updateID = this._boundsID),
        e || (this._boundsRect || (this._boundsRect = new wv),
        e = this._boundsRect),
        this._bounds.getRectangle(e)
    }
    getLocalBounds(t) {
        t || (this._localBoundsRect || (this._localBoundsRect = new wv),
        t = this._localBoundsRect),
        this._localBounds || (this._localBounds = new gI);
        const e = this.transform
          , n = this.parent;
        this.parent = null,
        this.transform = this._tempDisplayObjectParent.transform;
        const r = this._bounds
          , i = this._boundsID;
        this._bounds = this._localBounds;
        const s = this.getBounds(!1, t);
        return this.parent = n,
        this.transform = e,
        this._bounds = r,
        this._bounds.updateID += this._boundsID - i,
        s
    }
    toGlobal(t, e, n=!1) {
        return n || (this._recursivePostUpdateTransform(),
        this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
        this.displayObjectUpdateTransform(),
        this.parent = null)),
        this.worldTransform.apply(t, e)
    }
    toLocal(t, e, n, r) {
        return e && (t = e.toGlobal(t, n, r)),
        r || (this._recursivePostUpdateTransform(),
        this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
        this.displayObjectUpdateTransform(),
        this.parent = null)),
        this.worldTransform.applyInverse(t, n)
    }
    setParent(t) {
        if (!t || !t.addChild)
            throw new Error("setParent: Argument must be a Container");
        return t.addChild(this),
        t
    }
    removeFromParent() {
        this.parent?.removeChild(this)
    }
    setTransform(t=0, e=0, n=1, r=1, i=0, s=0, o=0, a=0, l=0) {
        return this.position.x = t,
        this.position.y = e,
        this.scale.x = n || 1,
        this.scale.y = r || 1,
        this.rotation = i,
        this.skew.x = s,
        this.skew.y = o,
        this.pivot.x = a,
        this.pivot.y = l,
        this
    }
    destroy(t) {
        this.removeFromParent(),
        this._destroyed = !0,
        this.transform = null,
        this.parent = null,
        this._bounds = null,
        this.mask = null,
        this.cullArea = null,
        this.filters = null,
        this.filterArea = null,
        this.hitArea = null,
        this.eventMode = "auto",
        this.interactiveChildren = !1,
        this.emit("destroyed"),
        this.removeAllListeners()
    }
    get _tempDisplayObjectParent() {
        return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new bI),
        this.tempDisplayObjectParent
    }
    enableTempParent() {
        const t = this.parent;
        return this.parent = this._tempDisplayObjectParent,
        t
    }
    disableTempParent(t) {
        this.parent = t
    }
    get x() {
        return this.position.x
    }
    set x(t) {
        this.transform.position.x = t
    }
    get y() {
        return this.position.y
    }
    set y(t) {
        this.transform.position.y = t
    }
    get worldTransform() {
        return this.transform.worldTransform
    }
    get localTransform() {
        return this.transform.localTransform
    }
    get position() {
        return this.transform.position
    }
    set position(t) {
        this.transform.position.copyFrom(t)
    }
    get scale() {
        return this.transform.scale
    }
    set scale(t) {
        this.transform.scale.copyFrom(t)
    }
    get pivot() {
        return this.transform.pivot
    }
    set pivot(t) {
        this.transform.pivot.copyFrom(t)
    }
    get skew() {
        return this.transform.skew
    }
    set skew(t) {
        this.transform.skew.copyFrom(t)
    }
    get rotation() {
        return this.transform.rotation
    }
    set rotation(t) {
        this.transform.rotation = t
    }
    get angle() {
        return this.transform.rotation * mv
    }
    set angle(t) {
        this.transform.rotation = t * gv
    }
    get zIndex() {
        return this._zIndex
    }
    set zIndex(t) {
        this._zIndex = t,
        this.parent && (this.parent.sortDirty = !0)
    }
    get worldVisible() {
        let t = this;
        do {
            if (!t.visible)
                return !1;
            t = t.parent
        } while (t);
        return !0
    }
    get mask() {
        return this._mask
    }
    set mask(t) {
        if (this._mask !== t) {
            if (this._mask) {
                const t = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                t && (t._maskRefCount--,
                0 === t._maskRefCount && (t.renderable = !0,
                t.isMask = !1))
            }
            if (this._mask = t,
            this._mask) {
                const t = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                t && (0 === t._maskRefCount && (t.renderable = !1,
                t.isMask = !0),
                t._maskRefCount++)
            }
        }
    }
}
class bI extends yI {
    constructor() {
        super(...arguments),
        this.sortDirty = null
    }
}
yI.prototype.displayObjectUpdateTransform = yI.prototype.updateTransform;
const vI = new Sv;
function wI(t, e) {
    return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex
}
const xI = class extends yI {
    constructor() {
        super(),
        this.children = [],
        this.sortableChildren = xI.defaultSortableChildren,
        this.sortDirty = !1
    }
    onChildrenChange(t) {}
    addChild(...t) {
        if (t.length > 1)
            for (let e = 0; e < t.length; e++)
                this.addChild(t[e]);
        else {
            const e = t[0];
            e.parent && e.parent.removeChild(e),
            e.parent = this,
            this.sortDirty = !0,
            e.transform._parentID = -1,
            this.children.push(e),
            this._boundsID++,
            this.onChildrenChange(this.children.length - 1),
            this.emit("childAdded", e, this, this.children.length - 1),
            e.emit("added", this)
        }
        return t[0]
    }
    addChildAt(t, e) {
        if (e < 0 || e > this.children.length)
            throw new Error(`${t}addChildAt: The index ${e} supplied is out of bounds ${this.children.length}`);
        return t.parent && t.parent.removeChild(t),
        t.parent = this,
        this.sortDirty = !0,
        t.transform._parentID = -1,
        this.children.splice(e, 0, t),
        this._boundsID++,
        this.onChildrenChange(e),
        t.emit("added", this),
        this.emit("childAdded", t, this, e),
        t
    }
    swapChildren(t, e) {
        if (t === e)
            return;
        const n = this.getChildIndex(t)
          , r = this.getChildIndex(e);
        this.children[n] = e,
        this.children[r] = t,
        this.onChildrenChange(n < r ? n : r)
    }
    getChildIndex(t) {
        const e = this.children.indexOf(t);
        if (-1 === e)
            throw new Error("The supplied DisplayObject must be a child of the caller");
        return e
    }
    setChildIndex(t, e) {
        if (e < 0 || e >= this.children.length)
            throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
        const n = this.getChildIndex(t);
        fg.removeItems(this.children, n, 1),
        this.children.splice(e, 0, t),
        this.onChildrenChange(e)
    }
    getChildAt(t) {
        if (t < 0 || t >= this.children.length)
            throw new Error(`getChildAt: Index (${t}) does not exist.`);
        return this.children[t]
    }
    removeChild(...t) {
        if (t.length > 1)
            for (let e = 0; e < t.length; e++)
                this.removeChild(t[e]);
        else {
            const e = t[0]
              , n = this.children.indexOf(e);
            if (-1 === n)
                return null;
            e.parent = null,
            e.transform._parentID = -1,
            fg.removeItems(this.children, n, 1),
            this._boundsID++,
            this.onChildrenChange(n),
            e.emit("removed", this),
            this.emit("childRemoved", e, this, n)
        }
        return t[0]
    }
    removeChildAt(t) {
        const e = this.getChildAt(t);
        return e.parent = null,
        e.transform._parentID = -1,
        fg.removeItems(this.children, t, 1),
        this._boundsID++,
        this.onChildrenChange(t),
        e.emit("removed", this),
        this.emit("childRemoved", e, this, t),
        e
    }
    removeChildren(t=0, e=this.children.length) {
        const n = t
          , r = e - n;
        let i;
        if (r > 0 && r <= e) {
            i = this.children.splice(n, r);
            for (let t = 0; t < i.length; ++t)
                i[t].parent = null,
                i[t].transform && (i[t].transform._parentID = -1);
            this._boundsID++,
            this.onChildrenChange(t);
            for (let t = 0; t < i.length; ++t)
                i[t].emit("removed", this),
                this.emit("childRemoved", i[t], this, t);
            return i
        }
        if (0 === r && 0 === this.children.length)
            return [];
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
    }
    sortChildren() {
        let t = !1;
        for (let e = 0, n = this.children.length; e < n; ++e) {
            const n = this.children[e];
            n._lastSortedIndex = e,
            t || 0 === n.zIndex || (t = !0)
        }
        t && this.children.length > 1 && this.children.sort(wI),
        this.sortDirty = !1
    }
    updateTransform() {
        this.sortableChildren && this.sortDirty && this.sortChildren(),
        this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (let t = 0, e = this.children.length; t < e; ++t) {
            const e = this.children[t];
            e.visible && e.updateTransform()
        }
    }
    calculateBounds() {
        this._bounds.clear(),
        this._calculateBounds();
        for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t];
            if (e.visible && e.renderable)
                if (e.calculateBounds(),
                e._mask) {
                    const t = e._mask.isMaskData ? e._mask.maskObject : e._mask;
                    t ? (t.calculateBounds(),
                    this._bounds.addBoundsMask(e._bounds, t._bounds)) : this._bounds.addBounds(e._bounds)
                } else
                    e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds)
        }
        this._bounds.updateID = this._boundsID
    }
    getLocalBounds(t, e=!1) {
        const n = super.getLocalBounds(t);
        if (!e)
            for (let t = 0, e = this.children.length; t < e; ++t) {
                const e = this.children[t];
                e.visible && e.updateTransform()
            }
        return n
    }
    _calculateBounds() {}
    _renderWithCulling(t) {
        const e = t.renderTexture.sourceFrame;
        if (!(e.width > 0 && e.height > 0))
            return;
        let n, r;
        this.cullArea ? (n = this.cullArea,
        r = this.worldTransform) : this._render !== xI.prototype._render && (n = this.getBounds(!0));
        const i = t.projection.transform;
        if (i && (r ? (r = vI.copyFrom(r),
        r.prepend(i)) : r = i),
        n && e.intersects(n, r))
            this._render(t);
        else if (this.cullArea)
            return;
        for (let e = 0, n = this.children.length; e < n; ++e) {
            const n = this.children[e]
              , r = n.cullable;
            n.cullable = r || !this.cullArea,
            n.render(t),
            n.cullable = r
        }
    }
    render(t) {
        if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
            if (this._mask || this.filters?.length)
                this.renderAdvanced(t);
            else if (this.cullable)
                this._renderWithCulling(t);
            else {
                this._render(t);
                for (let e = 0, n = this.children.length; e < n; ++e)
                    this.children[e].render(t)
            }
    }
    renderAdvanced(t) {
        const e = this.filters
          , n = this._mask;
        if (e) {
            this._enabledFilters || (this._enabledFilters = []),
            this._enabledFilters.length = 0;
            for (let t = 0; t < e.length; t++)
                e[t].enabled && this._enabledFilters.push(e[t])
        }
        const r = e && this._enabledFilters?.length || n && (!n.isMaskData || n.enabled && (n.autoDetect || n.type !== Hm.NONE));
        if (r && t.batch.flush(),
        e && this._enabledFilters?.length && t.filter.push(this, this._enabledFilters),
        n && t.mask.push(this, this._mask),
        this.cullable)
            this._renderWithCulling(t);
        else {
            this._render(t);
            for (let e = 0, n = this.children.length; e < n; ++e)
                this.children[e].render(t)
        }
        r && t.batch.flush(),
        n && t.mask.pop(this),
        e && this._enabledFilters?.length && t.filter.pop()
    }
    _render(t) {}
    destroy(t) {
        super.destroy(),
        this.sortDirty = !1;
        const e = "boolean" == typeof t ? t : t?.children
          , n = this.removeChildren(0, this.children.length);
        if (e)
            for (let e = 0; e < n.length; ++e)
                n[e].destroy(t)
    }
    get width() {
        return this.scale.x * this.getLocalBounds().width
    }
    set width(t) {
        const e = this.getLocalBounds().width;
        this.scale.x = 0 !== e ? t / e : 1,
        this._width = t
    }
    get height() {
        return this.scale.y * this.getLocalBounds().height
    }
    set height(t) {
        const e = this.getLocalBounds().height;
        this.scale.y = 0 !== e ? t / e : 1,
        this._height = t
    }
}
;
let EI = xI;
EI.defaultSortableChildren = !1,
EI.prototype.containerUpdateTransform = EI.prototype.updateTransform,
Object.defineProperties(Xm, {
    SORTABLE_CHILDREN: {
        get: ()=>EI.defaultSortableChildren,
        set(t) {
            fg.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"),
            EI.defaultSortableChildren = t
        }
    }
});
var _I = Object.defineProperty
  , AI = (t,e,n)=>(((t,e,n)=>{
    e in t ? _I(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n
}
)(t, "symbol" != typeof e ? e + "" : e, n),
n);
class SI {
    constructor(t) {
        AI(this, "parent"),
        AI(this, "paused"),
        this.parent = t,
        this.paused = !1
    }
    destroy() {}
    down(t) {
        return !1
    }
    move(t) {
        return !1
    }
    up(t) {
        return !1
    }
    wheel(t) {
        return !1
    }
    update(t) {}
    resize() {}
    reset() {}
    pause() {
        this.paused = !0
    }
    resume() {
        this.paused = !1
    }
}
var TI = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof n < "u" ? n : typeof self < "u" ? self : {}
  , kI = {
    exports: {}
};
!function(t, e) {
    (function() {
        var e;
        e = {
            linear: function(t, e, n, r) {
                return n * t / r + e
            },
            easeInQuad: function(t, e, n, r) {
                return n * (t /= r) * t + e
            },
            easeOutQuad: function(t, e, n, r) {
                return -n * (t /= r) * (t - 2) + e
            },
            easeInOutQuad: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * t * t + e : -n / 2 * (--t * (t - 2) - 1) + e
            },
            easeInCubic: function(t, e, n, r) {
                return n * (t /= r) * t * t + e
            },
            easeOutCubic: function(t, e, n, r) {
                return n * ((t = t / r - 1) * t * t + 1) + e
            },
            easeInOutCubic: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * t * t * t + e : n / 2 * ((t -= 2) * t * t + 2) + e
            },
            easeInQuart: function(t, e, n, r) {
                return n * (t /= r) * t * t * t + e
            },
            easeOutQuart: function(t, e, n, r) {
                return -n * ((t = t / r - 1) * t * t * t - 1) + e
            },
            easeInOutQuart: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * t * t * t * t + e : -n / 2 * ((t -= 2) * t * t * t - 2) + e
            },
            easeInQuint: function(t, e, n, r) {
                return n * (t /= r) * t * t * t * t + e
            },
            easeOutQuint: function(t, e, n, r) {
                return n * ((t = t / r - 1) * t * t * t * t + 1) + e
            },
            easeInOutQuint: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * t * t * t * t * t + e : n / 2 * ((t -= 2) * t * t * t * t + 2) + e
            },
            easeInSine: function(t, e, n, r) {
                return -n * Math.cos(t / r * (Math.PI / 2)) + n + e
            },
            easeOutSine: function(t, e, n, r) {
                return n * Math.sin(t / r * (Math.PI / 2)) + e
            },
            easeInOutSine: function(t, e, n, r) {
                return -n / 2 * (Math.cos(Math.PI * t / r) - 1) + e
            },
            easeInExpo: function(t, e, n, r) {
                return 0 === t ? e : n * Math.pow(2, 10 * (t / r - 1)) + e
            },
            easeOutExpo: function(t, e, n, r) {
                return t === r ? e + n : n * (1 - Math.pow(2, -10 * t / r)) + e
            },
            easeInOutExpo: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * Math.pow(2, 10 * (t - 1)) + e : n / 2 * (2 - Math.pow(2, -10 * --t)) + e
            },
            easeInCirc: function(t, e, n, r) {
                return -n * (Math.sqrt(1 - (t /= r) * t) - 1) + e
            },
            easeOutCirc: function(t, e, n, r) {
                return n * Math.sqrt(1 - (t = t / r - 1) * t) + e
            },
            easeInOutCirc: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? -n / 2 * (Math.sqrt(1 - t * t) - 1) + e : n / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + e
            },
            easeInElastic: function(t, e, n, r) {
                var i, s, o;
                return o = 1.70158,
                0 === t || (t /= r),
                (s = 0) || (s = .3 * r),
                (i = n) < Math.abs(n) ? (i = n,
                o = s / 4) : o = s / (2 * Math.PI) * Math.asin(n / i),
                -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * r - o) * (2 * Math.PI) / s) + e
            },
            easeOutElastic: function(t, e, n, r) {
                var i, s, o;
                return o = 1.70158,
                0 === t || (t /= r),
                (s = 0) || (s = .3 * r),
                (i = n) < Math.abs(n) ? (i = n,
                o = s / 4) : o = s / (2 * Math.PI) * Math.asin(n / i),
                i * Math.pow(2, -10 * t) * Math.sin((t * r - o) * (2 * Math.PI) / s) + n + e
            },
            easeInOutElastic: function(t, e, n, r) {
                var i, s, o;
                return o = 1.70158,
                0 === t || (t /= r / 2),
                (s = 0) || (s = r * (.3 * 1.5)),
                (i = n) < Math.abs(n) ? (i = n,
                o = s / 4) : o = s / (2 * Math.PI) * Math.asin(n / i),
                t < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * r - o) * (2 * Math.PI) / s) * -.5 + e : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * r - o) * (2 * Math.PI) / s) * .5 + n + e
            },
            easeInBack: function(t, e, n, r, i) {
                return void 0 === i && (i = 1.70158),
                n * (t /= r) * t * ((i + 1) * t - i) + e
            },
            easeOutBack: function(t, e, n, r, i) {
                return void 0 === i && (i = 1.70158),
                n * ((t = t / r - 1) * t * ((i + 1) * t + i) + 1) + e
            },
            easeInOutBack: function(t, e, n, r, i) {
                return void 0 === i && (i = 1.70158),
                (t /= r / 2) < 1 ? n / 2 * (t * t * ((1 + (i *= 1.525)) * t - i)) + e : n / 2 * ((t -= 2) * t * ((1 + (i *= 1.525)) * t + i) + 2) + e
            },
            easeInBounce: function(t, n, r, i) {
                return r - e.easeOutBounce(i - t, 0, r, i) + n
            },
            easeOutBounce: function(t, e, n, r) {
                return (t /= r) < 1 / 2.75 ? n * (7.5625 * t * t) + e : t < 2 / 2.75 ? n * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : t < 2.5 / 2.75 ? n * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : n * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e
            },
            easeInOutBounce: function(t, n, r, i) {
                return t < i / 2 ? .5 * e.easeInBounce(2 * t, 0, r, i) + n : .5 * e.easeOutBounce(2 * t - i, 0, r, i) + .5 * r + n
            }
        },
        function(e) {
            t.exports = e
        }(e)
    }
    ).call(TI)
}(kI);
const II = kI.exports;
function MI(t, e) {
    return t ? "function" == typeof t ? t : "string" == typeof t ? II[t] : void 0 : II[e]
}
const CI = {
    removeOnInterrupt: !1,
    ease: "linear",
    time: 1e3
};
class PI extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        AI(this, "startX"),
        AI(this, "startY"),
        AI(this, "deltaX"),
        AI(this, "deltaY"),
        AI(this, "keepCenter"),
        AI(this, "startWidth", null),
        AI(this, "startHeight", null),
        AI(this, "deltaWidth", null),
        AI(this, "deltaHeight", null),
        AI(this, "width", null),
        AI(this, "height", null),
        AI(this, "time", 0),
        this.options = Object.assign({}, CI, e),
        this.options.ease = MI(this.options.ease),
        this.setupPosition(),
        this.setupZoom(),
        this.time = 0
    }
    setupPosition() {
        typeof this.options.position < "u" ? (this.startX = this.parent.center.x,
        this.startY = this.parent.center.y,
        this.deltaX = this.options.position.x - this.parent.center.x,
        this.deltaY = this.options.position.y - this.parent.center.y,
        this.keepCenter = !1) : this.keepCenter = !0
    }
    setupZoom() {
        this.width = null,
        this.height = null,
        typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX),
        typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width),
        typeof this.options.height < "u" && (this.height = this.options.height)),
        null !== this.width && (this.startWidth = this.parent.screenWidthInWorldPixels,
        this.deltaWidth = this.width - this.startWidth),
        null !== this.height && (this.startHeight = this.parent.screenHeightInWorldPixels,
        this.deltaHeight = this.height - this.startHeight)
    }
    down() {
        return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"),
        !1
    }
    complete() {
        this.parent.plugins.remove("animate"),
        null !== this.width && this.parent.fitWidth(this.width, this.keepCenter, null === this.height),
        null !== this.height && this.parent.fitHeight(this.height, this.keepCenter, null === this.width),
        !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position),
        this.parent.emit("animate-end", this.parent),
        this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent)
    }
    update(t) {
        if (this.paused)
            return;
        this.time += t;
        const e = new bv(this.parent.scale.x,this.parent.scale.y);
        if (this.time >= this.options.time) {
            const t = this.parent.width
              , n = this.parent.height;
            this.complete(),
            (t !== this.parent.width || n !== this.parent.height) && this.parent.emit("zoomed", {
                viewport: this.parent,
                original: e,
                type: "animate"
            })
        } else {
            const t = this.options.ease(this.time, 0, 1, this.options.time);
            if (null !== this.width) {
                const e = this.startWidth
                  , n = this.deltaWidth;
                this.parent.fitWidth(e + n * t, this.keepCenter, null === this.height)
            }
            if (null !== this.height) {
                const e = this.startHeight
                  , n = this.deltaHeight;
                this.parent.fitHeight(e + n * t, this.keepCenter, null === this.width)
            }
            if (null === this.width ? this.parent.scale.x = this.parent.scale.y : null === this.height && (this.parent.scale.y = this.parent.scale.x),
            !this.keepCenter) {
                const e = this.startX
                  , n = this.startY
                  , r = this.deltaX
                  , i = this.deltaY
                  , s = new bv(this.parent.x,this.parent.y);
                this.parent.moveCenter(e + r * t, n + i * t),
                this.parent.emit("moved", {
                    viewport: this.parent,
                    original: s,
                    type: "animate"
                })
            }
            (this.width || this.height) && this.parent.emit("zoomed", {
                viewport: this.parent,
                original: e,
                type: "animate"
            })
        }
    }
}
const OI = {
    sides: "all",
    friction: .5,
    time: 150,
    ease: "easeInOutSine",
    underflow: "center",
    bounceBox: null
};
class NI extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        AI(this, "left"),
        AI(this, "top"),
        AI(this, "right"),
        AI(this, "bottom"),
        AI(this, "underflowX"),
        AI(this, "underflowY"),
        AI(this, "ease"),
        AI(this, "toX"),
        AI(this, "toY"),
        this.options = Object.assign({}, OI, e),
        this.ease = MI(this.options.ease, "easeInOutSine"),
        this.options.sides ? "all" === this.options.sides ? this.top = this.bottom = this.left = this.right = !0 : "horizontal" === this.options.sides ? (this.right = this.left = !0,
        this.top = this.bottom = !1) : "vertical" === this.options.sides ? (this.left = this.right = !1,
        this.top = this.bottom = !0) : (this.top = -1 !== this.options.sides.indexOf("top"),
        this.bottom = -1 !== this.options.sides.indexOf("bottom"),
        this.left = -1 !== this.options.sides.indexOf("left"),
        this.right = -1 !== this.options.sides.indexOf("right")) : this.left = this.top = this.right = this.bottom = !1;
        const n = this.options.underflow.toLowerCase();
        "center" === n ? (this.underflowX = 0,
        this.underflowY = 0) : (this.underflowX = -1 !== n.indexOf("left") ? -1 : -1 !== n.indexOf("right") ? 1 : 0,
        this.underflowY = -1 !== n.indexOf("top") ? -1 : -1 !== n.indexOf("bottom") ? 1 : 0),
        this.reset()
    }
    isActive() {
        return null !== this.toX || null !== this.toY
    }
    down() {
        return this.toX = this.toY = null,
        !1
    }
    up() {
        return this.bounce(),
        !1
    }
    update(t) {
        if (!this.paused) {
            if (this.bounce(),
            this.toX) {
                const e = this.toX;
                e.time += t,
                this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "bounce-x"
                }),
                e.time >= this.options.time ? (this.parent.x = e.end,
                this.toX = null,
                this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(e.time, e.start, e.delta, this.options.time)
            }
            if (this.toY) {
                const e = this.toY;
                e.time += t,
                this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "bounce-y"
                }),
                e.time >= this.options.time ? (this.parent.y = e.end,
                this.toY = null,
                this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(e.time, e.start, e.delta, this.options.time)
            }
        }
    }
    calcUnderflowX() {
        let t;
        switch (this.underflowX) {
        case -1:
            t = 0;
            break;
        case 1:
            t = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
        default:
            t = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2
        }
        return t
    }
    calcUnderflowY() {
        let t;
        switch (this.underflowY) {
        case -1:
            t = 0;
            break;
        case 1:
            t = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
        default:
            t = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2
        }
        return t
    }
    oob() {
        const t = this.options.bounceBox;
        if (t) {
            const e = typeof t.x > "u" ? 0 : t.x
              , n = typeof t.y > "u" ? 0 : t.y
              , r = typeof t.width > "u" ? this.parent.worldWidth : t.width
              , i = typeof t.height > "u" ? this.parent.worldHeight : t.height;
            return {
                left: this.parent.left < e,
                right: this.parent.right > r,
                top: this.parent.top < n,
                bottom: this.parent.bottom > i,
                topLeft: new bv(e * this.parent.scale.x,n * this.parent.scale.y),
                bottomRight: new bv(r * this.parent.scale.x - this.parent.screenWidth,i * this.parent.scale.y - this.parent.screenHeight)
            }
        }
        return {
            left: this.parent.left < 0,
            right: this.parent.right > this.parent.worldWidth,
            top: this.parent.top < 0,
            bottom: this.parent.bottom > this.parent.worldHeight,
            topLeft: new bv(0,0),
            bottomRight: new bv(this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight)
        }
    }
    bounce() {
        var t, e;
        if (this.paused)
            return;
        let n, r = this.parent.plugins.get("decelerate", !0);
        r && (r.x || r.y) && (r.x && r.percentChangeX === (null == (t = r.options) ? void 0 : t.friction) || r.y && r.percentChangeY === (null == (e = r.options) ? void 0 : e.friction)) && (n = this.oob(),
        (n.left && this.left || n.right && this.right) && (r.percentChangeX = this.options.friction),
        (n.top && this.top || n.bottom && this.bottom) && (r.percentChangeY = this.options.friction));
        const i = this.parent.plugins.get("drag", !0) || {}
          , s = this.parent.plugins.get("pinch", !0) || {};
        if (r = r || {},
        !(null != i && i.active || null != s && s.active || this.toX && this.toY || r.x && r.y)) {
            n = n || this.oob();
            const t = n.topLeft
              , e = n.bottomRight;
            if (!this.toX && !r.x) {
                let r = null;
                n.left && this.left ? r = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -t.x : n.right && this.right && (r = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -e.x),
                null !== r && this.parent.x !== r && (this.toX = {
                    time: 0,
                    start: this.parent.x,
                    delta: r - this.parent.x,
                    end: r
                },
                this.parent.emit("bounce-x-start", this.parent))
            }
            if (!this.toY && !r.y) {
                let r = null;
                n.top && this.top ? r = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -t.y : n.bottom && this.bottom && (r = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -e.y),
                null !== r && this.parent.y !== r && (this.toY = {
                    time: 0,
                    start: this.parent.y,
                    delta: r - this.parent.y,
                    end: r
                },
                this.parent.emit("bounce-y-start", this.parent))
            }
        }
    }
    reset() {
        this.toX = this.toY = null,
        this.bounce()
    }
}
const RI = {
    left: !1,
    right: !1,
    top: !1,
    bottom: !1,
    direction: null,
    underflow: "center"
};
class DI extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        AI(this, "last"),
        AI(this, "noUnderflow"),
        AI(this, "underflowX"),
        AI(this, "underflowY"),
        this.options = Object.assign({}, RI, e),
        this.options.direction && (this.options.left = "x" === this.options.direction || "all" === this.options.direction || null,
        this.options.right = "x" === this.options.direction || "all" === this.options.direction || null,
        this.options.top = "y" === this.options.direction || "all" === this.options.direction || null,
        this.options.bottom = "y" === this.options.direction || "all" === this.options.direction || null),
        this.parseUnderflow(),
        this.last = {
            x: null,
            y: null,
            scaleX: null,
            scaleY: null
        },
        this.update()
    }
    parseUnderflow() {
        const t = this.options.underflow.toLowerCase();
        "none" === t ? this.noUnderflow = !0 : "center" === t ? (this.underflowX = this.underflowY = 0,
        this.noUnderflow = !1) : (this.underflowX = -1 !== t.indexOf("left") ? -1 : -1 !== t.indexOf("right") ? 1 : 0,
        this.underflowY = -1 !== t.indexOf("top") ? -1 : -1 !== t.indexOf("bottom") ? 1 : 0,
        this.noUnderflow = !1)
    }
    move() {
        return this.update(),
        !1
    }
    update() {
        if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
            return;
        const t = new bv(this.parent.x,this.parent.y)
          , e = this.parent.plugins.decelerate || {};
        if (null !== this.options.left || null !== this.options.right) {
            let n = !1;
            if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
                switch (this.underflowX) {
                case -1:
                    0 !== this.parent.x && (this.parent.x = 0,
                    n = !0);
                    break;
                case 1:
                    this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth,
                    n = !0);
                    break;
                default:
                    this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2,
                    n = !0)
                }
            else
                null !== this.options.left && this.parent.left < (!0 === this.options.left ? 0 : this.options.left) && (this.parent.x = -(!0 === this.options.left ? 0 : this.options.left) * this.parent.scale.x,
                e.x = 0,
                n = !0),
                null !== this.options.right && this.parent.right > (!0 === this.options.right ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(!0 === this.options.right ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth,
                e.x = 0,
                n = !0);
            n && this.parent.emit("moved", {
                viewport: this.parent,
                original: t,
                type: "clamp-x"
            })
        }
        if (null !== this.options.top || null !== this.options.bottom) {
            let n = !1;
            if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
                switch (this.underflowY) {
                case -1:
                    0 !== this.parent.y && (this.parent.y = 0,
                    n = !0);
                    break;
                case 1:
                    this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight,
                    n = !0);
                    break;
                default:
                    this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2,
                    n = !0)
                }
            else
                null !== this.options.top && this.parent.top < (!0 === this.options.top ? 0 : this.options.top) && (this.parent.y = -(!0 === this.options.top ? 0 : this.options.top) * this.parent.scale.y,
                e.y = 0,
                n = !0),
                null !== this.options.bottom && this.parent.bottom > (!0 === this.options.bottom ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(!0 === this.options.bottom ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight,
                e.y = 0,
                n = !0);
            n && this.parent.emit("moved", {
                viewport: this.parent,
                original: t,
                type: "clamp-y"
            })
        }
        this.last.x = this.parent.x,
        this.last.y = this.parent.y,
        this.last.scaleX = this.parent.scale.x,
        this.last.scaleY = this.parent.scale.y
    }
    reset() {
        this.update()
    }
}
const BI = {
    minWidth: null,
    minHeight: null,
    maxWidth: null,
    maxHeight: null,
    minScale: null,
    maxScale: null
};
class LI extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        this.options = Object.assign({}, BI, e),
        this.clamp()
    }
    resize() {
        this.clamp()
    }
    clamp() {
        if (!this.paused)
            if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
                let t = this.parent.worldScreenWidth
                  , e = this.parent.worldScreenHeight;
                if (null !== this.options.minWidth && t < this.options.minWidth) {
                    const n = this.parent.scale.x;
                    this.parent.fitWidth(this.options.minWidth, !1, !1, !0),
                    this.parent.scale.y *= this.parent.scale.x / n,
                    t = this.parent.worldScreenWidth,
                    e = this.parent.worldScreenHeight,
                    this.parent.emit("zoomed", {
                        viewport: this.parent,
                        type: "clamp-zoom"
                    })
                }
                if (null !== this.options.maxWidth && t > this.options.maxWidth) {
                    const n = this.parent.scale.x;
                    this.parent.fitWidth(this.options.maxWidth, !1, !1, !0),
                    this.parent.scale.y *= this.parent.scale.x / n,
                    t = this.parent.worldScreenWidth,
                    e = this.parent.worldScreenHeight,
                    this.parent.emit("zoomed", {
                        viewport: this.parent,
                        type: "clamp-zoom"
                    })
                }
                if (null !== this.options.minHeight && e < this.options.minHeight) {
                    const n = this.parent.scale.y;
                    this.parent.fitHeight(this.options.minHeight, !1, !1, !0),
                    this.parent.scale.x *= this.parent.scale.y / n,
                    t = this.parent.worldScreenWidth,
                    e = this.parent.worldScreenHeight,
                    this.parent.emit("zoomed", {
                        viewport: this.parent,
                        type: "clamp-zoom"
                    })
                }
                if (null !== this.options.maxHeight && e > this.options.maxHeight) {
                    const t = this.parent.scale.y;
                    this.parent.fitHeight(this.options.maxHeight, !1, !1, !0),
                    this.parent.scale.x *= this.parent.scale.y / t,
                    this.parent.emit("zoomed", {
                        viewport: this.parent,
                        type: "clamp-zoom"
                    })
                }
            } else if (this.options.minScale || this.options.maxScale) {
                const t = {
                    x: null,
                    y: null
                }
                  , e = {
                    x: null,
                    y: null
                };
                if ("number" == typeof this.options.minScale)
                    t.x = this.options.minScale,
                    t.y = this.options.minScale;
                else if (null !== this.options.minScale) {
                    const e = this.options.minScale;
                    t.x = typeof e.x > "u" ? null : e.x,
                    t.y = typeof e.y > "u" ? null : e.y
                }
                if ("number" == typeof this.options.maxScale)
                    e.x = this.options.maxScale,
                    e.y = this.options.maxScale;
                else if (null !== this.options.maxScale) {
                    const t = this.options.maxScale;
                    e.x = typeof t.x > "u" ? null : t.x,
                    e.y = typeof t.y > "u" ? null : t.y
                }
                let n = this.parent.scale.x
                  , r = this.parent.scale.y;
                null !== t.x && n < t.x && (n = t.x),
                null !== e.x && n > e.x && (n = e.x),
                null !== t.y && r < t.y && (r = t.y),
                null !== e.y && r > e.y && (r = e.y),
                (n !== this.parent.scale.x || r !== this.parent.scale.y) && (this.parent.scale.set(n, r),
                this.parent.emit("zoomed", {
                    viewport: this.parent,
                    type: "clamp-zoom"
                }))
            }
    }
    reset() {
        this.clamp()
    }
}
const FI = {
    friction: .98,
    bounce: .8,
    minSpeed: .01
}
  , jI = 16;
class UI extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        AI(this, "x"),
        AI(this, "y"),
        AI(this, "percentChangeX"),
        AI(this, "percentChangeY"),
        AI(this, "saved"),
        AI(this, "timeSinceRelease"),
        this.options = Object.assign({}, FI, e),
        this.saved = [],
        this.timeSinceRelease = 0,
        this.reset(),
        this.parent.on("moved", (t=>this.handleMoved(t)))
    }
    down() {
        return this.saved = [],
        this.x = this.y = null,
        !1
    }
    isActive() {
        return !(!this.x && !this.y)
    }
    move() {
        if (this.paused)
            return !1;
        const t = this.parent.input.count();
        return (1 === t || t > 1 && !this.parent.plugins.get("pinch", !0)) && (this.saved.push({
            x: this.parent.x,
            y: this.parent.y,
            time: performance.now()
        }),
        this.saved.length > 60 && this.saved.splice(0, 30)),
        !1
    }
    handleMoved(t) {
        if (this.saved.length) {
            const e = this.saved[this.saved.length - 1];
            "clamp-x" === t.type && t.original ? e.x === t.original.x && (e.x = this.parent.x) : "clamp-y" === t.type && t.original && e.y === t.original.y && (e.y = this.parent.y)
        }
    }
    up() {
        if (0 === this.parent.input.count() && this.saved.length) {
            const t = performance.now();
            for (const e of this.saved)
                if (e.time >= t - 100) {
                    const n = t - e.time;
                    this.x = (this.parent.x - e.x) / n,
                    this.y = (this.parent.y - e.y) / n,
                    this.percentChangeX = this.percentChangeY = this.options.friction,
                    this.timeSinceRelease = 0;
                    break
                }
        }
        return !1
    }
    activate(t) {
        typeof (t = t || {}).x < "u" && (this.x = t.x,
        this.percentChangeX = this.options.friction),
        typeof t.y < "u" && (this.y = t.y,
        this.percentChangeY = this.options.friction)
    }
    update(t) {
        if (this.paused)
            return;
        const e = this.x || this.y
          , n = this.timeSinceRelease
          , r = this.timeSinceRelease + t;
        if (this.x) {
            const e = this.percentChangeX
              , i = Math.log(e);
            this.parent.x += this.x * jI / i * (Math.pow(e, r / jI) - Math.pow(e, n / jI)),
            this.x *= Math.pow(this.percentChangeX, t / jI)
        }
        if (this.y) {
            const e = this.percentChangeY
              , i = Math.log(e);
            this.parent.y += this.y * jI / i * (Math.pow(e, r / jI) - Math.pow(e, n / jI)),
            this.y *= Math.pow(this.percentChangeY, t / jI)
        }
        this.timeSinceRelease += t,
        this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0,
        this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0),
        Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)),
        e && this.parent.emit("moved", {
            viewport: this.parent,
            type: "decelerate"
        })
    }
    reset() {
        this.x = this.y = null
    }
}
const zI = {
    direction: "all",
    pressDrag: !0,
    wheel: !0,
    wheelScroll: 1,
    reverse: !1,
    clampWheel: !1,
    underflow: "center",
    factor: 1,
    mouseButtons: "all",
    keyToPress: null,
    ignoreKeyToPressOnTouch: !1,
    lineHeight: 20,
    wheelSwapAxes: !1
};
class VI extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        AI(this, "moved"),
        AI(this, "reverse"),
        AI(this, "xDirection"),
        AI(this, "yDirection"),
        AI(this, "keyIsPressed"),
        AI(this, "mouse"),
        AI(this, "underflowX"),
        AI(this, "underflowY"),
        AI(this, "last"),
        AI(this, "current"),
        AI(this, "windowEventHandlers", []),
        this.options = Object.assign({}, zI, e),
        this.moved = !1,
        this.reverse = this.options.reverse ? 1 : -1,
        this.xDirection = !this.options.direction || "all" === this.options.direction || "x" === this.options.direction,
        this.yDirection = !this.options.direction || "all" === this.options.direction || "y" === this.options.direction,
        this.keyIsPressed = !1,
        this.parseUnderflow(),
        this.mouseButtons(this.options.mouseButtons),
        this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress)
    }
    handleKeyPresses(t) {
        this.addWindowEventHandler("keyup", (e=>{
            t.includes(e.code) && (this.keyIsPressed = !1)
        }
        )),
        this.addWindowEventHandler("keydown", (e=>{
            t.includes(e.code) && (this.keyIsPressed = !0)
        }
        ))
    }
    addWindowEventHandler(t, e) {
        window.addEventListener(t, e),
        this.windowEventHandlers.push({
            event: t,
            handler: e
        })
    }
    destroy() {
        this.windowEventHandlers.forEach((({event: t, handler: e})=>{
            window.removeEventListener(t, e)
        }
        ))
    }
    mouseButtons(t) {
        this.mouse = t && "all" !== t ? [-1 !== t.indexOf("left"), -1 !== t.indexOf("middle"), -1 !== t.indexOf("right")] : [!0, !0, !0]
    }
    parseUnderflow() {
        const t = this.options.underflow.toLowerCase();
        "center" === t ? (this.underflowX = 0,
        this.underflowY = 0) : (t.includes("left") ? this.underflowX = -1 : t.includes("right") ? this.underflowX = 1 : this.underflowX = 0,
        t.includes("top") ? this.underflowY = -1 : t.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0)
    }
    checkButtons(t) {
        const e = "mouse" === t.pointerType
          , n = this.parent.input.count();
        return !(!(1 === n || n > 1 && !this.parent.plugins.get("pinch", !0)) || e && !this.mouse[t.button])
    }
    checkKeyPress(t) {
        return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && "touch" === t.data.pointerType
    }
    down(t) {
        return !(this.paused || !this.options.pressDrag) && (this.checkButtons(t) && this.checkKeyPress(t) ? (this.last = {
            x: t.global.x,
            y: t.global.y
        },
        this.current = t.pointerId,
        !0) : (this.last = null,
        !1))
    }
    get active() {
        return this.moved
    }
    move(t) {
        if (this.paused || !this.options.pressDrag)
            return !1;
        if (this.last && this.current === t.data.pointerId) {
            const e = t.global.x
              , n = t.global.y
              , r = this.parent.input.count();
            if (1 === r || r > 1 && !this.parent.plugins.get("pinch", !0)) {
                const r = e - this.last.x
                  , i = n - this.last.y;
                if (this.moved || this.xDirection && this.parent.input.checkThreshold(r) || this.yDirection && this.parent.input.checkThreshold(i)) {
                    const r = {
                        x: e,
                        y: n
                    };
                    return this.xDirection && (this.parent.x += (r.x - this.last.x) * this.options.factor),
                    this.yDirection && (this.parent.y += (r.y - this.last.y) * this.options.factor),
                    this.last = r,
                    this.moved || this.parent.emit("drag-start", {
                        event: t,
                        screen: new bv(this.last.x,this.last.y),
                        world: this.parent.toWorld(new bv(this.last.x,this.last.y)),
                        viewport: this.parent
                    }),
                    this.moved = !0,
                    this.parent.emit("moved", {
                        viewport: this.parent,
                        type: "drag"
                    }),
                    !0
                }
            } else
                this.moved = !1
        }
        return !1
    }
    up(t) {
        if (this.paused)
            return !1;
        const e = this.parent.input.touches;
        if (1 === e.length) {
            const t = e[0];
            return t.last && (this.last = {
                x: t.last.x,
                y: t.last.y
            },
            this.current = t.id),
            this.moved = !1,
            !0
        }
        if (this.last && this.moved) {
            const e = new bv(this.last.x,this.last.y);
            return this.parent.emit("drag-end", {
                event: t,
                screen: e,
                world: this.parent.toWorld(e),
                viewport: this.parent
            }),
            this.last = null,
            this.moved = !1,
            !0
        }
        return !1
    }
    wheel(t) {
        if (this.paused)
            return !1;
        if (this.options.wheel) {
            const e = this.parent.plugins.get("wheel", !0);
            if (!e || !e.options.wheelZoom && !t.ctrlKey) {
                const e = t.deltaMode ? this.options.lineHeight : 1
                  , n = [t.deltaX, t.deltaY]
                  , [r,i] = this.options.wheelSwapAxes ? n.reverse() : n;
                return this.xDirection && (this.parent.x += r * e * this.options.wheelScroll * this.reverse),
                this.yDirection && (this.parent.y += i * e * this.options.wheelScroll * this.reverse),
                this.options.clampWheel && this.clamp(),
                this.parent.emit("wheel-scroll", this.parent),
                this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "wheel"
                }),
                this.parent.options.passiveWheel || t.preventDefault(),
                this.parent.options.stopPropagation && t.stopPropagation(),
                !0
            }
        }
        return !1
    }
    resume() {
        this.last = null,
        this.paused = !1
    }
    clamp() {
        const t = this.parent.plugins.get("decelerate", !0) || {};
        if ("y" !== this.options.clampWheel)
            if (this.parent.screenWorldWidth < this.parent.screenWidth)
                switch (this.underflowX) {
                case -1:
                    this.parent.x = 0;
                    break;
                case 1:
                    this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
                    break;
                default:
                    this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2
                }
            else
                this.parent.left < 0 ? (this.parent.x = 0,
                t.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth,
                t.x = 0);
        if ("x" !== this.options.clampWheel)
            if (this.parent.screenWorldHeight < this.parent.screenHeight)
                switch (this.underflowY) {
                case -1:
                    this.parent.y = 0;
                    break;
                case 1:
                    this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
                    break;
                default:
                    this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2
                }
            else
                this.parent.top < 0 && (this.parent.y = 0,
                t.y = 0),
                this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight,
                t.y = 0)
    }
}
const WI = {
    speed: 0,
    acceleration: null,
    radius: null
};
class YI extends SI {
    constructor(t, e, n={}) {
        super(t),
        AI(this, "options"),
        AI(this, "target"),
        AI(this, "velocity"),
        this.target = e,
        this.options = Object.assign({}, WI, n),
        this.velocity = {
            x: 0,
            y: 0
        }
    }
    update(t) {
        if (this.paused)
            return;
        const e = this.parent.center;
        let n = this.target.x
          , r = this.target.y;
        if (this.options.radius) {
            if (!(Math.sqrt(Math.pow(this.target.y - e.y, 2) + Math.pow(this.target.x - e.x, 2)) > this.options.radius))
                return;
            {
                const t = Math.atan2(this.target.y - e.y, this.target.x - e.x);
                n = this.target.x - Math.cos(t) * this.options.radius,
                r = this.target.y - Math.sin(t) * this.options.radius
            }
        }
        const i = n - e.x
          , s = r - e.y;
        if (i || s)
            if (this.options.speed)
                if (this.options.acceleration) {
                    const t = Math.atan2(r - e.y, n - e.x)
                      , o = Math.sqrt(Math.pow(i, 2) + Math.pow(s, 2));
                    if (o) {
                        const a = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
                        this.velocity = o > a ? {
                            x: Math.min(this.velocity.x + (this.options.acceleration,
                            this.options.speed)),
                            y: Math.min(this.velocity.y + (this.options.acceleration,
                            this.options.speed))
                        } : {
                            x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
                            y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
                        };
                        const l = Math.cos(t) * this.velocity.x
                          , c = Math.sin(t) * this.velocity.y
                          , u = Math.abs(l) > Math.abs(i) ? n : e.x + l
                          , h = Math.abs(c) > Math.abs(s) ? r : e.y + c;
                        this.parent.moveCenter(u, h),
                        this.parent.emit("moved", {
                            viewport: this.parent,
                            type: "follow"
                        })
                    }
                } else {
                    const t = Math.atan2(r - e.y, n - e.x)
                      , o = Math.cos(t) * this.options.speed
                      , a = Math.sin(t) * this.options.speed
                      , l = Math.abs(o) > Math.abs(i) ? n : e.x + o
                      , c = Math.abs(a) > Math.abs(s) ? r : e.y + a;
                    this.parent.moveCenter(l, c),
                    this.parent.emit("moved", {
                        viewport: this.parent,
                        type: "follow"
                    })
                }
            else
                this.parent.moveCenter(n, r),
                this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "follow"
                })
    }
}
const HI = {
    radius: null,
    distance: null,
    top: null,
    bottom: null,
    left: null,
    right: null,
    speed: 8,
    reverse: !1,
    noDecelerate: !1,
    linear: !1,
    allowButtons: !1
};
class $I extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        AI(this, "reverse"),
        AI(this, "radiusSquared"),
        AI(this, "left"),
        AI(this, "top"),
        AI(this, "right"),
        AI(this, "bottom"),
        AI(this, "horizontal"),
        AI(this, "vertical"),
        this.options = Object.assign({}, HI, e),
        this.reverse = this.options.reverse ? 1 : -1,
        this.radiusSquared = "number" == typeof this.options.radius ? Math.pow(this.options.radius, 2) : null,
        this.resize()
    }
    resize() {
        const t = this.options.distance;
        null !== t ? (this.left = t,
        this.top = t,
        this.right = this.parent.screenWidth - t,
        this.bottom = this.parent.screenHeight - t) : this.options.radius || (this.left = this.options.left,
        this.top = this.options.top,
        this.right = null === this.options.right ? null : this.parent.screenWidth - this.options.right,
        this.bottom = null === this.options.bottom ? null : this.parent.screenHeight - this.options.bottom)
    }
    down() {
        return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null),
        !1
    }
    move(t) {
        if (this.paused || "mouse" !== t.pointerType && 1 !== t.pointerId || !this.options.allowButtons && 0 !== t.buttons)
            return !1;
        const e = t.global.x
          , n = t.global.y;
        if (this.radiusSquared) {
            const t = this.parent.toScreen(this.parent.center);
            if (Math.pow(t.x - e, 2) + Math.pow(t.y - n, 2) >= this.radiusSquared) {
                const r = Math.atan2(t.y - n, t.x - e);
                this.options.linear ? (this.horizontal = Math.round(Math.cos(r)) * this.options.speed * this.reverse * .06,
                this.vertical = Math.round(Math.sin(r)) * this.options.speed * this.reverse * .06) : (this.horizontal = Math.cos(r) * this.options.speed * this.reverse * .06,
                this.vertical = Math.sin(r) * this.options.speed * this.reverse * .06)
            } else
                this.horizontal && this.decelerateHorizontal(),
                this.vertical && this.decelerateVertical(),
                this.horizontal = this.vertical = 0
        } else
            null !== this.left && e < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * .06 : null !== this.right && e > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * .06 : (this.decelerateHorizontal(),
            this.horizontal = 0),
            null !== this.top && n < this.top ? this.vertical = Number(this.reverse) * this.options.speed * .06 : null !== this.bottom && n > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * .06 : (this.decelerateVertical(),
            this.vertical = 0);
        return !1
    }
    decelerateHorizontal() {
        const t = this.parent.plugins.get("decelerate", !0);
        this.horizontal && t && !this.options.noDecelerate && t.activate({
            x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60)
        })
    }
    decelerateVertical() {
        const t = this.parent.plugins.get("decelerate", !0);
        this.vertical && t && !this.options.noDecelerate && t.activate({
            y: this.vertical * this.options.speed * this.reverse / (1e3 / 60)
        })
    }
    up() {
        return this.paused || (this.horizontal && this.decelerateHorizontal(),
        this.vertical && this.decelerateVertical(),
        this.horizontal = this.vertical = null),
        !1
    }
    update() {
        if (!this.paused && (this.horizontal || this.vertical)) {
            const t = this.parent.center;
            this.horizontal && (t.x += this.horizontal * this.options.speed),
            this.vertical && (t.y += this.vertical * this.options.speed),
            this.parent.moveCenter(t),
            this.parent.emit("moved", {
                viewport: this.parent,
                type: "mouse-edges"
            })
        }
    }
}
const GI = {
    noDrag: !1,
    percent: 1,
    center: null,
    factor: 1,
    axis: "all"
};
class XI extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        AI(this, "active", !1),
        AI(this, "pinching", !1),
        AI(this, "moved", !1),
        AI(this, "lastCenter"),
        this.options = Object.assign({}, GI, e)
    }
    down() {
        return this.parent.input.count() >= 2 && (this.active = !0,
        !0)
    }
    isAxisX() {
        return ["all", "x"].includes(this.options.axis)
    }
    isAxisY() {
        return ["all", "y"].includes(this.options.axis)
    }
    move(t) {
        if (this.paused || !this.active)
            return !1;
        const e = t.global.x
          , n = t.global.y
          , r = this.parent.input.touches;
        if (r.length >= 2) {
            const i = r[0]
              , s = r[1]
              , o = i.last && s.last ? Math.sqrt(Math.pow(s.last.x - i.last.x, 2) + Math.pow(s.last.y - i.last.y, 2)) : null;
            if (i.id === t.pointerId ? i.last = {
                x: e,
                y: n,
                data: t
            } : s.id === t.pointerId && (s.last = {
                x: e,
                y: n,
                data: t
            }),
            o) {
                let t;
                const e = new bv(i.last.x + (s.last.x - i.last.x) / 2,i.last.y + (s.last.y - i.last.y) / 2);
                this.options.center || (t = this.parent.toLocal(e));
                let n = Math.sqrt(Math.pow(s.last.x - i.last.x, 2) + Math.pow(s.last.y - i.last.y, 2));
                n = 0 === n ? n = 1e-10 : n;
                const r = (1 - o / n) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
                this.isAxisX() && (this.parent.scale.x += r),
                this.isAxisY() && (this.parent.scale.y += r),
                this.parent.emit("zoomed", {
                    viewport: this.parent,
                    type: "pinch",
                    center: e
                });
                const a = this.parent.plugins.get("clamp-zoom", !0);
                if (a && a.clamp(),
                this.options.center)
                    this.parent.moveCenter(this.options.center);
                else {
                    const n = this.parent.toGlobal(t);
                    this.parent.x += (e.x - n.x) * this.options.factor,
                    this.parent.y += (e.y - n.y) * this.options.factor,
                    this.parent.emit("moved", {
                        viewport: this.parent,
                        type: "pinch"
                    })
                }
                !this.options.noDrag && this.lastCenter && (this.parent.x += (e.x - this.lastCenter.x) * this.options.factor,
                this.parent.y += (e.y - this.lastCenter.y) * this.options.factor,
                this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "pinch"
                })),
                this.lastCenter = e,
                this.moved = !0
            } else
                this.pinching || (this.parent.emit("pinch-start", this.parent),
                this.pinching = !0);
            return !0
        }
        return !1
    }
    up() {
        return !!(this.pinching && this.parent.input.touches.length <= 1) && (this.active = !1,
        this.lastCenter = null,
        this.pinching = !1,
        this.moved = !1,
        this.parent.emit("pinch-end", this.parent),
        !0)
    }
}
const qI = {
    topLeft: !1,
    friction: .8,
    time: 1e3,
    ease: "easeInOutSine",
    interrupt: !0,
    removeOnComplete: !1,
    removeOnInterrupt: !1,
    forceStart: !1
};
class KI extends SI {
    constructor(t, e, n, r={}) {
        super(t),
        AI(this, "options"),
        AI(this, "ease"),
        AI(this, "x"),
        AI(this, "y"),
        AI(this, "percent"),
        AI(this, "snapping"),
        AI(this, "deltaX"),
        AI(this, "deltaY"),
        AI(this, "startX"),
        AI(this, "startY"),
        this.options = Object.assign({}, qI, r),
        this.ease = MI(r.ease, "easeInOutSine"),
        this.x = e,
        this.y = n,
        this.options.forceStart && this.snapStart()
    }
    snapStart() {
        this.percent = 0,
        this.snapping = {
            time: 0
        };
        const t = this.options.topLeft ? this.parent.corner : this.parent.center;
        this.deltaX = this.x - t.x,
        this.deltaY = this.y - t.y,
        this.startX = t.x,
        this.startY = t.y,
        this.parent.emit("snap-start", this.parent)
    }
    wheel() {
        return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"),
        !1
    }
    down() {
        return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null),
        !1
    }
    up() {
        if (0 === this.parent.input.count()) {
            const t = this.parent.plugins.get("decelerate", !0);
            t && (t.x || t.y) && (t.percentChangeX = t.percentChangeY = this.options.friction)
        }
        return !1
    }
    update(t) {
        if (!(this.paused || this.options.interrupt && 0 !== this.parent.input.count()))
            if (this.snapping) {
                const e = this.snapping;
                let n, r, i;
                e.time += t;
                const s = this.startX
                  , o = this.startY
                  , a = this.deltaX
                  , l = this.deltaY;
                if (e.time > this.options.time)
                    n = !0,
                    r = s + a,
                    i = o + l;
                else {
                    const t = this.ease(e.time, 0, 1, this.options.time);
                    r = s + a * t,
                    i = o + l * t
                }
                this.options.topLeft ? this.parent.moveCorner(r, i) : this.parent.moveCenter(r, i),
                this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "snap"
                }),
                n && (this.options.removeOnComplete && this.parent.plugins.remove("snap"),
                this.parent.emit("snap-end", this.parent),
                this.snapping = null)
            } else {
                const t = this.options.topLeft ? this.parent.corner : this.parent.center;
                (t.x !== this.x || t.y !== this.y) && this.snapStart()
            }
    }
}
const QI = {
    width: 0,
    height: 0,
    time: 1e3,
    ease: "easeInOutSine",
    center: null,
    interrupt: !0,
    removeOnComplete: !1,
    removeOnInterrupt: !1,
    forceStart: !1,
    noMove: !1
};
class ZI extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        AI(this, "ease"),
        AI(this, "xScale"),
        AI(this, "yScale"),
        AI(this, "xIndependent"),
        AI(this, "yIndependent"),
        AI(this, "snapping"),
        this.options = Object.assign({}, QI, e),
        this.ease = MI(this.options.ease),
        this.xIndependent = !1,
        this.yIndependent = !1,
        this.xScale = 0,
        this.yScale = 0,
        this.options.width > 0 && (this.xScale = t.screenWidth / this.options.width,
        this.xIndependent = !0),
        this.options.height > 0 && (this.yScale = t.screenHeight / this.options.height,
        this.yIndependent = !0),
        this.xScale = this.xIndependent ? this.xScale : this.yScale,
        this.yScale = this.yIndependent ? this.yScale : this.xScale,
        0 === this.options.time ? (t.container.scale.x = this.xScale,
        t.container.scale.y = this.yScale,
        this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : e.forceStart && this.createSnapping()
    }
    createSnapping() {
        const t = this.parent.worldScreenWidth
          , e = this.parent.worldScreenHeight
          , n = this.parent.screenWidth / this.xScale
          , r = this.parent.screenHeight / this.yScale;
        this.snapping = {
            time: 0,
            startX: t,
            startY: e,
            deltaX: n - t,
            deltaY: r - e
        },
        this.parent.emit("snap-zoom-start", this.parent)
    }
    resize() {
        this.snapping = null,
        this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width),
        this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height),
        this.xScale = this.xIndependent ? this.xScale : this.yScale,
        this.yScale = this.yIndependent ? this.yScale : this.xScale
    }
    wheel() {
        return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"),
        !1
    }
    down() {
        return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null),
        !1
    }
    update(t) {
        if (this.paused || this.options.interrupt && 0 !== this.parent.input.count())
            return;
        let e;
        if (!this.options.center && !this.options.noMove && (e = this.parent.center),
        this.snapping) {
            if (this.snapping) {
                const n = this.snapping;
                if (n.time += t,
                n.time >= this.options.time)
                    this.parent.scale.set(this.xScale, this.yScale),
                    this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"),
                    this.parent.emit("snap-zoom-end", this.parent),
                    this.snapping = null;
                else {
                    const t = this.snapping
                      , e = this.ease(t.time, t.startX, t.deltaX, this.options.time)
                      , n = this.ease(t.time, t.startY, t.deltaY, this.options.time);
                    this.parent.scale.x = this.parent.screenWidth / e,
                    this.parent.scale.y = this.parent.screenHeight / n
                }
                const r = this.parent.plugins.get("clamp-zoom", !0);
                r && r.clamp(),
                this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(e))
            }
        } else
            (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping()
    }
    resume() {
        this.snapping = null,
        super.resume()
    }
}
const JI = {
    percent: .1,
    smooth: !1,
    interrupt: !0,
    reverse: !1,
    center: null,
    lineHeight: 20,
    axis: "all",
    keyToPress: null,
    trackpadPinch: !1,
    wheelZoom: !0
};
class tM extends SI {
    constructor(t, e={}) {
        super(t),
        AI(this, "options"),
        AI(this, "smoothing"),
        AI(this, "smoothingCenter"),
        AI(this, "smoothingCount"),
        AI(this, "keyIsPressed"),
        this.options = Object.assign({}, JI, e),
        this.keyIsPressed = !1,
        this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress)
    }
    handleKeyPresses(t) {
        window.addEventListener("keydown", (e=>{
            t.includes(e.code) && (this.keyIsPressed = !0)
        }
        )),
        window.addEventListener("keyup", (e=>{
            t.includes(e.code) && (this.keyIsPressed = !1)
        }
        ))
    }
    checkKeyPress() {
        return !this.options.keyToPress || this.keyIsPressed
    }
    down() {
        return this.options.interrupt && (this.smoothing = null),
        !1
    }
    isAxisX() {
        return ["all", "x"].includes(this.options.axis)
    }
    isAxisY() {
        return ["all", "y"].includes(this.options.axis)
    }
    update() {
        if (this.smoothing) {
            const t = this.smoothingCenter
              , e = this.smoothing;
            let n;
            this.options.center || (n = this.parent.toLocal(t)),
            this.isAxisX() && (this.parent.scale.x += e.x),
            this.isAxisY() && (this.parent.scale.y += e.y),
            this.parent.emit("zoomed", {
                viewport: this.parent,
                type: "wheel"
            });
            const r = this.parent.plugins.get("clamp-zoom", !0);
            if (r && r.clamp(),
            this.options.center)
                this.parent.moveCenter(this.options.center);
            else {
                const e = this.parent.toGlobal(n);
                this.parent.x += t.x - e.x,
                this.parent.y += t.y - e.y
            }
            this.parent.emit("moved", {
                viewport: this.parent,
                type: "wheel"
            }),
            this.smoothingCount++,
            this.smoothingCount >= this.options.smooth && (this.smoothing = null)
        }
    }
    pinch(t) {
        if (this.paused)
            return;
        const e = this.parent.input.getPointerPosition(t)
          , n = -t.deltaY * (t.deltaMode ? this.options.lineHeight : 1) / 200
          , r = Math.pow(2, (1 + this.options.percent) * n);
        let i;
        this.options.center || (i = this.parent.toLocal(e)),
        this.isAxisX() && (this.parent.scale.x *= r),
        this.isAxisY() && (this.parent.scale.y *= r),
        this.parent.emit("zoomed", {
            viewport: this.parent,
            type: "wheel"
        });
        const s = this.parent.plugins.get("clamp-zoom", !0);
        if (s && s.clamp(),
        this.options.center)
            this.parent.moveCenter(this.options.center);
        else {
            const t = this.parent.toGlobal(i);
            this.parent.x += e.x - t.x,
            this.parent.y += e.y - t.y
        }
        this.parent.emit("moved", {
            viewport: this.parent,
            type: "wheel"
        }),
        this.parent.emit("wheel-start", {
            event: t,
            viewport: this.parent
        })
    }
    wheel(t) {
        if (this.paused || !this.checkKeyPress())
            return !1;
        if (t.ctrlKey && this.options.trackpadPinch)
            this.pinch(t);
        else if (this.options.wheelZoom) {
            const e = this.parent.input.getPointerPosition(t)
              , n = (this.options.reverse ? -1 : 1) * -t.deltaY * (t.deltaMode ? this.options.lineHeight : 1) / 500
              , r = Math.pow(2, (1 + this.options.percent) * n);
            if (this.options.smooth) {
                const t = {
                    x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
                    y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
                };
                this.smoothing = {
                    x: ((this.parent.scale.x + t.x) * r - this.parent.scale.x) / this.options.smooth,
                    y: ((this.parent.scale.y + t.y) * r - this.parent.scale.y) / this.options.smooth
                },
                this.smoothingCount = 0,
                this.smoothingCenter = e
            } else {
                let t;
                this.options.center || (t = this.parent.toLocal(e)),
                this.isAxisX() && (this.parent.scale.x *= r),
                this.isAxisY() && (this.parent.scale.y *= r),
                this.parent.emit("zoomed", {
                    viewport: this.parent,
                    type: "wheel"
                });
                const n = this.parent.plugins.get("clamp-zoom", !0);
                if (n && n.clamp(),
                this.options.center)
                    this.parent.moveCenter(this.options.center);
                else {
                    const n = this.parent.toGlobal(t);
                    this.parent.x += e.x - n.x,
                    this.parent.y += e.y - n.y
                }
            }
            this.parent.emit("moved", {
                viewport: this.parent,
                type: "wheel"
            }),
            this.parent.emit("wheel-start", {
                event: t,
                viewport: this.parent
            })
        }
        return !this.parent.options.passiveWheel
    }
}
class eM {
    constructor(t) {
        AI(this, "viewport"),
        AI(this, "clickedAvailable"),
        AI(this, "isMouseDown"),
        AI(this, "last"),
        AI(this, "wheelFunction"),
        AI(this, "touches"),
        this.viewport = t,
        this.touches = [],
        this.addListeners()
    }
    addListeners() {
        this.viewport.interactive = !0,
        this.viewport.forceHitArea || (this.viewport.hitArea = new wv(0,0,this.viewport.worldWidth,this.viewport.worldHeight)),
        this.viewport.on("pointerdown", this.down, this),
        this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this),
        this.viewport.on("pointerup", this.up, this),
        this.viewport.on("pointerupoutside", this.up, this),
        this.viewport.on("pointercancel", this.up, this),
        this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this),
        this.wheelFunction = t=>this.handleWheel(t),
        this.viewport.options.events.domElement.addEventListener("wheel", this.wheelFunction, {
            passive: this.viewport.options.passiveWheel
        }),
        this.isMouseDown = !1
    }
    destroy() {
        this.viewport.options.events.domElement.removeEventListener("wheel", this.wheelFunction)
    }
    down(t) {
        if (!this.viewport.pause && this.viewport.worldVisible) {
            if ("mouse" === t.pointerType ? this.isMouseDown = !0 : this.get(t.pointerId) || this.touches.push({
                id: t.pointerId,
                last: null
            }),
            1 === this.count()) {
                this.last = t.global.clone();
                const e = this.viewport.plugins.get("decelerate", !0)
                  , n = this.viewport.plugins.get("bounce", !0);
                e && e.isActive() || n && n.isActive() ? this.clickedAvailable = !1 : this.clickedAvailable = !0
            } else
                this.clickedAvailable = !1;
            this.viewport.plugins.down(t) && this.viewport.options.stopPropagation && t.stopPropagation()
        }
    }
    clear() {
        this.isMouseDown = !1,
        this.touches = [],
        this.last = null
    }
    checkThreshold(t) {
        return Math.abs(t) >= this.viewport.threshold
    }
    move(t) {
        if (this.viewport.pause || !this.viewport.worldVisible)
            return;
        const e = this.viewport.plugins.move(t);
        if (this.clickedAvailable && this.last) {
            const e = t.global.x - this.last.x
              , n = t.global.y - this.last.y;
            (this.checkThreshold(e) || this.checkThreshold(n)) && (this.clickedAvailable = !1)
        }
        e && this.viewport.options.stopPropagation && t.stopPropagation()
    }
    up(t) {
        if (this.viewport.pause || !this.viewport.worldVisible)
            return;
        "mouse" === t.pointerType && (this.isMouseDown = !1),
        "mouse" !== t.pointerType && this.remove(t.pointerId);
        const e = this.viewport.plugins.up(t);
        this.clickedAvailable && 0 === this.count() && this.last && (this.viewport.emit("clicked", {
            event: t,
            screen: this.last,
            world: this.viewport.toWorld(this.last),
            viewport: this.viewport
        }),
        this.clickedAvailable = !1),
        e && this.viewport.options.stopPropagation && t.stopPropagation()
    }
    getPointerPosition(t) {
        const e = new bv;
        return this.viewport.options.events.mapPositionToPoint(e, t.clientX, t.clientY),
        e
    }
    handleWheel(t) {
        if (this.viewport.pause || !this.viewport.worldVisible)
            return;
        const e = this.viewport.toLocal(this.getPointerPosition(t));
        this.viewport.left <= e.x && e.x <= this.viewport.right && this.viewport.top <= e.y && e.y <= this.viewport.bottom && this.viewport.plugins.wheel(t) && !this.viewport.options.passiveWheel && t.preventDefault()
    }
    pause() {
        this.touches = [],
        this.isMouseDown = !1
    }
    get(t) {
        for (const e of this.touches)
            if (e.id === t)
                return e;
        return null
    }
    remove(t) {
        for (let e = 0; e < this.touches.length; e++)
            if (this.touches[e].id === t)
                return void this.touches.splice(e, 1)
    }
    count() {
        return (this.isMouseDown ? 1 : 0) + this.touches.length
    }
}
const nM = ["drag", "pinch", "wheel", "follow", "mouse-edges", "decelerate", "animate", "bounce", "snap-zoom", "clamp-zoom", "snap", "clamp"];
class rM {
    constructor(t) {
        AI(this, "plugins"),
        AI(this, "list"),
        AI(this, "viewport"),
        this.viewport = t,
        this.list = [],
        this.plugins = {}
    }
    add(t, e, n=nM.length) {
        const r = this.plugins[t];
        r && r.destroy(),
        this.plugins[t] = e;
        const i = nM.indexOf(t);
        -1 !== i && nM.splice(i, 1),
        nM.splice(n, 0, t),
        this.sort()
    }
    get(t, e) {
        var n;
        return e && null != (n = this.plugins[t]) && n.paused ? null : this.plugins[t]
    }
    update(t) {
        for (const e of this.list)
            e.update(t)
    }
    resize() {
        for (const t of this.list)
            t.resize()
    }
    reset() {
        for (const t of this.list)
            t.reset()
    }
    removeAll() {
        this.list.forEach((t=>{
            t.destroy()
        }
        )),
        this.plugins = {},
        this.sort()
    }
    remove(t) {
        var e;
        this.plugins[t] && (null == (e = this.plugins[t]) || e.destroy(),
        delete this.plugins[t],
        this.viewport.emit("plugin-remove", t),
        this.sort())
    }
    pause(t) {
        var e;
        null == (e = this.plugins[t]) || e.pause()
    }
    resume(t) {
        var e;
        null == (e = this.plugins[t]) || e.resume()
    }
    sort() {
        this.list = [];
        for (const t of nM)
            this.plugins[t] && this.list.push(this.plugins[t])
    }
    down(t) {
        let e = !1;
        for (const n of this.list)
            n.down(t) && (e = !0);
        return e
    }
    move(t) {
        let e = !1;
        for (const n of this.viewport.plugins.list)
            n.move(t) && (e = !0);
        return e
    }
    up(t) {
        let e = !1;
        for (const n of this.list)
            n.up(t) && (e = !0);
        return e
    }
    wheel(t) {
        let e = !1;
        for (const n of this.list)
            n.wheel(t) && (e = !0);
        return e
    }
}
const iM = {
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: null,
    worldHeight: null,
    threshold: 5,
    passiveWheel: !0,
    stopPropagation: !1,
    forceHitArea: null,
    noTicker: !1,
    disableOnContextMenu: !1,
    ticker: Bx.shared,
    allowPreserveDragOutside: !1
};
class sM extends EI {
    constructor(t) {
        super(),
        AI(this, "moving"),
        AI(this, "screenWidth"),
        AI(this, "screenHeight"),
        AI(this, "threshold"),
        AI(this, "input"),
        AI(this, "plugins"),
        AI(this, "zooming"),
        AI(this, "lastViewport"),
        AI(this, "options"),
        AI(this, "_dirty"),
        AI(this, "_forceHitArea"),
        AI(this, "_hitAreaDefault"),
        AI(this, "_pause"),
        AI(this, "tickerFunction"),
        AI(this, "_worldWidth"),
        AI(this, "_worldHeight"),
        AI(this, "_disableOnContextMenu", (t=>t.preventDefault())),
        this.options = {
            ...iM,
            ...t
        },
        this.screenWidth = this.options.screenWidth,
        this.screenHeight = this.options.screenHeight,
        this._worldWidth = this.options.worldWidth,
        this._worldHeight = this.options.worldHeight,
        this.forceHitArea = this.options.forceHitArea,
        this.threshold = this.options.threshold,
        this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu),
        this.options.noTicker || (this.tickerFunction = ()=>this.update(this.options.ticker.elapsedMS),
        this.options.ticker.add(this.tickerFunction)),
        this.input = new eM(this),
        this.plugins = new rM(this)
    }
    destroy(t) {
        !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction),
        this.options.disableOnContextMenu && this.options.events.domElement.removeEventListener("contextmenu", this._disableOnContextMenu),
        this.input.destroy(),
        super.destroy(t)
    }
    update(t) {
        this.pause || (this.plugins.update(t),
        this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = !0 : this.moving && (this.emit("moved-end", this),
        this.moving = !1),
        this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = !0 : this.zooming && (this.emit("zoomed-end", this),
        this.zooming = !1)),
        this.forceHitArea || (this._hitAreaDefault = new wv(this.left,this.top,this.worldScreenWidth,this.worldScreenHeight),
        this.hitArea = this._hitAreaDefault),
        this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y,
        this.lastViewport = {
            x: this.x,
            y: this.y,
            scaleX: this.scale.x,
            scaleY: this.scale.y
        },
        this.emit("frame-end", this))
    }
    resize(t=window.innerWidth, e=window.innerHeight, n, r) {
        this.screenWidth = t,
        this.screenHeight = e,
        typeof n < "u" && (this._worldWidth = n),
        typeof r < "u" && (this._worldHeight = r),
        this.plugins.resize(),
        this.dirty = !0
    }
    get worldWidth() {
        return this._worldWidth ? this._worldWidth : this.width / this.scale.x
    }
    set worldWidth(t) {
        this._worldWidth = t,
        this.plugins.resize()
    }
    get worldHeight() {
        return this._worldHeight ? this._worldHeight : this.height / this.scale.y
    }
    set worldHeight(t) {
        this._worldHeight = t,
        this.plugins.resize()
    }
    getVisibleBounds() {
        return new wv(this.left,this.top,this.worldScreenWidth,this.worldScreenHeight)
    }
    toWorld(t, e) {
        return 2 === arguments.length ? this.toLocal(new bv(t,e)) : this.toLocal(t)
    }
    toScreen(t, e) {
        return 2 === arguments.length ? this.toGlobal(new bv(t,e)) : this.toGlobal(t)
    }
    get worldScreenWidth() {
        return this.screenWidth / this.scale.x
    }
    get worldScreenHeight() {
        return this.screenHeight / this.scale.y
    }
    get screenWorldWidth() {
        return this.worldWidth * this.scale.x
    }
    get screenWorldHeight() {
        return this.worldHeight * this.scale.y
    }
    get center() {
        return new bv(this.worldScreenWidth / 2 - this.x / this.scale.x,this.worldScreenHeight / 2 - this.y / this.scale.y)
    }
    set center(t) {
        this.moveCenter(t)
    }
    moveCenter(...t) {
        let e, n;
        "number" == typeof t[0] ? (e = t[0],
        n = t[1]) : (e = t[0].x,
        n = t[0].y);
        const r = (this.worldScreenWidth / 2 - e) * this.scale.x
          , i = (this.worldScreenHeight / 2 - n) * this.scale.y;
        return (this.x !== r || this.y !== i) && (this.position.set(r, i),
        this.plugins.reset(),
        this.dirty = !0),
        this
    }
    get corner() {
        return new bv(-this.x / this.scale.x,-this.y / this.scale.y)
    }
    set corner(t) {
        this.moveCorner(t)
    }
    moveCorner(...t) {
        let e, n;
        return 1 === t.length ? (e = -t[0].x * this.scale.x,
        n = -t[0].y * this.scale.y) : (e = -t[0] * this.scale.x,
        n = -t[1] * this.scale.y),
        (e !== this.x || n !== this.y) && (this.position.set(e, n),
        this.plugins.reset(),
        this.dirty = !0),
        this
    }
    get screenWidthInWorldPixels() {
        return this.screenWidth / this.scale.x
    }
    get screenHeightInWorldPixels() {
        return this.screenHeight / this.scale.y
    }
    findFitWidth(t) {
        return this.screenWidth / t
    }
    findFitHeight(t) {
        return this.screenHeight / t
    }
    findFit(t, e) {
        const n = this.screenWidth / t
          , r = this.screenHeight / e;
        return Math.min(n, r)
    }
    findCover(t, e) {
        const n = this.screenWidth / t
          , r = this.screenHeight / e;
        return Math.max(n, r)
    }
    fitWidth(t=this.worldWidth, e, n=!0, r) {
        let i;
        e && (i = this.center),
        this.scale.x = this.screenWidth / t,
        n && (this.scale.y = this.scale.x);
        const s = this.plugins.get("clamp-zoom", !0);
        return !r && s && s.clamp(),
        e && i && this.moveCenter(i),
        this
    }
    fitHeight(t=this.worldHeight, e, n=!0, r) {
        let i;
        e && (i = this.center),
        this.scale.y = this.screenHeight / t,
        n && (this.scale.x = this.scale.y);
        const s = this.plugins.get("clamp-zoom", !0);
        return !r && s && s.clamp(),
        e && i && this.moveCenter(i),
        this
    }
    fitWorld(t) {
        let e;
        t && (e = this.center),
        this.scale.x = this.screenWidth / this.worldWidth,
        this.scale.y = this.screenHeight / this.worldHeight,
        this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
        const n = this.plugins.get("clamp-zoom", !0);
        return n && n.clamp(),
        t && e && this.moveCenter(e),
        this
    }
    fit(t, e=this.worldWidth, n=this.worldHeight) {
        let r;
        t && (r = this.center),
        this.scale.x = this.screenWidth / e,
        this.scale.y = this.screenHeight / n,
        this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
        const i = this.plugins.get("clamp-zoom", !0);
        return i && i.clamp(),
        t && r && this.moveCenter(r),
        this
    }
    setZoom(t, e) {
        let n;
        e && (n = this.center),
        this.scale.set(t);
        const r = this.plugins.get("clamp-zoom", !0);
        return r && r.clamp(),
        e && n && this.moveCenter(n),
        this
    }
    zoomPercent(t, e) {
        return this.setZoom(this.scale.x + this.scale.x * t, e)
    }
    zoom(t, e) {
        return this.fitWidth(t + this.worldScreenWidth, e),
        this
    }
    get scaled() {
        return this.scale.x
    }
    set scaled(t) {
        this.setZoom(t, !0)
    }
    snapZoom(t) {
        return this.plugins.add("snap-zoom", new ZI(this,t)),
        this
    }
    OOB() {
        return {
            left: this.left < 0,
            right: this.right > this.worldWidth,
            top: this.top < 0,
            bottom: this.bottom > this.worldHeight,
            cornerPoint: new bv(this.worldWidth * this.scale.x - this.screenWidth,this.worldHeight * this.scale.y - this.screenHeight)
        }
    }
    get right() {
        return -this.x / this.scale.x + this.worldScreenWidth
    }
    set right(t) {
        this.x = -t * this.scale.x + this.screenWidth,
        this.plugins.reset()
    }
    get left() {
        return -this.x / this.scale.x
    }
    set left(t) {
        this.x = -t * this.scale.x,
        this.plugins.reset()
    }
    get top() {
        return -this.y / this.scale.y
    }
    set top(t) {
        this.y = -t * this.scale.y,
        this.plugins.reset()
    }
    get bottom() {
        return -this.y / this.scale.y + this.worldScreenHeight
    }
    set bottom(t) {
        this.y = -t * this.scale.y + this.screenHeight,
        this.plugins.reset()
    }
    get dirty() {
        return !!this._dirty
    }
    set dirty(t) {
        this._dirty = t
    }
    get forceHitArea() {
        return this._forceHitArea
    }
    set forceHitArea(t) {
        t ? (this._forceHitArea = t,
        this.hitArea = t) : (this._forceHitArea = null,
        this.hitArea = new wv(0,0,this.worldWidth,this.worldHeight))
    }
    drag(t) {
        return this.plugins.add("drag", new VI(this,t)),
        this
    }
    clamp(t) {
        return this.plugins.add("clamp", new DI(this,t)),
        this
    }
    decelerate(t) {
        return this.plugins.add("decelerate", new UI(this,t)),
        this
    }
    bounce(t) {
        return this.plugins.add("bounce", new NI(this,t)),
        this
    }
    pinch(t) {
        return this.plugins.add("pinch", new XI(this,t)),
        this
    }
    snap(t, e, n) {
        return this.plugins.add("snap", new KI(this,t,e,n)),
        this
    }
    follow(t, e) {
        return this.plugins.add("follow", new YI(this,t,e)),
        this
    }
    wheel(t) {
        return this.plugins.add("wheel", new tM(this,t)),
        this
    }
    animate(t) {
        return this.plugins.add("animate", new PI(this,t)),
        this
    }
    clampZoom(t) {
        return this.plugins.add("clamp-zoom", new LI(this,t)),
        this
    }
    mouseEdges(t) {
        return this.plugins.add("mouse-edges", new $I(this,t)),
        this
    }
    get pause() {
        return !!this._pause
    }
    set pause(t) {
        this._pause = t,
        this.lastViewport = null,
        this.moving = !1,
        this.zooming = !1,
        t && this.input.pause()
    }
    ensureVisible(t, e, n, r, i) {
        i && (n > this.worldScreenWidth || r > this.worldScreenHeight) && (this.fit(!0, n, r),
        this.emit("zoomed", {
            viewport: this,
            type: "ensureVisible"
        }));
        let s = !1;
        t < this.left ? (this.left = t,
        s = !0) : t + n > this.right && (this.right = t + n,
        s = !0),
        e < this.top ? (this.top = e,
        s = !0) : e + r > this.bottom && (this.bottom = e + r,
        s = !0),
        s && this.emit("moved", {
            viewport: this,
            type: "ensureVisible"
        })
    }
}
const oM = new bv
  , aM = new Uint16Array([0, 1, 2, 0, 2, 3]);
class lM extends EI {
    constructor(t) {
        super(),
        this._anchor = new Rv(this._onAnchorUpdate,this,t ? t.defaultAnchor.x : 0,t ? t.defaultAnchor.y : 0),
        this._texture = null,
        this._width = 0,
        this._height = 0,
        this._tintColor = new nb(16777215),
        this._tintRGB = null,
        this.tint = 16777215,
        this.blendMode = Om.NORMAL,
        this._cachedTint = 16777215,
        this.uvs = null,
        this.texture = t || Ow.EMPTY,
        this.vertexData = new Float32Array(8),
        this.vertexTrimmedData = null,
        this._transformID = -1,
        this._textureID = -1,
        this._transformTrimmedID = -1,
        this._textureTrimmedID = -1,
        this.indices = aM,
        this.pluginName = "batch",
        this.isSprite = !0,
        this._roundPixels = Xm.ROUND_PIXELS
    }
    _onTextureUpdate() {
        this._textureID = -1,
        this._textureTrimmedID = -1,
        this._cachedTint = 16777215,
        this._width && (this.scale.x = fg.sign(this.scale.x) * this._width / this._texture.orig.width),
        this._height && (this.scale.y = fg.sign(this.scale.y) * this._height / this._texture.orig.height)
    }
    _onAnchorUpdate() {
        this._transformID = -1,
        this._transformTrimmedID = -1
    }
    calculateVertices() {
        const t = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === t._updateID)
            return;
        this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32),
        this._transformID = this.transform._worldID,
        this._textureID = t._updateID;
        const e = this.transform.worldTransform
          , n = e.a
          , r = e.b
          , i = e.c
          , s = e.d
          , o = e.tx
          , a = e.ty
          , l = this.vertexData
          , c = t.trim
          , u = t.orig
          , h = this._anchor;
        let d = 0
          , f = 0
          , p = 0
          , m = 0;
        if (c ? (f = c.x - h._x * u.width,
        d = f + c.width,
        m = c.y - h._y * u.height,
        p = m + c.height) : (f = -h._x * u.width,
        d = f + u.width,
        m = -h._y * u.height,
        p = m + u.height),
        l[0] = n * f + i * m + o,
        l[1] = s * m + r * f + a,
        l[2] = n * d + i * m + o,
        l[3] = s * m + r * d + a,
        l[4] = n * d + i * p + o,
        l[5] = s * p + r * d + a,
        l[6] = n * f + i * p + o,
        l[7] = s * p + r * f + a,
        this._roundPixels) {
            const t = Xm.RESOLUTION;
            for (let e = 0; e < l.length; ++e)
                l[e] = Math.round(l[e] * t) / t
        }
    }
    calculateTrimmedVertices() {
        if (this.vertexTrimmedData) {
            if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
                return
        } else
            this.vertexTrimmedData = new Float32Array(8);
        this._transformTrimmedID = this.transform._worldID,
        this._textureTrimmedID = this._texture._updateID;
        const t = this._texture
          , e = this.vertexTrimmedData
          , n = t.orig
          , r = this._anchor
          , i = this.transform.worldTransform
          , s = i.a
          , o = i.b
          , a = i.c
          , l = i.d
          , c = i.tx
          , u = i.ty
          , h = -r._x * n.width
          , d = h + n.width
          , f = -r._y * n.height
          , p = f + n.height;
        e[0] = s * h + a * f + c,
        e[1] = l * f + o * h + u,
        e[2] = s * d + a * f + c,
        e[3] = l * f + o * d + u,
        e[4] = s * d + a * p + c,
        e[5] = l * p + o * d + u,
        e[6] = s * h + a * p + c,
        e[7] = l * p + o * h + u
    }
    _render(t) {
        this.calculateVertices(),
        t.batch.setObjectRenderer(t.plugins[this.pluginName]),
        t.plugins[this.pluginName].render(this)
    }
    _calculateBounds() {
        const t = this._texture.trim
          , e = this._texture.orig;
        !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(),
        this._bounds.addQuad(this.vertexTrimmedData))
    }
    getLocalBounds(t) {
        return 0 === this.children.length ? (this._localBounds || (this._localBounds = new gI),
        this._localBounds.minX = this._texture.orig.width * -this._anchor._x,
        this._localBounds.minY = this._texture.orig.height * -this._anchor._y,
        this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x),
        this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y),
        t || (this._localBoundsRect || (this._localBoundsRect = new wv),
        t = this._localBoundsRect),
        this._localBounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, oM);
        const e = this._texture.orig.width
          , n = this._texture.orig.height
          , r = -e * this.anchor.x;
        let i = 0;
        return oM.x >= r && oM.x < r + e && (i = -n * this.anchor.y,
        oM.y >= i && oM.y < i + n)
    }
    destroy(t) {
        super.destroy(t),
        this._texture.off("update", this._onTextureUpdate, this),
        this._anchor = null;
        if ("boolean" == typeof t ? t : t?.texture) {
            const e = "boolean" == typeof t ? t : t?.baseTexture;
            this._texture.destroy(!!e)
        }
        this._texture = null
    }
    static from(t, e) {
        const n = t instanceof Ow ? t : Ow.from(t, e);
        return new lM(n)
    }
    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1),
        this._roundPixels = t
    }
    get roundPixels() {
        return this._roundPixels
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        const e = fg.sign(this.scale.x) || 1;
        this.scale.x = e * t / this._texture.orig.width,
        this._width = t
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        const e = fg.sign(this.scale.y) || 1;
        this.scale.y = e * t / this._texture.orig.height,
        this._height = t
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        this._anchor.copyFrom(t)
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        this._tintColor.setValue(t),
        this._tintRGB = this._tintColor.toLittleEndianNumber()
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this),
        this._texture = t || Ow.EMPTY,
        this._cachedTint = 16777215,
        this._textureID = -1,
        this._textureTrimmedID = -1,
        t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
    }
}
const cM = new Sv;
yI.prototype._cacheAsBitmap = !1,
yI.prototype._cacheData = null,
yI.prototype._cacheAsBitmapResolution = null,
yI.prototype._cacheAsBitmapMultisample = null;
class uM {
    constructor() {
        this.textureCacheId = null,
        this.originalRender = null,
        this.originalRenderCanvas = null,
        this.originalCalculateBounds = null,
        this.originalGetLocalBounds = null,
        this.originalUpdateTransform = null,
        this.originalDestroy = null,
        this.originalMask = null,
        this.originalFilterArea = null,
        this.originalContainsPoint = null,
        this.sprite = null
    }
}
Object.defineProperties(yI.prototype, {
    cacheAsBitmapResolution: {
        get() {
            return this._cacheAsBitmapResolution
        },
        set(t) {
            t !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t,
            this.cacheAsBitmap && (this.cacheAsBitmap = !1,
            this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmapMultisample: {
        get() {
            return this._cacheAsBitmapMultisample
        },
        set(t) {
            t !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t,
            this.cacheAsBitmap && (this.cacheAsBitmap = !1,
            this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmap: {
        get() {
            return this._cacheAsBitmap
        },
        set(t) {
            if (this._cacheAsBitmap === t)
                return;
            let e;
            this._cacheAsBitmap = t,
            t ? (this._cacheData || (this._cacheData = new uM),
            e = this._cacheData,
            e.originalRender = this.render,
            e.originalRenderCanvas = this.renderCanvas,
            e.originalUpdateTransform = this.updateTransform,
            e.originalCalculateBounds = this.calculateBounds,
            e.originalGetLocalBounds = this.getLocalBounds,
            e.originalDestroy = this.destroy,
            e.originalContainsPoint = this.containsPoint,
            e.originalMask = this._mask,
            e.originalFilterArea = this.filterArea,
            this.render = this._renderCached,
            this.renderCanvas = this._renderCachedCanvas,
            this.destroy = this._cacheAsBitmapDestroy) : (e = this._cacheData,
            e.sprite && this._destroyCachedDisplayObject(),
            this.render = e.originalRender,
            this.renderCanvas = e.originalRenderCanvas,
            this.calculateBounds = e.originalCalculateBounds,
            this.getLocalBounds = e.originalGetLocalBounds,
            this.destroy = e.originalDestroy,
            this.updateTransform = e.originalUpdateTransform,
            this.containsPoint = e.originalContainsPoint,
            this._mask = e.originalMask,
            this.filterArea = e.originalFilterArea)
        }
    }
}),
yI.prototype._renderCached = function(t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t),
    this._cacheData.sprite.transform._worldID = this.transform._worldID,
    this._cacheData.sprite.worldAlpha = this.worldAlpha,
    this._cacheData.sprite._render(t))
}
,
yI.prototype._initCachedDisplayObject = function(t) {
    if (this._cacheData?.sprite)
        return;
    const e = this.alpha;
    this.alpha = 1,
    t.batch.flush();
    const n = this.getLocalBounds(null, !0).clone();
    if (this.filters?.length) {
        const t = this.filters[0].padding;
        n.pad(t)
    }
    n.ceil(Xm.RESOLUTION);
    const r = t.renderTexture.current
      , i = t.renderTexture.sourceFrame.clone()
      , s = t.renderTexture.destinationFrame.clone()
      , o = t.projection.transform
      , a = Nw.create({
        width: n.width,
        height: n.height,
        resolution: this.cacheAsBitmapResolution || t.resolution,
        multisample: this.cacheAsBitmapMultisample ?? t.multisample
    })
      , l = `cacheAsBitmap_${fg.uid()}`;
    this._cacheData.textureCacheId = l,
    nv.addToCache(a.baseTexture, l),
    Ow.addToCache(a, l);
    const c = this.transform.localTransform.copyTo(cM).invert().translate(-n.x, -n.y);
    this.render = this._cacheData.originalRender,
    t.render(this, {
        renderTexture: a,
        clear: !0,
        transform: c,
        skipUpdateTransform: !1
    }),
    t.framebuffer.blit(),
    t.projection.transform = o,
    t.renderTexture.bind(r, i, s),
    this.render = this._renderCached,
    this.updateTransform = this.displayObjectUpdateTransform,
    this.calculateBounds = this._calculateCachedBounds,
    this.getLocalBounds = this._getCachedLocalBounds,
    this._mask = null,
    this.filterArea = null,
    this.alpha = e;
    const u = new lM(a);
    u.transform.worldTransform = this.transform.worldTransform,
    u.anchor.x = -n.x / n.width,
    u.anchor.y = -n.y / n.height,
    u.alpha = e,
    u._bounds = this._bounds,
    this._cacheData.sprite = u,
    this.transform._parentID = -1,
    this.parent ? this.updateTransform() : (this.enableTempParent(),
    this.updateTransform(),
    this.disableTempParent(null)),
    this.containsPoint = u.containsPoint.bind(u)
}
,
yI.prototype._renderCachedCanvas = function(t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t),
    this._cacheData.sprite.worldAlpha = this.worldAlpha,
    this._cacheData.sprite._renderCanvas(t))
}
,
yI.prototype._initCachedDisplayObjectCanvas = function(t) {
    if (this._cacheData?.sprite)
        return;
    const e = this.getLocalBounds(null, !0)
      , n = this.alpha;
    this.alpha = 1;
    const r = t.canvasContext.activeContext
      , i = t._projTransform;
    e.ceil(Xm.RESOLUTION);
    const s = Nw.create({
        width: e.width,
        height: e.height
    })
      , o = `cacheAsBitmap_${fg.uid()}`;
    this._cacheData.textureCacheId = o,
    nv.addToCache(s.baseTexture, o),
    Ow.addToCache(s, o);
    const a = cM;
    this.transform.localTransform.copyTo(a),
    a.invert(),
    a.tx -= e.x,
    a.ty -= e.y,
    this.renderCanvas = this._cacheData.originalRenderCanvas,
    t.render(this, {
        renderTexture: s,
        clear: !0,
        transform: a,
        skipUpdateTransform: !1
    }),
    t.canvasContext.activeContext = r,
    t._projTransform = i,
    this.renderCanvas = this._renderCachedCanvas,
    this.updateTransform = this.displayObjectUpdateTransform,
    this.calculateBounds = this._calculateCachedBounds,
    this.getLocalBounds = this._getCachedLocalBounds,
    this._mask = null,
    this.filterArea = null,
    this.alpha = n;
    const l = new lM(s);
    l.transform.worldTransform = this.transform.worldTransform,
    l.anchor.x = -e.x / e.width,
    l.anchor.y = -e.y / e.height,
    l.alpha = n,
    l._bounds = this._bounds,
    this._cacheData.sprite = l,
    this.transform._parentID = -1,
    this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent,
    this.updateTransform(),
    this.parent = null),
    this.containsPoint = l.containsPoint.bind(l)
}
,
yI.prototype._calculateCachedBounds = function() {
    this._bounds.clear(),
    this._cacheData.sprite.transform._worldID = this.transform._worldID,
    this._cacheData.sprite._calculateBounds(),
    this._bounds.updateID = this._boundsID
}
,
yI.prototype._getCachedLocalBounds = function() {
    return this._cacheData.sprite.getLocalBounds(null)
}
,
yI.prototype._destroyCachedDisplayObject = function() {
    this._cacheData.sprite._texture.destroy(!0),
    this._cacheData.sprite = null,
    nv.removeFromCache(this._cacheData.textureCacheId),
    Ow.removeFromCache(this._cacheData.textureCacheId),
    this._cacheData.textureCacheId = null
}
,
yI.prototype._cacheAsBitmapDestroy = function(t) {
    this.cacheAsBitmap = !1,
    this.destroy(t)
}
,
yI.prototype.name = null,
EI.prototype.getChildByName = function(t, e) {
    for (let e = 0, n = this.children.length; e < n; e++)
        if (this.children[e].name === t)
            return this.children[e];
    if (e)
        for (let e = 0, n = this.children.length; e < n; e++) {
            const n = this.children[e];
            if (!n.getChildByName)
                continue;
            const r = n.getChildByName(t, !0);
            if (r)
                return r
        }
    return null
}
,
yI.prototype.getGlobalPosition = function(t=new bv, e=!1) {
    return this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x,
    t.y = this.position.y),
    t
}
;
const hM = {
    5: [.153388, .221461, .250301],
    7: [.071303, .131514, .189879, .214607],
    9: [.028532, .067234, .124009, .179044, .20236],
    11: [.0093, .028002, .065984, .121703, .175713, .198596],
    13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
    15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
}
  , dM = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
function fM(t) {
    const e = hM[t]
      , n = e.length;
    let r = dM
      , i = "";
    let s;
    for (let r = 0; r < t; r++) {
        let o = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", r.toString());
        s = r,
        r >= n && (s = t - r - 1),
        o = o.replace("%value%", e[s].toString()),
        i += o,
        i += "\n"
    }
    return r = r.replace("%blur%", i),
    r = r.replace("%size%", t.toString()),
    r
}
const pM = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
function mM(t, e) {
    const n = Math.ceil(t / 2);
    let r, i = pM, s = "";
    r = e ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (let e = 0; e < t; e++) {
        let t = r.replace("%index%", e.toString());
        t = t.replace("%sampleIndex%", e - (n - 1) + ".0"),
        s += t,
        s += "\n"
    }
    return i = i.replace("%blur%", s),
    i = i.replace("%size%", t.toString()),
    i
}
class gM extends vw {
    constructor(t, e=8, n=4, r=vw.defaultResolution, i=5) {
        super(mM(i, t), fM(i)),
        this.horizontal = t,
        this.resolution = r,
        this._quality = 0,
        this.quality = n,
        this.blur = e
    }
    apply(t, e, n, r) {
        if (n ? this.horizontal ? this.uniforms.strength = 1 / n.width * (n.width / e.width) : this.uniforms.strength = 1 / n.height * (n.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height),
        this.uniforms.strength *= this.strength,
        this.uniforms.strength /= this.passes,
        1 === this.passes)
            t.applyFilter(this, e, n, r);
        else {
            const i = t.getFilterTexture()
              , s = t.renderer;
            let o = e
              , a = i;
            this.state.blend = !1,
            t.applyFilter(this, o, a, Vm.CLEAR);
            for (let e = 1; e < this.passes - 1; e++) {
                t.bindAndClear(o, Vm.BLIT),
                this.uniforms.uSampler = a;
                const e = a;
                a = o,
                o = e,
                s.shader.bind(this),
                s.geometry.draw(5)
            }
            this.state.blend = !0,
            t.applyFilter(this, a, n, r),
            t.returnFilterTexture(i)
        }
    }
    get blur() {
        return this.strength
    }
    set blur(t) {
        this.padding = 1 + 2 * Math.abs(t),
        this.strength = t
    }
    get quality() {
        return this._quality
    }
    set quality(t) {
        this._quality = t,
        this.passes = t
    }
}
class yM extends vw {
    constructor() {
        const t = {
            m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
            uAlpha: 1
        };
        super(Ux, "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", t),
        this.alpha = 1
    }
    _loadMatrix(t, e=!1) {
        let n = t;
        e && (this._multiply(n, this.uniforms.m, t),
        n = this._colorMatrix(n)),
        this.uniforms.m = n
    }
    _multiply(t, e, n) {
        return t[0] = e[0] * n[0] + e[1] * n[5] + e[2] * n[10] + e[3] * n[15],
        t[1] = e[0] * n[1] + e[1] * n[6] + e[2] * n[11] + e[3] * n[16],
        t[2] = e[0] * n[2] + e[1] * n[7] + e[2] * n[12] + e[3] * n[17],
        t[3] = e[0] * n[3] + e[1] * n[8] + e[2] * n[13] + e[3] * n[18],
        t[4] = e[0] * n[4] + e[1] * n[9] + e[2] * n[14] + e[3] * n[19] + e[4],
        t[5] = e[5] * n[0] + e[6] * n[5] + e[7] * n[10] + e[8] * n[15],
        t[6] = e[5] * n[1] + e[6] * n[6] + e[7] * n[11] + e[8] * n[16],
        t[7] = e[5] * n[2] + e[6] * n[7] + e[7] * n[12] + e[8] * n[17],
        t[8] = e[5] * n[3] + e[6] * n[8] + e[7] * n[13] + e[8] * n[18],
        t[9] = e[5] * n[4] + e[6] * n[9] + e[7] * n[14] + e[8] * n[19] + e[9],
        t[10] = e[10] * n[0] + e[11] * n[5] + e[12] * n[10] + e[13] * n[15],
        t[11] = e[10] * n[1] + e[11] * n[6] + e[12] * n[11] + e[13] * n[16],
        t[12] = e[10] * n[2] + e[11] * n[7] + e[12] * n[12] + e[13] * n[17],
        t[13] = e[10] * n[3] + e[11] * n[8] + e[12] * n[13] + e[13] * n[18],
        t[14] = e[10] * n[4] + e[11] * n[9] + e[12] * n[14] + e[13] * n[19] + e[14],
        t[15] = e[15] * n[0] + e[16] * n[5] + e[17] * n[10] + e[18] * n[15],
        t[16] = e[15] * n[1] + e[16] * n[6] + e[17] * n[11] + e[18] * n[16],
        t[17] = e[15] * n[2] + e[16] * n[7] + e[17] * n[12] + e[18] * n[17],
        t[18] = e[15] * n[3] + e[16] * n[8] + e[17] * n[13] + e[18] * n[18],
        t[19] = e[15] * n[4] + e[16] * n[9] + e[17] * n[14] + e[18] * n[19] + e[19],
        t
    }
    _colorMatrix(t) {
        const e = new Float32Array(t);
        return e[4] /= 255,
        e[9] /= 255,
        e[14] /= 255,
        e[19] /= 255,
        e
    }
    brightness(t, e) {
        const n = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    tint(t, e) {
        const [n,r,i] = nb.shared.setValue(t).toArray()
          , s = [n, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, e)
    }
    greyscale(t, e) {
        const n = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    blackAndWhite(t) {
        this._loadMatrix([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], t)
    }
    hue(t, e) {
        t = (t || 0) / 180 * Math.PI;
        const n = Math.cos(t)
          , r = Math.sin(t)
          , i = 1 / 3
          , s = (0,
        Math.sqrt)(i)
          , o = [n + (1 - n) * i, i * (1 - n) - s * r, i * (1 - n) + s * r, 0, 0, i * (1 - n) + s * r, n + i * (1 - n), i * (1 - n) - s * r, 0, 0, i * (1 - n) - s * r, i * (1 - n) + s * r, n + i * (1 - n), 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(o, e)
    }
    contrast(t, e) {
        const n = (t || 0) + 1
          , r = -.5 * (n - 1)
          , i = [n, 0, 0, 0, r, 0, n, 0, 0, r, 0, 0, n, 0, r, 0, 0, 0, 1, 0];
        this._loadMatrix(i, e)
    }
    saturate(t=0, e) {
        const n = 2 * t / 3 + 1
          , r = -.5 * (n - 1)
          , i = [n, r, r, 0, 0, r, n, r, 0, 0, r, r, n, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, e)
    }
    desaturate() {
        this.saturate(-1)
    }
    negative(t) {
        this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t)
    }
    sepia(t) {
        this._loadMatrix([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], t)
    }
    technicolor(t) {
        this._loadMatrix([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t)
    }
    polaroid(t) {
        this._loadMatrix([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t)
    }
    toBGR(t) {
        this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t)
    }
    kodachrome(t) {
        this._loadMatrix([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t)
    }
    browni(t) {
        this._loadMatrix([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t)
    }
    vintage(t) {
        this._loadMatrix([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t)
    }
    colorTone(t, e, n, r, i) {
        t = t || .2,
        e = e || .15,
        n = n || 16770432,
        r = r || 3375104;
        const s = nb.shared
          , [o,a,l] = s.setValue(n).toArray()
          , [c,u,h] = s.setValue(r).toArray()
          , d = [.3, .59, .11, 0, 0, o, a, l, t, 0, c, u, h, e, 0, o - c, a - u, l - h, 0, 0];
        this._loadMatrix(d, i)
    }
    night(t, e) {
        const n = [-2 * (t = t || .1), -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    predator(t, e) {
        const n = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    lsd(t) {
        this._loadMatrix([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], t)
    }
    reset() {
        this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1)
    }
    get matrix() {
        return this.uniforms.m
    }
    set matrix(t) {
        this.uniforms.m = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
yM.prototype.grayscale = yM.prototype.greyscale;
const bM = {
    AlphaFilter: class extends vw {
        constructor(t=1) {
            super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", {
                uAlpha: 1
            }),
            this.alpha = t
        }
        get alpha() {
            return this.uniforms.uAlpha
        }
        set alpha(t) {
            this.uniforms.uAlpha = t
        }
    }
    ,
    BlurFilter: class extends vw {
        constructor(t=8, e=4, n=vw.defaultResolution, r=5) {
            super(),
            this._repeatEdgePixels = !1,
            this.blurXFilter = new gM(!0,t,e,n,r),
            this.blurYFilter = new gM(!1,t,e,n,r),
            this.resolution = n,
            this.quality = e,
            this.blur = t,
            this.repeatEdgePixels = !1
        }
        apply(t, e, n, r) {
            const i = Math.abs(this.blurXFilter.strength)
              , s = Math.abs(this.blurYFilter.strength);
            if (i && s) {
                const i = t.getFilterTexture();
                this.blurXFilter.apply(t, e, i, Vm.CLEAR),
                this.blurYFilter.apply(t, i, n, r),
                t.returnFilterTexture(i)
            } else
                s ? this.blurYFilter.apply(t, e, n, r) : this.blurXFilter.apply(t, e, n, r)
        }
        updatePadding() {
            this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength))
        }
        get blur() {
            return this.blurXFilter.blur
        }
        set blur(t) {
            this.blurXFilter.blur = this.blurYFilter.blur = t,
            this.updatePadding()
        }
        get quality() {
            return this.blurXFilter.quality
        }
        set quality(t) {
            this.blurXFilter.quality = this.blurYFilter.quality = t
        }
        get blurX() {
            return this.blurXFilter.blur
        }
        set blurX(t) {
            this.blurXFilter.blur = t,
            this.updatePadding()
        }
        get blurY() {
            return this.blurYFilter.blur
        }
        set blurY(t) {
            this.blurYFilter.blur = t,
            this.updatePadding()
        }
        get blendMode() {
            return this.blurYFilter.blendMode
        }
        set blendMode(t) {
            this.blurYFilter.blendMode = t
        }
        get repeatEdgePixels() {
            return this._repeatEdgePixels
        }
        set repeatEdgePixels(t) {
            this._repeatEdgePixels = t,
            this.updatePadding()
        }
    }
    ,
    BlurFilterPass: gM,
    ColorMatrixFilter: yM,
    DisplacementFilter: class extends vw {
        constructor(t, e) {
            const n = new Sv;
            t.renderable = !1,
            super("attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", {
                mapSampler: t._texture,
                filterMatrix: n,
                scale: {
                    x: 1,
                    y: 1
                },
                rotation: new Float32Array([1, 0, 0, 1])
            }),
            this.maskSprite = t,
            this.maskMatrix = n,
            null == e && (e = 20),
            this.scale = new bv(e,e)
        }
        apply(t, e, n, r) {
            this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite),
            this.uniforms.scale.x = this.scale.x,
            this.uniforms.scale.y = this.scale.y;
            const i = this.maskSprite.worldTransform
              , s = Math.sqrt(i.a * i.a + i.b * i.b)
              , o = Math.sqrt(i.c * i.c + i.d * i.d);
            0 !== s && 0 !== o && (this.uniforms.rotation[0] = i.a / s,
            this.uniforms.rotation[1] = i.b / s,
            this.uniforms.rotation[2] = i.c / o,
            this.uniforms.rotation[3] = i.d / o),
            t.applyFilter(this, e, n, r)
        }
        get map() {
            return this.uniforms.mapSampler
        }
        set map(t) {
            this.uniforms.mapSampler = t
        }
    }
    ,
    FXAAFilter: class extends vw {
        constructor() {
            super("\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n')
        }
    }
    ,
    NoiseFilter: class extends vw {
        constructor(t=.5, e=Math.random()) {
            super(Ux, "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", {
                uNoise: 0,
                uSeed: 0
            }),
            this.noise = t,
            this.seed = e
        }
        get noise() {
            return this.uniforms.uNoise
        }
        set noise(t) {
            this.uniforms.uNoise = t
        }
        get seed() {
            return this.uniforms.uSeed
        }
        set seed(t) {
            this.uniforms.uSeed = t
        }
    }
};
Object.entries(bM).forEach((([t,e])=>{
    Object.defineProperty(bM, t, {
        get: ()=>(fg.deprecation("7.1.0", `filters.${t} has moved to ${t}`),
        e)
    })
}
));
const vM = new class {
    constructor() {
        this.interactionFrequency = 10,
        this._deltaTime = 0,
        this._didMove = !1,
        this.tickerAdded = !1,
        this._pauseUpdate = !0
    }
    init(t) {
        this.removeTickerListener(),
        this.events = t,
        this.interactionFrequency = 10,
        this._deltaTime = 0,
        this._didMove = !1,
        this.tickerAdded = !1,
        this._pauseUpdate = !0
    }
    get pauseUpdate() {
        return this._pauseUpdate
    }
    set pauseUpdate(t) {
        this._pauseUpdate = t
    }
    addTickerListener() {
        !this.tickerAdded && this.domElement && (Bx.system.add(this.tickerUpdate, this, Nx.INTERACTION),
        this.tickerAdded = !0)
    }
    removeTickerListener() {
        this.tickerAdded && (Bx.system.remove(this.tickerUpdate, this),
        this.tickerAdded = !1)
    }
    pointerMoved() {
        this._didMove = !0
    }
    update() {
        if (!this.domElement || this._pauseUpdate)
            return;
        if (this._didMove)
            return void (this._didMove = !1);
        const t = this.events.rootPointerEvent;
        this.events.supportsTouchEvents && "touch" === t.pointerType || globalThis.document.dispatchEvent(new PointerEvent("pointermove",{
            clientX: t.clientX,
            clientY: t.clientY
        }))
    }
    tickerUpdate(t) {
        this._deltaTime += t,
        this._deltaTime < this.interactionFrequency || (this._deltaTime = 0,
        this.update())
    }
}
;
class wM {
    constructor(t) {
        this.bubbles = !0,
        this.cancelBubble = !0,
        this.cancelable = !1,
        this.composed = !1,
        this.defaultPrevented = !1,
        this.eventPhase = wM.prototype.NONE,
        this.propagationStopped = !1,
        this.propagationImmediatelyStopped = !1,
        this.layer = new bv,
        this.page = new bv,
        this.NONE = 0,
        this.CAPTURING_PHASE = 1,
        this.AT_TARGET = 2,
        this.BUBBLING_PHASE = 3,
        this.manager = t
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []),
        this.path
    }
    initEvent(t, e, n) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    initUIEvent(t, e, n, r, i) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
        this.defaultPrevented = !0
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
class xM extends wM {
    constructor() {
        super(...arguments),
        this.client = new bv,
        this.movement = new bv,
        this.offset = new bv,
        this.global = new bv,
        this.screen = new bv
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getLocalPosition(t, e, n) {
        return t.worldTransform.applyInverse(n || this.global, e)
    }
    getModifierState(t) {
        return "getModifierState"in this.nativeEvent && this.nativeEvent.getModifierState(t)
    }
    initMouseEvent(t, e, n, r, i, s, o, a, l, c, u, h, d, f, p) {
        throw new Error("Method not implemented.")
    }
}
class EM extends xM {
    constructor() {
        super(...arguments),
        this.width = 0,
        this.height = 0,
        this.isPrimary = !1
    }
    getCoalescedEvents() {
        return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : []
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}
class _M extends xM {
    constructor() {
        super(...arguments),
        this.DOM_DELTA_PIXEL = 0,
        this.DOM_DELTA_LINE = 1,
        this.DOM_DELTA_PAGE = 2
    }
}
_M.DOM_DELTA_PIXEL = 0,
_M.DOM_DELTA_LINE = 1,
_M.DOM_DELTA_PAGE = 2;
const AM = new bv
  , SM = new bv;
class TM {
    constructor(t) {
        this.dispatch = new fg.EventEmitter,
        this.moveOnAll = !1,
        this.enableGlobalMoveEvents = !0,
        this.mappingState = {
            trackingData: {}
        },
        this.eventPool = new Map,
        this._allInteractiveElements = [],
        this._hitElements = [],
        this._isPointerMoveEvent = !1,
        this.rootTarget = t,
        this.hitPruneFn = this.hitPruneFn.bind(this),
        this.hitTestFn = this.hitTestFn.bind(this),
        this.mapPointerDown = this.mapPointerDown.bind(this),
        this.mapPointerMove = this.mapPointerMove.bind(this),
        this.mapPointerOut = this.mapPointerOut.bind(this),
        this.mapPointerOver = this.mapPointerOver.bind(this),
        this.mapPointerUp = this.mapPointerUp.bind(this),
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this),
        this.mapWheel = this.mapWheel.bind(this),
        this.mappingTable = {},
        this.addEventMapping("pointerdown", this.mapPointerDown),
        this.addEventMapping("pointermove", this.mapPointerMove),
        this.addEventMapping("pointerout", this.mapPointerOut),
        this.addEventMapping("pointerleave", this.mapPointerOut),
        this.addEventMapping("pointerover", this.mapPointerOver),
        this.addEventMapping("pointerup", this.mapPointerUp),
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
        this.addEventMapping("wheel", this.mapWheel)
    }
    addEventMapping(t, e) {
        this.mappingTable[t] || (this.mappingTable[t] = []),
        this.mappingTable[t].push({
            fn: e,
            priority: 0
        }),
        this.mappingTable[t].sort(((t,e)=>t.priority - e.priority))
    }
    dispatchEvent(t, e) {
        t.propagationStopped = !1,
        t.propagationImmediatelyStopped = !1,
        this.propagate(t, e),
        this.dispatch.emit(e || t.type, t)
    }
    mapEvent(t) {
        if (!this.rootTarget)
            return;
        const e = this.mappingTable[t.type];
        if (e)
            for (let n = 0, r = e.length; n < r; n++)
                e[n].fn(t);
        else
            console.warn(`[EventBoundary]: Event mapping not defined for ${t.type}`)
    }
    hitTest(t, e) {
        vM.pauseUpdate = !0;
        const n = this[this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"](this.rootTarget, this.rootTarget.eventMode, AM.set(t, e), this.hitTestFn, this.hitPruneFn);
        return n && n[0]
    }
    propagate(t, e) {
        if (!t.target)
            return;
        const n = t.composedPath();
        t.eventPhase = t.CAPTURING_PHASE;
        for (let r = 0, i = n.length - 1; r < i; r++)
            if (t.currentTarget = n[r],
            this.notifyTarget(t, e),
            t.propagationStopped || t.propagationImmediatelyStopped)
                return;
        if (t.eventPhase = t.AT_TARGET,
        t.currentTarget = t.target,
        this.notifyTarget(t, e),
        !t.propagationStopped && !t.propagationImmediatelyStopped) {
            t.eventPhase = t.BUBBLING_PHASE;
            for (let r = n.length - 2; r >= 0; r--)
                if (t.currentTarget = n[r],
                this.notifyTarget(t, e),
                t.propagationStopped || t.propagationImmediatelyStopped)
                    return
        }
    }
    all(t, e, n=this._allInteractiveElements) {
        if (0 === n.length)
            return;
        t.eventPhase = t.BUBBLING_PHASE;
        const r = Array.isArray(e) ? e : [e];
        for (let e = n.length - 1; e >= 0; e--)
            r.forEach((r=>{
                t.currentTarget = n[e],
                this.notifyTarget(t, r)
            }
            ))
    }
    propagationPath(t) {
        const e = [t];
        for (let n = 0; n < 2048 && t !== this.rootTarget; n++) {
            if (!t.parent)
                throw new Error("Cannot find propagation path to disconnected target");
            e.push(t.parent),
            t = t.parent
        }
        return e.reverse(),
        e
    }
    hitTestMoveRecursive(t, e, n, r, i, s=!1) {
        let o = !1;
        if (this._interactivePrune(t))
            return null;
        if ("dynamic" !== t.eventMode && "dynamic" !== e || (vM.pauseUpdate = !1),
        t.interactiveChildren && t.children) {
            const a = t.children;
            for (let l = a.length - 1; l >= 0; l--) {
                const c = a[l]
                  , u = this.hitTestMoveRecursive(c, this._isInteractive(e) ? e : c.eventMode, n, r, i, s || i(t, n));
                if (u) {
                    if (u.length > 0 && !u[u.length - 1].parent)
                        continue;
                    const e = t.isInteractive();
                    (u.length > 0 || e) && (e && this._allInteractiveElements.push(t),
                    u.push(t)),
                    0 === this._hitElements.length && (this._hitElements = u),
                    o = !0
                }
            }
        }
        const a = this._isInteractive(e)
          , l = t.isInteractive();
        return l && l && this._allInteractiveElements.push(t),
        s || this._hitElements.length > 0 ? null : o ? this._hitElements : a && !i(t, n) && r(t, n) ? l ? [t] : [] : null
    }
    hitTestRecursive(t, e, n, r, i) {
        if (this._interactivePrune(t) || i(t, n))
            return null;
        if ("dynamic" !== t.eventMode && "dynamic" !== e || (vM.pauseUpdate = !1),
        t.interactiveChildren && t.children) {
            const s = t.children;
            for (let o = s.length - 1; o >= 0; o--) {
                const a = s[o]
                  , l = this.hitTestRecursive(a, this._isInteractive(e) ? e : a.eventMode, n, r, i);
                if (l) {
                    if (l.length > 0 && !l[l.length - 1].parent)
                        continue;
                    const e = t.isInteractive();
                    return (l.length > 0 || e) && l.push(t),
                    l
                }
            }
        }
        const s = this._isInteractive(e)
          , o = t.isInteractive();
        return s && r(t, n) ? o ? [t] : [] : null
    }
    _isInteractive(t) {
        return "static" === t || "dynamic" === t
    }
    _interactivePrune(t) {
        return !(t && !t.isMask && t.visible && t.renderable) || ("none" === t.eventMode || ("passive" === t.eventMode && !t.interactiveChildren || !!t.isMask))
    }
    hitPruneFn(t, e) {
        if (t.hitArea && (t.worldTransform.applyInverse(e, SM),
        !t.hitArea.contains(SM.x, SM.y)))
            return !0;
        if (t._mask) {
            const n = t._mask.isMaskData ? t._mask.maskObject : t._mask;
            if (n && !n.containsPoint?.(e))
                return !0
        }
        return !1
    }
    hitTestFn(t, e) {
        return "passive" !== t.eventMode && (!!t.hitArea || !!t.containsPoint && t.containsPoint(e))
    }
    notifyTarget(t, e) {
        const n = `on${e = e ?? t.type}`;
        t.currentTarget[n]?.(t);
        const r = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e;
        this.notifyListeners(t, r),
        t.eventPhase === t.AT_TARGET && this.notifyListeners(t, e)
    }
    mapPointerDown(t) {
        if (!(t instanceof EM))
            return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        const e = this.createPointerEvent(t);
        if (this.dispatchEvent(e, "pointerdown"),
        "touch" === e.pointerType)
            this.dispatchEvent(e, "touchstart");
        else if ("mouse" === e.pointerType || "pen" === e.pointerType) {
            const t = 2 === e.button;
            this.dispatchEvent(e, t ? "rightdown" : "mousedown")
        }
        this.trackingData(t.pointerId).pressTargetsByButton[t.button] = e.composedPath(),
        this.freeEvent(e)
    }
    mapPointerMove(t) {
        if (!(t instanceof EM))
            return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        this._allInteractiveElements.length = 0,
        this._hitElements.length = 0,
        this._isPointerMoveEvent = !0;
        const e = this.createPointerEvent(t);
        this._isPointerMoveEvent = !1;
        const n = "mouse" === e.pointerType || "pen" === e.pointerType
          , r = this.trackingData(t.pointerId)
          , i = this.findMountedTarget(r.overTargets);
        if (r.overTargets?.length > 0 && i !== e.target) {
            const r = "mousemove" === t.type ? "mouseout" : "pointerout"
              , s = this.createPointerEvent(t, r, i);
            if (this.dispatchEvent(s, "pointerout"),
            n && this.dispatchEvent(s, "mouseout"),
            !e.composedPath().includes(i)) {
                const r = this.createPointerEvent(t, "pointerleave", i);
                for (r.eventPhase = r.AT_TARGET; r.target && !e.composedPath().includes(r.target); )
                    r.currentTarget = r.target,
                    this.notifyTarget(r),
                    n && this.notifyTarget(r, "mouseleave"),
                    r.target = r.target.parent;
                this.freeEvent(r)
            }
            this.freeEvent(s)
        }
        if (i !== e.target) {
            const r = "mousemove" === t.type ? "mouseover" : "pointerover"
              , s = this.clonePointerEvent(e, r);
            this.dispatchEvent(s, "pointerover"),
            n && this.dispatchEvent(s, "mouseover");
            let o = i?.parent;
            for (; o && o !== this.rootTarget.parent && o !== e.target; )
                o = o.parent;
            if (!o || o === this.rootTarget.parent) {
                const t = this.clonePointerEvent(e, "pointerenter");
                for (t.eventPhase = t.AT_TARGET; t.target && t.target !== i && t.target !== this.rootTarget.parent; )
                    t.currentTarget = t.target,
                    this.notifyTarget(t),
                    n && this.notifyTarget(t, "mouseenter"),
                    t.target = t.target.parent;
                this.freeEvent(t)
            }
            this.freeEvent(s)
        }
        const s = []
          , o = this.enableGlobalMoveEvents ?? !0;
        this.moveOnAll ? s.push("pointermove") : this.dispatchEvent(e, "pointermove"),
        o && s.push("globalpointermove"),
        "touch" === e.pointerType && (this.moveOnAll ? s.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"),
        o && s.push("globaltouchmove")),
        n && (this.moveOnAll ? s.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"),
        o && s.push("globalmousemove"),
        this.cursor = e.target?.cursor),
        s.length > 0 && this.all(e, s),
        this._allInteractiveElements.length = 0,
        this._hitElements.length = 0,
        r.overTargets = e.composedPath(),
        this.freeEvent(e)
    }
    mapPointerOver(t) {
        if (!(t instanceof EM))
            return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        const e = this.trackingData(t.pointerId)
          , n = this.createPointerEvent(t)
          , r = "mouse" === n.pointerType || "pen" === n.pointerType;
        this.dispatchEvent(n, "pointerover"),
        r && this.dispatchEvent(n, "mouseover"),
        "mouse" === n.pointerType && (this.cursor = n.target?.cursor);
        const i = this.clonePointerEvent(n, "pointerenter");
        for (i.eventPhase = i.AT_TARGET; i.target && i.target !== this.rootTarget.parent; )
            i.currentTarget = i.target,
            this.notifyTarget(i),
            r && this.notifyTarget(i, "mouseenter"),
            i.target = i.target.parent;
        e.overTargets = n.composedPath(),
        this.freeEvent(n),
        this.freeEvent(i)
    }
    mapPointerOut(t) {
        if (!(t instanceof EM))
            return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        const e = this.trackingData(t.pointerId);
        if (e.overTargets) {
            const n = "mouse" === t.pointerType || "pen" === t.pointerType
              , r = this.findMountedTarget(e.overTargets)
              , i = this.createPointerEvent(t, "pointerout", r);
            this.dispatchEvent(i),
            n && this.dispatchEvent(i, "mouseout");
            const s = this.createPointerEvent(t, "pointerleave", r);
            for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent; )
                s.currentTarget = s.target,
                this.notifyTarget(s),
                n && this.notifyTarget(s, "mouseleave"),
                s.target = s.target.parent;
            e.overTargets = null,
            this.freeEvent(i),
            this.freeEvent(s)
        }
        this.cursor = null
    }
    mapPointerUp(t) {
        if (!(t instanceof EM))
            return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        const e = performance.now()
          , n = this.createPointerEvent(t);
        if (this.dispatchEvent(n, "pointerup"),
        "touch" === n.pointerType)
            this.dispatchEvent(n, "touchend");
        else if ("mouse" === n.pointerType || "pen" === n.pointerType) {
            const t = 2 === n.button;
            this.dispatchEvent(n, t ? "rightup" : "mouseup")
        }
        const r = this.trackingData(t.pointerId)
          , i = this.findMountedTarget(r.pressTargetsByButton[t.button]);
        let s = i;
        if (i && !n.composedPath().includes(i)) {
            let e = i;
            for (; e && !n.composedPath().includes(e); ) {
                if (n.currentTarget = e,
                this.notifyTarget(n, "pointerupoutside"),
                "touch" === n.pointerType)
                    this.notifyTarget(n, "touchendoutside");
                else if ("mouse" === n.pointerType || "pen" === n.pointerType) {
                    const t = 2 === n.button;
                    this.notifyTarget(n, t ? "rightupoutside" : "mouseupoutside")
                }
                e = e.parent
            }
            delete r.pressTargetsByButton[t.button],
            s = e
        }
        if (s) {
            const i = this.clonePointerEvent(n, "click");
            i.target = s,
            i.path = null,
            r.clicksByButton[t.button] || (r.clicksByButton[t.button] = {
                clickCount: 0,
                target: i.target,
                timeStamp: e
            });
            const o = r.clicksByButton[t.button];
            if (o.target === i.target && e - o.timeStamp < 200 ? ++o.clickCount : o.clickCount = 1,
            o.target = i.target,
            o.timeStamp = e,
            i.detail = o.clickCount,
            "mouse" === i.pointerType) {
                const t = 2 === i.button;
                this.dispatchEvent(i, t ? "rightclick" : "click")
            } else
                "touch" === i.pointerType && this.dispatchEvent(i, "tap");
            this.dispatchEvent(i, "pointertap"),
            this.freeEvent(i)
        }
        this.freeEvent(n)
    }
    mapPointerUpOutside(t) {
        if (!(t instanceof EM))
            return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
        const e = this.trackingData(t.pointerId)
          , n = this.findMountedTarget(e.pressTargetsByButton[t.button])
          , r = this.createPointerEvent(t);
        if (n) {
            let i = n;
            for (; i; )
                r.currentTarget = i,
                this.notifyTarget(r, "pointerupoutside"),
                "touch" === r.pointerType ? this.notifyTarget(r, "touchendoutside") : "mouse" !== r.pointerType && "pen" !== r.pointerType || this.notifyTarget(r, 2 === r.button ? "rightupoutside" : "mouseupoutside"),
                i = i.parent;
            delete e.pressTargetsByButton[t.button]
        }
        this.freeEvent(r)
    }
    mapWheel(t) {
        if (!(t instanceof _M))
            return void console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
        const e = this.createWheelEvent(t);
        this.dispatchEvent(e),
        this.freeEvent(e)
    }
    findMountedTarget(t) {
        if (!t)
            return null;
        let e = t[0];
        for (let n = 1; n < t.length && t[n].parent === e; n++)
            e = t[n];
        return e
    }
    createPointerEvent(t, e, n) {
        const r = this.allocateEvent(EM);
        return this.copyPointerData(t, r),
        this.copyMouseData(t, r),
        this.copyData(t, r),
        r.nativeEvent = t.nativeEvent,
        r.originalEvent = t,
        r.target = n ?? this.hitTest(r.global.x, r.global.y) ?? this._hitElements[0],
        "string" == typeof e && (r.type = e),
        r
    }
    createWheelEvent(t) {
        const e = this.allocateEvent(_M);
        return this.copyWheelData(t, e),
        this.copyMouseData(t, e),
        this.copyData(t, e),
        e.nativeEvent = t.nativeEvent,
        e.originalEvent = t,
        e.target = this.hitTest(e.global.x, e.global.y),
        e
    }
    clonePointerEvent(t, e) {
        const n = this.allocateEvent(EM);
        return n.nativeEvent = t.nativeEvent,
        n.originalEvent = t.originalEvent,
        this.copyPointerData(t, n),
        this.copyMouseData(t, n),
        this.copyData(t, n),
        n.target = t.target,
        n.path = t.composedPath().slice(),
        n.type = e ?? n.type,
        n
    }
    copyWheelData(t, e) {
        e.deltaMode = t.deltaMode,
        e.deltaX = t.deltaX,
        e.deltaY = t.deltaY,
        e.deltaZ = t.deltaZ
    }
    copyPointerData(t, e) {
        t instanceof EM && e instanceof EM && (e.pointerId = t.pointerId,
        e.width = t.width,
        e.height = t.height,
        e.isPrimary = t.isPrimary,
        e.pointerType = t.pointerType,
        e.pressure = t.pressure,
        e.tangentialPressure = t.tangentialPressure,
        e.tiltX = t.tiltX,
        e.tiltY = t.tiltY,
        e.twist = t.twist)
    }
    copyMouseData(t, e) {
        t instanceof xM && e instanceof xM && (e.altKey = t.altKey,
        e.button = t.button,
        e.buttons = t.buttons,
        e.client.copyFrom(t.client),
        e.ctrlKey = t.ctrlKey,
        e.metaKey = t.metaKey,
        e.movement.copyFrom(t.movement),
        e.screen.copyFrom(t.screen),
        e.shiftKey = t.shiftKey,
        e.global.copyFrom(t.global))
    }
    copyData(t, e) {
        e.isTrusted = t.isTrusted,
        e.srcElement = t.srcElement,
        e.timeStamp = performance.now(),
        e.type = t.type,
        e.detail = t.detail,
        e.view = t.view,
        e.which = t.which,
        e.layer.copyFrom(t.layer),
        e.page.copyFrom(t.page)
    }
    trackingData(t) {
        return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }),
        this.mappingState.trackingData[t]
    }
    allocateEvent(t) {
        this.eventPool.has(t) || this.eventPool.set(t, []);
        const e = this.eventPool.get(t).pop() || new t(this);
        return e.eventPhase = e.NONE,
        e.currentTarget = null,
        e.path = null,
        e.target = null,
        e
    }
    freeEvent(t) {
        if (t.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const e = t.constructor;
        this.eventPool.has(e) || this.eventPool.set(e, []),
        this.eventPool.get(e).push(t)
    }
    notifyListeners(t, e) {
        const n = t.currentTarget._events[e];
        if (n && t.currentTarget.isInteractive())
            if ("fn"in n)
                n.once && t.currentTarget.removeListener(e, n.fn, void 0, !0),
                n.fn.call(n.context, t);
            else
                for (let r = 0, i = n.length; r < i && !t.propagationImmediatelyStopped; r++)
                    n[r].once && t.currentTarget.removeListener(e, n[r].fn, void 0, !0),
                    n[r].fn.call(n[r].context, t)
    }
}
const kM = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
}
  , IM = class {
    constructor(t) {
        this.supportsTouchEvents = "ontouchstart"in globalThis,
        this.supportsPointerEvents = !!globalThis.PointerEvent,
        this.domElement = null,
        this.resolution = 1,
        this.renderer = t,
        this.rootBoundary = new TM(null),
        vM.init(this),
        this.autoPreventDefault = !0,
        this.eventsAdded = !1,
        this.rootPointerEvent = new EM(null),
        this.rootWheelEvent = new _M(null),
        this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
        },
        this.features = new Proxy({
            ...IM.defaultEventFeatures
        },{
            set: (t,e,n)=>("globalMove" === e && (this.rootBoundary.enableGlobalMoveEvents = n),
            t[e] = n,
            !0)
        }),
        this.onPointerDown = this.onPointerDown.bind(this),
        this.onPointerMove = this.onPointerMove.bind(this),
        this.onPointerUp = this.onPointerUp.bind(this),
        this.onPointerOverOut = this.onPointerOverOut.bind(this),
        this.onWheel = this.onWheel.bind(this)
    }
    static get defaultEventMode() {
        return this._defaultEventMode
    }
    init(t) {
        const {view: e, resolution: n} = this.renderer;
        this.setTargetElement(e),
        this.resolution = n,
        IM._defaultEventMode = t.eventMode ?? "auto",
        Object.assign(this.features, t.eventFeatures ?? {}),
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
    }
    resolutionChange(t) {
        this.resolution = t
    }
    destroy() {
        this.setTargetElement(null),
        this.renderer = null
    }
    setCursor(t) {
        t = t || "default";
        let e = !0;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = !1),
        this.currentCursor === t)
            return;
        this.currentCursor = t;
        const n = this.cursorStyles[t];
        if (n)
            switch (typeof n) {
            case "string":
                e && (this.domElement.style.cursor = n);
                break;
            case "function":
                n(t);
                break;
            case "object":
                e && Object.assign(this.domElement.style, n)
            }
        else
            e && "string" == typeof t && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t)
    }
    get pointer() {
        return this.rootPointerEvent
    }
    onPointerDown(t) {
        if (!this.features.click)
            return;
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.supportsTouchEvents && "touch" === t.pointerType)
            return;
        const e = this.normalizeToPointerData(t);
        if (this.autoPreventDefault && e[0].isNormalized) {
            (t.cancelable || !("cancelable"in t)) && t.preventDefault()
        }
        for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t]
              , r = this.bootstrapEvent(this.rootPointerEvent, n);
            this.rootBoundary.mapEvent(r)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerMove(t) {
        if (!this.features.move)
            return;
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.supportsTouchEvents && "touch" === t.pointerType)
            return;
        vM.pointerMoved();
        const e = this.normalizeToPointerData(t);
        for (let t = 0, n = e.length; t < n; t++) {
            const n = this.bootstrapEvent(this.rootPointerEvent, e[t]);
            this.rootBoundary.mapEvent(n)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerUp(t) {
        if (!this.features.click)
            return;
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.supportsTouchEvents && "touch" === t.pointerType)
            return;
        let e = t.target;
        t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]);
        const n = e !== this.domElement ? "outside" : ""
          , r = this.normalizeToPointerData(t);
        for (let t = 0, e = r.length; t < e; t++) {
            const e = this.bootstrapEvent(this.rootPointerEvent, r[t]);
            e.type += n,
            this.rootBoundary.mapEvent(e)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerOverOut(t) {
        if (!this.features.click)
            return;
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.supportsTouchEvents && "touch" === t.pointerType)
            return;
        const e = this.normalizeToPointerData(t);
        for (let t = 0, n = e.length; t < n; t++) {
            const n = this.bootstrapEvent(this.rootPointerEvent, e[t]);
            this.rootBoundary.mapEvent(n)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onWheel(t) {
        if (!this.features.wheel)
            return;
        const e = this.normalizeWheelEvent(t);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.rootBoundary.mapEvent(e)
    }
    setTargetElement(t) {
        this.removeEvents(),
        this.domElement = t,
        vM.domElement = t,
        this.addEvents()
    }
    addEvents() {
        if (this.eventsAdded || !this.domElement)
            return;
        vM.addTickerListener();
        const t = this.domElement.style;
        t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none",
        t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")),
        this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0),
        this.domElement.addEventListener("pointerdown", this.onPointerDown, !0),
        this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0),
        this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0),
        globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0),
        this.domElement.addEventListener("mousedown", this.onPointerDown, !0),
        this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0),
        this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0),
        globalThis.addEventListener("mouseup", this.onPointerUp, !0)),
        this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0),
        this.domElement.addEventListener("touchend", this.onPointerUp, !0),
        this.domElement.addEventListener("touchmove", this.onPointerMove, !0)),
        this.domElement.addEventListener("wheel", this.onWheel, {
            passive: !0,
            capture: !0
        }),
        this.eventsAdded = !0
    }
    removeEvents() {
        if (!this.eventsAdded || !this.domElement)
            return;
        vM.removeTickerListener();
        const t = this.domElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "",
        t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""),
        this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0),
        this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0),
        this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0),
        this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0),
        globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0),
        this.domElement.removeEventListener("mousedown", this.onPointerDown, !0),
        this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0),
        this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0),
        globalThis.removeEventListener("mouseup", this.onPointerUp, !0)),
        this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0),
        this.domElement.removeEventListener("touchend", this.onPointerUp, !0),
        this.domElement.removeEventListener("touchmove", this.onPointerMove, !0)),
        this.domElement.removeEventListener("wheel", this.onWheel, !0),
        this.domElement = null,
        this.eventsAdded = !1
    }
    mapPositionToPoint(t, e, n) {
        let r;
        r = this.domElement.parentElement ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
        };
        const i = 1 / this.resolution;
        t.x = (e - r.left) * (this.domElement.width / r.width) * i,
        t.y = (n - r.top) * (this.domElement.height / r.height) * i
    }
    normalizeToPointerData(t) {
        const e = [];
        if (this.supportsTouchEvents && t instanceof TouchEvent)
            for (let n = 0, r = t.changedTouches.length; n < r; n++) {
                const r = t.changedTouches[n];
                void 0 === r.button && (r.button = 0),
                void 0 === r.buttons && (r.buttons = 1),
                void 0 === r.isPrimary && (r.isPrimary = 1 === t.touches.length && "touchstart" === t.type),
                void 0 === r.width && (r.width = r.radiusX || 1),
                void 0 === r.height && (r.height = r.radiusY || 1),
                void 0 === r.tiltX && (r.tiltX = 0),
                void 0 === r.tiltY && (r.tiltY = 0),
                void 0 === r.pointerType && (r.pointerType = "touch"),
                void 0 === r.pointerId && (r.pointerId = r.identifier || 0),
                void 0 === r.pressure && (r.pressure = r.force || .5),
                void 0 === r.twist && (r.twist = 0),
                void 0 === r.tangentialPressure && (r.tangentialPressure = 0),
                void 0 === r.layerX && (r.layerX = r.offsetX = r.clientX),
                void 0 === r.layerY && (r.layerY = r.offsetY = r.clientY),
                r.isNormalized = !0,
                r.type = t.type,
                e.push(r)
            }
        else if (globalThis.MouseEvent && (!(t instanceof MouseEvent) || this.supportsPointerEvents && t instanceof globalThis.PointerEvent))
            e.push(t);
        else {
            const n = t;
            void 0 === n.isPrimary && (n.isPrimary = !0),
            void 0 === n.width && (n.width = 1),
            void 0 === n.height && (n.height = 1),
            void 0 === n.tiltX && (n.tiltX = 0),
            void 0 === n.tiltY && (n.tiltY = 0),
            void 0 === n.pointerType && (n.pointerType = "mouse"),
            void 0 === n.pointerId && (n.pointerId = 1),
            void 0 === n.pressure && (n.pressure = .5),
            void 0 === n.twist && (n.twist = 0),
            void 0 === n.tangentialPressure && (n.tangentialPressure = 0),
            n.isNormalized = !0,
            e.push(n)
        }
        return e
    }
    normalizeWheelEvent(t) {
        const e = this.rootWheelEvent;
        return this.transferMouseData(e, t),
        e.deltaX = t.deltaX,
        e.deltaY = t.deltaY,
        e.deltaZ = t.deltaZ,
        e.deltaMode = t.deltaMode,
        this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
        e.global.copyFrom(e.screen),
        e.offset.copyFrom(e.screen),
        e.nativeEvent = t,
        e.type = t.type,
        e
    }
    bootstrapEvent(t, e) {
        return t.originalEvent = null,
        t.nativeEvent = e,
        t.pointerId = e.pointerId,
        t.width = e.width,
        t.height = e.height,
        t.isPrimary = e.isPrimary,
        t.pointerType = e.pointerType,
        t.pressure = e.pressure,
        t.tangentialPressure = e.tangentialPressure,
        t.tiltX = e.tiltX,
        t.tiltY = e.tiltY,
        t.twist = e.twist,
        this.transferMouseData(t, e),
        this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
        t.global.copyFrom(t.screen),
        t.offset.copyFrom(t.screen),
        t.isTrusted = e.isTrusted,
        "pointerleave" === t.type && (t.type = "pointerout"),
        t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")),
        t.type.startsWith("touch") && (t.type = kM[t.type] || t.type),
        t
    }
    transferMouseData(t, e) {
        t.isTrusted = e.isTrusted,
        t.srcElement = e.srcElement,
        t.timeStamp = performance.now(),
        t.type = e.type,
        t.altKey = e.altKey,
        t.button = e.button,
        t.buttons = e.buttons,
        t.client.x = e.clientX,
        t.client.y = e.clientY,
        t.ctrlKey = e.ctrlKey,
        t.metaKey = e.metaKey,
        t.movement.x = e.movementX,
        t.movement.y = e.movementY,
        t.page.x = e.pageX,
        t.page.y = e.pageY,
        t.relatedTarget = null,
        t.shiftKey = e.shiftKey
    }
}
;
let MM = IM;
function CM(t) {
    return "dynamic" === t || "static" === t
}
MM.extension = {
    name: "events",
    type: [Ub.RendererSystem, Ub.CanvasRendererSystem]
},
MM.defaultEventFeatures = {
    move: !0,
    globalMove: !0,
    click: !0,
    wheel: !0
},
Wb.add(MM);
const PM = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    _internalInteractive: void 0,
    get interactive() {
        return this._internalInteractive ?? CM(MM.defaultEventMode)
    },
    set interactive(t) {
        fg.deprecation("7.2.0", "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."),
        this._internalInteractive = t,
        this.eventMode = t ? "static" : "auto"
    },
    _internalEventMode: void 0,
    get eventMode() {
        return this._internalEventMode ?? MM.defaultEventMode
    },
    set eventMode(t) {
        this._internalInteractive = CM(t),
        this._internalEventMode = t
    },
    isInteractive() {
        return "static" === this.eventMode || "dynamic" === this.eventMode
    },
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(t, e, n) {
        const r = "function" == typeof e ? void 0 : e;
        t = "boolean" == typeof n && n || "object" == typeof n && n.capture ? `${t}capture` : t,
        e = "function" == typeof e ? e : e.handleEvent,
        this.on(t, e, r)
    },
    removeEventListener(t, e, n) {
        const r = "function" == typeof e ? void 0 : e;
        t = "boolean" == typeof n && n || "object" == typeof n && n.capture ? `${t}capture` : t,
        e = "function" == typeof e ? e : e.handleEvent,
        this.off(t, e, r)
    },
    dispatchEvent(t) {
        if (!(t instanceof wM))
            throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return t.defaultPrevented = !1,
        t.path = null,
        t.target = this,
        t.manager.dispatchEvent(t),
        !t.defaultPrevented
    }
};
yI.mixin(PM);
yI.mixin({
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1
});
class OM {
    constructor(t) {
        this.debug = !1,
        this._isActive = !1,
        this._isMobileAccessibility = !1,
        this.pool = [],
        this.renderId = 0,
        this.children = [],
        this.androidUpdateCount = 0,
        this.androidUpdateFrequency = 500,
        this._hookDiv = null,
        (fg.isMobile.tablet || fg.isMobile.phone) && this.createTouchHook();
        const e = document.createElement("div");
        e.style.width = "100px",
        e.style.height = "100px",
        e.style.position = "absolute",
        e.style.top = "0px",
        e.style.left = "0px",
        e.style.zIndex = 2..toString(),
        this.div = e,
        this.renderer = t,
        this._onKeyDown = this._onKeyDown.bind(this),
        this._onMouseMove = this._onMouseMove.bind(this),
        globalThis.addEventListener("keydown", this._onKeyDown, !1)
    }
    get isActive() {
        return this._isActive
    }
    get isMobileAccessibility() {
        return this._isMobileAccessibility
    }
    createTouchHook() {
        const t = document.createElement("button");
        t.style.width = "1px",
        t.style.height = "1px",
        t.style.position = "absolute",
        t.style.top = "-1000px",
        t.style.left = "-1000px",
        t.style.zIndex = 2..toString(),
        t.style.backgroundColor = "#FF0000",
        t.title = "select to enable accessibility for this content",
        t.addEventListener("focus", (()=>{
            this._isMobileAccessibility = !0,
            this.activate(),
            this.destroyTouchHook()
        }
        )),
        document.body.appendChild(t),
        this._hookDiv = t
    }
    destroyTouchHook() {
        this._hookDiv && (document.body.removeChild(this._hookDiv),
        this._hookDiv = null)
    }
    activate() {
        this._isActive || (this._isActive = !0,
        globalThis.document.addEventListener("mousemove", this._onMouseMove, !0),
        globalThis.removeEventListener("keydown", this._onKeyDown, !1),
        this.renderer.on("postrender", this.update, this),
        this.renderer.view.parentNode?.appendChild(this.div))
    }
    deactivate() {
        this._isActive && !this._isMobileAccessibility && (this._isActive = !1,
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
        globalThis.addEventListener("keydown", this._onKeyDown, !1),
        this.renderer.off("postrender", this.update),
        this.div.parentNode?.removeChild(this.div))
    }
    updateAccessibleObjects(t) {
        if (!t.visible || !t.accessibleChildren)
            return;
        t.accessible && t.isInteractive() && (t._accessibleActive || this.addChild(t),
        t.renderId = this.renderId);
        const e = t.children;
        if (e)
            for (let t = 0; t < e.length; t++)
                this.updateAccessibleObjects(e[t])
    }
    update() {
        const t = performance.now();
        if (fg.isMobile.android.device && t < this.androidUpdateCount)
            return;
        if (this.androidUpdateCount = t + this.androidUpdateFrequency,
        !this.renderer.renderingToScreen)
            return;
        this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
        const {x: e, y: n, width: r, height: i} = this.renderer.view.getBoundingClientRect()
          , {width: s, height: o, resolution: a} = this.renderer
          , l = r / s * a
          , c = i / o * a;
        let u = this.div;
        u.style.left = `${e}px`,
        u.style.top = `${n}px`,
        u.style.width = `${s}px`,
        u.style.height = `${o}px`;
        for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t];
            if (e.renderId !== this.renderId)
                e._accessibleActive = !1,
                fg.removeItems(this.children, t, 1),
                this.div.removeChild(e._accessibleDiv),
                this.pool.push(e._accessibleDiv),
                e._accessibleDiv = null,
                t--;
            else {
                u = e._accessibleDiv;
                let t = e.hitArea;
                const n = e.worldTransform;
                e.hitArea ? (u.style.left = (n.tx + t.x * n.a) * l + "px",
                u.style.top = (n.ty + t.y * n.d) * c + "px",
                u.style.width = t.width * n.a * l + "px",
                u.style.height = t.height * n.d * c + "px") : (t = e.getBounds(),
                this.capHitArea(t),
                u.style.left = t.x * l + "px",
                u.style.top = t.y * c + "px",
                u.style.width = t.width * l + "px",
                u.style.height = t.height * c + "px",
                u.title !== e.accessibleTitle && null !== e.accessibleTitle && (u.title = e.accessibleTitle),
                u.getAttribute("aria-label") !== e.accessibleHint && null !== e.accessibleHint && u.setAttribute("aria-label", e.accessibleHint)),
                e.accessibleTitle === u.title && e.tabIndex === u.tabIndex || (u.title = e.accessibleTitle,
                u.tabIndex = e.tabIndex,
                this.debug && this.updateDebugHTML(u))
            }
        }
        this.renderId++
    }
    updateDebugHTML(t) {
        t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
    }
    capHitArea(t) {
        t.x < 0 && (t.width += t.x,
        t.x = 0),
        t.y < 0 && (t.height += t.y,
        t.y = 0);
        const {width: e, height: n} = this.renderer;
        t.x + t.width > e && (t.width = e - t.x),
        t.y + t.height > n && (t.height = n - t.y)
    }
    addChild(t) {
        let e = this.pool.pop();
        e || (e = document.createElement("button"),
        e.style.width = "100px",
        e.style.height = "100px",
        e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent",
        e.style.position = "absolute",
        e.style.zIndex = 2..toString(),
        e.style.borderStyle = "none",
        navigator.userAgent.toLowerCase().includes("chrome") ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"),
        navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"),
        e.addEventListener("click", this._onClick.bind(this)),
        e.addEventListener("focus", this._onFocus.bind(this)),
        e.addEventListener("focusout", this._onFocusOut.bind(this))),
        e.style.pointerEvents = t.accessiblePointerEvents,
        e.type = t.accessibleType,
        t.accessibleTitle && null !== t.accessibleTitle ? e.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (e.title = `displayObject ${t.tabIndex}`),
        t.accessibleHint && null !== t.accessibleHint && e.setAttribute("aria-label", t.accessibleHint),
        this.debug && this.updateDebugHTML(e),
        t._accessibleActive = !0,
        t._accessibleDiv = e,
        e.displayObject = t,
        this.children.push(t),
        this.div.appendChild(t._accessibleDiv),
        t._accessibleDiv.tabIndex = t.tabIndex
    }
    _dispatchEvent(t, e) {
        const {displayObject: n} = t.target
          , r = this.renderer.events.rootBoundary
          , i = Object.assign(new wM(r), {
            target: n
        });
        r.rootTarget = this.renderer.lastObjectRendered,
        e.forEach((t=>r.dispatchEvent(i, t)))
    }
    _onClick(t) {
        this._dispatchEvent(t, ["click", "pointertap", "tap"])
    }
    _onFocus(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"),
        this._dispatchEvent(t, ["mouseover"])
    }
    _onFocusOut(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"),
        this._dispatchEvent(t, ["mouseout"])
    }
    _onKeyDown(t) {
        9 === t.keyCode && this.activate()
    }
    _onMouseMove(t) {
        0 === t.movementX && 0 === t.movementY || this.deactivate()
    }
    destroy() {
        this.destroyTouchHook(),
        this.div = null,
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
        globalThis.removeEventListener("keydown", this._onKeyDown),
        this.pool = null,
        this.children = null,
        this.renderer = null
    }
}
OM.extension = {
    name: "accessibility",
    type: [Ub.RendererPlugin, Ub.CanvasRendererPlugin]
},
Wb.add(OM);
const NM = class {
    constructor(t) {
        this.stage = new EI,
        t = Object.assign({
            forceCanvas: !1
        }, t),
        this.renderer = jx(t),
        NM._plugins.forEach((e=>{
            e.init.call(this, t)
        }
        ))
    }
    render() {
        this.renderer.render(this.stage)
    }
    get view() {
        return this.renderer.view
    }
    get screen() {
        return this.renderer.screen
    }
    destroy(t, e) {
        const n = NM._plugins.slice(0);
        n.reverse(),
        n.forEach((t=>{
            t.destroy.call(this)
        }
        )),
        this.stage.destroy(e),
        this.stage = null,
        this.renderer.destroy(t),
        this.renderer = null
    }
}
;
let RM = NM;
RM._plugins = [],
Wb.handleByList(Ub.Application, RM._plugins);
class DM {
    static init(t) {
        Object.defineProperty(this, "resizeTo", {
            set(t) {
                globalThis.removeEventListener("resize", this.queueResize),
                this._resizeTo = t,
                t && (globalThis.addEventListener("resize", this.queueResize),
                this.resize())
            },
            get() {
                return this._resizeTo
            }
        }),
        this.queueResize = ()=>{
            this._resizeTo && (this.cancelResize(),
            this._resizeId = requestAnimationFrame((()=>this.resize())))
        }
        ,
        this.cancelResize = ()=>{
            this._resizeId && (cancelAnimationFrame(this._resizeId),
            this._resizeId = null)
        }
        ,
        this.resize = ()=>{
            if (!this._resizeTo)
                return;
            let t, e;
            if (this.cancelResize(),
            this._resizeTo === globalThis.window)
                t = globalThis.innerWidth,
                e = globalThis.innerHeight;
            else {
                const {clientWidth: n, clientHeight: r} = this._resizeTo;
                t = n,
                e = r
            }
            this.renderer.resize(t, e),
            this.render()
        }
        ,
        this._resizeId = null,
        this._resizeTo = null,
        this.resizeTo = t.resizeTo || null
    }
    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize),
        this.cancelResize(),
        this.cancelResize = null,
        this.queueResize = null,
        this.resizeTo = null,
        this.resize = null
    }
}
DM.extension = Ub.Application,
Wb.add(DM);
var BM = (t=>(t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT",
t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT",
t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT",
t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT",
t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",
t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",
t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",
t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT",
t[t.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC",
t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC",
t[t.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC",
t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC",
t[t.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2",
t[t.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC",
t[t.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2",
t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG",
t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",
t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL",
t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL",
t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",
t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL",
t[t.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR",
t))(BM || {});
const LM = {
    33776: .5,
    33777: .5,
    33778: 1,
    33779: 1,
    35916: .5,
    35917: .5,
    35918: 1,
    35919: 1,
    37488: .5,
    37489: .5,
    37490: 1,
    37491: 1,
    37492: .5,
    37496: 1,
    37493: .5,
    37497: 1,
    37494: .5,
    37495: .5,
    35840: .5,
    35842: .5,
    35841: .25,
    35843: .25,
    36196: .5,
    35986: .5,
    35986: 1,
    34798: 1,
    37808: 1
};
let FM, jM;
function UM() {
    jM = {
        s3tc: FM.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: FM.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: FM.getExtension("WEBGL_compressed_texture_etc"),
        etc1: FM.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: FM.getExtension("WEBGL_compressed_texture_pvrtc") || FM.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: FM.getExtension("WEBGL_compressed_texture_atc"),
        astc: FM.getExtension("WEBGL_compressed_texture_astc")
    }
}
const zM = {
    extension: {
        type: Ub.DetectionParser,
        priority: 2
    },
    test: async()=>{
        const t = Xm.ADAPTER.createCanvas().getContext("webgl");
        return t ? (FM = t,
        !0) : (console.warn("WebGL not available for compressed textures."),
        !1)
    }
    ,
    add: async t=>{
        jM || UM();
        const e = [];
        for (const t in jM) {
            jM[t] && e.push(t)
        }
        return [...e, ...t]
    }
    ,
    remove: async t=>(jM || UM(),
    t.filter((t=>!(t in jM))))
};
Wb.add(zM);
class VM extends Jb {
    constructor(t, e={
        width: 1,
        height: 1,
        autoLoad: !0
    }) {
        let n, r;
        "string" == typeof t ? (n = t,
        r = new Uint8Array) : (n = null,
        r = t),
        super(r, e),
        this.origin = n,
        this.buffer = r ? new Yb(r) : null,
        this._load = null,
        this.loaded = !1,
        null !== this.origin && !1 !== e.autoLoad && this.load(),
        null === this.origin && this.buffer && (this._load = Promise.resolve(this),
        this.loaded = !0,
        this.onBlobLoaded(this.buffer.rawBinaryData))
    }
    onBlobLoaded(t) {}
    load() {
        return this._load || (this._load = fetch(this.origin).then((t=>t.blob())).then((t=>t.arrayBuffer())).then((t=>(this.data = new Uint32Array(t),
        this.buffer = new Yb(t),
        this.loaded = !0,
        this.onBlobLoaded(t),
        this.update(),
        this)))),
        this._load
    }
}
class WM extends VM {
    constructor(t, e) {
        super(t, e),
        this.format = e.format,
        this.levels = e.levels || 1,
        this._width = e.width,
        this._height = e.height,
        this._extension = WM._formatToExtension(this.format),
        (e.levelBuffers || this.buffer) && (this._levelBuffers = e.levelBuffers || WM._createLevelBuffers(t instanceof Uint8Array ? t : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
    }
    upload(t, e, n) {
        const r = t.gl;
        if (!t.context.extensions[this._extension])
            throw new Error(`${this._extension} textures are not supported on the current machine`);
        if (!this._levelBuffers)
            return !1;
        for (let t = 0, e = this.levels; t < e; t++) {
            const {levelID: e, levelWidth: n, levelHeight: i, levelBuffer: s} = this._levelBuffers[t];
            r.compressedTexImage2D(r.TEXTURE_2D, e, this.format, n, i, 0, s)
        }
        return !0
    }
    onBlobLoaded() {
        this._levelBuffers = WM._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
    }
    static _formatToExtension(t) {
        if (t >= 33776 && t <= 33779)
            return "s3tc";
        if (t >= 37488 && t <= 37497)
            return "etc";
        if (t >= 35840 && t <= 35843)
            return "pvrtc";
        if (t >= 36196)
            return "etc1";
        if (t >= 35986 && t <= 34798)
            return "atc";
        throw new Error("Invalid (compressed) texture format given!")
    }
    static _createLevelBuffers(t, e, n, r, i, s, o) {
        const a = new Array(n);
        let l = t.byteOffset
          , c = s
          , u = o
          , h = c + r - 1 & ~(r - 1)
          , d = u + i - 1 & ~(i - 1)
          , f = h * d * LM[e];
        for (let s = 0; s < n; s++)
            a[s] = {
                levelID: s,
                levelWidth: n > 1 ? c : h,
                levelHeight: n > 1 ? u : d,
                levelBuffer: new Uint8Array(t.buffer,l,f)
            },
            l += f,
            c = c >> 1 || 1,
            u = u >> 1 || 1,
            h = c + r - 1 & ~(r - 1),
            d = u + i - 1 & ~(i - 1),
            f = h * d * LM[e];
        return a
    }
}
const YM = 4
  , HM = 124
  , $M = 32
  , GM = 20
  , XM = 542327876
  , qM = {
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19
}
  , KM = {
    SIZE: 0,
    FLAGS: 1,
    FOURCC: 2,
    RGB_BITCOUNT: 3,
    R_BIT_MASK: 4,
    G_BIT_MASK: 5,
    B_BIT_MASK: 6,
    A_BIT_MASK: 7
}
  , QM = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
};
const ZM = 1
  , JM = 2
  , tC = 4
  , eC = 64
  , nC = 512
  , rC = 131072
  , iC = 808540228
  , sC = 4
  , oC = {
    827611204: BM.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    861165636: BM.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    894720068: BM.COMPRESSED_RGBA_S3TC_DXT5_EXT
}
  , aC = {
    70: BM.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    71: BM.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    73: BM.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    74: BM.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    76: BM.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    77: BM.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    72: BM.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
    75: BM.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
    78: BM.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function lC(t) {
    const e = new Uint32Array(t);
    if (e[0] !== XM)
        throw new Error("Invalid DDS file magic word");
    const n = new Uint32Array(t,0,HM / Uint32Array.BYTES_PER_ELEMENT)
      , r = n[qM.HEIGHT]
      , i = n[qM.WIDTH]
      , s = n[qM.MIPMAP_COUNT]
      , o = new Uint32Array(t,qM.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,$M / Uint32Array.BYTES_PER_ELEMENT)
      , a = o[ZM];
    if (a & tC) {
        const n = o[KM.FOURCC];
        if (n !== iC) {
            const e = oC[n]
              , o = new Uint8Array(t,YM + HM);
            return [new WM(o,{
                format: e,
                width: i,
                height: r,
                levels: s
            })]
        }
        const a = YM + HM
          , l = new Uint32Array(e.buffer,a,GM / Uint32Array.BYTES_PER_ELEMENT)
          , c = l[QM.DXGI_FORMAT]
          , u = l[QM.RESOURCE_DIMENSION]
          , h = l[QM.MISC_FLAG]
          , d = l[QM.ARRAY_SIZE]
          , f = aC[c];
        if (void 0 === f)
            throw new Error(`DDSParser cannot parse texture data with DXGI format ${c}`);
        if (h === sC)
            throw new Error("DDSParser does not support cubemap textures");
        if (6 === u)
            throw new Error("DDSParser does not supported 3D texture data");
        const p = new Array
          , m = YM + HM + GM;
        if (1 === d)
            p.push(new Uint8Array(t,m));
        else {
            const e = LM[f];
            let n = 0
              , o = i
              , a = r;
            for (let t = 0; t < s; t++) {
                n += Math.max(1, o + 3 & -4) * Math.max(1, a + 3 & -4) * e,
                o >>>= 1,
                a >>>= 1
            }
            let l = m;
            for (let e = 0; e < d; e++)
                p.push(new Uint8Array(t,l,n)),
                l += n
        }
        return p.map((t=>new WM(t,{
            format: f,
            width: i,
            height: r,
            levels: s
        })))
    }
    if (a & eC)
        throw new Error("DDSParser does not support uncompressed texture data.");
    if (a & nC)
        throw new Error("DDSParser does not supported YUV uncompressed texture data.");
    if (a & rC)
        throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
    if (a & JM)
        throw new Error("DDSParser does not support single-channel (alpha) texture data!");
    throw new Error("DDSParser failed to load a texture file due to an unknown reason!")
}
const cC = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]
  , uC = 67305985
  , hC = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
}
  , dC = 64
  , fC = {
    [Bm.UNSIGNED_BYTE]: 1,
    [Bm.UNSIGNED_SHORT]: 2,
    [Bm.INT]: 4,
    [Bm.UNSIGNED_INT]: 4,
    [Bm.FLOAT]: 4,
    [Bm.HALF_FLOAT]: 8
}
  , pC = {
    [Rm.RGBA]: 4,
    [Rm.RGB]: 3,
    [Rm.RG]: 2,
    [Rm.RED]: 1,
    [Rm.LUMINANCE]: 1,
    [Rm.LUMINANCE_ALPHA]: 2,
    [Rm.ALPHA]: 1
}
  , mC = {
    [Bm.UNSIGNED_SHORT_4_4_4_4]: 2,
    [Bm.UNSIGNED_SHORT_5_5_5_1]: 2,
    [Bm.UNSIGNED_SHORT_5_6_5]: 2
};
function gC(t, e, n=!1) {
    const r = new DataView(e);
    if (!function(t, e) {
        for (let n = 0; n < cC.length; n++)
            if (e.getUint8(n) !== cC[n])
                return console.error(`${t} is not a valid *.ktx file!`),
                !1;
        return !0
    }(t, r))
        return null;
    const i = r.getUint32(hC.ENDIANNESS, !0) === uC
      , s = r.getUint32(hC.GL_TYPE, i)
      , o = r.getUint32(hC.GL_FORMAT, i)
      , a = r.getUint32(hC.GL_INTERNAL_FORMAT, i)
      , l = r.getUint32(hC.PIXEL_WIDTH, i)
      , c = r.getUint32(hC.PIXEL_HEIGHT, i) || 1
      , u = r.getUint32(hC.PIXEL_DEPTH, i) || 1
      , h = r.getUint32(hC.NUMBER_OF_ARRAY_ELEMENTS, i) || 1
      , d = r.getUint32(hC.NUMBER_OF_FACES, i)
      , f = r.getUint32(hC.NUMBER_OF_MIPMAP_LEVELS, i)
      , p = r.getUint32(hC.BYTES_OF_KEY_VALUE_DATA, i);
    if (0 === c || 1 !== u)
        throw new Error("Only 2D textures are supported");
    if (1 !== d)
        throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (1 !== h)
        throw new Error("WebGL does not support array textures");
    const m = l + 3 & -4
      , g = c + 3 & -4
      , y = new Array(h);
    let b, v = l * c;
    if (0 === s && (v = m * g),
    b = 0 !== s ? fC[s] ? fC[s] * pC[o] : mC[s] : LM[a],
    void 0 === b)
        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    const w = n ? function(t, e, n) {
        const r = new Map;
        let i = 0;
        for (; i < e; ) {
            const s = t.getUint32(dC + i, n)
              , o = dC + i + 4
              , a = 3 - (s + 3) % 4;
            if (0 === s || s > e - i) {
                console.error("KTXLoader: keyAndValueByteSize out of bounds");
                break
            }
            let l = 0;
            for (; l < s && 0 !== t.getUint8(o + l); l++)
                ;
            if (-1 === l) {
                console.error("KTXLoader: Failed to find null byte terminating kvData key");
                break
            }
            const c = (new TextDecoder).decode(new Uint8Array(t.buffer,o,l))
              , u = new DataView(t.buffer,o + l + 1,s - l - 1);
            r.set(c, u),
            i += 4 + s + a
        }
        return r
    }(r, p, i) : null;
    let x = v * b
      , E = l
      , _ = c
      , A = m
      , S = g
      , T = dC + p;
    for (let t = 0; t < f; t++) {
        const n = r.getUint32(T, i);
        let o = T + 4;
        for (let n = 0; n < h; n++) {
            let r = y[n];
            r || (r = y[n] = new Array(f)),
            r[t] = {
                levelID: t,
                levelWidth: f > 1 || 0 !== s ? E : A,
                levelHeight: f > 1 || 0 !== s ? _ : S,
                levelBuffer: new Uint8Array(e,o,x)
            },
            o += x
        }
        T += n + 4,
        T = T % 4 != 0 ? T + 4 - T % 4 : T,
        E = E >> 1 || 1,
        _ = _ >> 1 || 1,
        A = E + 4 - 1 & -4,
        S = _ + 4 - 1 & -4,
        x = A * S * b
    }
    return 0 !== s ? {
        uncompressed: y.map((t=>{
            let e = t[0].levelBuffer
              , n = !1;
            return s === Bm.FLOAT ? e = new Float32Array(t[0].levelBuffer.buffer,t[0].levelBuffer.byteOffset,t[0].levelBuffer.byteLength / 4) : s === Bm.UNSIGNED_INT ? (n = !0,
            e = new Uint32Array(t[0].levelBuffer.buffer,t[0].levelBuffer.byteOffset,t[0].levelBuffer.byteLength / 4)) : s === Bm.INT && (n = !0,
            e = new Int32Array(t[0].levelBuffer.buffer,t[0].levelBuffer.byteOffset,t[0].levelBuffer.byteLength / 4)),
            {
                resource: new Jb(e,{
                    width: t[0].levelWidth,
                    height: t[0].levelHeight
                }),
                type: s,
                format: n ? yC(o) : o
            }
        }
        )),
        kvData: w
    } : {
        compressed: y.map((t=>new WM(null,{
            format: a,
            width: l,
            height: c,
            levels: f,
            levelBuffers: t
        }))),
        kvData: w
    }
}
function yC(t) {
    switch (t) {
    case Rm.RGBA:
        return Rm.RGBA_INTEGER;
    case Rm.RGB:
        return Rm.RGB_INTEGER;
    case Rm.RG:
        return Rm.RG_INTEGER;
    case Rm.RED:
        return Rm.RED_INTEGER;
    default:
        return t
    }
}
const bC = {
    extension: {
        type: Ub.LoadParser,
        priority: NE.High
    },
    name: "loadDDS",
    test: t=>SE(t, ".dds"),
    async load(t, e, n) {
        const r = await Xm.ADAPTER.fetch(t)
          , i = lC(await r.arrayBuffer()).map((r=>GE(new nv(r,{
            mipmap: Um.OFF,
            alphaMode: zm.NO_PREMULTIPLIED_ALPHA,
            resolution: fg.getResolutionOfUrl(t),
            ...e.data
        }), n, t)));
        return 1 === i.length ? i[0] : i
    },
    unload(t) {
        Array.isArray(t) ? t.forEach((t=>t.destroy(!0))) : t.destroy(!0)
    }
};
Wb.add(bC);
const vC = {
    extension: {
        type: Ub.LoadParser,
        priority: NE.High
    },
    name: "loadKTX",
    test: t=>SE(t, ".ktx"),
    async load(t, e, n) {
        const r = await Xm.ADAPTER.fetch(t)
          , i = await r.arrayBuffer()
          , {compressed: s, uncompressed: o, kvData: a} = gC(t, i)
          , l = s ?? o
          , c = {
            mipmap: Um.OFF,
            alphaMode: zm.NO_PREMULTIPLIED_ALPHA,
            resolution: fg.getResolutionOfUrl(t),
            ...e.data
        }
          , u = l.map((e=>{
            l === o && Object.assign(c, {
                type: e.type,
                format: e.format
            });
            const r = new nv(e,c);
            return r.ktxKeyValueData = a,
            GE(r, n, t)
        }
        ));
        return 1 === u.length ? u[0] : u
    },
    unload(t) {
        Array.isArray(t) ? t.forEach((t=>t.destroy(!0))) : t.destroy(!0)
    }
};
Wb.add(vC);
const wC = {
    extension: Ub.ResolveParser,
    test: t=>{
        const e = t.split("?")[0].split(".").pop();
        return ["basis", "ktx", "dds"].includes(e)
    }
    ,
    parse: t=>{
        if ("ktx" === t.split("?")[0].split(".").pop()) {
            const e = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
            if (e.some((e=>t.endsWith(e))))
                return {
                    resolution: parseFloat(Xm.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
                    format: e.find((e=>t.endsWith(e))),
                    src: t
                }
        }
        return {
            resolution: parseFloat(Xm.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
            format: t.split(".").pop(),
            src: t
        }
    }
};
Wb.add(wC);
const xC = new wv
  , EC = class {
    constructor(t) {
        this.renderer = t
    }
    async image(t, e, n) {
        const r = new Image;
        return r.src = await this.base64(t, e, n),
        r
    }
    async base64(t, e, n) {
        const r = this.canvas(t);
        if (void 0 !== r.toBlob)
            return new Promise(((t,i)=>{
                r.toBlob((e=>{
                    if (!e)
                        return void i(new Error("ICanvas.toBlob failed!"));
                    const n = new FileReader;
                    n.onload = ()=>t(n.result),
                    n.onerror = i,
                    n.readAsDataURL(e)
                }
                ), e, n)
            }
            ));
        if (void 0 !== r.toDataURL)
            return r.toDataURL(e, n);
        if (void 0 !== r.convertToBlob) {
            const t = await r.convertToBlob({
                type: e,
                quality: n
            });
            return new Promise(((e,n)=>{
                const r = new FileReader;
                r.onload = ()=>e(r.result),
                r.onerror = n,
                r.readAsDataURL(t)
            }
            ))
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
    }
    canvas(t, e) {
        const {pixels: n, width: r, height: i, flipY: s} = this._rawPixels(t, e);
        s && EC._flipY(n, r, i),
        EC._unpremultiplyAlpha(n);
        const o = new fg.CanvasRenderTarget(r,i,1)
          , a = new ImageData(new Uint8ClampedArray(n.buffer),r,i);
        return o.context.putImageData(a, 0, 0),
        o.canvas
    }
    pixels(t, e) {
        const {pixels: n, width: r, height: i, flipY: s} = this._rawPixels(t, e);
        return s && EC._flipY(n, r, i),
        EC._unpremultiplyAlpha(n),
        n
    }
    _rawPixels(t, e) {
        const n = this.renderer;
        if (!n)
            throw new Error("The Extract has already been destroyed");
        let r, i, s = !1, o = !1;
        if (t && (t instanceof Nw ? i = t : (i = n.generateTexture(t, {
            resolution: n.resolution,
            multisample: n.multisample
        }),
        o = !0)),
        i) {
            if (r = i.baseTexture.resolution,
            e = e ?? i.frame,
            s = !1,
            !o) {
                n.renderTexture.bind(i);
                const t = i.framebuffer.glFramebuffers[n.CONTEXT_UID];
                t.blitFramebuffer && n.framebuffer.bind(t.blitFramebuffer)
            }
        } else
            r = n.resolution,
            e || ((e = xC).width = n.width / r,
            e.height = n.height / r),
            s = !0,
            n.renderTexture.bind();
        const a = Math.round(e.width * r)
          , l = Math.round(e.height * r)
          , c = new Uint8Array(4 * a * l)
          , u = n.gl;
        return u.readPixels(Math.round(e.x * r), Math.round(e.y * r), a, l, u.RGBA, u.UNSIGNED_BYTE, c),
        o && i?.destroy(!0),
        {
            pixels: c,
            width: a,
            height: l,
            flipY: s
        }
    }
    destroy() {
        this.renderer = null
    }
    static _flipY(t, e, n) {
        const r = e << 2
          , i = n >> 1
          , s = new Uint8Array(r);
        for (let e = 0; e < i; e++) {
            const i = e * r
              , o = (n - e - 1) * r;
            s.set(t.subarray(i, i + r)),
            t.copyWithin(i, o, o + r),
            t.set(s, o)
        }
    }
    static _unpremultiplyAlpha(t) {
        t instanceof Uint8ClampedArray && (t = new Uint8Array(t.buffer));
        const e = t.length;
        for (let n = 0; n < e; n += 4) {
            const e = t[n + 3];
            if (0 !== e) {
                const r = 255.001 / e;
                t[n] = t[n] * r + .5,
                t[n + 1] = t[n + 1] * r + .5,
                t[n + 2] = t[n + 2] * r + .5
            }
        }
    }
}
;
let _C = EC;
_C.extension = {
    name: "extract",
    type: Ub.RendererSystem
},
Wb.add(_C);
const AC = {
    build(t) {
        const e = t.points;
        let n, r, i, s, o, a;
        if (t.type === yv.CIRC) {
            const e = t.shape;
            n = e.x,
            r = e.y,
            o = a = e.radius,
            i = s = 0
        } else if (t.type === yv.ELIP) {
            const e = t.shape;
            n = e.x,
            r = e.y,
            o = e.width,
            a = e.height,
            i = s = 0
        } else {
            const e = t.shape
              , l = e.width / 2
              , c = e.height / 2;
            n = e.x + l,
            r = e.y + c,
            o = a = Math.max(0, Math.min(e.radius, Math.min(l, c))),
            i = l - o,
            s = c - a
        }
        if (!(o >= 0 && a >= 0 && i >= 0 && s >= 0))
            return void (e.length = 0);
        const l = Math.ceil(2.3 * Math.sqrt(o + a))
          , c = 8 * l + (i ? 4 : 0) + (s ? 4 : 0);
        if (e.length = c,
        0 === c)
            return;
        if (0 === l)
            return e.length = 8,
            e[0] = e[6] = n + i,
            e[1] = e[3] = r + s,
            e[2] = e[4] = n - i,
            void (e[5] = e[7] = r - s);
        let u = 0
          , h = 4 * l + (i ? 2 : 0) + 2
          , d = h
          , f = c;
        {
            const t = i + o
              , a = s
              , l = n + t
              , c = n - t
              , p = r + a;
            if (e[u++] = l,
            e[u++] = p,
            e[--h] = p,
            e[--h] = c,
            s) {
                const t = r - a;
                e[d++] = c,
                e[d++] = t,
                e[--f] = t,
                e[--f] = l
            }
        }
        for (let t = 1; t < l; t++) {
            const c = Math.PI / 2 * (t / l)
              , p = i + Math.cos(c) * o
              , m = s + Math.sin(c) * a
              , g = n + p
              , y = n - p
              , b = r + m
              , v = r - m;
            e[u++] = g,
            e[u++] = b,
            e[--h] = b,
            e[--h] = y,
            e[d++] = y,
            e[d++] = v,
            e[--f] = v,
            e[--f] = g
        }
        {
            const t = s + a
              , o = n + i
              , l = n - i
              , c = r + t
              , h = r - t;
            e[u++] = o,
            e[u++] = c,
            e[--f] = h,
            e[--f] = o,
            i && (e[u++] = l,
            e[u++] = c,
            e[--f] = h,
            e[--f] = l)
        }
    },
    triangulate(t, e) {
        const n = t.points
          , r = e.points
          , i = e.indices;
        if (0 === n.length)
            return;
        let s = r.length / 2;
        const o = s;
        let a, l;
        if (t.type !== yv.RREC) {
            const e = t.shape;
            a = e.x,
            l = e.y
        } else {
            const e = t.shape;
            a = e.x + e.width / 2,
            l = e.y + e.height / 2
        }
        const c = t.matrix;
        r.push(t.matrix ? c.a * a + c.c * l + c.tx : a, t.matrix ? c.b * a + c.d * l + c.ty : l),
        s++,
        r.push(n[0], n[1]);
        for (let t = 2; t < n.length; t += 2)
            r.push(n[t], n[t + 1]),
            i.push(s++, o, s);
        i.push(o + 1, o, s)
    }
};
function SC(t, e=!1) {
    const n = t.length;
    if (n < 6)
        return;
    let r = 0;
    for (let e = 0, i = t[n - 2], s = t[n - 1]; e < n; e += 2) {
        const n = t[e]
          , o = t[e + 1];
        r += (n - i) * (o + s),
        i = n,
        s = o
    }
    if (!e && r > 0 || e && r <= 0) {
        const e = n / 2;
        for (let r = e + e % 2; r < n; r += 2) {
            const e = n - r - 2
              , i = n - r - 1
              , s = r
              , o = r + 1;
            [t[e],t[s]] = [t[s], t[e]],
            [t[i],t[o]] = [t[o], t[i]]
        }
    }
}
const TC = {
    build(t) {
        t.points = t.shape.points.slice()
    },
    triangulate(t, e) {
        let n = t.points;
        const r = t.holes
          , i = e.points
          , s = e.indices;
        if (n.length >= 6) {
            SC(n, !1);
            const t = [];
            for (let e = 0; e < r.length; e++) {
                const i = r[e];
                SC(i.points, !0),
                t.push(n.length / 2),
                n = n.concat(i.points)
            }
            const e = fg.earcut(n, t, 2);
            if (!e)
                return;
            const o = i.length / 2;
            for (let t = 0; t < e.length; t += 3)
                s.push(e[t] + o),
                s.push(e[t + 1] + o),
                s.push(e[t + 2] + o);
            for (let t = 0; t < n.length; t++)
                i.push(n[t])
        }
    }
}
  , kC = {
    build(t) {
        const e = t.shape
          , n = e.x
          , r = e.y
          , i = e.width
          , s = e.height
          , o = t.points;
        o.length = 0,
        i >= 0 && s >= 0 && o.push(n, r, n + i, r, n + i, r + s, n, r + s)
    },
    triangulate(t, e) {
        const n = t.points
          , r = e.points;
        if (0 === n.length)
            return;
        const i = r.length / 2;
        r.push(n[0], n[1], n[2], n[3], n[6], n[7], n[4], n[5]),
        e.indices.push(i, i + 1, i + 2, i + 1, i + 2, i + 3)
    }
}
  , IC = {
    build(t) {
        AC.build(t)
    },
    triangulate(t, e) {
        AC.triangulate(t, e)
    }
};
var MC = (t=>(t.MITER = "miter",
t.BEVEL = "bevel",
t.ROUND = "round",
t))(MC || {})
  , CC = (t=>(t.BUTT = "butt",
t.ROUND = "round",
t.SQUARE = "square",
t))(CC || {});
const PC = {
    adaptive: !0,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(t, e=20) {
        if (!this.adaptive || !t || isNaN(t))
            return e;
        let n = Math.ceil(t / this.maxLength);
        return n < this.minSegments ? n = this.minSegments : n > this.maxSegments && (n = this.maxSegments),
        n
    }
};
class OC {
    static curveTo(t, e, n, r, i, s) {
        const o = s[s.length - 2]
          , a = s[s.length - 1] - e
          , l = o - t
          , c = r - e
          , u = n - t
          , h = Math.abs(a * u - l * c);
        if (h < 1e-8 || 0 === i)
            return s[s.length - 2] === t && s[s.length - 1] === e || s.push(t, e),
            null;
        const d = a * a + l * l
          , f = c * c + u * u
          , p = a * c + l * u
          , m = i * Math.sqrt(d) / h
          , g = i * Math.sqrt(f) / h
          , y = m * p / d
          , b = g * p / f
          , v = m * u + g * l
          , w = m * c + g * a
          , x = l * (g + y)
          , E = a * (g + y)
          , _ = u * (m + b)
          , A = c * (m + b);
        return {
            cx: v + t,
            cy: w + e,
            radius: i,
            startAngle: Math.atan2(E - w, x - v),
            endAngle: Math.atan2(A - w, _ - v),
            anticlockwise: l * c > u * a
        }
    }
    static arc(t, e, n, r, i, s, o, a, l) {
        const c = o - s
          , u = PC._segmentsCount(Math.abs(c) * i, 40 * Math.ceil(Math.abs(c) / pv))
          , h = c / (2 * u)
          , d = 2 * h
          , f = Math.cos(h)
          , p = Math.sin(h)
          , m = u - 1
          , g = m % 1 / m;
        for (let t = 0; t <= m; ++t) {
            const e = h + s + d * (t + g * t)
              , o = Math.cos(e)
              , a = -Math.sin(e);
            l.push((f * o + p * a) * i + n, (f * -a + p * o) * i + r)
        }
    }
}
class NC {
    constructor() {
        this.reset()
    }
    begin(t, e, n) {
        this.reset(),
        this.style = t,
        this.start = e,
        this.attribStart = n
    }
    end(t, e) {
        this.attribSize = e - this.attribStart,
        this.size = t - this.start
    }
    reset() {
        this.style = null,
        this.size = 0,
        this.start = 0,
        this.attribStart = 0,
        this.attribSize = 0
    }
}
class RC {
    static curveLength(t, e, n, r, i, s, o, a) {
        let l = 0
          , c = 0
          , u = 0
          , h = 0
          , d = 0
          , f = 0
          , p = 0
          , m = 0
          , g = 0
          , y = 0
          , b = 0
          , v = t
          , w = e;
        for (let x = 1; x <= 10; ++x)
            c = x / 10,
            u = c * c,
            h = u * c,
            d = 1 - c,
            f = d * d,
            p = f * d,
            m = p * t + 3 * f * c * n + 3 * d * u * i + h * o,
            g = p * e + 3 * f * c * r + 3 * d * u * s + h * a,
            y = v - m,
            b = w - g,
            v = m,
            w = g,
            l += Math.sqrt(y * y + b * b);
        return l
    }
    static curveTo(t, e, n, r, i, s, o) {
        const a = o[o.length - 2]
          , l = o[o.length - 1];
        o.length -= 2;
        const c = PC._segmentsCount(RC.curveLength(a, l, t, e, n, r, i, s));
        let u = 0
          , h = 0
          , d = 0
          , f = 0
          , p = 0;
        o.push(a, l);
        for (let m = 1, g = 0; m <= c; ++m)
            g = m / c,
            u = 1 - g,
            h = u * u,
            d = h * u,
            f = g * g,
            p = f * g,
            o.push(d * a + 3 * h * g * t + 3 * u * f * n + p * i, d * l + 3 * h * g * e + 3 * u * f * r + p * s)
    }
}
function DC(t, e, n, r, i, s, o, a) {
    let l, c;
    o ? (l = r,
    c = -n) : (l = -r,
    c = n);
    const u = t - n * i + l
      , h = e - r * i + c
      , d = t + n * s + l
      , f = e + r * s + c;
    return a.push(u, h, d, f),
    2
}
function BC(t, e, n, r, i, s, o, a) {
    const l = n - t
      , c = r - e;
    let u = Math.atan2(l, c)
      , h = Math.atan2(i - t, s - e);
    a && u < h ? u += 2 * Math.PI : !a && u > h && (h += 2 * Math.PI);
    let d = u;
    const f = h - u
      , p = Math.abs(f)
      , m = Math.sqrt(l * l + c * c)
      , g = 1 + (15 * p * Math.sqrt(m) / Math.PI >> 0)
      , y = f / g;
    if (d += y,
    a) {
        o.push(t, e, n, r);
        for (let n = 1, r = d; n < g; n++,
        r += y)
            o.push(t, e, t + Math.sin(r) * m, e + Math.cos(r) * m);
        o.push(t, e, i, s)
    } else {
        o.push(n, r, t, e);
        for (let n = 1, r = d; n < g; n++,
        r += y)
            o.push(t + Math.sin(r) * m, e + Math.cos(r) * m, t, e);
        o.push(i, s, t, e)
    }
    return 2 * g
}
function LC(t, e) {
    t.lineStyle.native ? function(t, e) {
        let n = 0;
        const r = t.shape
          , i = t.points || r.points
          , s = r.type !== yv.POLY || r.closeStroke;
        if (0 === i.length)
            return;
        const o = e.points
          , a = e.indices
          , l = i.length / 2
          , c = o.length / 2;
        let u = c;
        for (o.push(i[0], i[1]),
        n = 1; n < l; n++)
            o.push(i[2 * n], i[2 * n + 1]),
            a.push(u, u + 1),
            u++;
        s && a.push(u, c)
    }(t, e) : function(t, e) {
        const n = t.shape;
        let r = t.points || n.points.slice();
        const i = e.closePointEps;
        if (0 === r.length)
            return;
        const s = t.lineStyle
          , o = new bv(r[0],r[1])
          , a = new bv(r[r.length - 2],r[r.length - 1])
          , l = n.type !== yv.POLY || n.closeStroke
          , c = Math.abs(o.x - a.x) < i && Math.abs(o.y - a.y) < i;
        if (l) {
            r = r.slice(),
            c && (r.pop(),
            r.pop(),
            a.set(r[r.length - 2], r[r.length - 1]));
            const t = .5 * (o.x + a.x)
              , e = .5 * (a.y + o.y);
            r.unshift(t, e),
            r.push(t, e)
        }
        const u = e.points
          , h = r.length / 2;
        let d = r.length;
        const f = u.length / 2
          , p = s.width / 2
          , m = p * p
          , g = s.miterLimit * s.miterLimit;
        let y = r[0]
          , b = r[1]
          , v = r[2]
          , w = r[3]
          , x = 0
          , E = 0
          , _ = -(b - w)
          , A = y - v
          , S = 0
          , T = 0
          , k = Math.sqrt(_ * _ + A * A);
        _ /= k,
        A /= k,
        _ *= p,
        A *= p;
        const I = s.alignment
          , M = 2 * (1 - I)
          , C = 2 * I;
        l || (s.cap === CC.ROUND ? d += BC(y - _ * (M - C) * .5, b - A * (M - C) * .5, y - _ * M, b - A * M, y + _ * C, b + A * C, u, !0) + 2 : s.cap === CC.SQUARE && (d += DC(y, b, _, A, M, C, !0, u))),
        u.push(y - _ * M, b - A * M, y + _ * C, b + A * C);
        for (let t = 1; t < h - 1; ++t) {
            y = r[2 * (t - 1)],
            b = r[2 * (t - 1) + 1],
            v = r[2 * t],
            w = r[2 * t + 1],
            x = r[2 * (t + 1)],
            E = r[2 * (t + 1) + 1],
            _ = -(b - w),
            A = y - v,
            k = Math.sqrt(_ * _ + A * A),
            _ /= k,
            A /= k,
            _ *= p,
            A *= p,
            S = -(w - E),
            T = v - x,
            k = Math.sqrt(S * S + T * T),
            S /= k,
            T /= k,
            S *= p,
            T *= p;
            const e = v - y
              , n = b - w
              , i = v - x
              , o = E - w
              , a = e * i + n * o
              , l = n * i - o * e
              , c = l < 0;
            if (Math.abs(l) < .001 * Math.abs(a)) {
                u.push(v - _ * M, w - A * M, v + _ * C, w + A * C),
                a >= 0 && (s.join === MC.ROUND ? d += BC(v, w, v - _ * M, w - A * M, v - S * M, w - T * M, u, !1) + 4 : d += 2,
                u.push(v - S * C, w - T * C, v + S * M, w + T * M));
                continue
            }
            const h = (-_ + y) * (-A + w) - (-_ + v) * (-A + b)
              , f = (-S + x) * (-T + w) - (-S + v) * (-T + E)
              , I = (e * f - i * h) / l
              , P = (o * h - n * f) / l
              , O = (I - v) * (I - v) + (P - w) * (P - w)
              , N = v + (I - v) * M
              , R = w + (P - w) * M
              , D = v - (I - v) * C
              , B = w - (P - w) * C
              , L = c ? M : C
              , F = O <= Math.min(e * e + n * n, i * i + o * o) + L * L * m;
            let j = s.join;
            if (j === MC.MITER && O / m > g && (j = MC.BEVEL),
            F)
                switch (j) {
                case MC.MITER:
                    u.push(N, R, D, B);
                    break;
                case MC.BEVEL:
                    c ? u.push(N, R, v + _ * C, w + A * C, N, R, v + S * C, w + T * C) : u.push(v - _ * M, w - A * M, D, B, v - S * M, w - T * M, D, B),
                    d += 2;
                    break;
                case MC.ROUND:
                    c ? (u.push(N, R, v + _ * C, w + A * C),
                    d += BC(v, w, v + _ * C, w + A * C, v + S * C, w + T * C, u, !0) + 4,
                    u.push(N, R, v + S * C, w + T * C)) : (u.push(v - _ * M, w - A * M, D, B),
                    d += BC(v, w, v - _ * M, w - A * M, v - S * M, w - T * M, u, !1) + 4,
                    u.push(v - S * M, w - T * M, D, B))
                }
            else {
                switch (u.push(v - _ * M, w - A * M, v + _ * C, w + A * C),
                j) {
                case MC.MITER:
                    c ? u.push(D, B, D, B) : u.push(N, R, N, R),
                    d += 2;
                    break;
                case MC.ROUND:
                    d += c ? BC(v, w, v + _ * C, w + A * C, v + S * C, w + T * C, u, !0) + 2 : BC(v, w, v - _ * M, w - A * M, v - S * M, w - T * M, u, !1) + 2
                }
                u.push(v - S * M, w - T * M, v + S * C, w + T * C),
                d += 2
            }
        }
        y = r[2 * (h - 2)],
        b = r[2 * (h - 2) + 1],
        v = r[2 * (h - 1)],
        w = r[2 * (h - 1) + 1],
        _ = -(b - w),
        A = y - v,
        k = Math.sqrt(_ * _ + A * A),
        _ /= k,
        A /= k,
        _ *= p,
        A *= p,
        u.push(v - _ * M, w - A * M, v + _ * C, w + A * C),
        l || (s.cap === CC.ROUND ? d += BC(v - _ * (M - C) * .5, w - A * (M - C) * .5, v - _ * M, w - A * M, v + _ * C, w + A * C, u, !1) + 2 : s.cap === CC.SQUARE && (d += DC(v, w, _, A, M, C, !1, u)));
        const P = e.indices
          , O = PC.epsilon * PC.epsilon;
        for (let t = f; t < d + f - 2; ++t)
            y = u[2 * t],
            b = u[2 * t + 1],
            v = u[2 * (t + 1)],
            w = u[2 * (t + 1) + 1],
            x = u[2 * (t + 2)],
            E = u[2 * (t + 2) + 1],
            Math.abs(y * (w - E) + v * (E - b) + x * (b - w)) < O || P.push(t, t + 1, t + 2)
    }(t, e)
}
class FC {
    static curveLength(t, e, n, r, i, s) {
        const o = t - 2 * n + i
          , a = e - 2 * r + s
          , l = 2 * n - 2 * t
          , c = 2 * r - 2 * e
          , u = 4 * (o * o + a * a)
          , h = 4 * (o * l + a * c)
          , d = l * l + c * c
          , f = 2 * Math.sqrt(u + h + d)
          , p = Math.sqrt(u)
          , m = 2 * u * p
          , g = 2 * Math.sqrt(d)
          , y = h / p;
        return (m * f + p * h * (f - g) + (4 * d * u - h * h) * Math.log((2 * p + y + f) / (y + g))) / (4 * m)
    }
    static curveTo(t, e, n, r, i) {
        const s = i[i.length - 2]
          , o = i[i.length - 1]
          , a = PC._segmentsCount(FC.curveLength(s, o, t, e, n, r));
        let l = 0
          , c = 0;
        for (let u = 1; u <= a; ++u) {
            const h = u / a;
            l = s + (t - s) * h,
            c = o + (e - o) * h,
            i.push(l + (t + (n - t) * h - l) * h, c + (e + (r - e) * h - c) * h)
        }
    }
}
const jC = {
    [yv.POLY]: TC,
    [yv.CIRC]: AC,
    [yv.ELIP]: AC,
    [yv.RECT]: kC,
    [yv.RREC]: IC
}
  , UC = []
  , zC = [];
class VC {
    constructor(t, e=null, n=null, r=null) {
        this.points = [],
        this.holes = [],
        this.shape = t,
        this.lineStyle = n,
        this.fillStyle = e,
        this.matrix = r,
        this.type = t.type
    }
    clone() {
        return new VC(this.shape,this.fillStyle,this.lineStyle,this.matrix)
    }
    destroy() {
        this.shape = null,
        this.holes.length = 0,
        this.holes = null,
        this.points.length = 0,
        this.points = null,
        this.lineStyle = null,
        this.fillStyle = null
    }
}
const WC = new bv
  , YC = class extends fv {
    constructor() {
        super(),
        this.closePointEps = 1e-4,
        this.boundsPadding = 0,
        this.uvsFloat32 = null,
        this.indicesUint16 = null,
        this.batchable = !1,
        this.points = [],
        this.colors = [],
        this.uvs = [],
        this.indices = [],
        this.textureIds = [],
        this.graphicsData = [],
        this.drawCalls = [],
        this.batchDirty = -1,
        this.batches = [],
        this.dirty = 0,
        this.cacheDirty = -1,
        this.clearDirty = 0,
        this.shapeIndex = 0,
        this._bounds = new gI,
        this.boundsDirty = -1
    }
    get bounds() {
        return this.updateBatches(),
        this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty,
        this.calculateBounds()),
        this._bounds
    }
    invalidate() {
        this.boundsDirty = -1,
        this.dirty++,
        this.batchDirty++,
        this.shapeIndex = 0,
        this.points.length = 0,
        this.colors.length = 0,
        this.uvs.length = 0,
        this.indices.length = 0,
        this.textureIds.length = 0;
        for (let t = 0; t < this.drawCalls.length; t++)
            this.drawCalls[t].texArray.clear(),
            zC.push(this.drawCalls[t]);
        this.drawCalls.length = 0;
        for (let t = 0; t < this.batches.length; t++) {
            const e = this.batches[t];
            e.reset(),
            UC.push(e)
        }
        this.batches.length = 0
    }
    clear() {
        return this.graphicsData.length > 0 && (this.invalidate(),
        this.clearDirty++,
        this.graphicsData.length = 0),
        this
    }
    drawShape(t, e=null, n=null, r=null) {
        const i = new VC(t,e,n,r);
        return this.graphicsData.push(i),
        this.dirty++,
        this
    }
    drawHole(t, e=null) {
        if (!this.graphicsData.length)
            return null;
        const n = new VC(t,null,null,e)
          , r = this.graphicsData[this.graphicsData.length - 1];
        return n.lineStyle = r.lineStyle,
        r.holes.push(n),
        this.dirty++,
        this
    }
    destroy() {
        super.destroy();
        for (let t = 0; t < this.graphicsData.length; ++t)
            this.graphicsData[t].destroy();
        this.points.length = 0,
        this.points = null,
        this.colors.length = 0,
        this.colors = null,
        this.uvs.length = 0,
        this.uvs = null,
        this.indices.length = 0,
        this.indices = null,
        this.indexBuffer.destroy(),
        this.indexBuffer = null,
        this.graphicsData.length = 0,
        this.graphicsData = null,
        this.drawCalls.length = 0,
        this.drawCalls = null,
        this.batches.length = 0,
        this.batches = null,
        this._bounds = null
    }
    containsPoint(t) {
        const e = this.graphicsData;
        for (let n = 0; n < e.length; ++n) {
            const r = e[n];
            if (r.fillStyle.visible && (r.shape && (r.matrix ? r.matrix.applyInverse(t, WC) : WC.copyFrom(t),
            r.shape.contains(WC.x, WC.y)))) {
                let t = !1;
                if (r.holes)
                    for (let e = 0; e < r.holes.length; e++) {
                        if (r.holes[e].shape.contains(WC.x, WC.y)) {
                            t = !0;
                            break
                        }
                    }
                if (!t)
                    return !0
            }
        }
        return !1
    }
    updateBatches() {
        if (!this.graphicsData.length)
            return void (this.batchable = !0);
        if (!this.validateBatching())
            return;
        this.cacheDirty = this.dirty;
        const t = this.uvs
          , e = this.graphicsData;
        let n = null
          , r = null;
        this.batches.length > 0 && (n = this.batches[this.batches.length - 1],
        r = n.style);
        for (let i = this.shapeIndex; i < e.length; i++) {
            this.shapeIndex++;
            const s = e[i]
              , o = s.fillStyle
              , a = s.lineStyle;
            jC[s.type].build(s),
            s.matrix && this.transformPoints(s.points, s.matrix),
            (o.visible || a.visible) && this.processHoles(s.holes);
            for (let e = 0; e < 2; e++) {
                const i = 0 === e ? o : a;
                if (!i.visible)
                    continue;
                const l = i.texture.baseTexture
                  , c = this.indices.length
                  , u = this.points.length / 2;
                l.wrapMode = jm.REPEAT,
                0 === e ? this.processFill(s) : this.processLine(s);
                const h = this.points.length / 2 - u;
                0 !== h && (n && !this._compareStyles(r, i) && (n.end(c, u),
                n = null),
                n || (n = UC.pop() || new NC,
                n.begin(i, c, u),
                this.batches.push(n),
                r = i),
                this.addUvs(this.points, t, i.texture, u, h, i.matrix))
            }
        }
        const i = this.indices.length
          , s = this.points.length / 2;
        if (n && n.end(i, s),
        0 === this.batches.length)
            return void (this.batchable = !0);
        const o = s > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && o === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = o ? new Uint32Array(this.indices) : new Uint16Array(this.indices),
        this.batchable = this.isBatchable(),
        this.batchable ? this.packBatches() : this.buildDrawCalls()
    }
    _compareStyles(t, e) {
        return !(!t || !e) && (t.texture.baseTexture === e.texture.baseTexture && (t.color + t.alpha === e.color + e.alpha && !!t.native == !!e.native))
    }
    validateBatching() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length)
            return !1;
        for (let t = 0, e = this.graphicsData.length; t < e; t++) {
            const e = this.graphicsData[t]
              , n = e.fillStyle
              , r = e.lineStyle;
            if (n && !n.texture.baseTexture.valid)
                return !1;
            if (r && !r.texture.baseTexture.valid)
                return !1
        }
        return !0
    }
    packBatches() {
        this.batchDirty++,
        this.uvsFloat32 = new Float32Array(this.uvs);
        const t = this.batches;
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            for (let t = 0; t < n.size; t++) {
                const e = n.start + t;
                this.indicesUint16[e] = this.indicesUint16[e] - n.attribStart
            }
        }
    }
    isBatchable() {
        if (this.points.length > 131070)
            return !1;
        const t = this.batches;
        for (let e = 0; e < t.length; e++)
            if (t[e].style.native)
                return !1;
        return this.points.length < 2 * YC.BATCHABLE_SIZE
    }
    buildDrawCalls() {
        let t = ++nv._globalBatch;
        for (let t = 0; t < this.drawCalls.length; t++)
            this.drawCalls[t].texArray.clear(),
            zC.push(this.drawCalls[t]);
        this.drawCalls.length = 0;
        const e = this.colors
          , n = this.textureIds;
        let r = zC.pop();
        r || (r = new rv,
        r.texArray = new fw),
        r.texArray.count = 0,
        r.start = 0,
        r.size = 0,
        r.type = Nm.TRIANGLES;
        let i = 0
          , s = null
          , o = 0
          , a = !1
          , l = Nm.TRIANGLES
          , c = 0;
        this.drawCalls.push(r);
        for (let u = 0; u < this.batches.length; u++) {
            const h = this.batches[u]
              , d = 8
              , f = h.style
              , p = f.texture.baseTexture;
            a !== !!f.native && (a = !!f.native,
            l = a ? Nm.LINES : Nm.TRIANGLES,
            s = null,
            i = d,
            t++),
            s !== p && (s = p,
            p._batchEnabled !== t && (i === d && (t++,
            i = 0,
            r.size > 0 && (r = zC.pop(),
            r || (r = new rv,
            r.texArray = new fw),
            this.drawCalls.push(r)),
            r.start = c,
            r.size = 0,
            r.texArray.count = 0,
            r.type = l),
            p.touched = 1,
            p._batchEnabled = t,
            p._batchLocation = i,
            p.wrapMode = jm.REPEAT,
            r.texArray.elements[r.texArray.count++] = p,
            i++)),
            r.size += h.size,
            c += h.size,
            o = p._batchLocation,
            this.addColors(e, f.color, f.alpha, h.attribSize, h.attribStart),
            this.addTextureIds(n, o, h.attribSize, h.attribStart)
        }
        nv._globalBatch = t,
        this.packAttributes()
    }
    packAttributes() {
        const t = this.points
          , e = this.uvs
          , n = this.colors
          , r = this.textureIds
          , i = new ArrayBuffer(12 * t.length)
          , s = new Float32Array(i)
          , o = new Uint32Array(i);
        let a = 0;
        for (let i = 0; i < t.length / 2; i++)
            s[a++] = t[2 * i],
            s[a++] = t[2 * i + 1],
            s[a++] = e[2 * i],
            s[a++] = e[2 * i + 1],
            o[a++] = n[i],
            s[a++] = r[i];
        this._buffer.update(i),
        this._indexBuffer.update(this.indicesUint16)
    }
    processFill(t) {
        if (t.holes.length)
            TC.triangulate(t, this);
        else {
            jC[t.type].triangulate(t, this)
        }
    }
    processLine(t) {
        LC(t, this);
        for (let e = 0; e < t.holes.length; e++)
            LC(t.holes[e], this)
    }
    processHoles(t) {
        for (let e = 0; e < t.length; e++) {
            const n = t[e];
            jC[n.type].build(n),
            n.matrix && this.transformPoints(n.points, n.matrix)
        }
    }
    calculateBounds() {
        const t = this._bounds;
        t.clear(),
        t.addVertexData(this.points, 0, this.points.length),
        t.pad(this.boundsPadding, this.boundsPadding)
    }
    transformPoints(t, e) {
        for (let n = 0; n < t.length / 2; n++) {
            const r = t[2 * n]
              , i = t[2 * n + 1];
            t[2 * n] = e.a * r + e.c * i + e.tx,
            t[2 * n + 1] = e.b * r + e.d * i + e.ty
        }
    }
    addColors(t, e, n, r, i=0) {
        const s = nb.shared.setValue(e).toLittleEndianNumber()
          , o = nb.shared.setValue(s).toPremultiplied(n);
        t.length = Math.max(t.length, i + r);
        for (let e = 0; e < r; e++)
            t[i + e] = o
    }
    addTextureIds(t, e, n, r=0) {
        t.length = Math.max(t.length, r + n);
        for (let i = 0; i < n; i++)
            t[r + i] = e
    }
    addUvs(t, e, n, r, i, s=null) {
        let o = 0;
        const a = e.length
          , l = n.frame;
        for (; o < i; ) {
            let n = t[2 * (r + o)]
              , i = t[2 * (r + o) + 1];
            if (s) {
                const t = s.a * n + s.c * i + s.tx;
                i = s.b * n + s.d * i + s.ty,
                n = t
            }
            o++,
            e.push(n / l.width, i / l.height)
        }
        const c = n.baseTexture;
        (l.width < c.width || l.height < c.height) && this.adjustUvs(e, n, a, i)
    }
    adjustUvs(t, e, n, r) {
        const i = e.baseTexture
          , s = 1e-6
          , o = n + 2 * r
          , a = e.frame
          , l = a.width / i.width
          , c = a.height / i.height;
        let u = a.x / a.width
          , h = a.y / a.height
          , d = Math.floor(t[n] + s)
          , f = Math.floor(t[n + 1] + s);
        for (let e = n + 2; e < o; e += 2)
            d = Math.min(d, Math.floor(t[e] + s)),
            f = Math.min(f, Math.floor(t[e + 1] + s));
        u -= d,
        h -= f;
        for (let e = n; e < o; e += 2)
            t[e] = (t[e] + u) * l,
            t[e + 1] = (t[e + 1] + h) * c
    }
}
;
let HC = YC;
HC.BATCHABLE_SIZE = 100;
class $C {
    constructor() {
        this.color = 16777215,
        this.alpha = 1,
        this.texture = Ow.WHITE,
        this.matrix = null,
        this.visible = !1,
        this.reset()
    }
    clone() {
        const t = new $C;
        return t.color = this.color,
        t.alpha = this.alpha,
        t.texture = this.texture,
        t.matrix = this.matrix,
        t.visible = this.visible,
        t
    }
    reset() {
        this.color = 16777215,
        this.alpha = 1,
        this.texture = Ow.WHITE,
        this.matrix = null,
        this.visible = !1
    }
    destroy() {
        this.texture = null,
        this.matrix = null
    }
}
class GC extends $C {
    constructor() {
        super(...arguments),
        this.width = 0,
        this.alignment = .5,
        this.native = !1,
        this.cap = CC.BUTT,
        this.join = MC.MITER,
        this.miterLimit = 10
    }
    clone() {
        const t = new GC;
        return t.color = this.color,
        t.alpha = this.alpha,
        t.texture = this.texture,
        t.matrix = this.matrix,
        t.visible = this.visible,
        t.width = this.width,
        t.alignment = this.alignment,
        t.native = this.native,
        t.cap = this.cap,
        t.join = this.join,
        t.miterLimit = this.miterLimit,
        t
    }
    reset() {
        super.reset(),
        this.color = 0,
        this.alignment = .5,
        this.width = 0,
        this.native = !1
    }
}
const XC = {}
  , qC = class extends EI {
    constructor(t=null) {
        super(),
        this.shader = null,
        this.pluginName = "batch",
        this.currentPath = null,
        this.batches = [],
        this.batchTint = -1,
        this.batchDirty = -1,
        this.vertexData = null,
        this._fillStyle = new $C,
        this._lineStyle = new GC,
        this._matrix = null,
        this._holeMode = !1,
        this.state = Xb.for2d(),
        this._geometry = t || new HC,
        this._geometry.refCount++,
        this._transformID = -1,
        this._tintColor = new nb(16777215),
        this.blendMode = Om.NORMAL
    }
    get geometry() {
        return this._geometry
    }
    clone() {
        return this.finishPoly(),
        new qC(this._geometry)
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get blendMode() {
        return this.state.blendMode
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        this._tintColor.setValue(t)
    }
    get fill() {
        return this._fillStyle
    }
    get line() {
        return this._lineStyle
    }
    lineStyle(t=null, e=0, n, r=.5, i=!1) {
        return "number" == typeof t && (t = {
            width: t,
            color: e,
            alpha: n,
            alignment: r,
            native: i
        }),
        this.lineTextureStyle(t)
    }
    lineTextureStyle(t) {
        const e = {
            width: 0,
            texture: Ow.WHITE,
            color: t?.texture ? 16777215 : 0,
            matrix: null,
            alignment: .5,
            native: !1,
            cap: CC.BUTT,
            join: MC.MITER,
            miterLimit: 10
        };
        t = Object.assign(e, t),
        this.normalizeColor(t),
        this.currentPath && this.startPoly();
        const n = t.width > 0 && t.alpha > 0;
        return n ? (t.matrix && (t.matrix = t.matrix.clone(),
        t.matrix.invert()),
        Object.assign(this._lineStyle, {
            visible: n
        }, t)) : this._lineStyle.reset(),
        this
    }
    startPoly() {
        if (this.currentPath) {
            const t = this.currentPath.points
              , e = this.currentPath.points.length;
            e > 2 && (this.drawShape(this.currentPath),
            this.currentPath = new _v,
            this.currentPath.closeStroke = !1,
            this.currentPath.points.push(t[e - 2], t[e - 1]))
        } else
            this.currentPath = new _v,
            this.currentPath.closeStroke = !1
    }
    finishPoly() {
        this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath),
        this.currentPath = null) : this.currentPath.points.length = 0)
    }
    moveTo(t, e) {
        return this.startPoly(),
        this.currentPath.points[0] = t,
        this.currentPath.points[1] = e,
        this
    }
    lineTo(t, e) {
        this.currentPath || this.moveTo(0, 0);
        const n = this.currentPath.points
          , r = n[n.length - 2]
          , i = n[n.length - 1];
        return r === t && i === e || n.push(t, e),
        this
    }
    _initCurve(t=0, e=0) {
        this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [t, e]) : this.moveTo(t, e)
    }
    quadraticCurveTo(t, e, n, r) {
        this._initCurve();
        const i = this.currentPath.points;
        return 0 === i.length && this.moveTo(0, 0),
        FC.curveTo(t, e, n, r, i),
        this
    }
    bezierCurveTo(t, e, n, r, i, s) {
        return this._initCurve(),
        RC.curveTo(t, e, n, r, i, s, this.currentPath.points),
        this
    }
    arcTo(t, e, n, r, i) {
        this._initCurve(t, e);
        const s = this.currentPath.points
          , o = OC.curveTo(t, e, n, r, i, s);
        if (o) {
            const {cx: t, cy: e, radius: n, startAngle: r, endAngle: i, anticlockwise: s} = o;
            this.arc(t, e, n, r, i, s)
        }
        return this
    }
    arc(t, e, n, r, i, s=!1) {
        if (r === i)
            return this;
        !s && i <= r ? i += pv : s && r <= i && (r += pv);
        if (0 === i - r)
            return this;
        const o = t + Math.cos(r) * n
          , a = e + Math.sin(r) * n
          , l = this._geometry.closePointEps;
        let c = this.currentPath ? this.currentPath.points : null;
        if (c) {
            const t = Math.abs(c[c.length - 2] - o)
              , e = Math.abs(c[c.length - 1] - a);
            t < l && e < l || c.push(o, a)
        } else
            this.moveTo(o, a),
            c = this.currentPath.points;
        return OC.arc(o, a, t, e, n, r, i, s, c),
        this
    }
    beginFill(t=0, e) {
        return this.beginTextureFill({
            texture: Ow.WHITE,
            color: t,
            alpha: e
        })
    }
    normalizeColor(t) {
        const e = nb.shared.setValue(t.color ?? 0);
        t.color = e.toNumber(),
        t.alpha ?? (t.alpha = e.alpha)
    }
    beginTextureFill(t) {
        const e = {
            texture: Ow.WHITE,
            color: 16777215,
            matrix: null
        };
        t = Object.assign(e, t),
        this.normalizeColor(t),
        this.currentPath && this.startPoly();
        const n = t.alpha > 0;
        return n ? (t.matrix && (t.matrix = t.matrix.clone(),
        t.matrix.invert()),
        Object.assign(this._fillStyle, {
            visible: n
        }, t)) : this._fillStyle.reset(),
        this
    }
    endFill() {
        return this.finishPoly(),
        this._fillStyle.reset(),
        this
    }
    drawRect(t, e, n, r) {
        return this.drawShape(new wv(t,e,n,r))
    }
    drawRoundedRect(t, e, n, r, i) {
        return this.drawShape(new Av(t,e,n,r,i))
    }
    drawCircle(t, e, n) {
        return this.drawShape(new xv(t,e,n))
    }
    drawEllipse(t, e, n, r) {
        return this.drawShape(new Ev(t,e,n,r))
    }
    drawPolygon(...t) {
        let e, n = !0;
        const r = t[0];
        r.points ? (n = r.closeStroke,
        e = r.points) : e = Array.isArray(t[0]) ? t[0] : t;
        const i = new _v(e);
        return i.closeStroke = n,
        this.drawShape(i),
        this
    }
    drawShape(t) {
        return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix),
        this
    }
    clear() {
        return this._geometry.clear(),
        this._lineStyle.reset(),
        this._fillStyle.reset(),
        this._boundsID++,
        this._matrix = null,
        this._holeMode = !1,
        this.currentPath = null,
        this
    }
    isFastRect() {
        const t = this._geometry.graphicsData;
        return !(1 !== t.length || t[0].shape.type !== yv.RECT || t[0].matrix || t[0].holes.length || t[0].lineStyle.visible && t[0].lineStyle.width)
    }
    _render(t) {
        this.finishPoly();
        const e = this._geometry;
        e.updateBatches(),
        e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(),
        this._renderBatched(t)) : (t.batch.flush(),
        this._renderDirect(t))
    }
    _populateBatches() {
        const t = this._geometry
          , e = this.blendMode
          , n = t.batches.length;
        this.batchTint = -1,
        this._transformID = -1,
        this.batchDirty = t.batchDirty,
        this.batches.length = n,
        this.vertexData = new Float32Array(t.points);
        for (let r = 0; r < n; r++) {
            const n = t.batches[r]
              , i = n.style.color
              , s = new Float32Array(this.vertexData.buffer,8 * n.attribStart,2 * n.attribSize)
              , o = new Float32Array(t.uvsFloat32.buffer,8 * n.attribStart,2 * n.attribSize)
              , a = {
                vertexData: s,
                blendMode: e,
                indices: new Uint16Array(t.indicesUint16.buffer,2 * n.start,n.size),
                uvs: o,
                _batchRGB: nb.shared.setValue(i).toRgbArray(),
                _tintRGB: i,
                _texture: n.style.texture,
                alpha: n.style.alpha,
                worldAlpha: 1
            };
            this.batches[r] = a
        }
    }
    _renderBatched(t) {
        if (this.batches.length) {
            t.batch.setObjectRenderer(t.plugins[this.pluginName]),
            this.calculateVertices(),
            this.calculateTints();
            for (let e = 0, n = this.batches.length; e < n; e++) {
                const n = this.batches[e];
                n.worldAlpha = this.worldAlpha * n.alpha,
                t.plugins[this.pluginName].render(n)
            }
        }
    }
    _renderDirect(t) {
        const e = this._resolveDirectShader(t)
          , n = this._geometry
          , r = this.worldAlpha
          , i = e.uniforms
          , s = n.drawCalls;
        i.translationMatrix = this.transform.worldTransform,
        nb.shared.setValue(this._tintColor).premultiply(r).toArray(i.tint),
        t.shader.bind(e),
        t.geometry.bind(n, e),
        t.state.set(this.state);
        for (let e = 0, r = s.length; e < r; e++)
            this._renderDrawCallDirect(t, n.drawCalls[e])
    }
    _renderDrawCallDirect(t, e) {
        const {texArray: n, type: r, size: i, start: s} = e
          , o = n.count;
        for (let e = 0; e < o; e++)
            t.texture.bind(n.elements[e], e);
        t.geometry.draw(r, i, s)
    }
    _resolveDirectShader(t) {
        let e = this.shader;
        const n = this.pluginName;
        if (!e) {
            if (!XC[n]) {
                const {maxTextures: e} = t.plugins[n]
                  , r = new Int32Array(e);
                for (let t = 0; t < e; t++)
                    r[t] = t;
                const i = {
                    tint: new Float32Array([1, 1, 1, 1]),
                    translationMatrix: new Sv,
                    default: uw.from({
                        uSamplers: r
                    }, !0)
                }
                  , s = t.plugins[n]._shader.program;
                XC[n] = new hw(s,i)
            }
            e = XC[n]
        }
        return e
    }
    _calculateBounds() {
        this.finishPoly();
        const t = this._geometry;
        if (!t.graphicsData.length)
            return;
        const {minX: e, minY: n, maxX: r, maxY: i} = t.bounds;
        this._bounds.addFrame(this.transform, e, n, r, i)
    }
    containsPoint(t) {
        return this.worldTransform.applyInverse(t, qC._TEMP_POINT),
        this._geometry.containsPoint(qC._TEMP_POINT)
    }
    calculateTints() {
        if (this.batchTint !== this.tint) {
            this.batchTint = this._tintColor.toNumber();
            for (let t = 0; t < this.batches.length; t++) {
                const e = this.batches[t];
                e._tintRGB = nb.shared.setValue(this._tintColor).multiply(e._batchRGB).toLittleEndianNumber()
            }
        }
    }
    calculateVertices() {
        const t = this.transform._worldID;
        if (this._transformID === t)
            return;
        this._transformID = t;
        const e = this.transform.worldTransform
          , n = e.a
          , r = e.b
          , i = e.c
          , s = e.d
          , o = e.tx
          , a = e.ty
          , l = this._geometry.points
          , c = this.vertexData;
        let u = 0;
        for (let t = 0; t < l.length; t += 2) {
            const e = l[t]
              , h = l[t + 1];
            c[u++] = n * e + i * h + o,
            c[u++] = s * h + r * e + a
        }
    }
    closePath() {
        const t = this.currentPath;
        return t && (t.closeStroke = !0,
        this.finishPoly()),
        this
    }
    setMatrix(t) {
        return this._matrix = t,
        this
    }
    beginHole() {
        return this.finishPoly(),
        this._holeMode = !0,
        this
    }
    endHole() {
        return this.finishPoly(),
        this._holeMode = !1,
        this
    }
    destroy(t) {
        this._geometry.refCount--,
        0 === this._geometry.refCount && this._geometry.dispose(),
        this._matrix = null,
        this.currentPath = null,
        this._lineStyle.destroy(),
        this._lineStyle = null,
        this._fillStyle.destroy(),
        this._fillStyle = null,
        this._geometry = null,
        this.shader = null,
        this.vertexData = null,
        this.batches.length = 0,
        this.batches = null,
        super.destroy(t)
    }
}
;
let KC = qC;
KC.curves = PC,
KC._TEMP_POINT = new bv;
class QC {
    constructor(t, e) {
        this.uvBuffer = t,
        this.uvMatrix = e,
        this.data = null,
        this._bufferUpdateId = -1,
        this._textureUpdateId = -1,
        this._updateID = 0
    }
    update(t) {
        if (!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)
            return;
        this._bufferUpdateId = this.uvBuffer._updateID,
        this._textureUpdateId = this.uvMatrix._updateID;
        const e = this.uvBuffer.data;
        this.data && this.data.length === e.length || (this.data = new Float32Array(e.length)),
        this.uvMatrix.multiplyUvs(e, this.data),
        this._updateID++
    }
}
const ZC = new bv
  , JC = new _v
  , tP = class extends EI {
    constructor(t, e, n, r=Nm.TRIANGLES) {
        super(),
        this.geometry = t,
        this.shader = e,
        this.state = n || Xb.for2d(),
        this.drawMode = r,
        this.start = 0,
        this.size = 0,
        this.uvs = null,
        this.indices = null,
        this.vertexData = new Float32Array(1),
        this.vertexDirty = -1,
        this._transformID = -1,
        this._roundPixels = Xm.ROUND_PIXELS,
        this.batchUvs = null
    }
    get geometry() {
        return this._geometry
    }
    set geometry(t) {
        this._geometry !== t && (this._geometry && (this._geometry.refCount--,
        0 === this._geometry.refCount && this._geometry.dispose()),
        this._geometry = t,
        this._geometry && this._geometry.refCount++,
        this.vertexDirty = -1)
    }
    get uvBuffer() {
        return this.geometry.buffers[1]
    }
    get verticesBuffer() {
        return this.geometry.buffers[0]
    }
    set material(t) {
        this.shader = t
    }
    get material() {
        return this.shader
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get blendMode() {
        return this.state.blendMode
    }
    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1),
        this._roundPixels = t
    }
    get roundPixels() {
        return this._roundPixels
    }
    get tint() {
        return "tint"in this.shader ? this.shader.tint : null
    }
    set tint(t) {
        this.shader.tint = t
    }
    get tintValue() {
        return this.shader.tintValue
    }
    get texture() {
        return "texture"in this.shader ? this.shader.texture : null
    }
    set texture(t) {
        this.shader.texture = t
    }
    _render(t) {
        const e = this.geometry.buffers[0].data;
        this.shader.batchable && this.drawMode === Nm.TRIANGLES && e.length < 2 * tP.BATCHABLE_SIZE ? this._renderToBatch(t) : this._renderDefault(t)
    }
    _renderDefault(t) {
        const e = this.shader;
        e.alpha = this.worldAlpha,
        e.update && e.update(),
        t.batch.flush(),
        e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0),
        t.shader.bind(e),
        t.state.set(this.state),
        t.geometry.bind(this.geometry, e),
        t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
    }
    _renderToBatch(t) {
        const e = this.geometry
          , n = this.shader;
        n.uvMatrix && (n.uvMatrix.update(),
        this.calculateUvs()),
        this.calculateVertices(),
        this.indices = e.indexBuffer.data,
        this._tintRGB = n._tintRGB,
        this._texture = n.texture;
        const r = this.material.pluginName;
        t.batch.setObjectRenderer(t.plugins[r]),
        t.plugins[r].render(this)
    }
    calculateVertices() {
        const t = this.geometry.buffers[0]
          , e = t.data
          , n = t._updateID;
        if (n === this.vertexDirty && this._transformID === this.transform._worldID)
            return;
        this._transformID = this.transform._worldID,
        this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length));
        const r = this.transform.worldTransform
          , i = r.a
          , s = r.b
          , o = r.c
          , a = r.d
          , l = r.tx
          , c = r.ty
          , u = this.vertexData;
        for (let t = 0; t < u.length / 2; t++) {
            const n = e[2 * t]
              , r = e[2 * t + 1];
            u[2 * t] = i * n + o * r + l,
            u[2 * t + 1] = s * n + a * r + c
        }
        if (this._roundPixels) {
            const t = Xm.RESOLUTION;
            for (let e = 0; e < u.length; ++e)
                u[e] = Math.round(u[e] * t) / t
        }
        this.vertexDirty = n
    }
    calculateUvs() {
        const t = this.geometry.buffers[1]
          , e = this.shader;
        e.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new QC(t,e.uvMatrix)),
        this.batchUvs.update(),
        this.uvs = this.batchUvs.data)
    }
    _calculateBounds() {
        this.calculateVertices(),
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
    }
    containsPoint(t) {
        if (!this.getBounds().contains(t.x, t.y))
            return !1;
        this.worldTransform.applyInverse(t, ZC);
        const e = this.geometry.getBuffer("aVertexPosition").data
          , n = JC.points
          , r = this.geometry.getIndex().data
          , i = r.length
          , s = 4 === this.drawMode ? 3 : 1;
        for (let t = 0; t + 2 < i; t += s) {
            const i = 2 * r[t]
              , s = 2 * r[t + 1]
              , o = 2 * r[t + 2];
            if (n[0] = e[i],
            n[1] = e[i + 1],
            n[2] = e[s],
            n[3] = e[s + 1],
            n[4] = e[o],
            n[5] = e[o + 1],
            JC.contains(ZC.x, ZC.y))
                return !0
        }
        return !1
    }
    destroy(t) {
        super.destroy(t),
        this._cachedTexture && (this._cachedTexture.destroy(),
        this._cachedTexture = null),
        this.geometry = null,
        this.shader = null,
        this.state = null,
        this.uvs = null,
        this.indices = null,
        this.vertexData = null
    }
}
;
let eP = tP;
eP.BATCHABLE_SIZE = 100;
class nP extends dv {
    constructor(t, e, n) {
        super();
        const r = new sv(t)
          , i = new sv(e,!0)
          , s = new sv(n,!0,!0);
        this.addAttribute("aVertexPosition", r, 2, !1, Bm.FLOAT).addAttribute("aTextureCoord", i, 2, !1, Bm.FLOAT).addIndex(s),
        this._updateId = -1
    }
    get vertexDirtyId() {
        return this.buffers[0]._updateID
    }
}
class rP extends hw {
    constructor(t, e) {
        const n = {
            uSampler: t,
            alpha: 1,
            uTextureMatrix: Sv.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1])
        };
        (e = Object.assign({
            tint: 16777215,
            alpha: 1,
            pluginName: "batch"
        }, e)).uniforms && Object.assign(n, e.uniforms),
        super(e.program || lw.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"), n),
        this._colorDirty = !1,
        this.uvMatrix = new Gw(t),
        this.batchable = void 0 === e.program,
        this.pluginName = e.pluginName,
        this._tintColor = new nb(e.tint),
        this._tintRGB = this._tintColor.toLittleEndianNumber(),
        this._colorDirty = !0,
        this.alpha = e.alpha
    }
    get texture() {
        return this.uniforms.uSampler
    }
    set texture(t) {
        this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0),
        this.uniforms.uSampler = t,
        this.uvMatrix.texture = t)
    }
    set alpha(t) {
        t !== this._alpha && (this._alpha = t,
        this._colorDirty = !0)
    }
    get alpha() {
        return this._alpha
    }
    set tint(t) {
        t !== this.tint && (this._tintColor.setValue(t),
        this._tintRGB = this._tintColor.toLittleEndianNumber(),
        this._colorDirty = !0)
    }
    get tint() {
        return this._tintColor.value
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    update() {
        if (this._colorDirty) {
            this._colorDirty = !1;
            const t = this.texture.baseTexture.alphaMode;
            nb.shared.setValue(this._tintColor).premultiply(this._alpha, t).toArray(this.uniforms.uColor)
        }
        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
    }
}
class iP extends eP {
    constructor(t=Ow.EMPTY, e, n, r, i) {
        const s = new nP(e,n,r);
        s.getBuffer("aVertexPosition").static = !1;
        super(s, new rP(t), null, i),
        this.autoUpdate = !0
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }
    _render(t) {
        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(),
        super._render(t)
    }
}
class sP {
    constructor(t, e, n) {
        this.geometry = new dv,
        this.indexBuffer = null,
        this.size = n,
        this.dynamicProperties = [],
        this.staticProperties = [];
        for (let n = 0; n < t.length; ++n) {
            let r = t[n];
            r = {
                attributeName: r.attributeName,
                size: r.size,
                uploadFunction: r.uploadFunction,
                type: r.type || Bm.FLOAT,
                offset: r.offset
            },
            e[n] ? this.dynamicProperties.push(r) : this.staticProperties.push(r)
        }
        this.staticStride = 0,
        this.staticBuffer = null,
        this.staticData = null,
        this.staticDataUint32 = null,
        this.dynamicStride = 0,
        this.dynamicBuffer = null,
        this.dynamicData = null,
        this.dynamicDataUint32 = null,
        this._updateID = 0,
        this.initBuffers()
    }
    initBuffers() {
        const t = this.geometry;
        let e = 0;
        this.indexBuffer = new sv(fg.createIndicesForQuads(this.size),!0,!0),
        t.addIndex(this.indexBuffer),
        this.dynamicStride = 0;
        for (let t = 0; t < this.dynamicProperties.length; ++t) {
            const n = this.dynamicProperties[t];
            n.offset = e,
            e += n.size,
            this.dynamicStride += n.size
        }
        const n = new ArrayBuffer(this.size * this.dynamicStride * 16);
        this.dynamicData = new Float32Array(n),
        this.dynamicDataUint32 = new Uint32Array(n),
        this.dynamicBuffer = new sv(this.dynamicData,!1,!1);
        let r = 0;
        this.staticStride = 0;
        for (let t = 0; t < this.staticProperties.length; ++t) {
            const e = this.staticProperties[t];
            e.offset = r,
            r += e.size,
            this.staticStride += e.size
        }
        const i = new ArrayBuffer(this.size * this.staticStride * 16);
        this.staticData = new Float32Array(i),
        this.staticDataUint32 = new Uint32Array(i),
        this.staticBuffer = new sv(this.staticData,!0,!1);
        for (let e = 0; e < this.dynamicProperties.length; ++e) {
            const n = this.dynamicProperties[e];
            t.addAttribute(n.attributeName, this.dynamicBuffer, 0, n.type === Bm.UNSIGNED_BYTE, n.type, 4 * this.dynamicStride, 4 * n.offset)
        }
        for (let e = 0; e < this.staticProperties.length; ++e) {
            const n = this.staticProperties[e];
            t.addAttribute(n.attributeName, this.staticBuffer, 0, n.type === Bm.UNSIGNED_BYTE, n.type, 4 * this.staticStride, 4 * n.offset)
        }
    }
    uploadDynamic(t, e, n) {
        for (let r = 0; r < this.dynamicProperties.length; r++) {
            const i = this.dynamicProperties[r];
            i.uploadFunction(t, e, n, i.type === Bm.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, i.offset)
        }
        this.dynamicBuffer._updateID++
    }
    uploadStatic(t, e, n) {
        for (let r = 0; r < this.staticProperties.length; r++) {
            const i = this.staticProperties[r];
            i.uploadFunction(t, e, n, i.type === Bm.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, i.offset)
        }
        this.staticBuffer._updateID++
    }
    destroy() {
        this.indexBuffer = null,
        this.dynamicProperties = null,
        this.dynamicBuffer = null,
        this.dynamicData = null,
        this.dynamicDataUint32 = null,
        this.staticProperties = null,
        this.staticBuffer = null,
        this.staticData = null,
        this.staticDataUint32 = null,
        this.geometry.destroy()
    }
}
class oP extends mw {
    constructor(t) {
        super(t),
        this.shader = null,
        this.properties = null,
        this.tempMatrix = new Sv,
        this.properties = [{
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0
        }, {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0
        }, {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0
        }, {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0
        }, {
            attributeName: "aColor",
            size: 1,
            type: Bm.UNSIGNED_BYTE,
            uploadFunction: this.uploadTint,
            offset: 0
        }],
        this.shader = hw.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", {}),
        this.state = Xb.for2d()
    }
    render(t) {
        const e = t.children
          , n = t._maxSize
          , r = t._batchSize
          , i = this.renderer;
        let s = e.length;
        if (0 === s)
            return;
        s > n && !t.autoResize && (s = n);
        let o = t._buffers;
        o || (o = t._buffers = this.generateBuffers(t));
        const a = e[0]._texture.baseTexture
          , l = a.alphaMode > 0;
        this.state.blendMode = fg.correctBlendMode(t.blendMode, l),
        i.state.set(this.state);
        const c = i.gl
          , u = t.worldTransform.copyTo(this.tempMatrix);
        u.prepend(i.globalUniforms.uniforms.projectionMatrix),
        this.shader.uniforms.translationMatrix = u.toArray(!0),
        this.shader.uniforms.uColor = nb.shared.setValue(t.tintRgb).premultiply(t.worldAlpha, l).toArray(this.shader.uniforms.uColor),
        this.shader.uniforms.uSampler = a,
        this.renderer.shader.bind(this.shader);
        let h = !1;
        for (let n = 0, a = 0; n < s; n += r,
        a += 1) {
            let l = s - n;
            l > r && (l = r),
            a >= o.length && o.push(this._generateOneMoreBuffer(t));
            const u = o[a];
            u.uploadDynamic(e, n, l);
            const d = t._bufferUpdateIDs[a] || 0;
            h = h || u._updateID < d,
            h && (u._updateID = t._updateID,
            u.uploadStatic(e, n, l)),
            i.geometry.bind(u.geometry),
            c.drawElements(c.TRIANGLES, 6 * l, c.UNSIGNED_SHORT, 0)
        }
    }
    generateBuffers(t) {
        const e = []
          , n = t._maxSize
          , r = t._batchSize
          , i = t._properties;
        for (let t = 0; t < n; t += r)
            e.push(new sP(this.properties,i,r));
        return e
    }
    _generateOneMoreBuffer(t) {
        const e = t._batchSize
          , n = t._properties;
        return new sP(this.properties,n,e)
    }
    uploadVertices(t, e, n, r, i, s) {
        let o = 0
          , a = 0
          , l = 0
          , c = 0;
        for (let u = 0; u < n; ++u) {
            const n = t[e + u]
              , h = n._texture
              , d = n.scale.x
              , f = n.scale.y
              , p = h.trim
              , m = h.orig;
            p ? (a = p.x - n.anchor.x * m.width,
            o = a + p.width,
            c = p.y - n.anchor.y * m.height,
            l = c + p.height) : (o = m.width * (1 - n.anchor.x),
            a = m.width * -n.anchor.x,
            l = m.height * (1 - n.anchor.y),
            c = m.height * -n.anchor.y),
            r[s] = a * d,
            r[s + 1] = c * f,
            r[s + i] = o * d,
            r[s + i + 1] = c * f,
            r[s + 2 * i] = o * d,
            r[s + 2 * i + 1] = l * f,
            r[s + 3 * i] = a * d,
            r[s + 3 * i + 1] = l * f,
            s += 4 * i
        }
    }
    uploadPosition(t, e, n, r, i, s) {
        for (let o = 0; o < n; o++) {
            const n = t[e + o].position;
            r[s] = n.x,
            r[s + 1] = n.y,
            r[s + i] = n.x,
            r[s + i + 1] = n.y,
            r[s + 2 * i] = n.x,
            r[s + 2 * i + 1] = n.y,
            r[s + 3 * i] = n.x,
            r[s + 3 * i + 1] = n.y,
            s += 4 * i
        }
    }
    uploadRotation(t, e, n, r, i, s) {
        for (let o = 0; o < n; o++) {
            const n = t[e + o].rotation;
            r[s] = n,
            r[s + i] = n,
            r[s + 2 * i] = n,
            r[s + 3 * i] = n,
            s += 4 * i
        }
    }
    uploadUvs(t, e, n, r, i, s) {
        for (let o = 0; o < n; ++o) {
            const n = t[e + o]._texture._uvs;
            n ? (r[s] = n.x0,
            r[s + 1] = n.y0,
            r[s + i] = n.x1,
            r[s + i + 1] = n.y1,
            r[s + 2 * i] = n.x2,
            r[s + 2 * i + 1] = n.y2,
            r[s + 3 * i] = n.x3,
            r[s + 3 * i + 1] = n.y3,
            s += 4 * i) : (r[s] = 0,
            r[s + 1] = 0,
            r[s + i] = 0,
            r[s + i + 1] = 0,
            r[s + 2 * i] = 0,
            r[s + 2 * i + 1] = 0,
            r[s + 3 * i] = 0,
            r[s + 3 * i + 1] = 0,
            s += 4 * i)
        }
    }
    uploadTint(t, e, n, r, i, s) {
        for (let o = 0; o < n; ++o) {
            const n = t[e + o]
              , a = nb.shared.setValue(n._tintRGB).toPremultiplied(n.alpha, n.texture.baseTexture.alphaMode > 0);
            r[s] = a,
            r[s + i] = a,
            r[s + 2 * i] = a,
            r[s + 3 * i] = a,
            s += 4 * i
        }
    }
    destroy() {
        super.destroy(),
        this.shader && (this.shader.destroy(),
        this.shader = null),
        this.tempMatrix = null
    }
}
oP.extension = {
    name: "particle",
    type: Ub.RendererPlugin
},
Wb.add(oP);
var aP = (t=>(t[t.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL",
t[t.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL",
t))(aP || {});
const lP = {
    willReadFrequently: !0
}
  , cP = class {
    static get experimentalLetterSpacingSupported() {
        let t = cP._experimentalLetterSpacingSupported;
        if (void 0 !== t) {
            const e = Xm.ADAPTER.getCanvasRenderingContext2D().prototype;
            t = cP._experimentalLetterSpacingSupported = "letterSpacing"in e || "textLetterSpacing"in e
        }
        return t
    }
    constructor(t, e, n, r, i, s, o, a, l) {
        this.text = t,
        this.style = e,
        this.width = n,
        this.height = r,
        this.lines = i,
        this.lineWidths = s,
        this.lineHeight = o,
        this.maxLineWidth = a,
        this.fontProperties = l
    }
    static measureText(t, e, n, r=cP._canvas) {
        n = null == n ? e.wordWrap : n;
        const i = e.toFontString()
          , s = cP.measureFont(i);
        0 === s.fontSize && (s.fontSize = e.fontSize,
        s.ascent = e.fontSize);
        const o = r.getContext("2d", lP);
        o.font = i;
        const a = (n ? cP.wordWrap(t, e, r) : t).split(/(?:\r\n|\r|\n)/)
          , l = new Array(a.length);
        let c = 0;
        for (let t = 0; t < a.length; t++) {
            const n = cP._measureText(a[t], e.letterSpacing, o);
            l[t] = n,
            c = Math.max(c, n)
        }
        let u = c + e.strokeThickness;
        e.dropShadow && (u += e.dropShadowDistance);
        const h = e.lineHeight || s.fontSize + e.strokeThickness;
        let d = Math.max(h, s.fontSize + 2 * e.strokeThickness) + (a.length - 1) * (h + e.leading);
        return e.dropShadow && (d += e.dropShadowDistance),
        new cP(t,e,u,d,a,l,h + e.leading,c,s)
    }
    static _measureText(t, e, n) {
        let r = !1;
        cP.experimentalLetterSpacingSupported && (cP.experimentalLetterSpacing ? (n.letterSpacing = `${e}px`,
        n.textLetterSpacing = `${e}px`,
        r = !0) : (n.letterSpacing = "0px",
        n.textLetterSpacing = "0px"));
        let i = n.measureText(t).width;
        return i > 0 && (r ? i -= e : i += (cP.graphemeSegmenter(t).length - 1) * e),
        i
    }
    static wordWrap(t, e, n=cP._canvas) {
        const r = n.getContext("2d", lP);
        let i = 0
          , s = ""
          , o = "";
        const a = Object.create(null)
          , {letterSpacing: l, whiteSpace: c} = e
          , u = cP.collapseSpaces(c)
          , h = cP.collapseNewlines(c);
        let d = !u;
        const f = e.wordWrapWidth + l
          , p = cP.tokenize(t);
        for (let t = 0; t < p.length; t++) {
            let n = p[t];
            if (cP.isNewline(n)) {
                if (!h) {
                    o += cP.addLine(s),
                    d = !u,
                    s = "",
                    i = 0;
                    continue
                }
                n = " "
            }
            if (u) {
                const t = cP.isBreakingSpace(n)
                  , e = cP.isBreakingSpace(s[s.length - 1]);
                if (t && e)
                    continue
            }
            const c = cP.getFromCache(n, l, a, r);
            if (c > f)
                if ("" !== s && (o += cP.addLine(s),
                s = "",
                i = 0),
                cP.canBreakWords(n, e.breakWords)) {
                    const t = cP.wordWrapSplit(n);
                    for (let c = 0; c < t.length; c++) {
                        let u = t[c]
                          , h = u
                          , p = 1;
                        for (; t[c + p]; ) {
                            const r = t[c + p];
                            if (cP.canBreakChars(h, r, n, c, e.breakWords))
                                break;
                            u += r,
                            h = r,
                            p++
                        }
                        c += p - 1;
                        const m = cP.getFromCache(u, l, a, r);
                        m + i > f && (o += cP.addLine(s),
                        d = !1,
                        s = "",
                        i = 0),
                        s += u,
                        i += m
                    }
                } else {
                    s.length > 0 && (o += cP.addLine(s),
                    s = "",
                    i = 0);
                    const e = t === p.length - 1;
                    o += cP.addLine(n, !e),
                    d = !1,
                    s = "",
                    i = 0
                }
            else
                c + i > f && (d = !1,
                o += cP.addLine(s),
                s = "",
                i = 0),
                (s.length > 0 || !cP.isBreakingSpace(n) || d) && (s += n,
                i += c)
        }
        return o += cP.addLine(s, !1),
        o
    }
    static addLine(t, e=!0) {
        return t = cP.trimRight(t),
        t = e ? `${t}\n` : t
    }
    static getFromCache(t, e, n, r) {
        let i = n[t];
        return "number" != typeof i && (i = cP._measureText(t, e, r) + e,
        n[t] = i),
        i
    }
    static collapseSpaces(t) {
        return "normal" === t || "pre-line" === t
    }
    static collapseNewlines(t) {
        return "normal" === t
    }
    static trimRight(t) {
        if ("string" != typeof t)
            return "";
        for (let e = t.length - 1; e >= 0; e--) {
            const n = t[e];
            if (!cP.isBreakingSpace(n))
                break;
            t = t.slice(0, -1)
        }
        return t
    }
    static isNewline(t) {
        return "string" == typeof t && cP._newlines.includes(t.charCodeAt(0))
    }
    static isBreakingSpace(t, e) {
        return "string" == typeof t && cP._breakingSpaces.includes(t.charCodeAt(0))
    }
    static tokenize(t) {
        const e = [];
        let n = "";
        if ("string" != typeof t)
            return e;
        for (let r = 0; r < t.length; r++) {
            const i = t[r]
              , s = t[r + 1];
            cP.isBreakingSpace(i, s) || cP.isNewline(i) ? ("" !== n && (e.push(n),
            n = ""),
            e.push(i)) : n += i
        }
        return "" !== n && e.push(n),
        e
    }
    static canBreakWords(t, e) {
        return e
    }
    static canBreakChars(t, e, n, r, i) {
        return !0
    }
    static wordWrapSplit(t) {
        return cP.graphemeSegmenter(t)
    }
    static measureFont(t) {
        if (cP._fonts[t])
            return cP._fonts[t];
        const e = {
            ascent: 0,
            descent: 0,
            fontSize: 0
        }
          , n = cP._canvas
          , r = cP._context;
        r.font = t;
        const i = cP.METRICS_STRING + cP.BASELINE_SYMBOL
          , s = Math.ceil(r.measureText(i).width);
        let o = Math.ceil(r.measureText(cP.BASELINE_SYMBOL).width);
        const a = Math.ceil(cP.HEIGHT_MULTIPLIER * o);
        if (o = o * cP.BASELINE_MULTIPLIER | 0,
        0 === s || 0 === a)
            return cP._fonts[t] = e,
            e;
        n.width = s,
        n.height = a,
        r.fillStyle = "#f00",
        r.fillRect(0, 0, s, a),
        r.font = t,
        r.textBaseline = "alphabetic",
        r.fillStyle = "#000",
        r.fillText(i, 0, o);
        const l = r.getImageData(0, 0, s, a).data
          , c = l.length
          , u = 4 * s;
        let h = 0
          , d = 0
          , f = !1;
        for (h = 0; h < o; ++h) {
            for (let t = 0; t < u; t += 4)
                if (255 !== l[d + t]) {
                    f = !0;
                    break
                }
            if (f)
                break;
            d += u
        }
        for (e.ascent = o - h,
        d = c - u,
        f = !1,
        h = a; h > o; --h) {
            for (let t = 0; t < u; t += 4)
                if (255 !== l[d + t]) {
                    f = !0;
                    break
                }
            if (f)
                break;
            d -= u
        }
        return e.descent = h - o,
        e.fontSize = e.ascent + e.descent,
        cP._fonts[t] = e,
        e
    }
    static clearMetrics(t="") {
        t ? delete cP._fonts[t] : cP._fonts = {}
    }
    static get _canvas() {
        if (!cP.__canvas) {
            let t;
            try {
                const e = new OffscreenCanvas(0,0)
                  , n = e.getContext("2d", lP);
                if (n?.measureText)
                    return cP.__canvas = e,
                    e;
                t = Xm.ADAPTER.createCanvas()
            } catch (e) {
                t = Xm.ADAPTER.createCanvas()
            }
            t.width = t.height = 10,
            cP.__canvas = t
        }
        return cP.__canvas
    }
    static get _context() {
        return cP.__context || (cP.__context = cP._canvas.getContext("2d", lP)),
        cP.__context
    }
}
;
let uP = cP;
uP.METRICS_STRING = "|ÉqÅ",
uP.BASELINE_SYMBOL = "M",
uP.BASELINE_MULTIPLIER = 1.4,
uP.HEIGHT_MULTIPLIER = 2,
uP.graphemeSegmenter = (()=>{
    if ("function" == typeof Intl?.Segmenter) {
        const t = new Intl.Segmenter;
        return e=>[...t.segment(e)].map((t=>t.segment))
    }
    return t=>[...t]
}
)(),
uP.experimentalLetterSpacing = !1,
uP._fonts = {},
uP._newlines = [10, 13],
uP._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
const hP = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
  , dP = class {
    constructor(t) {
        this.styleID = 0,
        this.reset(),
        mP(this, t, t)
    }
    clone() {
        const t = {};
        return mP(t, this, dP.defaultStyle),
        new dP(t)
    }
    reset() {
        mP(this, dP.defaultStyle, dP.defaultStyle)
    }
    get align() {
        return this._align
    }
    set align(t) {
        this._align !== t && (this._align = t,
        this.styleID++)
    }
    get breakWords() {
        return this._breakWords
    }
    set breakWords(t) {
        this._breakWords !== t && (this._breakWords = t,
        this.styleID++)
    }
    get dropShadow() {
        return this._dropShadow
    }
    set dropShadow(t) {
        this._dropShadow !== t && (this._dropShadow = t,
        this.styleID++)
    }
    get dropShadowAlpha() {
        return this._dropShadowAlpha
    }
    set dropShadowAlpha(t) {
        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t,
        this.styleID++)
    }
    get dropShadowAngle() {
        return this._dropShadowAngle
    }
    set dropShadowAngle(t) {
        this._dropShadowAngle !== t && (this._dropShadowAngle = t,
        this.styleID++)
    }
    get dropShadowBlur() {
        return this._dropShadowBlur
    }
    set dropShadowBlur(t) {
        this._dropShadowBlur !== t && (this._dropShadowBlur = t,
        this.styleID++)
    }
    get dropShadowColor() {
        return this._dropShadowColor
    }
    set dropShadowColor(t) {
        const e = pP(t);
        this._dropShadowColor !== e && (this._dropShadowColor = e,
        this.styleID++)
    }
    get dropShadowDistance() {
        return this._dropShadowDistance
    }
    set dropShadowDistance(t) {
        this._dropShadowDistance !== t && (this._dropShadowDistance = t,
        this.styleID++)
    }
    get fill() {
        return this._fill
    }
    set fill(t) {
        const e = pP(t);
        this._fill !== e && (this._fill = e,
        this.styleID++)
    }
    get fillGradientType() {
        return this._fillGradientType
    }
    set fillGradientType(t) {
        this._fillGradientType !== t && (this._fillGradientType = t,
        this.styleID++)
    }
    get fillGradientStops() {
        return this._fillGradientStops
    }
    set fillGradientStops(t) {
        (function(t, e) {
            if (!Array.isArray(t) || !Array.isArray(e))
                return !1;
            if (t.length !== e.length)
                return !1;
            for (let n = 0; n < t.length; ++n)
                if (t[n] !== e[n])
                    return !1;
            return !0
        }
        )(this._fillGradientStops, t) || (this._fillGradientStops = t,
        this.styleID++)
    }
    get fontFamily() {
        return this._fontFamily
    }
    set fontFamily(t) {
        this.fontFamily !== t && (this._fontFamily = t,
        this.styleID++)
    }
    get fontSize() {
        return this._fontSize
    }
    set fontSize(t) {
        this._fontSize !== t && (this._fontSize = t,
        this.styleID++)
    }
    get fontStyle() {
        return this._fontStyle
    }
    set fontStyle(t) {
        this._fontStyle !== t && (this._fontStyle = t,
        this.styleID++)
    }
    get fontVariant() {
        return this._fontVariant
    }
    set fontVariant(t) {
        this._fontVariant !== t && (this._fontVariant = t,
        this.styleID++)
    }
    get fontWeight() {
        return this._fontWeight
    }
    set fontWeight(t) {
        this._fontWeight !== t && (this._fontWeight = t,
        this.styleID++)
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(t) {
        this._letterSpacing !== t && (this._letterSpacing = t,
        this.styleID++)
    }
    get lineHeight() {
        return this._lineHeight
    }
    set lineHeight(t) {
        this._lineHeight !== t && (this._lineHeight = t,
        this.styleID++)
    }
    get leading() {
        return this._leading
    }
    set leading(t) {
        this._leading !== t && (this._leading = t,
        this.styleID++)
    }
    get lineJoin() {
        return this._lineJoin
    }
    set lineJoin(t) {
        this._lineJoin !== t && (this._lineJoin = t,
        this.styleID++)
    }
    get miterLimit() {
        return this._miterLimit
    }
    set miterLimit(t) {
        this._miterLimit !== t && (this._miterLimit = t,
        this.styleID++)
    }
    get padding() {
        return this._padding
    }
    set padding(t) {
        this._padding !== t && (this._padding = t,
        this.styleID++)
    }
    get stroke() {
        return this._stroke
    }
    set stroke(t) {
        const e = pP(t);
        this._stroke !== e && (this._stroke = e,
        this.styleID++)
    }
    get strokeThickness() {
        return this._strokeThickness
    }
    set strokeThickness(t) {
        this._strokeThickness !== t && (this._strokeThickness = t,
        this.styleID++)
    }
    get textBaseline() {
        return this._textBaseline
    }
    set textBaseline(t) {
        this._textBaseline !== t && (this._textBaseline = t,
        this.styleID++)
    }
    get trim() {
        return this._trim
    }
    set trim(t) {
        this._trim !== t && (this._trim = t,
        this.styleID++)
    }
    get whiteSpace() {
        return this._whiteSpace
    }
    set whiteSpace(t) {
        this._whiteSpace !== t && (this._whiteSpace = t,
        this.styleID++)
    }
    get wordWrap() {
        return this._wordWrap
    }
    set wordWrap(t) {
        this._wordWrap !== t && (this._wordWrap = t,
        this.styleID++)
    }
    get wordWrapWidth() {
        return this._wordWrapWidth
    }
    set wordWrapWidth(t) {
        this._wordWrapWidth !== t && (this._wordWrapWidth = t,
        this.styleID++)
    }
    toFontString() {
        const t = "number" == typeof this.fontSize ? `${this.fontSize}px` : this.fontSize;
        let e = this.fontFamily;
        Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
        for (let t = e.length - 1; t >= 0; t--) {
            let n = e[t].trim();
            /([\"\'])[^\'\"]+\1/.test(n) || hP.includes(n) || (n = `"${n}"`),
            e[t] = n
        }
        return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${t} ${e.join(",")}`
    }
}
;
let fP = dP;
function pP(t) {
    const e = nb.shared;
    return Array.isArray(t) ? t.map((t=>e.setValue(t).toHex())) : e.setValue(t).toHex()
}
function mP(t, e, n) {
    for (const r in n)
        Array.isArray(e[r]) ? t[r] = e[r].slice() : t[r] = e[r]
}
fP.defaultStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: aP.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};
const gP = {
    texture: !0,
    children: !1,
    baseTexture: !0
}
  , yP = class extends lM {
    constructor(t, e, n) {
        let r = !1;
        n || (n = Xm.ADAPTER.createCanvas(),
        r = !0),
        n.width = 3,
        n.height = 3;
        const i = Ow.from(n);
        i.orig = new wv,
        i.trim = new wv,
        super(i),
        this._ownCanvas = r,
        this.canvas = n,
        this.context = n.getContext("2d", {
            willReadFrequently: !0
        }),
        this._resolution = yP.defaultResolution ?? Xm.RESOLUTION,
        this._autoResolution = yP.defaultAutoResolution,
        this._text = null,
        this._style = null,
        this._styleListener = null,
        this._font = "",
        this.text = t,
        this.style = e,
        this.localStyleID = -1
    }
    static get experimentalLetterSpacing() {
        return uP.experimentalLetterSpacing
    }
    static set experimentalLetterSpacing(t) {
        fg.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"),
        uP.experimentalLetterSpacing = t
    }
    updateText(t) {
        const e = this._style;
        if (this.localStyleID !== e.styleID && (this.dirty = !0,
        this.localStyleID = e.styleID),
        !this.dirty && t)
            return;
        this._font = this._style.toFontString();
        const n = this.context
          , r = uP.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas)
          , i = r.width
          , s = r.height
          , o = r.lines
          , a = r.lineHeight
          , l = r.lineWidths
          , c = r.maxLineWidth
          , u = r.fontProperties;
        let h, d;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, i) + 2 * e.padding) * this._resolution),
        this.canvas.height = Math.ceil(Math.ceil(Math.max(1, s) + 2 * e.padding) * this._resolution),
        n.scale(this._resolution, this._resolution),
        n.clearRect(0, 0, this.canvas.width, this.canvas.height),
        n.font = this._font,
        n.lineWidth = e.strokeThickness,
        n.textBaseline = e.textBaseline,
        n.lineJoin = e.lineJoin,
        n.miterLimit = e.miterLimit;
        const f = e.dropShadow ? 2 : 1;
        for (let t = 0; t < f; ++t) {
            const i = e.dropShadow && 0 === t
              , f = i ? Math.ceil(Math.max(1, s) + 2 * e.padding) : 0
              , p = f * this._resolution;
            if (i) {
                n.fillStyle = "black",
                n.strokeStyle = "black";
                const t = e.dropShadowColor
                  , r = e.dropShadowBlur * this._resolution
                  , i = e.dropShadowDistance * this._resolution;
                n.shadowColor = nb.shared.setValue(t).setAlpha(e.dropShadowAlpha).toRgbaString(),
                n.shadowBlur = r,
                n.shadowOffsetX = Math.cos(e.dropShadowAngle) * i,
                n.shadowOffsetY = Math.sin(e.dropShadowAngle) * i + p
            } else
                n.fillStyle = this._generateFillStyle(e, o, r),
                n.strokeStyle = e.stroke,
                n.shadowColor = "black",
                n.shadowBlur = 0,
                n.shadowOffsetX = 0,
                n.shadowOffsetY = 0;
            let m = (a - u.fontSize) / 2;
            a - u.fontSize < 0 && (m = 0);
            for (let t = 0; t < o.length; t++)
                h = e.strokeThickness / 2,
                d = e.strokeThickness / 2 + t * a + u.ascent + m,
                "right" === e.align ? h += c - l[t] : "center" === e.align && (h += (c - l[t]) / 2),
                e.stroke && e.strokeThickness && this.drawLetterSpacing(o[t], h + e.padding, d + e.padding - f, !0),
                e.fill && this.drawLetterSpacing(o[t], h + e.padding, d + e.padding - f)
        }
        this.updateTexture()
    }
    drawLetterSpacing(t, e, n, r=!1) {
        const i = this._style.letterSpacing;
        let s = !1;
        if (uP.experimentalLetterSpacingSupported && (uP.experimentalLetterSpacing ? (this.context.letterSpacing = `${i}px`,
        this.context.textLetterSpacing = `${i}px`,
        s = !0) : (this.context.letterSpacing = "0px",
        this.context.textLetterSpacing = "0px")),
        0 === i || s)
            return void (r ? this.context.strokeText(t, e, n) : this.context.fillText(t, e, n));
        let o = e;
        const a = uP.graphemeSegmenter(t);
        let l = this.context.measureText(t).width
          , c = 0;
        for (let t = 0; t < a.length; ++t) {
            const e = a[t];
            r ? this.context.strokeText(e, o, n) : this.context.fillText(e, o, n);
            let s = "";
            for (let e = t + 1; e < a.length; ++e)
                s += a[e];
            c = this.context.measureText(s).width,
            o += l - c + i,
            l = c
        }
    }
    updateTexture() {
        const t = this.canvas;
        if (this._style.trim) {
            const e = fg.trimCanvas(t);
            e.data && (t.width = e.width,
            t.height = e.height,
            this.context.putImageData(e.data, 0, 0))
        }
        const e = this._texture
          , n = this._style
          , r = n.trim ? 0 : n.padding
          , i = e.baseTexture;
        e.trim.width = e._frame.width = t.width / this._resolution,
        e.trim.height = e._frame.height = t.height / this._resolution,
        e.trim.x = -r,
        e.trim.y = -r,
        e.orig.width = e._frame.width - 2 * r,
        e.orig.height = e._frame.height - 2 * r,
        this._onTextureUpdate(),
        i.setRealSize(t.width, t.height, this._resolution),
        e.updateUvs(),
        this.dirty = !1
    }
    _render(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._render(t)
    }
    updateTransform() {
        this.updateText(!0),
        super.updateTransform()
    }
    getBounds(t, e) {
        return this.updateText(!0),
        -1 === this._textureID && (t = !1),
        super.getBounds(t, e)
    }
    getLocalBounds(t) {
        return this.updateText(!0),
        super.getLocalBounds.call(this, t)
    }
    _calculateBounds() {
        this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)
    }
    _generateFillStyle(t, e, n) {
        const r = t.fill;
        if (!Array.isArray(r))
            return r;
        if (1 === r.length)
            return r[0];
        let i;
        const s = t.dropShadow ? t.dropShadowDistance : 0
          , o = t.padding || 0
          , a = this.canvas.width / this._resolution - s - 2 * o
          , l = this.canvas.height / this._resolution - s - 2 * o
          , c = r.slice()
          , u = t.fillGradientStops.slice();
        if (!u.length) {
            const t = c.length + 1;
            for (let e = 1; e < t; ++e)
                u.push(e / t)
        }
        if (c.unshift(r[0]),
        u.unshift(0),
        c.push(r[r.length - 1]),
        u.push(1),
        t.fillGradientType === aP.LINEAR_VERTICAL) {
            i = this.context.createLinearGradient(a / 2, o, a / 2, l + o);
            const r = n.fontProperties.fontSize + t.strokeThickness;
            for (let t = 0; t < e.length; t++) {
                const s = n.lineHeight * (t - 1) + r
                  , o = n.lineHeight * t;
                let a = o;
                t > 0 && s > o && (a = (o + s) / 2);
                const h = o + r
                  , d = n.lineHeight * (t + 1);
                let f = h;
                t + 1 < e.length && d < h && (f = (h + d) / 2);
                const p = (f - a) / l;
                for (let t = 0; t < c.length; t++) {
                    let e = 0;
                    e = "number" == typeof u[t] ? u[t] : t / c.length;
                    let n = Math.min(1, Math.max(0, a / l + e * p));
                    n = Number(n.toFixed(5)),
                    i.addColorStop(n, c[t])
                }
            }
        } else {
            i = this.context.createLinearGradient(o, l / 2, a + o, l / 2);
            const t = c.length + 1;
            let e = 1;
            for (let n = 0; n < c.length; n++) {
                let r;
                r = "number" == typeof u[n] ? u[n] : e / t,
                i.addColorStop(r, c[n]),
                e++
            }
        }
        return i
    }
    destroy(t) {
        "boolean" == typeof t && (t = {
            children: t
        }),
        t = Object.assign({}, gP, t),
        super.destroy(t),
        this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
        this.context = null,
        this.canvas = null,
        this._style = null
    }
    get width() {
        return this.updateText(!0),
        Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        this.updateText(!0);
        const e = fg.sign(this.scale.x) || 1;
        this.scale.x = e * t / this._texture.orig.width,
        this._width = t
    }
    get height() {
        return this.updateText(!0),
        Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        this.updateText(!0);
        const e = fg.sign(this.scale.y) || 1;
        this.scale.y = e * t / this._texture.orig.height,
        this._height = t
    }
    get style() {
        return this._style
    }
    set style(t) {
        t = t || {},
        this._style = t instanceof fP ? t : new fP(t),
        this.localStyleID = -1,
        this.dirty = !0
    }
    get text() {
        return this._text
    }
    set text(t) {
        t = String(null == t ? "" : t),
        this._text !== t && (this._text = t,
        this.dirty = !0)
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._autoResolution = !1,
        this._resolution !== t && (this._resolution = t,
        this.dirty = !0)
    }
}
;
let bP = yP;
bP.defaultAutoResolution = !0;
class vP {
    constructor(t) {
        this.maxItemsPerFrame = t,
        this.itemsLeft = 0
    }
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame
    }
    allowedToUpload() {
        return this.itemsLeft-- > 0
    }
}
function wP(t, e) {
    let n = !1;
    if (t?._textures?.length)
        for (let r = 0; r < t._textures.length; r++)
            if (t._textures[r]instanceof Ow) {
                const i = t._textures[r].baseTexture;
                e.includes(i) || (e.push(i),
                n = !0)
            }
    return n
}
function xP(t, e) {
    if (t.baseTexture instanceof nv) {
        const n = t.baseTexture;
        return e.includes(n) || e.push(n),
        !0
    }
    return !1
}
function EP(t, e) {
    if (t._texture && t._texture instanceof Ow) {
        const n = t._texture.baseTexture;
        return e.includes(n) || e.push(n),
        !0
    }
    return !1
}
function _P(t, e) {
    return e instanceof bP && (e.updateText(!0),
    !0)
}
function AP(t, e) {
    if (e instanceof fP) {
        const t = e.toFontString();
        return uP.measureFont(t),
        !0
    }
    return !1
}
function SP(t, e) {
    if (t instanceof bP) {
        e.includes(t.style) || e.push(t.style),
        e.includes(t) || e.push(t);
        const n = t._texture.baseTexture;
        return e.includes(n) || e.push(n),
        !0
    }
    return !1
}
function TP(t, e) {
    return t instanceof fP && (e.includes(t) || e.push(t),
    !0)
}
const kP = class {
    constructor(t) {
        this.limiter = new vP(kP.uploadsPerFrame),
        this.renderer = t,
        this.uploadHookHelper = null,
        this.queue = [],
        this.addHooks = [],
        this.uploadHooks = [],
        this.completes = [],
        this.ticking = !1,
        this.delayedTick = ()=>{
            this.queue && this.prepareItems()
        }
        ,
        this.registerFindHook(SP),
        this.registerFindHook(TP),
        this.registerFindHook(wP),
        this.registerFindHook(xP),
        this.registerFindHook(EP),
        this.registerUploadHook(_P),
        this.registerUploadHook(AP)
    }
    upload(t) {
        return new Promise((e=>{
            t && this.add(t),
            this.queue.length ? (this.completes.push(e),
            this.ticking || (this.ticking = !0,
            Bx.system.addOnce(this.tick, this, Nx.UTILITY))) : e()
        }
        ))
    }
    tick() {
        setTimeout(this.delayedTick, 0)
    }
    prepareItems() {
        for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
            const t = this.queue[0];
            let e = !1;
            if (t && !t._destroyed)
                for (let n = 0, r = this.uploadHooks.length; n < r; n++)
                    if (this.uploadHooks[n](this.uploadHookHelper, t)) {
                        this.queue.shift(),
                        e = !0;
                        break
                    }
            e || this.queue.shift()
        }
        if (this.queue.length)
            Bx.system.addOnce(this.tick, this, Nx.UTILITY);
        else {
            this.ticking = !1;
            const t = this.completes.slice(0);
            this.completes.length = 0;
            for (let e = 0, n = t.length; e < n; e++)
                t[e]()
        }
    }
    registerFindHook(t) {
        return t && this.addHooks.push(t),
        this
    }
    registerUploadHook(t) {
        return t && this.uploadHooks.push(t),
        this
    }
    add(t) {
        for (let e = 0, n = this.addHooks.length; e < n && !this.addHooks[e](t, this.queue); e++)
            ;
        if (t instanceof EI)
            for (let e = t.children.length - 1; e >= 0; e--)
                this.add(t.children[e]);
        return this
    }
    destroy() {
        this.ticking && Bx.system.remove(this.tick, this),
        this.ticking = !1,
        this.addHooks = null,
        this.uploadHooks = null,
        this.renderer = null,
        this.completes = null,
        this.queue = null,
        this.limiter = null,
        this.uploadHookHelper = null
    }
}
;
let IP = kP;
function MP(t, e) {
    return e instanceof nv && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e),
    !0)
}
function CP(t, e) {
    if (!(e instanceof KC))
        return !1;
    const {geometry: n} = e;
    e.finishPoly(),
    n.updateBatches();
    const {batches: r} = n;
    for (let e = 0; e < r.length; e++) {
        const {texture: n} = r[e].style;
        n && MP(t, n.baseTexture)
    }
    return n.batchable || t.geometry.bind(n, e._resolveDirectShader(t)),
    !0
}
function PP(t, e) {
    return t instanceof KC && (e.push(t),
    !0)
}
IP.uploadsPerFrame = 4,
Object.defineProperties(Xm, {
    UPLOADS_PER_FRAME: {
        get: ()=>IP.uploadsPerFrame,
        set(t) {
            fg.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"),
            IP.uploadsPerFrame = t
        }
    }
});
class OP extends IP {
    constructor(t) {
        super(t),
        this.uploadHookHelper = this.renderer,
        this.registerFindHook(PP),
        this.registerUploadHook(MP),
        this.registerUploadHook(CP)
    }
}
OP.extension = {
    name: "prepare",
    type: Ub.RendererSystem
},
Wb.add(OP);
new bv;
var NP = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
const RP = new Sv;
class DP extends mw {
    constructor(t) {
        super(t),
        t.runners.contextChange.add(this),
        this.quad = new Bw,
        this.state = Xb.for2d()
    }
    contextChange() {
        const t = this.renderer
          , e = {
            globals: t.globalUniforms
        };
        this.simpleShader = hw.from(NP, "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n", e),
        this.shader = t.context.webGLVersion > 1 ? hw.from("#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n", e) : hw.from(NP, "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n", e)
    }
    render(t) {
        const e = this.renderer
          , n = this.quad;
        let r = n.vertices;
        r[0] = r[6] = t._width * -t.anchor.x,
        r[1] = r[3] = t._height * -t.anchor.y,
        r[2] = r[4] = t._width * (1 - t.anchor.x),
        r[5] = r[7] = t._height * (1 - t.anchor.y);
        const i = t.uvRespectAnchor ? t.anchor.x : 0
          , s = t.uvRespectAnchor ? t.anchor.y : 0;
        r = n.uvs,
        r[0] = r[6] = -i,
        r[1] = r[3] = -s,
        r[2] = r[4] = 1 - i,
        r[5] = r[7] = 1 - s,
        n.invalidate();
        const o = t._texture
          , a = o.baseTexture
          , l = a.alphaMode > 0
          , c = t.tileTransform.localTransform
          , u = t.uvMatrix;
        let h = a.isPowerOfTwo && o.frame.width === a.width && o.frame.height === a.height;
        h && (a._glTextures[e.CONTEXT_UID] ? h = a.wrapMode !== jm.CLAMP : a.wrapMode === jm.CLAMP && (a.wrapMode = jm.REPEAT));
        const d = h ? this.simpleShader : this.shader
          , f = o.width
          , p = o.height
          , m = t._width
          , g = t._height;
        RP.set(c.a * f / m, c.b * f / g, c.c * p / m, c.d * p / g, c.tx / m, c.ty / g),
        RP.invert(),
        h ? RP.prepend(u.mapCoord) : (d.uniforms.uMapCoord = u.mapCoord.toArray(!0),
        d.uniforms.uClampFrame = u.uClampFrame,
        d.uniforms.uClampOffset = u.uClampOffset),
        d.uniforms.uTransform = RP.toArray(!0),
        d.uniforms.uColor = nb.shared.setValue(t.tint).premultiply(t.worldAlpha, l).toArray(d.uniforms.uColor),
        d.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0),
        d.uniforms.uSampler = o,
        e.shader.bind(d),
        e.geometry.bind(n),
        this.state.blendMode = fg.correctBlendMode(t.blendMode, l),
        e.state.set(this.state),
        e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
    }
}
DP.extension = {
    name: "tilingSprite",
    type: Ub.RendererPlugin
},
Wb.add(DP);
const BP = class {
    constructor(t, e, n=null) {
        this.linkedSheets = [],
        this._texture = t instanceof Ow ? t : null,
        this.baseTexture = t instanceof nv ? t : this._texture.baseTexture,
        this.textures = {},
        this.animations = {},
        this.data = e;
        const r = this.baseTexture.resource;
        this.resolution = this._updateResolution(n || (r ? r.url : null)),
        this._frames = this.data.frames,
        this._frameKeys = Object.keys(this._frames),
        this._batchIndex = 0,
        this._callback = null
    }
    _updateResolution(t=null) {
        const {scale: e} = this.data.meta;
        let n = fg.getResolutionOfUrl(t, null);
        return null === n && (n = parseFloat(e ?? "1")),
        1 !== n && this.baseTexture.setResolution(n),
        n
    }
    parse() {
        return new Promise((t=>{
            this._callback = t,
            this._batchIndex = 0,
            this._frameKeys.length <= BP.BATCH_SIZE ? (this._processFrames(0),
            this._processAnimations(),
            this._parseComplete()) : this._nextBatch()
        }
        ))
    }
    _processFrames(t) {
        let e = t;
        const n = BP.BATCH_SIZE;
        for (; e - t < n && e < this._frameKeys.length; ) {
            const t = this._frameKeys[e]
              , n = this._frames[t]
              , r = n.frame;
            if (r) {
                let e = null
                  , i = null;
                const s = !1 !== n.trimmed && n.sourceSize ? n.sourceSize : n.frame
                  , o = new wv(0,0,Math.floor(s.w) / this.resolution,Math.floor(s.h) / this.resolution);
                e = n.rotated ? new wv(Math.floor(r.x) / this.resolution,Math.floor(r.y) / this.resolution,Math.floor(r.h) / this.resolution,Math.floor(r.w) / this.resolution) : new wv(Math.floor(r.x) / this.resolution,Math.floor(r.y) / this.resolution,Math.floor(r.w) / this.resolution,Math.floor(r.h) / this.resolution),
                !1 !== n.trimmed && n.spriteSourceSize && (i = new wv(Math.floor(n.spriteSourceSize.x) / this.resolution,Math.floor(n.spriteSourceSize.y) / this.resolution,Math.floor(r.w) / this.resolution,Math.floor(r.h) / this.resolution)),
                this.textures[t] = new Ow(this.baseTexture,e,o,i,n.rotated ? 2 : 0,n.anchor,n.borders),
                Ow.addToCache(this.textures[t], t)
            }
            e++
        }
    }
    _processAnimations() {
        const t = this.data.animations || {};
        for (const e in t) {
            this.animations[e] = [];
            for (let n = 0; n < t[e].length; n++) {
                const r = t[e][n];
                this.animations[e].push(this.textures[r])
            }
        }
    }
    _parseComplete() {
        const t = this._callback;
        this._callback = null,
        this._batchIndex = 0,
        t.call(this, this.textures)
    }
    _nextBatch() {
        this._processFrames(this._batchIndex * BP.BATCH_SIZE),
        this._batchIndex++,
        setTimeout((()=>{
            this._batchIndex * BP.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(),
            this._parseComplete())
        }
        ), 0)
    }
    destroy(t=!1) {
        for (const t in this.textures)
            this.textures[t].destroy();
        this._frames = null,
        this._frameKeys = null,
        this.data = null,
        this.textures = null,
        t && (this._texture?.destroy(),
        this.baseTexture.destroy()),
        this._texture = null,
        this.baseTexture = null,
        this.linkedSheets = []
    }
}
;
let LP = BP;
LP.BATCH_SIZE = 1e3;
const FP = ["jpg", "png", "jpeg", "avif", "webp"];
function jP(t, e, n) {
    const r = {};
    if (t.forEach((t=>{
        r[t] = e
    }
    )),
    Object.keys(e.textures).forEach((t=>{
        r[t] = e.textures[t]
    }
    )),
    !n) {
        const n = fg.path.dirname(t[0]);
        e.linkedSheets.forEach(((t,i)=>{
            const s = jP([`${n}/${e.data.meta.related_multi_packs[i]}`], t, !0);
            Object.assign(r, s)
        }
        ))
    }
    return r
}
const UP = {
    extension: Ub.Asset,
    cache: {
        test: t=>t instanceof LP,
        getCacheableAssets: (t,e)=>jP(t, e, !1)
    },
    resolver: {
        test: t=>{
            const e = t.split("?")[0].split(".")
              , n = e.pop()
              , r = e.pop();
            return "json" === n && FP.includes(r)
        }
        ,
        parse: t=>{
            const e = t.split(".");
            return {
                resolution: parseFloat(Xm.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
                format: e[e.length - 2],
                src: t
            }
        }
    },
    loader: {
        name: "spritesheetLoader",
        extension: {
            type: Ub.LoadParser,
            priority: NE.Normal
        },
        testParse: async(t,e)=>".json" === fg.path.extname(e.src).toLowerCase() && !!t.frames,
        async parse(t, e, n) {
            let r = fg.path.dirname(e.src);
            r && r.lastIndexOf("/") !== r.length - 1 && (r += "/");
            let i = r + t.meta.image;
            i = kE(i, e.src);
            const s = (await n.load([i]))[i]
              , o = new LP(s.baseTexture,t,e.src);
            await o.parse();
            const a = t?.meta?.related_multi_packs;
            if (Array.isArray(a)) {
                const t = [];
                for (const i of a) {
                    if ("string" != typeof i)
                        continue;
                    let s = r + i;
                    e.data?.ignoreMultiPack || (s = kE(s, e.src),
                    t.push(n.load({
                        src: s,
                        data: {
                            ignoreMultiPack: !0
                        }
                    })))
                }
                const i = await Promise.all(t);
                o.linkedSheets = i,
                i.forEach((t=>{
                    t.linkedSheets = [o].concat(o.linkedSheets.filter((e=>e !== t)))
                }
                ))
            }
            return o
        },
        unload(t) {
            t.destroy(!0)
        }
    }
};
Wb.add(UP);
class zP {
    constructor() {
        this.info = [],
        this.common = [],
        this.page = [],
        this.char = [],
        this.kerning = [],
        this.distanceField = []
    }
}
class VP {
    static test(t) {
        return "string" == typeof t && t.startsWith("info face=")
    }
    static parse(t) {
        const e = t.match(/^[a-z]+\s+.+$/gm)
          , n = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
        };
        for (const t in e) {
            const r = e[t].match(/^[a-z]+/gm)[0]
              , i = e[t].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm)
              , s = {};
            for (const t in i) {
                const e = i[t].split("=")
                  , n = e[0]
                  , r = e[1].replace(/"/gm, "")
                  , o = parseFloat(r)
                  , a = isNaN(o) ? r : o;
                s[n] = a
            }
            n[r].push(s)
        }
        const r = new zP;
        return n.info.forEach((t=>r.info.push({
            face: t.face,
            size: parseInt(t.size, 10)
        }))),
        n.common.forEach((t=>r.common.push({
            lineHeight: parseInt(t.lineHeight, 10)
        }))),
        n.page.forEach((t=>r.page.push({
            id: parseInt(t.id, 10),
            file: t.file
        }))),
        n.char.forEach((t=>r.char.push({
            id: parseInt(t.id, 10),
            page: parseInt(t.page, 10),
            x: parseInt(t.x, 10),
            y: parseInt(t.y, 10),
            width: parseInt(t.width, 10),
            height: parseInt(t.height, 10),
            xoffset: parseInt(t.xoffset, 10),
            yoffset: parseInt(t.yoffset, 10),
            xadvance: parseInt(t.xadvance, 10)
        }))),
        n.kerning.forEach((t=>r.kerning.push({
            first: parseInt(t.first, 10),
            second: parseInt(t.second, 10),
            amount: parseInt(t.amount, 10)
        }))),
        n.distanceField.forEach((t=>r.distanceField.push({
            distanceRange: parseInt(t.distanceRange, 10),
            fieldType: t.fieldType
        }))),
        r
    }
}
class WP {
    static test(t) {
        const e = t;
        return "getElementsByTagName"in e && e.getElementsByTagName("page").length && null !== e.getElementsByTagName("info")[0].getAttribute("face")
    }
    static parse(t) {
        const e = new zP
          , n = t.getElementsByTagName("info")
          , r = t.getElementsByTagName("common")
          , i = t.getElementsByTagName("page")
          , s = t.getElementsByTagName("char")
          , o = t.getElementsByTagName("kerning")
          , a = t.getElementsByTagName("distanceField");
        for (let t = 0; t < n.length; t++)
            e.info.push({
                face: n[t].getAttribute("face"),
                size: parseInt(n[t].getAttribute("size"), 10)
            });
        for (let t = 0; t < r.length; t++)
            e.common.push({
                lineHeight: parseInt(r[t].getAttribute("lineHeight"), 10)
            });
        for (let t = 0; t < i.length; t++)
            e.page.push({
                id: parseInt(i[t].getAttribute("id"), 10) || 0,
                file: i[t].getAttribute("file")
            });
        for (let t = 0; t < s.length; t++) {
            const n = s[t];
            e.char.push({
                id: parseInt(n.getAttribute("id"), 10),
                page: parseInt(n.getAttribute("page"), 10) || 0,
                x: parseInt(n.getAttribute("x"), 10),
                y: parseInt(n.getAttribute("y"), 10),
                width: parseInt(n.getAttribute("width"), 10),
                height: parseInt(n.getAttribute("height"), 10),
                xoffset: parseInt(n.getAttribute("xoffset"), 10),
                yoffset: parseInt(n.getAttribute("yoffset"), 10),
                xadvance: parseInt(n.getAttribute("xadvance"), 10)
            })
        }
        for (let t = 0; t < o.length; t++)
            e.kerning.push({
                first: parseInt(o[t].getAttribute("first"), 10),
                second: parseInt(o[t].getAttribute("second"), 10),
                amount: parseInt(o[t].getAttribute("amount"), 10)
            });
        for (let t = 0; t < a.length; t++)
            e.distanceField.push({
                fieldType: a[t].getAttribute("fieldType"),
                distanceRange: parseInt(a[t].getAttribute("distanceRange"), 10)
            });
        return e
    }
}
class YP {
    static test(t) {
        return !("string" != typeof t || !t.includes("<font>")) && WP.test(Xm.ADAPTER.parseXML(t))
    }
    static parse(t) {
        return WP.parse(Xm.ADAPTER.parseXML(t))
    }
}
const HP = [VP, WP, YP];
function $P(t) {
    for (let e = 0; e < HP.length; e++)
        if (HP[e].test(t))
            return HP[e];
    return null
}
function GP(t, e, n, r, i, s) {
    const o = n.fill;
    if (!Array.isArray(o))
        return o;
    if (1 === o.length)
        return o[0];
    let a;
    const l = n.dropShadow ? n.dropShadowDistance : 0
      , c = n.padding || 0
      , u = t.width / r - l - 2 * c
      , h = t.height / r - l - 2 * c
      , d = o.slice()
      , f = n.fillGradientStops.slice();
    if (!f.length) {
        const t = d.length + 1;
        for (let e = 1; e < t; ++e)
            f.push(e / t)
    }
    if (d.unshift(o[0]),
    f.unshift(0),
    d.push(o[o.length - 1]),
    f.push(1),
    n.fillGradientType === aP.LINEAR_VERTICAL) {
        a = e.createLinearGradient(u / 2, c, u / 2, h + c);
        let t = 0;
        const r = (s.fontProperties.fontSize + n.strokeThickness) / h;
        for (let e = 0; e < i.length; e++) {
            const n = s.lineHeight * e;
            for (let e = 0; e < d.length; e++) {
                let i = 0;
                i = "number" == typeof f[e] ? f[e] : e / d.length;
                const s = n / h + i * r;
                let o = Math.max(t, s);
                o = Math.min(o, 1),
                a.addColorStop(o, d[e]),
                t = o
            }
        }
    } else {
        a = e.createLinearGradient(c, h / 2, u + c, h / 2);
        const t = d.length + 1;
        let n = 1;
        for (let e = 0; e < d.length; e++) {
            let r;
            r = "number" == typeof f[e] ? f[e] : n / t,
            a.addColorStop(r, d[e]),
            n++
        }
    }
    return a
}
function XP(t, e, n, r, i, s, o) {
    const a = n.text
      , l = n.fontProperties;
    e.translate(r, i),
    e.scale(s, s);
    const c = o.strokeThickness / 2
      , u = -o.strokeThickness / 2;
    if (e.font = o.toFontString(),
    e.lineWidth = o.strokeThickness,
    e.textBaseline = o.textBaseline,
    e.lineJoin = o.lineJoin,
    e.miterLimit = o.miterLimit,
    e.fillStyle = GP(t, e, o, s, [a], n),
    e.strokeStyle = o.stroke,
    o.dropShadow) {
        const t = o.dropShadowColor
          , n = o.dropShadowBlur * s
          , r = o.dropShadowDistance * s;
        e.shadowColor = nb.shared.setValue(t).setAlpha(o.dropShadowAlpha).toRgbaString(),
        e.shadowBlur = n,
        e.shadowOffsetX = Math.cos(o.dropShadowAngle) * r,
        e.shadowOffsetY = Math.sin(o.dropShadowAngle) * r
    } else
        e.shadowColor = "black",
        e.shadowBlur = 0,
        e.shadowOffsetX = 0,
        e.shadowOffsetY = 0;
    o.stroke && o.strokeThickness && e.strokeText(a, c, u + n.lineHeight - l.descent),
    o.fill && e.fillText(a, c, u + n.lineHeight - l.descent),
    e.setTransform(1, 0, 0, 1, 0, 0),
    e.fillStyle = "rgba(0, 0, 0, 0)"
}
function qP(t) {
    return t.codePointAt ? t.codePointAt(0) : t.charCodeAt(0)
}
function KP(t) {
    return Array.from ? Array.from(t) : t.split("")
}
function QP(t) {
    "string" == typeof t && (t = [t]);
    const e = [];
    for (let n = 0, r = t.length; n < r; n++) {
        const r = t[n];
        if (Array.isArray(r)) {
            if (2 !== r.length)
                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
            const t = r[0].charCodeAt(0)
              , n = r[1].charCodeAt(0);
            if (n < t)
                throw new Error("[BitmapFont]: Invalid character range.");
            for (let r = t, i = n; r <= i; r++)
                e.push(String.fromCharCode(r))
        } else
            e.push(...KP(r))
    }
    if (0 === e.length)
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return e
}
const ZP = class {
    constructor(t, e, n) {
        const [r] = t.info
          , [i] = t.common
          , [s] = t.page
          , [o] = t.distanceField
          , a = fg.getResolutionOfUrl(s.file)
          , l = {};
        this._ownsTextures = n,
        this.font = r.face,
        this.size = r.size,
        this.lineHeight = i.lineHeight / a,
        this.chars = {},
        this.pageTextures = l;
        for (let n = 0; n < t.page.length; n++) {
            const {id: r, file: i} = t.page[n];
            l[r] = e instanceof Array ? e[n] : e[i],
            o?.fieldType && "none" !== o.fieldType && (l[r].baseTexture.alphaMode = zm.NO_PREMULTIPLIED_ALPHA,
            l[r].baseTexture.mipmap = Um.OFF)
        }
        for (let e = 0; e < t.char.length; e++) {
            const {id: n, page: r} = t.char[e];
            let {x: i, y: s, width: o, height: c, xoffset: u, yoffset: h, xadvance: d} = t.char[e];
            i /= a,
            s /= a,
            o /= a,
            c /= a,
            u /= a,
            h /= a,
            d /= a;
            const f = new wv(i + l[r].frame.x / a,s + l[r].frame.y / a,o,c);
            this.chars[n] = {
                xOffset: u,
                yOffset: h,
                xAdvance: d,
                kerning: {},
                texture: new Ow(l[r].baseTexture,f),
                page: r
            }
        }
        for (let e = 0; e < t.kerning.length; e++) {
            let {first: n, second: r, amount: i} = t.kerning[e];
            n /= a,
            r /= a,
            i /= a,
            this.chars[r] && (this.chars[r].kerning[n] = i)
        }
        this.distanceFieldRange = o?.distanceRange,
        this.distanceFieldType = o?.fieldType?.toLowerCase() ?? "none"
    }
    destroy() {
        for (const t in this.chars)
            this.chars[t].texture.destroy(),
            this.chars[t].texture = null;
        for (const t in this.pageTextures)
            this._ownsTextures && this.pageTextures[t].destroy(!0),
            this.pageTextures[t] = null;
        this.chars = null,
        this.pageTextures = null
    }
    static install(t, e, n) {
        let r;
        if (t instanceof zP)
            r = t;
        else {
            const e = $P(t);
            if (!e)
                throw new Error("Unrecognized data format for font.");
            r = e.parse(t)
        }
        e instanceof Ow && (e = [e]);
        const i = new ZP(r,e,n);
        return ZP.available[i.font] = i,
        i
    }
    static uninstall(t) {
        const e = ZP.available[t];
        if (!e)
            throw new Error(`No font found named '${t}'`);
        e.destroy(),
        delete ZP.available[t]
    }
    static from(t, e, n) {
        if (!t)
            throw new Error("[BitmapFont] Property `name` is required.");
        const {chars: r, padding: i, resolution: s, textureWidth: o, textureHeight: a, ...l} = Object.assign({}, ZP.defaultOptions, n)
          , c = QP(r)
          , u = e instanceof fP ? e : new fP(e)
          , h = o
          , d = new zP;
        d.info[0] = {
            face: u.fontFamily,
            size: u.fontSize
        },
        d.common[0] = {
            lineHeight: u.fontSize
        };
        let f, p, m, g = 0, y = 0, b = 0;
        const v = []
          , w = [];
        for (let t = 0; t < c.length; t++) {
            f || (f = Xm.ADAPTER.createCanvas(),
            f.width = o,
            f.height = a,
            p = f.getContext("2d"),
            m = new nv(f,{
                resolution: s,
                ...l
            }),
            v.push(m),
            w.push(new Ow(m)),
            d.page.push({
                id: w.length - 1,
                file: ""
            }));
            const e = c[t]
              , n = uP.measureText(e, u, !1, f)
              , r = n.width
              , x = Math.ceil(n.height)
              , E = Math.ceil(("italic" === u.fontStyle ? 2 : 1) * r);
            if (y >= a - x * s) {
                if (0 === y)
                    throw new Error(`[BitmapFont] textureHeight ${a}px is too small (fontFamily: '${u.fontFamily}', fontSize: ${u.fontSize}px, char: '${e}')`);
                --t,
                f = null,
                p = null,
                m = null,
                y = 0,
                g = 0,
                b = 0;
                continue
            }
            if (b = Math.max(x + n.fontProperties.descent, b),
            E * s + g >= h) {
                if (0 === g)
                    throw new Error(`[BitmapFont] textureWidth ${o}px is too small (fontFamily: '${u.fontFamily}', fontSize: ${u.fontSize}px, char: '${e}')`);
                --t,
                y += b * s,
                y = Math.ceil(y),
                g = 0,
                b = 0;
                continue
            }
            XP(f, p, n, g, y, s, u);
            const _ = qP(n.text);
            d.char.push({
                id: _,
                page: w.length - 1,
                x: g / s,
                y: y / s,
                width: E,
                height: x,
                xoffset: 0,
                yoffset: 0,
                xadvance: r - (u.dropShadow ? u.dropShadowDistance : 0) - (u.stroke ? u.strokeThickness : 0)
            }),
            g += (E + 2 * i) * s,
            g = Math.ceil(g)
        }
        for (let t = 0, e = c.length; t < e; t++) {
            const n = c[t];
            for (let t = 0; t < e; t++) {
                const e = c[t]
                  , r = p.measureText(n).width
                  , i = p.measureText(e).width
                  , s = p.measureText(n + e).width - (r + i);
                s && d.kerning.push({
                    first: qP(n),
                    second: qP(e),
                    amount: s
                })
            }
        }
        const x = new ZP(d,w,!0);
        return void 0 !== ZP.available[t] && ZP.uninstall(t),
        ZP.available[t] = x,
        x
    }
}
;
let JP = ZP;
JP.ALPHA = [["a", "z"], ["A", "Z"], " "],
JP.NUMERIC = [["0", "9"]],
JP.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "],
JP.ASCII = [[" ", "~"]],
JP.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: ZP.ALPHANUMERIC
},
JP.available = {};
const tO = []
  , eO = []
  , nO = []
  , rO = class extends EI {
    constructor(t, e={}) {
        super();
        const {align: n, tint: r, maxWidth: i, letterSpacing: s, fontName: o, fontSize: a} = Object.assign({}, rO.styleDefaults, e);
        if (!JP.available[o])
            throw new Error(`Missing BitmapFont "${o}"`);
        this._activePagesMeshData = [],
        this._textWidth = 0,
        this._textHeight = 0,
        this._align = n,
        this._tintColor = new nb(r),
        this._font = void 0,
        this._fontName = o,
        this._fontSize = a,
        this.text = t,
        this._maxWidth = i,
        this._maxLineHeight = 0,
        this._letterSpacing = s,
        this._anchor = new Rv((()=>{
            this.dirty = !0
        }
        ),this,0,0),
        this._roundPixels = Xm.ROUND_PIXELS,
        this.dirty = !0,
        this._resolution = Xm.RESOLUTION,
        this._autoResolution = !0,
        this._textureCache = {}
    }
    updateText() {
        const t = JP.available[this._fontName]
          , e = this.fontSize
          , n = e / t.size
          , r = new bv
          , i = []
          , s = []
          , o = []
          , a = KP(this._text.replace(/(?:\r\n|\r)/g, "\n") || " ")
          , l = this._maxWidth * t.size / e
          , c = "none" === t.distanceFieldType ? tO : eO;
        let u = null
          , h = 0
          , d = 0
          , f = 0
          , p = -1
          , m = 0
          , g = 0
          , y = 0
          , b = 0;
        for (let e = 0; e < a.length; e++) {
            const n = a[e]
              , c = qP(n);
            if (/(?:\s)/.test(n) && (p = e,
            m = h,
            b++),
            "\r" === n || "\n" === n) {
                s.push(h),
                o.push(-1),
                d = Math.max(d, h),
                ++f,
                ++g,
                r.x = 0,
                r.y += t.lineHeight,
                u = null,
                b = 0;
                continue
            }
            const v = t.chars[c];
            if (!v)
                continue;
            u && v.kerning[u] && (r.x += v.kerning[u]);
            const w = nO.pop() || {
                texture: Ow.EMPTY,
                line: 0,
                charCode: 0,
                prevSpaces: 0,
                position: new bv
            };
            w.texture = v.texture,
            w.line = f,
            w.charCode = c,
            w.position.x = Math.round(r.x + v.xOffset + this._letterSpacing / 2),
            w.position.y = Math.round(r.y + v.yOffset),
            w.prevSpaces = b,
            i.push(w),
            h = w.position.x + Math.max(v.xAdvance - v.xOffset, v.texture.orig.width),
            r.x += v.xAdvance + this._letterSpacing,
            y = Math.max(y, v.yOffset + v.texture.height),
            u = c,
            -1 !== p && l > 0 && r.x > l && (++g,
            fg.removeItems(i, 1 + p - g, 1 + e - p),
            e = p,
            p = -1,
            s.push(m),
            o.push(i.length > 0 ? i[i.length - 1].prevSpaces : 0),
            d = Math.max(d, m),
            f++,
            r.x = 0,
            r.y += t.lineHeight,
            u = null,
            b = 0)
        }
        const v = a[a.length - 1];
        "\r" !== v && "\n" !== v && (/(?:\s)/.test(v) && (h = m),
        s.push(h),
        d = Math.max(d, h),
        o.push(-1));
        const w = [];
        for (let t = 0; t <= f; t++) {
            let e = 0;
            "right" === this._align ? e = d - s[t] : "center" === this._align ? e = (d - s[t]) / 2 : "justify" === this._align && (e = o[t] < 0 ? 0 : (d - s[t]) / o[t]),
            w.push(e)
        }
        const x = i.length
          , E = {}
          , _ = []
          , A = this._activePagesMeshData;
        c.push(...A);
        for (let e = 0; e < x; e++) {
            const n = i[e].texture
              , r = n.baseTexture.uid;
            if (!E[r]) {
                let e = c.pop();
                if (!e) {
                    const n = new nP;
                    let r, i;
                    "none" === t.distanceFieldType ? (r = new rP(Ow.EMPTY),
                    i = Om.NORMAL) : (r = new rP(Ow.EMPTY,{
                        program: lw.from("// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n", "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n"),
                        uniforms: {
                            uFWidth: 0
                        }
                    }),
                    i = Om.NORMAL_NPM);
                    const s = new eP(n,r);
                    s.blendMode = i,
                    e = {
                        index: 0,
                        indexCount: 0,
                        vertexCount: 0,
                        uvsCount: 0,
                        total: 0,
                        mesh: s,
                        vertices: null,
                        uvs: null,
                        indices: null
                    }
                }
                e.index = 0,
                e.indexCount = 0,
                e.vertexCount = 0,
                e.uvsCount = 0,
                e.total = 0;
                const {_textureCache: i} = this;
                i[r] = i[r] || new Ow(n.baseTexture),
                e.mesh.texture = i[r],
                e.mesh.tint = this._tintColor.value,
                _.push(e),
                E[r] = e
            }
            E[r].total++
        }
        for (let t = 0; t < A.length; t++)
            _.includes(A[t]) || this.removeChild(A[t].mesh);
        for (let t = 0; t < _.length; t++)
            _[t].mesh.parent !== this && this.addChild(_[t].mesh);
        this._activePagesMeshData = _;
        for (const t in E) {
            const e = E[t]
              , n = e.total;
            if (!(e.indices?.length > 6 * n) || e.vertices.length < 2 * eP.BATCHABLE_SIZE)
                e.vertices = new Float32Array(8 * n),
                e.uvs = new Float32Array(8 * n),
                e.indices = new Uint16Array(6 * n);
            else {
                const t = e.total
                  , n = e.vertices;
                for (let e = 8 * t; e < n.length; e++)
                    n[e] = 0
            }
            e.mesh.size = 6 * n
        }
        for (let t = 0; t < x; t++) {
            const e = i[t];
            let r = e.position.x + w[e.line] * ("justify" === this._align ? e.prevSpaces : 1);
            this._roundPixels && (r = Math.round(r));
            const s = r * n
              , o = e.position.y * n
              , a = e.texture
              , l = E[a.baseTexture.uid]
              , c = a.frame
              , u = a._uvs
              , h = l.index++;
            l.indices[6 * h + 0] = 0 + 4 * h,
            l.indices[6 * h + 1] = 1 + 4 * h,
            l.indices[6 * h + 2] = 2 + 4 * h,
            l.indices[6 * h + 3] = 0 + 4 * h,
            l.indices[6 * h + 4] = 2 + 4 * h,
            l.indices[6 * h + 5] = 3 + 4 * h,
            l.vertices[8 * h + 0] = s,
            l.vertices[8 * h + 1] = o,
            l.vertices[8 * h + 2] = s + c.width * n,
            l.vertices[8 * h + 3] = o,
            l.vertices[8 * h + 4] = s + c.width * n,
            l.vertices[8 * h + 5] = o + c.height * n,
            l.vertices[8 * h + 6] = s,
            l.vertices[8 * h + 7] = o + c.height * n,
            l.uvs[8 * h + 0] = u.x0,
            l.uvs[8 * h + 1] = u.y0,
            l.uvs[8 * h + 2] = u.x1,
            l.uvs[8 * h + 3] = u.y1,
            l.uvs[8 * h + 4] = u.x2,
            l.uvs[8 * h + 5] = u.y2,
            l.uvs[8 * h + 6] = u.x3,
            l.uvs[8 * h + 7] = u.y3
        }
        this._textWidth = d * n,
        this._textHeight = (r.y + t.lineHeight) * n;
        for (const t in E) {
            const e = E[t];
            if (0 !== this.anchor.x || 0 !== this.anchor.y) {
                let t = 0;
                const n = this._textWidth * this.anchor.x
                  , r = this._textHeight * this.anchor.y;
                for (let i = 0; i < e.total; i++)
                    e.vertices[t++] -= n,
                    e.vertices[t++] -= r,
                    e.vertices[t++] -= n,
                    e.vertices[t++] -= r,
                    e.vertices[t++] -= n,
                    e.vertices[t++] -= r,
                    e.vertices[t++] -= n,
                    e.vertices[t++] -= r
            }
            this._maxLineHeight = y * n;
            const r = e.mesh.geometry.getBuffer("aVertexPosition")
              , i = e.mesh.geometry.getBuffer("aTextureCoord")
              , s = e.mesh.geometry.getIndex();
            r.data = e.vertices,
            i.data = e.uvs,
            s.data = e.indices,
            r.update(),
            i.update(),
            s.update()
        }
        for (let t = 0; t < i.length; t++)
            nO.push(i[t]);
        this._font = t,
        this.dirty = !1
    }
    updateTransform() {
        this.validate(),
        this.containerUpdateTransform()
    }
    _render(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0);
        const {distanceFieldRange: e, distanceFieldType: n, size: r} = JP.available[this._fontName];
        if ("none" !== n) {
            const {a: n, b: i, c: s, d: o} = this.worldTransform
              , a = Math.sqrt(n * n + i * i)
              , l = Math.sqrt(s * s + o * o)
              , c = (Math.abs(a) + Math.abs(l)) / 2
              , u = this.fontSize / r
              , h = t._view.resolution;
            for (const t of this._activePagesMeshData)
                t.mesh.shader.uniforms.uFWidth = c * e * u * h
        }
        super._render(t)
    }
    getLocalBounds() {
        return this.validate(),
        super.getLocalBounds()
    }
    validate() {
        const t = JP.available[this._fontName];
        if (!t)
            throw new Error(`Missing BitmapFont "${this._fontName}"`);
        this._font !== t && (this.dirty = !0),
        this.dirty && this.updateText()
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        if (this.tint !== t) {
            this._tintColor.setValue(t);
            for (let e = 0; e < this._activePagesMeshData.length; e++)
                this._activePagesMeshData[e].mesh.tint = t
        }
    }
    get align() {
        return this._align
    }
    set align(t) {
        this._align !== t && (this._align = t,
        this.dirty = !0)
    }
    get fontName() {
        return this._fontName
    }
    set fontName(t) {
        if (!JP.available[t])
            throw new Error(`Missing BitmapFont "${t}"`);
        this._fontName !== t && (this._fontName = t,
        this.dirty = !0)
    }
    get fontSize() {
        return this._fontSize ?? JP.available[this._fontName].size
    }
    set fontSize(t) {
        this._fontSize !== t && (this._fontSize = t,
        this.dirty = !0)
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        "number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t)
    }
    get text() {
        return this._text
    }
    set text(t) {
        t = String(null == t ? "" : t),
        this._text !== t && (this._text = t,
        this.dirty = !0)
    }
    get maxWidth() {
        return this._maxWidth
    }
    set maxWidth(t) {
        this._maxWidth !== t && (this._maxWidth = t,
        this.dirty = !0)
    }
    get maxLineHeight() {
        return this.validate(),
        this._maxLineHeight
    }
    get textWidth() {
        return this.validate(),
        this._textWidth
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(t) {
        this._letterSpacing !== t && (this._letterSpacing = t,
        this.dirty = !0)
    }
    get roundPixels() {
        return this._roundPixels
    }
    set roundPixels(t) {
        t !== this._roundPixels && (this._roundPixels = t,
        this.dirty = !0)
    }
    get textHeight() {
        return this.validate(),
        this._textHeight
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._autoResolution = !1,
        this._resolution !== t && (this._resolution = t,
        this.dirty = !0)
    }
    destroy(t) {
        const {_textureCache: e} = this
          , n = "none" === JP.available[this._fontName].distanceFieldType ? tO : eO;
        n.push(...this._activePagesMeshData);
        for (const t of this._activePagesMeshData)
            this.removeChild(t.mesh);
        this._activePagesMeshData = [],
        n.filter((t=>e[t.mesh.texture.baseTexture.uid])).forEach((t=>{
            t.mesh.texture = Ow.EMPTY
        }
        ));
        for (const t in e) {
            e[t].destroy(),
            delete e[t]
        }
        this._font = null,
        this._tintColor = null,
        this._textureCache = null,
        super.destroy(t)
    }
}
;
rO.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
};
const iO = [".xml", ".fnt"]
  , sO = {
    extension: {
        type: Ub.LoadParser,
        priority: NE.Normal
    },
    name: "loadBitmapFont",
    test: t=>iO.includes(fg.path.extname(t).toLowerCase()),
    testParse: async t=>VP.test(t) || YP.test(t),
    async parse(t, e, n) {
        const r = VP.test(t) ? VP.parse(t) : YP.parse(t)
          , {src: i} = e
          , {page: s} = r
          , o = [];
        for (let t = 0; t < s.length; ++t) {
            const e = s[t].file;
            let n = fg.path.join(fg.path.dirname(i), e);
            n = kE(n, i),
            o.push(n)
        }
        const a = await n.load(o)
          , l = o.map((t=>a[t]));
        return JP.install(r, l, !0)
    },
    load: async(t,e)=>(await Xm.ADAPTER.fetch(t)).text(),
    unload(t) {
        t.destroy()
    }
};
Wb.add(sO);
const oO = class extends fP {
    constructor() {
        super(...arguments),
        this._fonts = [],
        this._overrides = [],
        this._stylesheet = "",
        this.fontsDirty = !1
    }
    static from(t) {
        return new oO(Object.keys(oO.defaultOptions).reduce(((e,n)=>({
            ...e,
            [n]: t[n]
        })), {}))
    }
    cleanFonts() {
        this._fonts.length > 0 && (this._fonts.forEach((t=>{
            URL.revokeObjectURL(t.src),
            t.refs--,
            0 === t.refs && (t.fontFace && document.fonts.delete(t.fontFace),
            delete oO.availableFonts[t.originalUrl])
        }
        )),
        this.fontFamily = "Arial",
        this._fonts.length = 0,
        this.styleID++,
        this.fontsDirty = !0)
    }
    loadFont(t, e={}) {
        const {availableFonts: n} = oO;
        if (n[t]) {
            const e = n[t];
            return this._fonts.push(e),
            e.refs++,
            this.styleID++,
            this.fontsDirty = !0,
            Promise.resolve()
        }
        return Xm.ADAPTER.fetch(t).then((t=>t.blob())).then((async t=>new Promise(((e,n)=>{
            const r = URL.createObjectURL(t)
              , i = new FileReader;
            i.onload = ()=>e([r, i.result]),
            i.onerror = n,
            i.readAsDataURL(t)
        }
        )))).then((async([r,i])=>{
            const s = Object.assign({
                family: fg.path.basename(t, fg.path.extname(t)),
                weight: "normal",
                style: "normal",
                src: r,
                dataSrc: i,
                refs: 1,
                originalUrl: t,
                fontFace: null
            }, e);
            n[t] = s,
            this._fonts.push(s),
            this.styleID++;
            const o = new FontFace(s.family,`url(${s.src})`,{
                weight: s.weight,
                style: s.style
            });
            s.fontFace = o,
            await o.load(),
            document.fonts.add(o),
            await document.fonts.ready,
            this.styleID++,
            this.fontsDirty = !0
        }
        ))
    }
    addOverride(...t) {
        const e = t.filter((t=>!this._overrides.includes(t)));
        e.length > 0 && (this._overrides.push(...e),
        this.styleID++)
    }
    removeOverride(...t) {
        const e = t.filter((t=>this._overrides.includes(t)));
        e.length > 0 && (this._overrides = this._overrides.filter((t=>!e.includes(t))),
        this.styleID++)
    }
    toCSS(t) {
        return [`transform: scale(${t})`, "transform-origin: top left", "display: inline-block", `color: ${this.normalizeColor(this.fill)}`, `font-size: ${this.fontSize}px`, `font-family: ${this.fontFamily}`, `font-weight: ${this.fontWeight}`, `font-style: ${this.fontStyle}`, `font-variant: ${this.fontVariant}`, `letter-spacing: ${this.letterSpacing}px`, `text-align: ${this.align}`, `padding: ${this.padding}px`, `white-space: ${this.whiteSpace}`, ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [], ...this.wordWrap ? ["word-wrap: " + (this.breakWords ? "break-all" : "break-word"), `max-width: ${this.wordWrapWidth}px`] : [], ...this.strokeThickness ? [`-webkit-text-stroke-width: ${this.strokeThickness}px`, `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`, `text-stroke-width: ${this.strokeThickness}px`, `text-stroke-color: ${this.normalizeColor(this.stroke)}`, "paint-order: stroke"] : [], ...this.dropShadow ? [this.dropShadowToCSS()] : [], ...this._overrides].join(";")
    }
    toGlobalCSS() {
        return this._fonts.reduce(((t,e)=>`${t}\n            @font-face {\n                font-family: "${e.family}";\n                src: url('${e.dataSrc}');\n                font-weight: ${e.weight};\n                font-style: ${e.style}; \n            }`), this._stylesheet)
    }
    get stylesheet() {
        return this._stylesheet
    }
    set stylesheet(t) {
        this._stylesheet !== t && (this._stylesheet = t,
        this.styleID++)
    }
    normalizeColor(t) {
        return Array.isArray(t) && (t = fg.rgb2hex(t)),
        "number" == typeof t ? fg.hex2string(t) : t
    }
    dropShadowToCSS() {
        let t = this.normalizeColor(this.dropShadowColor);
        const e = this.dropShadowAlpha
          , n = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance)
          , r = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
        t.startsWith("#") && e < 1 && (t += (255 * e | 0).toString(16).padStart(2, "0"));
        const i = `${n}px ${r}px`;
        return this.dropShadowBlur > 0 ? `text-shadow: ${i} ${this.dropShadowBlur}px ${t}` : `text-shadow: ${i} ${t}`
    }
    reset() {
        Object.assign(this, oO.defaultOptions)
    }
    onBeforeDraw() {
        const {fontsDirty: t} = this;
        return this.fontsDirty = !1,
        this.isSafari && this._fonts.length > 0 && t ? new Promise((t=>setTimeout(t, 100))) : Promise.resolve()
    }
    get isSafari() {
        const {userAgent: t} = Xm.ADAPTER.getNavigator();
        return /^((?!chrome|android).)*safari/i.test(t)
    }
    set fillGradientStops(t) {
        console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText")
    }
    get fillGradientStops() {
        return super.fillGradientStops
    }
    set fillGradientType(t) {
        console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText")
    }
    get fillGradientType() {
        return super.fillGradientType
    }
    set miterLimit(t) {
        console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText")
    }
    get miterLimit() {
        return super.miterLimit
    }
    set trim(t) {
        console.warn("[HTMLTextStyle] trim is not supported by HTMLText")
    }
    get trim() {
        return super.trim
    }
    set textBaseline(t) {
        console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText")
    }
    get textBaseline() {
        return super.textBaseline
    }
    set leading(t) {
        console.warn("[HTMLTextStyle] leading is not supported by HTMLText")
    }
    get leading() {
        return super.leading
    }
    set lineJoin(t) {
        console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText")
    }
    get lineJoin() {
        return super.lineJoin
    }
}
;
let aO = oO;
aO.availableFonts = {},
aO.defaultOptions = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    whiteSpace: "normal",
    wordWrap: !1,
    wordWrapWidth: 100
};
const lO = class extends lM {
    constructor(t="", e={}) {
        super(Ow.EMPTY),
        this._text = null,
        this._style = null,
        this._autoResolution = !0,
        this._loading = !1,
        this.localStyleID = -1,
        this.dirty = !1,
        this.ownsStyle = !1;
        const n = new Image
          , r = Ow.from(n, {
            scaleMode: Xm.SCALE_MODE,
            resourceOptions: {
                autoLoad: !1
            }
        });
        r.orig = new wv,
        r.trim = new wv,
        this.texture = r;
        const i = "http://www.w3.org/2000/svg"
          , s = "http://www.w3.org/1999/xhtml"
          , o = document.createElementNS(i, "svg")
          , a = document.createElementNS(i, "foreignObject")
          , l = document.createElementNS(s, "div")
          , c = document.createElementNS(s, "style");
        a.setAttribute("width", "10000"),
        a.setAttribute("height", "10000"),
        a.style.overflow = "hidden",
        o.appendChild(a),
        this.maxWidth = lO.defaultMaxWidth,
        this.maxHeight = lO.defaultMaxHeight,
        this._domElement = l,
        this._styleElement = c,
        this._svgRoot = o,
        this._foreignObject = a,
        this._foreignObject.appendChild(c),
        this._foreignObject.appendChild(l),
        this._image = n,
        this._loadImage = new Image,
        this._autoResolution = lO.defaultAutoResolution,
        this._resolution = lO.defaultResolution ?? Xm.RESOLUTION,
        this.text = t,
        this.style = e
    }
    measureText(t) {
        const {text: e, style: n, resolution: r} = Object.assign({
            text: this._text,
            style: this._style,
            resolution: this._resolution
        }, t);
        Object.assign(this._domElement, {
            innerHTML: e,
            style: n.toCSS(r)
        }),
        this._styleElement.textContent = n.toGlobalCSS(),
        document.body.appendChild(this._svgRoot);
        const i = this._domElement.getBoundingClientRect();
        this._svgRoot.remove();
        const s = Math.min(this.maxWidth, Math.ceil(i.width))
          , o = Math.min(this.maxHeight, Math.ceil(i.height));
        return this._svgRoot.setAttribute("width", s.toString()),
        this._svgRoot.setAttribute("height", o.toString()),
        e !== this._text && (this._domElement.innerHTML = this._text),
        n !== this._style && (Object.assign(this._domElement, {
            style: this._style?.toCSS(r)
        }),
        this._styleElement.textContent = this._style?.toGlobalCSS()),
        {
            width: s + 2 * n.padding,
            height: o + 2 * n.padding
        }
    }
    async updateText(t=!0) {
        const {style: e, _image: n, _loadImage: r} = this;
        if (this.localStyleID !== e.styleID && (this.dirty = !0,
        this.localStyleID = e.styleID),
        !this.dirty && t)
            return;
        const {width: i, height: s} = this.measureText();
        n.width = r.width = Math.ceil(Math.max(1, i)),
        n.height = r.height = Math.ceil(Math.max(1, s)),
        this._loading || (this._loading = !0,
        await new Promise((t=>{
            r.onload = async()=>{
                await e.onBeforeDraw(),
                this._loading = !1,
                n.src = r.src,
                r.onload = null,
                r.src = "",
                this.updateTexture(),
                t()
            }
            ;
            const i = (new XMLSerializer).serializeToString(this._svgRoot);
            r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(i)}`
        }
        )))
    }
    get source() {
        return this._image
    }
    updateTexture() {
        const {style: t, texture: e, _image: n, resolution: r} = this
          , {padding: i} = t
          , {baseTexture: s} = e;
        e.trim.width = e._frame.width = n.width / r,
        e.trim.height = e._frame.height = n.height / r,
        e.trim.x = -i,
        e.trim.y = -i,
        e.orig.width = e._frame.width - 2 * i,
        e.orig.height = e._frame.height - 2 * i,
        this._onTextureUpdate(),
        s.setRealSize(n.width, n.height, r),
        this.dirty = !1
    }
    _render(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._render(t)
    }
    _renderCanvas(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._renderCanvas(t)
    }
    getLocalBounds(t) {
        return this.updateText(!0),
        super.getLocalBounds(t)
    }
    _calculateBounds() {
        this.updateText(!0),
        this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)
    }
    _onStyleChange() {
        this.dirty = !0
    }
    destroy(t) {
        "boolean" == typeof t && (t = {
            children: t
        }),
        t = Object.assign({}, lO.defaultDestroyOptions, t),
        super.destroy(t);
        const e = null;
        this.ownsStyle && this._style?.cleanFonts(),
        this._style = e,
        this._svgRoot?.remove(),
        this._svgRoot = e,
        this._domElement?.remove(),
        this._domElement = e,
        this._foreignObject?.remove(),
        this._foreignObject = e,
        this._styleElement?.remove(),
        this._styleElement = e,
        this._loadImage.src = "",
        this._loadImage.onload = null,
        this._loadImage = e,
        this._image.src = "",
        this._image = e
    }
    get width() {
        return this.updateText(!0),
        Math.abs(this.scale.x) * this._image.width / this.resolution
    }
    set width(t) {
        this.updateText(!0);
        const e = fg.sign(this.scale.x) || 1;
        this.scale.x = e * t / this._image.width / this.resolution,
        this._width = t
    }
    get height() {
        return this.updateText(!0),
        Math.abs(this.scale.y) * this._image.height / this.resolution
    }
    set height(t) {
        this.updateText(!0);
        const e = fg.sign(this.scale.y) || 1;
        this.scale.y = e * t / this._image.height / this.resolution,
        this._height = t
    }
    get style() {
        return this._style
    }
    set style(t) {
        this._style !== t && ((t = t || {})instanceof aO ? (this.ownsStyle = !1,
        this._style = t) : t instanceof fP ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"),
        this.ownsStyle = !0,
        this._style = aO.from(t)) : (this.ownsStyle = !0,
        this._style = new aO(t)),
        this.localStyleID = -1,
        this.dirty = !0)
    }
    get text() {
        return this._text
    }
    set text(t) {
        t = String("" === t || null == t ? " " : t),
        t = this.sanitiseText(t),
        this._text !== t && (this._text = t,
        this.dirty = !0)
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._autoResolution = !1,
        this._resolution !== t && (this._resolution = t,
        this.dirty = !0)
    }
    sanitiseText(t) {
        return t.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;")
    }
}
;
let cO, uO = lO;
var hO;
let dO;
var fO;
let pO;
var mO;
let gO;
var yO;
let bO;
var vO;
let wO;
var xO;
uO.defaultDestroyOptions = {
    texture: !0,
    children: !1,
    baseTexture: !0
},
uO.defaultMaxWidth = 2024,
uO.defaultMaxHeight = 2024,
uO.defaultAutoResolution = !0,
(hO = cO || (cO = {})).Blue = "blue",
hO.Green = "green",
hO.Pink = "pink",
hO.Teal = "teal",
hO.Yellow = "yellow",
hO.Rock = "rock",
hO.Rock2 = "rock-2",
hO.Spike = "spike",
hO.Lava = "lava",
hO.Jumper = "jumper",
hO.Jumper2 = "jumper-2",
hO.Grass = "grass",
(fO = dO || (dO = {})).Monster = "monster",
fO.Octopus = "octopus",
fO.Bat = "bat",
fO.Ghost = "ghost",
(mO = pO || (pO = {})).Rocket = "rocket",
mO.Invincibility = "invincibility",
mO.Blackhole = "blackhole",
(yO = gO || (gO = {})).Music1 = "music1",
yO.Music2 = "music2",
yO.Music3 = "music3",
yO.Music4 = "music4",
yO.Music5 = "music5",
yO.Neutral1 = "neutral1",
yO.Neutral2 = "neutral2",
yO.Neutral3 = "neutral3",
yO.Neutral4 = "neutral4",
yO.Neutral5 = "neutral5",
yO.Neutral6 = "neutral6",
yO.Neutral7 = "neutral7",
yO.ItemRocket = "rocket",
yO.ItemInvincibility = "invincibility",
yO.PlatformRock = "rock",
yO.PlatformSpike = "spike",
yO.PlatformJumper = "jumper",
yO.PlatformLava = "lava",
yO.Shoot = "shoot",
yO.Jump = "jump",
yO.BatDeath = "bat-death",
yO.BatIdle = "bat-idle",
yO.GhostDeath = "ghost-death",
yO.GhostIdle = "ghost-idle",
yO.OctopusDeath = "octopus-death",
yO.OctopusIdle = "octopus-idle",
yO.MonsterDeath = "monster-death",
yO.MonsterIdle = "monster-idle",
yO.GameOk = "ok",
yO.GamePlay = "play",
yO.GameWin = "win",
yO.GamePause = "pause",
yO.GameMusicToggle = "music-toggle",
(vO = bO || (bO = {}))[vO.Blue = 1e4] = "Blue",
vO[vO.Green = 2e4] = "Green",
vO[vO.Pink = 4e4] = "Pink",
vO[vO.Teal = 8e4] = "Teal",
vO[vO.Yellow = 1e10] = "Yellow",
(xO = wO || (wO = {}))[xO.Blue = 12376820] = "Blue",
xO[xO.Green = 9627852] = "Green",
xO[xO.Pink = 16295623] = "Pink",
xO[xO.Teal = 12181179] = "Teal",
xO[xO.Yellow = 16113013] = "Yellow",
xO[xO.DarkBlue = 2129350] = "DarkBlue",
xO[xO.DarkGreen = 820060] = "DarkGreen",
xO[xO.DarkPink = 11875979] = "DarkPink",
xO[xO.DarkTeal = 4688715] = "DarkTeal",
xO[xO.DarkYellow = 13347352] = "DarkYellow";
var EO = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== n ? n : "undefined" != typeof self ? self : {};
function _O(t, e) {
    return t(e = {
        exports: {}
    }, e.exports),
    e.exports
}
var AO = _O((function(t, e) {
    (function() {
        var e;
        e = {
            linear: function(t, e, n, r) {
                return n * t / r + e
            },
            easeInQuad: function(t, e, n, r) {
                return n * (t /= r) * t + e
            },
            easeOutQuad: function(t, e, n, r) {
                return -n * (t /= r) * (t - 2) + e
            },
            easeInOutQuad: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * t * t + e : -n / 2 * (--t * (t - 2) - 1) + e
            },
            easeInCubic: function(t, e, n, r) {
                return n * (t /= r) * t * t + e
            },
            easeOutCubic: function(t, e, n, r) {
                return n * ((t = t / r - 1) * t * t + 1) + e
            },
            easeInOutCubic: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * t * t * t + e : n / 2 * ((t -= 2) * t * t + 2) + e
            },
            easeInQuart: function(t, e, n, r) {
                return n * (t /= r) * t * t * t + e
            },
            easeOutQuart: function(t, e, n, r) {
                return -n * ((t = t / r - 1) * t * t * t - 1) + e
            },
            easeInOutQuart: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * t * t * t * t + e : -n / 2 * ((t -= 2) * t * t * t - 2) + e
            },
            easeInQuint: function(t, e, n, r) {
                return n * (t /= r) * t * t * t * t + e
            },
            easeOutQuint: function(t, e, n, r) {
                return n * ((t = t / r - 1) * t * t * t * t + 1) + e
            },
            easeInOutQuint: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * t * t * t * t * t + e : n / 2 * ((t -= 2) * t * t * t * t + 2) + e
            },
            easeInSine: function(t, e, n, r) {
                return -n * Math.cos(t / r * (Math.PI / 2)) + n + e
            },
            easeOutSine: function(t, e, n, r) {
                return n * Math.sin(t / r * (Math.PI / 2)) + e
            },
            easeInOutSine: function(t, e, n, r) {
                return -n / 2 * (Math.cos(Math.PI * t / r) - 1) + e
            },
            easeInExpo: function(t, e, n, r) {
                return 0 === t ? e : n * Math.pow(2, 10 * (t / r - 1)) + e
            },
            easeOutExpo: function(t, e, n, r) {
                return t === r ? e + n : n * (1 - Math.pow(2, -10 * t / r)) + e
            },
            easeInOutExpo: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? n / 2 * Math.pow(2, 10 * (t - 1)) + e : n / 2 * (2 - Math.pow(2, -10 * --t)) + e
            },
            easeInCirc: function(t, e, n, r) {
                return -n * (Math.sqrt(1 - (t /= r) * t) - 1) + e
            },
            easeOutCirc: function(t, e, n, r) {
                return n * Math.sqrt(1 - (t = t / r - 1) * t) + e
            },
            easeInOutCirc: function(t, e, n, r) {
                return (t /= r / 2) < 1 ? -n / 2 * (Math.sqrt(1 - t * t) - 1) + e : n / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + e
            },
            easeInElastic: function(t, e, n, r) {
                var i, s, o;
                return o = 1.70158,
                0 === t || (t /= r),
                (s = 0) || (s = .3 * r),
                (i = n) < Math.abs(n) ? (i = n,
                o = s / 4) : o = s / (2 * Math.PI) * Math.asin(n / i),
                -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * r - o) * (2 * Math.PI) / s) + e
            },
            easeOutElastic: function(t, e, n, r) {
                var i, s, o;
                return o = 1.70158,
                0 === t || (t /= r),
                (s = 0) || (s = .3 * r),
                (i = n) < Math.abs(n) ? (i = n,
                o = s / 4) : o = s / (2 * Math.PI) * Math.asin(n / i),
                i * Math.pow(2, -10 * t) * Math.sin((t * r - o) * (2 * Math.PI) / s) + n + e
            },
            easeInOutElastic: function(t, e, n, r) {
                var i, s, o;
                return o = 1.70158,
                0 === t || (t /= r / 2),
                (s = 0) || (s = r * (.3 * 1.5)),
                (i = n) < Math.abs(n) ? (i = n,
                o = s / 4) : o = s / (2 * Math.PI) * Math.asin(n / i),
                t < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * r - o) * (2 * Math.PI) / s) * -.5 + e : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * r - o) * (2 * Math.PI) / s) * .5 + n + e
            },
            easeInBack: function(t, e, n, r, i) {
                return void 0 === i && (i = 1.70158),
                n * (t /= r) * t * ((i + 1) * t - i) + e
            },
            easeOutBack: function(t, e, n, r, i) {
                return void 0 === i && (i = 1.70158),
                n * ((t = t / r - 1) * t * ((i + 1) * t + i) + 1) + e
            },
            easeInOutBack: function(t, e, n, r, i) {
                return void 0 === i && (i = 1.70158),
                (t /= r / 2) < 1 ? n / 2 * (t * t * ((1 + (i *= 1.525)) * t - i)) + e : n / 2 * ((t -= 2) * t * ((1 + (i *= 1.525)) * t + i) + 2) + e
            },
            easeInBounce: function(t, n, r, i) {
                return r - e.easeOutBounce(i - t, 0, r, i) + n
            },
            easeOutBounce: function(t, e, n, r) {
                return (t /= r) < 1 / 2.75 ? n * (7.5625 * t * t) + e : t < 2 / 2.75 ? n * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : t < 2.5 / 2.75 ? n * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : n * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e
            },
            easeInOutBounce: function(t, n, r, i) {
                return t < i / 2 ? .5 * e.easeInBounce(2 * t, 0, r, i) + n : .5 * e.easeOutBounce(2 * t - i, 0, r, i) + .5 * r + n
            }
        },
        function(e) {
            t.exports = e
        }(e)
    }
    ).call(EO)
}
))
  , SO = _O((function(t) {
    var e = Object.prototype.hasOwnProperty
      , n = "~";
    function r() {}
    function i(t, e, n) {
        this.fn = t,
        this.context = e,
        this.once = n || !1
    }
    function s(t, e, r, s, o) {
        if ("function" != typeof r)
            throw new TypeError("The listener must be a function");
        var a = new i(r,s || t,o)
          , l = n ? n + e : e;
        return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], a] : t._events[l].push(a) : (t._events[l] = a,
        t._eventsCount++),
        t
    }
    function o(t, e) {
        0 == --t._eventsCount ? t._events = new r : delete t._events[e]
    }
    function a() {
        this._events = new r,
        this._eventsCount = 0
    }
    Object.create && (r.prototype = Object.create(null),
    (new r).__proto__ || (n = !1)),
    a.prototype.eventNames = function() {
        var t, r, i = [];
        if (0 === this._eventsCount)
            return i;
        for (r in t = this._events)
            e.call(t, r) && i.push(n ? r.slice(1) : r);
        return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
    }
    ,
    a.prototype.listeners = function(t) {
        var e = n ? n + t : t
          , r = this._events[e];
        if (!r)
            return [];
        if (r.fn)
            return [r.fn];
        for (var i = 0, s = r.length, o = new Array(s); i < s; i++)
            o[i] = r[i].fn;
        return o
    }
    ,
    a.prototype.listenerCount = function(t) {
        var e = n ? n + t : t
          , r = this._events[e];
        return r ? r.fn ? 1 : r.length : 0
    }
    ,
    a.prototype.emit = function(t, e, r, i, s, o) {
        var a = n ? n + t : t;
        if (!this._events[a])
            return !1;
        var l, c, u = this._events[a], h = arguments.length;
        if (u.fn) {
            switch (u.once && this.removeListener(t, u.fn, void 0, !0),
            h) {
            case 1:
                return u.fn.call(u.context),
                !0;
            case 2:
                return u.fn.call(u.context, e),
                !0;
            case 3:
                return u.fn.call(u.context, e, r),
                !0;
            case 4:
                return u.fn.call(u.context, e, r, i),
                !0;
            case 5:
                return u.fn.call(u.context, e, r, i, s),
                !0;
            case 6:
                return u.fn.call(u.context, e, r, i, s, o),
                !0
            }
            for (c = 1,
            l = new Array(h - 1); c < h; c++)
                l[c - 1] = arguments[c];
            u.fn.apply(u.context, l)
        } else {
            var d, f = u.length;
            for (c = 0; c < f; c++)
                switch (u[c].once && this.removeListener(t, u[c].fn, void 0, !0),
                h) {
                case 1:
                    u[c].fn.call(u[c].context);
                    break;
                case 2:
                    u[c].fn.call(u[c].context, e);
                    break;
                case 3:
                    u[c].fn.call(u[c].context, e, r);
                    break;
                case 4:
                    u[c].fn.call(u[c].context, e, r, i);
                    break;
                default:
                    if (!l)
                        for (d = 1,
                        l = new Array(h - 1); d < h; d++)
                            l[d - 1] = arguments[d];
                    u[c].fn.apply(u[c].context, l)
                }
        }
        return !0
    }
    ,
    a.prototype.on = function(t, e, n) {
        return s(this, t, e, n, !1)
    }
    ,
    a.prototype.once = function(t, e, n) {
        return s(this, t, e, n, !0)
    }
    ,
    a.prototype.removeListener = function(t, e, r, i) {
        var s = n ? n + t : t;
        if (!this._events[s])
            return this;
        if (!e)
            return o(this, s),
            this;
        var a = this._events[s];
        if (a.fn)
            a.fn !== e || i && !a.once || r && a.context !== r || o(this, s);
        else {
            for (var l = 0, c = [], u = a.length; l < u; l++)
                (a[l].fn !== e || i && !a[l].once || r && a[l].context !== r) && c.push(a[l]);
            c.length ? this._events[s] = 1 === c.length ? c[0] : c : o(this, s)
        }
        return this
    }
    ,
    a.prototype.removeAllListeners = function(t) {
        var e;
        return t ? (e = n ? n + t : t,
        this._events[e] && o(this, e)) : (this._events = new r,
        this._eventsCount = 0),
        this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.addListener = a.prototype.on,
    a.prefixed = n,
    a.EventEmitter = a,
    t.exports = a
}
));
class TO extends SO {
    constructor(t, e, n) {
        super(),
        this.elements = Array.isArray(t) ? t : [t],
        this.eases = [],
        this.options = n || {},
        this.time = 0;
        for (let t in e)
            for (let n of this.elements)
                this.addParam(n, t, e[t])
    }
    addParam(t, e, n) {
        let r, i, s, o, a = e;
        switch (e) {
        case "scaleX":
        case "skewX":
            a = e.substr(0, e.length - 1),
            r = t[a].x,
            i = n,
            s = n - r,
            o = t=>this.updateCoord(t, a, "x");
            break;
        case "scaleY":
        case "skewY":
            a = e.substr(0, e.length - 1),
            r = t[a].y,
            i = n,
            s = n - r,
            o = t=>this.updateCoord(t, a, "y");
            break;
        case "tint":
        case "blend":
            const l = Array.isArray(n) ? n : [t.tint, n];
            r = 0,
            i = l.length,
            s = i,
            o = "tint" === e ? t=>this.updateTint(t, l) : t=>this.updateBlend(t, l);
            break;
        case "shake":
            r = {
                x: t.x,
                y: t.y
            },
            i = n,
            o = t=>this.updateShake(t);
            break;
        case "position":
            r = {
                x: t.x,
                y: t.y
            },
            i = {
                x: n.x,
                y: n.y
            },
            s = {
                x: i.x - r.x,
                y: i.y - r.y
            },
            o = t=>this.updatePosition(t);
            break;
        case "skew":
        case "scale":
            r = t[e].x,
            i = n,
            s = n - r,
            o = t=>this.updatePoint(t, e);
            break;
        case "face":
            r = t.rotation,
            i = TO.shortestAngle(r, Math.atan2(n.y - t.y, n.x - t.x)),
            s = i - r,
            o = t=>this.updateOne(t, "rotation");
            break;
        default:
            r = t[e],
            i = n,
            s = n - r,
            o = t=>this.updateOne(t, e)
        }
        this.eases.push({
            element: t,
            entry: e,
            update: o,
            start: r,
            to: i,
            delta: s
        })
    }
    static shortestAngle(t, e) {
        const n = 2 * Math.PI;
        let r = Math.abs(t - e) % n;
        r = r > Math.PI ? n - r : r;
        const i = function(t, e) {
            return (t % e + e) % e
        }(e - t + Math.PI, n) - Math.PI > 0 ? 1 : -1;
        return r * i
    }
    remove(t, e) {
        if (0 === arguments.length)
            this.eases = [];
        else {
            "string" == typeof e && (e = [e]);
            for (let n = 0; n < this.eases.length; n++) {
                const r = this.eases[n];
                t && r.element !== t || e && -1 === e.indexOf(r.entry) || (this.eases.splice(n, 1),
                n--)
            }
        }
        if (0 === this.eases.length)
            return !0
    }
    updateOne(t, e) {
        t.element[e] = this.options.ease(this.time, t.start, t.delta, this.options.duration)
    }
    updatePoint(t, e) {
        t.element[e].x = t.element[e].y = this.options.ease(this.time, t.start, t.delta, this.options.duration)
    }
    updatePosition(t) {
        t.element.x = this.options.ease(this.time, t.start.x, t.delta.x, this.options.duration),
        t.element.y = this.options.ease(this.time, t.start.y, t.delta.y, this.options.duration)
    }
    updateCoord(t, e, n) {
        t.element[e][n] = this.options.ease(this.time, t.start, t.delta, this.options.duration)
    }
    updateTint(t, e) {
        let n = Math.floor(this.options.ease(this.time, t.start, t.delta, this.options.duration));
        n === e.length && (n = e.length - 1),
        t.element.tint = e[n]
    }
    updateBlend(t, e) {
        const n = this.options.ease(this.time, t.start, t.delta, this.options.duration);
        let r = Math.floor(n);
        r === e.length && (r = e.length - 1);
        let i = r + 1;
        i === e.length && (i = this.options.reverse ? r - 1 : this.options.repeat ? 0 : r);
        const s = n - r
          , o = e[r]
          , a = e[i]
          , l = 1 - s
          , c = l * (o >> 16) + s * (a >> 16)
          , u = l * (o >> 8 & 255) + s * (a >> 8 & 255)
          , h = l * (255 & o) + s * (255 & a);
        t.element.tint = c << 16 | u << 8 | h
    }
    updateShake(t) {
        function e(t) {
            return Math.floor(Math.random() * t) - Math.floor(t / 2)
        }
        t.element.x = t.start.x + e(t.to),
        t.element.y = t.start.y + e(t.to)
    }
    complete(t) {
        "shake" === t.entry && (t.element.x = t.start.x,
        t.element.y = t.start.y)
    }
    reverse(t) {
        if ("position" === t.entry) {
            const e = t.to.x
              , n = t.to.y;
            t.to.x = t.start.x,
            t.to.y = t.start.y,
            t.start.x = e,
            t.start.y = n,
            t.delta.x = -t.delta.x,
            t.delta.y = -t.delta.y
        } else {
            const e = t.to;
            t.to = t.start,
            t.start = e,
            t.delta = -t.delta
        }
    }
    repeat(t) {
        switch (t.entry) {
        case "skewX":
            t.element.skew.x = t.start;
            break;
        case "skewY":
            t.element.skew.y = t.start;
            break;
        case "skew":
            t.element.skew.x = t.start,
            t.element.skew.y = t.start;
            break;
        case "scaleX":
            t.element.scale.x = t.start;
            break;
        case "scaleY":
            t.element.scale.y = t.start;
            break;
        case "scale":
            t.element.scale.x = t.start,
            t.element.scale.y = t.start;
            break;
        case "position":
            t.element.x = t.start.x,
            t.element.y = t.start.y;
            break;
        default:
            t.element[t.entry] = t.start
        }
    }
    update(t) {
        if (0 === this.eases.length)
            return !0;
        if (this.options.wait) {
            if (this.options.wait -= t,
            this.options.wait > 0)
                return void this.emit("wait", this);
            t = -this.options.wait,
            this.options.wait = 0,
            this.emit("wait-end", this)
        }
        this.time += t;
        let e = 0;
        this.time >= this.options.duration && (e = this.time - this.options.duration,
        this.time = this.options.duration);
        for (let t = 0; t < this.eases.length; t++) {
            const e = this.eases[t];
            e.element._destroyed ? (this.eases.splice(t, 1),
            t--) : e.update(e)
        }
        if (this.emit("each", this),
        this.time >= this.options.duration)
            if (this.options.reverse)
                this.eases.forEach((t=>this.reverse(t))),
                this.time = e,
                e && this.eases.forEach((t=>t.update(t))),
                this.emit("reverse", this),
                this.options.repeat ? !0 !== this.options.repeat && this.options.repeat-- : this.options.reverse = !1;
            else {
                if (!this.options.repeat)
                    return this.eases.forEach((t=>this.complete(t))),
                    this.emit("complete", this),
                    !0;
                this.eases.forEach((t=>this.repeat(t))),
                this.time = e,
                e && this.eases.forEach((t=>t.update(t))),
                !0 !== this.options.repeat && this.options.repeat--,
                this.emit("repeat", this)
            }
    }
    get count() {
        return this.eases.length
    }
}
const kO = {
    duration: 1e3,
    ease: AO.easeInOutSine,
    maxFrame: 1e3 / 60,
    ticker: null,
    useRAF: !0
};
class IO extends SO {
    constructor(t) {
        super(),
        this.options = Object.assign({}, kO, t),
        this.easings = [],
        this.empty = !0,
        this.options.ticker && this.options.ticker.add(this.update, this)
    }
    destroy() {
        this.removeAll(),
        this.options.useTicker ? this.ticker.remove(this.update, this) : this.options.useRAF && (cancelAnimationFrame(this.handleRAF),
        this.handleRAF = null)
    }
    add(t, e, n) {
        (n = n || {}).duration = void 0 !== n.duration ? n.duration : this.options.duration,
        n.ease = n.ease || this.options.ease,
        "string" == typeof n.ease && (n.ease = AO[n.ease]);
        const r = new TO(t,e,n);
        return this.easings.push(r),
        this.empty && this.options.useRAF && (this.handleRAF = requestAnimationFrame((()=>this.update())),
        this.lastTime = Date.now()),
        this.empty = !1,
        r
    }
    target(t, e, n, r) {
        const i = Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)) / n;
        return (r = r || {}).duration = i,
        this.add(t, {
            x: e.x,
            y: e.y
        }, r)
    }
    face(t, e, n, r) {
        const i = TO.shortestAngle(t.rotation, Math.atan2(e.y - t.y, e.x - t.x))
          , s = Math.abs(i - t.rotation) / n;
        return (r = r || {}).duration = s,
        this.add(t, {
            rotation: i
        }, r)
    }
    removeEase(t, e) {
        for (let n = 0; n < this.easings.length; n++)
            this.easings[n].remove(t, e) && (this.easings.splice(n, 1),
            n--);
        0 === this.easings.length && (this.empty = !0,
        this.options.useRAF && this.handleRAF && (cancelAnimationFrame(this.handleRAF),
        this.handleRAF = null))
    }
    removeAll() {
        this.easings = [],
        this.empty = !0,
        this.options.useRAF && this.handleRAF && (cancelAnimationFrame(this.handleRAF),
        this.handleRAF = null)
    }
    update(t) {
        if (this.options.useTicker)
            t = this.ticker.elapsedMS;
        else if (this.options.useRAF) {
            const e = Date.now();
            t = e - this.lastTime,
            this.lastTime = e
        }
        if (t = Math.min(t, this.options.maxFrame),
        !this.empty) {
            const e = this.easings.slice(0);
            for (let n of e)
                n.update(t) && this.easings.splice(this.easings.indexOf(n), 1);
            this.emit("each", this),
            0 === this.easings.length && (this.empty = !0,
            this.emit("complete", this))
        }
        this.options.useRAF && this.easings.length ? this.handleRAF = requestAnimationFrame((()=>this.update())) : this.handleRAF = null
    }
    get count() {
        return this.easings.length
    }
    countRunning() {
        let t = 0;
        for (let e of this.easings)
            t += e.count;
        return t
    }
    set duration(t) {
        this.options.duration = t
    }
    get duration() {
        return this.options.duration
    }
    set ease(t) {
        this.options.ease = t
    }
    get ease() {
        return this.options.ease
    }
}
IO.id = 0;
let MO = new IO;
IO.ease = MO;
var CO = (t=>(t[t.Region = 0] = "Region",
t[t.BoundingBox = 1] = "BoundingBox",
t[t.Mesh = 2] = "Mesh",
t[t.LinkedMesh = 3] = "LinkedMesh",
t[t.Path = 4] = "Path",
t[t.Point = 5] = "Point",
t[t.Clipping = 6] = "Clipping",
t))(CO || {});
class PO {
    constructor(t, e=new Array, n=0, r=new DataView(t.buffer)) {
        this.strings = e,
        this.index = n,
        this.buffer = r
    }
    readByte() {
        return this.buffer.getInt8(this.index++)
    }
    readUnsignedByte() {
        return this.buffer.getUint8(this.index++)
    }
    readShort() {
        const t = this.buffer.getInt16(this.index);
        return this.index += 2,
        t
    }
    readInt32() {
        const t = this.buffer.getInt32(this.index);
        return this.index += 4,
        t
    }
    readInt(t) {
        let e = this.readByte()
          , n = 127 & e;
        return 0 != (128 & e) && (e = this.readByte(),
        n |= (127 & e) << 7,
        0 != (128 & e) && (e = this.readByte(),
        n |= (127 & e) << 14,
        0 != (128 & e) && (e = this.readByte(),
        n |= (127 & e) << 21,
        0 != (128 & e) && (e = this.readByte(),
        n |= (127 & e) << 28)))),
        t ? n : n >>> 1 ^ -(1 & n)
    }
    readStringRef() {
        const t = this.readInt(!0);
        return 0 == t ? null : this.strings[t - 1]
    }
    readString() {
        let t = this.readInt(!0);
        switch (t) {
        case 0:
            return null;
        case 1:
            return ""
        }
        t--;
        let e = "";
        for (let n = 0; n < t; ) {
            const t = this.readUnsignedByte();
            switch (t >> 4) {
            case 12:
            case 13:
                e += String.fromCharCode((31 & t) << 6 | 63 & this.readByte()),
                n += 2;
                break;
            case 14:
                e += String.fromCharCode((15 & t) << 12 | (63 & this.readByte()) << 6 | 63 & this.readByte()),
                n += 3;
                break;
            default:
                e += String.fromCharCode(t),
                n++
            }
        }
        return e
    }
    readFloat() {
        const t = this.buffer.getFloat32(this.index);
        return this.index += 4,
        t
    }
    readBoolean() {
        return 0 != this.readByte()
    }
}
var OO = (t=>(t[t.setup = 0] = "setup",
t[t.first = 1] = "first",
t[t.replace = 2] = "replace",
t[t.add = 3] = "add",
t))(OO || {})
  , NO = (t=>(t[t.mixIn = 0] = "mixIn",
t[t.mixOut = 1] = "mixOut",
t))(NO || {})
  , RO = (t=>(t[t.Fixed = 0] = "Fixed",
t[t.Percent = 1] = "Percent",
t))(RO || {})
  , DO = (t=>(t[t.Tangent = 0] = "Tangent",
t[t.Chain = 1] = "Chain",
t[t.ChainScale = 2] = "ChainScale",
t))(DO || {})
  , BO = (t=>(t[t.Normal = 0] = "Normal",
t[t.OnlyTranslation = 1] = "OnlyTranslation",
t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection",
t[t.NoScale = 3] = "NoScale",
t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection",
t))(BO || {});
function LO(t) {
    switch (t.toLowerCase()) {
    case "nearest":
        return FO.Nearest;
    case "linear":
        return FO.Linear;
    case "mipmap":
        return FO.MipMap;
    case "mipmapnearestnearest":
        return FO.MipMapNearestNearest;
    case "mipmaplinearnearest":
        return FO.MipMapLinearNearest;
    case "mipmapnearestlinear":
        return FO.MipMapNearestLinear;
    case "mipmaplinearlinear":
        return FO.MipMapLinearLinear;
    default:
        throw new Error(`Unknown texture filter ${t}`)
    }
}
var FO = (t=>(t[t.Nearest = 9728] = "Nearest",
t[t.Linear = 9729] = "Linear",
t[t.MipMap = 9987] = "MipMap",
t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest",
t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest",
t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear",
t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear",
t))(FO || {})
  , jO = (t=>(t[t.MirroredRepeat = 33648] = "MirroredRepeat",
t[t.ClampToEdge = 33071] = "ClampToEdge",
t[t.Repeat = 10497] = "Repeat",
t))(jO || {});
class UO {
    constructor() {
        this.size = null,
        this.names = null,
        this.values = null,
        this.renderObject = null
    }
    get width() {
        const t = this.texture;
        return t.trim ? t.trim.width : t.orig.width
    }
    get height() {
        const t = this.texture;
        return t.trim ? t.trim.height : t.orig.height
    }
    get u() {
        return this.texture._uvs.x0
    }
    get v() {
        return this.texture._uvs.y0
    }
    get u2() {
        return this.texture._uvs.x2
    }
    get v2() {
        return this.texture._uvs.y2
    }
    get offsetX() {
        const t = this.texture;
        return t.trim ? t.trim.x : 0
    }
    get offsetY() {
        return this.spineOffsetY
    }
    get pixiOffsetY() {
        const t = this.texture;
        return t.trim ? t.trim.y : 0
    }
    get spineOffsetY() {
        const t = this.texture;
        return this.originalHeight - this.height - (t.trim ? t.trim.y : 0)
    }
    get originalWidth() {
        return this.texture.orig.width
    }
    get originalHeight() {
        return this.texture.orig.height
    }
    get x() {
        return this.texture.frame.x
    }
    get y() {
        return this.texture.frame.y
    }
    get rotate() {
        return 0 !== this.texture.rotate
    }
    get degrees() {
        return (360 - 45 * this.texture.rotate) % 360
    }
}
class zO {
    constructor() {
        this.x = 0,
        this.y = 0,
        this.width = 0,
        this.height = 0,
        this.offsetX = 0,
        this.offsetY = 0,
        this.originalWidth = 0,
        this.originalHeight = 0,
        this.rotate = 0,
        this.index = 0
    }
}
class VO {
    constructor(t, e, n) {
        this.pages = new Array,
        this.regions = new Array,
        t && this.addSpineAtlas(t, e, n)
    }
    addTexture(t, e) {
        const n = this.pages;
        let r = null;
        for (let t = 0; t < n.length; t++)
            if (n[t].baseTexture === e.baseTexture) {
                r = n[t];
                break
            }
        if (null === r) {
            r = new YO,
            r.name = "texturePage";
            const t = e.baseTexture;
            r.width = t.realWidth,
            r.height = t.realHeight,
            r.baseTexture = t,
            r.minFilter = r.magFilter = FO.Nearest,
            r.uWrap = jO.ClampToEdge,
            r.vWrap = jO.ClampToEdge,
            n.push(r)
        }
        const i = new HO;
        return i.name = t,
        i.page = r,
        i.texture = e,
        i.index = -1,
        this.regions.push(i),
        i
    }
    addTextureHash(t, e) {
        for (const n in t)
            t.hasOwnProperty(n) && this.addTexture(e && -1 !== n.indexOf(".") ? n.substr(0, n.lastIndexOf(".")) : n, t[n])
    }
    addSpineAtlas(t, e, n) {
        return this.load(t, e, n)
    }
    load(t, e, n) {
        if (null == e)
            throw new Error("textureLoader cannot be null.");
        const r = new WO(t)
          , i = new Array(4);
        let s = null;
        const o = {};
        let a = null;
        o.size = ()=>{
            s.width = parseInt(i[1]),
            s.height = parseInt(i[2])
        }
        ,
        o.format = ()=>{}
        ,
        o.filter = ()=>{
            s.minFilter = LO(i[1]),
            s.magFilter = LO(i[2])
        }
        ,
        o.repeat = ()=>{
            -1 != i[1].indexOf("x") && (s.uWrap = jO.Repeat),
            -1 != i[1].indexOf("y") && (s.vWrap = jO.Repeat)
        }
        ,
        o.pma = ()=>{
            s.pma = "true" == i[1]
        }
        ;
        const l = {
            xy: ()=>{
                a.x = parseInt(i[1]),
                a.y = parseInt(i[2])
            }
            ,
            size: ()=>{
                a.width = parseInt(i[1]),
                a.height = parseInt(i[2])
            }
            ,
            bounds: ()=>{
                a.x = parseInt(i[1]),
                a.y = parseInt(i[2]),
                a.width = parseInt(i[3]),
                a.height = parseInt(i[4])
            }
            ,
            offset: ()=>{
                a.offsetX = parseInt(i[1]),
                a.offsetY = parseInt(i[2])
            }
            ,
            orig: ()=>{
                a.originalWidth = parseInt(i[1]),
                a.originalHeight = parseInt(i[2])
            }
            ,
            offsets: ()=>{
                a.offsetX = parseInt(i[1]),
                a.offsetY = parseInt(i[2]),
                a.originalWidth = parseInt(i[3]),
                a.originalHeight = parseInt(i[4])
            }
            ,
            rotate: ()=>{
                const t = i[1];
                let e = 0;
                e = "true" == t.toLocaleLowerCase() ? 6 : "false" == t.toLocaleLowerCase() ? 0 : (720 - parseFloat(t)) % 360 / 45,
                a.rotate = e
            }
            ,
            index: ()=>{
                a.index = parseInt(i[1])
            }
        };
        let c = r.readLine();
        for (; null != c && 0 == c.trim().length; )
            c = r.readLine();
        for (; null != c && 0 != c.trim().length && 0 != r.readEntry(i, c); )
            c = r.readLine();
        const u = ()=>{
            for (; ; ) {
                if (null == c)
                    return n && n(this);
                if (0 == c.trim().length)
                    s = null,
                    c = r.readLine();
                else {
                    if (null === s) {
                        for (s = new YO,
                        s.name = c.trim(); 0 != r.readEntry(i, c = r.readLine()); ) {
                            const t = o[i[0]];
                            t && t()
                        }
                        this.pages.push(s),
                        e(s.name, (t=>{
                            if (null === t)
                                return this.pages.splice(this.pages.indexOf(s), 1),
                                n && n(null);
                            s.baseTexture = t,
                            s.pma && (t.alphaMode = zm.PMA),
                            t.valid || t.setSize(s.width, s.height),
                            s.setFilters(),
                            s.width && s.height || (s.width = t.realWidth,
                            s.height = t.realHeight,
                            s.width && s.height || console.log(`ERROR spine atlas page ${s.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),
                            u()
                        }
                        ));
                        break
                    }
                    {
                        a = new zO;
                        const t = new HO;
                        t.name = c,
                        t.page = s;
                        let e = null
                          , n = null;
                        for (; ; ) {
                            const t = r.readEntry(i, c = r.readLine());
                            if (0 == t)
                                break;
                            const s = l[i[0]];
                            if (s)
                                s();
                            else {
                                null == e && (e = [],
                                n = []),
                                e.push(i[0]);
                                const r = [];
                                for (let e = 0; e < t; e++)
                                    r.push(parseInt(i[e + 1]));
                                n.push(r)
                            }
                        }
                        0 == a.originalWidth && 0 == a.originalHeight && (a.originalWidth = a.width,
                        a.originalHeight = a.height);
                        const o = s.baseTexture.resolution;
                        a.x /= o,
                        a.y /= o,
                        a.width /= o,
                        a.height /= o,
                        a.originalWidth /= o,
                        a.originalHeight /= o,
                        a.offsetX /= o,
                        a.offsetY /= o;
                        const u = a.rotate % 4 != 0
                          , h = new wv(a.x,a.y,u ? a.height : a.width,u ? a.width : a.height)
                          , d = new wv(0,0,a.originalWidth,a.originalHeight)
                          , f = new wv(a.offsetX,a.originalHeight - a.height - a.offsetY,a.width,a.height);
                        t.texture = new Ow(t.page.baseTexture,h,d,f,a.rotate),
                        t.index = a.index,
                        t.texture.updateUvs(),
                        this.regions.push(t)
                    }
                }
            }
        }
        ;
        u()
    }
    findRegion(t) {
        for (let e = 0; e < this.regions.length; e++)
            if (this.regions[e].name == t)
                return this.regions[e];
        return null
    }
    dispose() {
        for (let t = 0; t < this.pages.length; t++)
            this.pages[t].baseTexture.dispose()
    }
}
class WO {
    constructor(t) {
        this.index = 0,
        this.lines = t.split(/\r\n|\r|\n/)
    }
    readLine() {
        return this.index >= this.lines.length ? null : this.lines[this.index++]
    }
    readEntry(t, e) {
        if (null == e)
            return 0;
        if (0 == (e = e.trim()).length)
            return 0;
        const n = e.indexOf(":");
        if (-1 == n)
            return 0;
        t[0] = e.substr(0, n).trim();
        for (let r = 1, i = n + 1; ; r++) {
            const n = e.indexOf(",", i);
            if (-1 == n)
                return t[r] = e.substr(i).trim(),
                r;
            if (t[r] = e.substr(i, n - i).trim(),
            i = n + 1,
            4 == r)
                return 4
        }
    }
}
class YO {
    constructor() {
        this.minFilter = FO.Nearest,
        this.magFilter = FO.Nearest,
        this.uWrap = jO.ClampToEdge,
        this.vWrap = jO.ClampToEdge
    }
    setFilters() {
        const t = this.baseTexture
          , e = this.minFilter;
        e == FO.Linear ? t.scaleMode = Fm.LINEAR : this.minFilter == FO.Nearest ? t.scaleMode = Fm.NEAREST : (t.mipmap = Um.POW2,
        e == FO.MipMapNearestNearest ? t.scaleMode = Fm.NEAREST : t.scaleMode = Fm.LINEAR)
    }
}
class HO extends UO {
}
class $O {
    constructor() {
        this.array = new Array
    }
    add(t) {
        const e = this.contains(t);
        return this.array[0 | t] = 0 | t,
        !e
    }
    contains(t) {
        return null != this.array[0 | t]
    }
    remove(t) {
        this.array[0 | t] = void 0
    }
    clear() {
        this.array.length = 0
    }
}
class GO {
    constructor() {
        this.entries = {},
        this.size = 0
    }
    add(t) {
        const e = this.entries[t];
        return this.entries[t] = !0,
        !e && (this.size++,
        !0)
    }
    addAll(t) {
        const e = this.size;
        for (let e = 0, n = t.length; e < n; e++)
            this.add(t[e]);
        return e != this.size
    }
    contains(t) {
        return this.entries[t]
    }
    clear() {
        this.entries = {},
        this.size = 0
    }
}
const XO = class {
    constructor(t=0, e=0, n=0, r=0) {
        this.r = t,
        this.g = e,
        this.b = n,
        this.a = r
    }
    set(t, e, n, r) {
        return this.r = t,
        this.g = e,
        this.b = n,
        this.a = r,
        this.clamp()
    }
    setFromColor(t) {
        return this.r = t.r,
        this.g = t.g,
        this.b = t.b,
        this.a = t.a,
        this
    }
    setFromString(t) {
        return t = "#" == t.charAt(0) ? t.substr(1) : t,
        this.r = parseInt(t.substr(0, 2), 16) / 255,
        this.g = parseInt(t.substr(2, 2), 16) / 255,
        this.b = parseInt(t.substr(4, 2), 16) / 255,
        this.a = 8 != t.length ? 1 : parseInt(t.substr(6, 2), 16) / 255,
        this
    }
    add(t, e, n, r) {
        return this.r += t,
        this.g += e,
        this.b += n,
        this.a += r,
        this.clamp()
    }
    clamp() {
        return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1),
        this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1),
        this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1),
        this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1),
        this
    }
    static rgba8888ToColor(t, e) {
        t.r = ((4278190080 & e) >>> 24) / 255,
        t.g = ((16711680 & e) >>> 16) / 255,
        t.b = ((65280 & e) >>> 8) / 255,
        t.a = (255 & e) / 255
    }
    static rgb888ToColor(t, e) {
        t.r = ((16711680 & e) >>> 16) / 255,
        t.g = ((65280 & e) >>> 8) / 255,
        t.b = (255 & e) / 255
    }
    static fromString(t) {
        return (new XO).setFromString(t)
    }
}
;
let qO = XO;
qO.WHITE = new XO(1,1,1,1),
qO.RED = new XO(1,0,0,1),
qO.GREEN = new XO(0,1,0,1),
qO.BLUE = new XO(0,0,1,1),
qO.MAGENTA = new XO(1,0,1,1);
const KO = class {
    static clamp(t, e, n) {
        return t < e ? e : t > n ? n : t
    }
    static cosDeg(t) {
        return Math.cos(t * KO.degRad)
    }
    static sinDeg(t) {
        return Math.sin(t * KO.degRad)
    }
    static signum(t) {
        return Math.sign(t)
    }
    static toInt(t) {
        return t > 0 ? Math.floor(t) : Math.ceil(t)
    }
    static cbrt(t) {
        const e = Math.pow(Math.abs(t), 1 / 3);
        return t < 0 ? -e : e
    }
    static randomTriangular(t, e) {
        return KO.randomTriangularWith(t, e, .5 * (t + e))
    }
    static randomTriangularWith(t, e, n) {
        const r = Math.random()
          , i = e - t;
        return r <= (n - t) / i ? t + Math.sqrt(r * i * (n - t)) : e - Math.sqrt((1 - r) * i * (e - n))
    }
    static isPowerOfTwo(t) {
        return t && 0 == (t & t - 1)
    }
}
;
let QO = KO;
QO.PI = 3.1415927,
QO.PI2 = 2 * KO.PI,
QO.radiansToDegrees = 180 / KO.PI,
QO.radDeg = KO.radiansToDegrees,
QO.degreesToRadians = KO.PI / 180,
QO.degRad = KO.degreesToRadians;
class ZO {
    apply(t, e, n) {
        return t + (e - t) * this.applyInternal(n)
    }
}
class JO extends ZO {
    constructor(t) {
        super(),
        this.power = 2,
        this.power = t
    }
    applyInternal(t) {
        return t <= .5 ? Math.pow(2 * t, this.power) / 2 : Math.pow(2 * (t - 1), this.power) / (this.power % 2 == 0 ? -2 : 2) + 1
    }
}
class tN extends JO {
    applyInternal(t) {
        return Math.pow(t - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1
    }
}
const eN = class {
    static arrayCopy(t, e, n, r, i) {
        for (let s = e, o = r; s < e + i; s++,
        o++)
            n[o] = t[s]
    }
    static arrayFill(t, e, n, r) {
        for (let i = e; i < n; i++)
            t[i] = r
    }
    static setArraySize(t, e, n=0) {
        const r = t.length;
        if (r == e)
            return t;
        if (t.length = e,
        r < e)
            for (let i = r; i < e; i++)
                t[i] = n;
        return t
    }
    static ensureArrayCapacity(t, e, n=0) {
        return t.length >= e ? t : eN.setArraySize(t, e, n)
    }
    static newArray(t, e) {
        const n = new Array(t);
        for (let r = 0; r < t; r++)
            n[r] = e;
        return n
    }
    static newFloatArray(t) {
        if (eN.SUPPORTS_TYPED_ARRAYS)
            return new Float32Array(t);
        const e = new Array(t);
        for (let t = 0; t < e.length; t++)
            e[t] = 0;
        return e
    }
    static newShortArray(t) {
        if (eN.SUPPORTS_TYPED_ARRAYS)
            return new Int16Array(t);
        const e = new Array(t);
        for (let t = 0; t < e.length; t++)
            e[t] = 0;
        return e
    }
    static toFloatArray(t) {
        return eN.SUPPORTS_TYPED_ARRAYS ? new Float32Array(t) : t
    }
    static toSinglePrecision(t) {
        return eN.SUPPORTS_TYPED_ARRAYS ? Math.fround(t) : t
    }
    static webkit602BugfixHelper(t, e) {}
    static contains(t, e, n=!0) {
        for (let n = 0; n < t.length; n++)
            if (t[n] == e)
                return !0;
        return !1
    }
    static enumValue(t, e) {
        return t[e[0].toUpperCase() + e.slice(1)]
    }
}
;
let nN = eN;
nN.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array;
class rN {
    constructor(t) {
        this.items = new Array,
        this.instantiator = t
    }
    obtain() {
        return this.items.length > 0 ? this.items.pop() : this.instantiator()
    }
    free(t) {
        t.reset && t.reset(),
        this.items.push(t)
    }
    freeAll(t) {
        for (let e = 0; e < t.length; e++)
            this.free(t[e])
    }
    clear() {
        this.items.length = 0
    }
}
class iN {
    constructor(t=0, e=0) {
        this.x = t,
        this.y = e
    }
    set(t, e) {
        return this.x = t,
        this.y = e,
        this
    }
    length() {
        const t = this.x
          , e = this.y;
        return Math.sqrt(t * t + e * e)
    }
    normalize() {
        const t = this.length();
        return 0 != t && (this.x /= t,
        this.y /= t),
        this
    }
}
class sN {
    constructor() {
        this.minX = 0,
        this.minY = 0,
        this.maxX = 0,
        this.maxY = 0,
        this.boundingBoxes = new Array,
        this.polygons = new Array,
        this.polygonPool = new rN((()=>nN.newFloatArray(16)))
    }
    update(t, e) {
        if (!t)
            throw new Error("skeleton cannot be null.");
        const n = this.boundingBoxes
          , r = this.polygons
          , i = this.polygonPool
          , s = t.slots
          , o = s.length;
        n.length = 0,
        i.freeAll(r),
        r.length = 0;
        for (let t = 0; t < o; t++) {
            const e = s[t];
            if (!e.bone.active)
                continue;
            const o = e.getAttachment();
            if (null != o && o.type === CO.BoundingBox) {
                const t = o;
                n.push(t);
                let s = i.obtain();
                s.length != t.worldVerticesLength && (s = nN.newFloatArray(t.worldVerticesLength)),
                r.push(s),
                t.computeWorldVertices(e, 0, t.worldVerticesLength, s, 0, 2)
            }
        }
        e ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY,
        this.minY = Number.POSITIVE_INFINITY,
        this.maxX = Number.NEGATIVE_INFINITY,
        this.maxY = Number.NEGATIVE_INFINITY)
    }
    aabbCompute() {
        let t = Number.POSITIVE_INFINITY
          , e = Number.POSITIVE_INFINITY
          , n = Number.NEGATIVE_INFINITY
          , r = Number.NEGATIVE_INFINITY;
        const i = this.polygons;
        for (let s = 0, o = i.length; s < o; s++) {
            const o = i[s]
              , a = o;
            for (let i = 0, s = o.length; i < s; i += 2) {
                const s = a[i]
                  , o = a[i + 1];
                t = Math.min(t, s),
                e = Math.min(e, o),
                n = Math.max(n, s),
                r = Math.max(r, o)
            }
        }
        this.minX = t,
        this.minY = e,
        this.maxX = n,
        this.maxY = r
    }
    aabbContainsPoint(t, e) {
        return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
    }
    aabbIntersectsSegment(t, e, n, r) {
        const i = this.minX
          , s = this.minY
          , o = this.maxX
          , a = this.maxY;
        if (t <= i && n <= i || e <= s && r <= s || t >= o && n >= o || e >= a && r >= a)
            return !1;
        const l = (r - e) / (n - t);
        let c = l * (i - t) + e;
        if (c > s && c < a)
            return !0;
        if (c = l * (o - t) + e,
        c > s && c < a)
            return !0;
        let u = (s - e) / l + t;
        return u > i && u < o || (u = (a - e) / l + t,
        u > i && u < o)
    }
    aabbIntersectsSkeleton(t) {
        return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
    }
    containsPoint(t, e) {
        const n = this.polygons;
        for (let r = 0, i = n.length; r < i; r++)
            if (this.containsPointPolygon(n[r], t, e))
                return this.boundingBoxes[r];
        return null
    }
    containsPointPolygon(t, e, n) {
        const r = t
          , i = t.length;
        let s = i - 2
          , o = !1;
        for (let t = 0; t < i; t += 2) {
            const i = r[t + 1]
              , a = r[s + 1];
            if (i < n && a >= n || a < n && i >= n) {
                const l = r[t];
                l + (n - i) / (a - i) * (r[s] - l) < e && (o = !o)
            }
            s = t
        }
        return o
    }
    intersectsSegment(t, e, n, r) {
        const i = this.polygons;
        for (let s = 0, o = i.length; s < o; s++)
            if (this.intersectsSegmentPolygon(i[s], t, e, n, r))
                return this.boundingBoxes[s];
        return null
    }
    intersectsSegmentPolygon(t, e, n, r, i) {
        const s = t
          , o = t.length
          , a = e - r
          , l = n - i
          , c = e * i - n * r;
        let u = s[o - 2]
          , h = s[o - 1];
        for (let t = 0; t < o; t += 2) {
            const o = s[t]
              , d = s[t + 1]
              , f = u * d - h * o
              , p = u - o
              , m = h - d
              , g = a * m - l * p
              , y = (c * p - a * f) / g;
            if ((y >= u && y <= o || y >= o && y <= u) && (y >= e && y <= r || y >= r && y <= e)) {
                const t = (c * m - l * f) / g;
                if ((t >= h && t <= d || t >= d && t <= h) && (t >= n && t <= i || t >= i && t <= n))
                    return !0
            }
            u = o,
            h = d
        }
        return !1
    }
    getPolygon(t) {
        if (!t)
            throw new Error("boundingBox cannot be null.");
        const e = this.boundingBoxes.indexOf(t);
        return -1 == e ? null : this.polygons[e]
    }
    getWidth() {
        return this.maxX - this.minX
    }
    getHeight() {
        return this.maxY - this.minY
    }
}
const oN = {
    yDown: !0,
    FAIL_ON_NON_EXISTING_SKIN: !1,
    GLOBAL_AUTO_UPDATE: !0,
    GLOBAL_DELAY_LIMIT: 0
}
  , aN = [0, 0, 0];
class lN extends lM {
    constructor() {
        super(...arguments),
        this.region = null,
        this.attachment = null
    }
}
class cN extends iP {
    constructor(t, e, n, r, i) {
        super(t, e, n, r, i),
        this.region = null,
        this.attachment = null
    }
}
const uN = class extends EI {
    constructor(t) {
        if (super(),
        !t)
            throw new Error("The spineData param is required.");
        if ("string" == typeof t)
            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
        this.spineData = t,
        this.createSkeleton(t),
        this.slotContainers = [],
        this.tempClipContainers = [];
        for (let t = 0, e = this.skeleton.slots.length; t < e; t++) {
            const e = this.skeleton.slots[t]
              , n = e.getAttachment()
              , r = this.newContainer();
            if (this.slotContainers.push(r),
            this.addChild(r),
            this.tempClipContainers.push(null),
            n)
                if (n.type === CO.Region) {
                    const t = n.name
                      , i = this.createSprite(e, n, t);
                    e.currentSprite = i,
                    e.currentSpriteName = t,
                    r.addChild(i)
                } else if (n.type === CO.Mesh) {
                    const t = this.createMesh(e, n);
                    e.currentMesh = t,
                    e.currentMeshId = n.id,
                    e.currentMeshName = n.name,
                    r.addChild(t)
                } else
                    n.type === CO.Clipping && (this.createGraphics(e, n),
                    r.addChild(e.clippingContainer),
                    r.addChild(e.currentGraphics))
        }
        this.tintRgb = new Float32Array([1, 1, 1]),
        this.autoUpdate = !0,
        this.visible = !0
    }
    get debug() {
        return this._debug
    }
    set debug(t) {
        t != this._debug && (this._debug?.unregisterSpine(this),
        t?.registerSpine(this),
        this._debug = t)
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        t !== this._autoUpdate && (this._autoUpdate = t,
        this.updateTransform = t ? uN.prototype.autoUpdateTransform : EI.prototype.updateTransform)
    }
    get tint() {
        return fg.rgb2hex(this.tintRgb)
    }
    set tint(t) {
        this.tintRgb = fg.hex2rgb(t, this.tintRgb)
    }
    get delayLimit() {
        return (void 0 !== this.localDelayLimit ? this.localDelayLimit : oN.GLOBAL_DELAY_LIMIT) || Number.MAX_VALUE
    }
    update(t) {
        const e = this.delayLimit;
        if (t > e && (t = e),
        this.state.update(t),
        this.state.apply(this.skeleton),
        !this.skeleton)
            return;
        this.skeleton.updateWorldTransform();
        const n = this.skeleton.slots
          , r = this.color;
        let i = null
          , s = null;
        r ? (i = r.light,
        s = r.dark) : i = this.tintRgb;
        for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t]
              , r = e.getAttachment()
              , o = this.slotContainers[t];
            if (!r) {
                o.visible = !1;
                continue
            }
            let a = null;
            r.sequence && r.sequence.apply(e, r);
            let l = r.region;
            const c = r.color;
            switch (null != r && r.type) {
            case CO.Region:
                if (o.transform.setFromMatrix(e.bone.matrix),
                l = r.region,
                e.currentMesh && (e.currentMesh.visible = !1,
                e.currentMesh = null,
                e.currentMeshId = void 0,
                e.currentMeshName = void 0),
                !l) {
                    e.currentSprite && (e.currentSprite.renderable = !1);
                    break
                }
                if (!e.currentSpriteName || e.currentSpriteName !== r.name) {
                    const t = r.name;
                    if (e.currentSprite && (e.currentSprite.visible = !1),
                    e.sprites = e.sprites || {},
                    void 0 !== e.sprites[t])
                        e.sprites[t].visible = !0;
                    else {
                        const n = this.createSprite(e, r, t);
                        o.addChild(n)
                    }
                    e.currentSprite = e.sprites[t],
                    e.currentSpriteName = t
                }
                e.currentSprite.renderable = !0,
                e.hackRegion || this.setSpriteRegion(r, e.currentSprite, l),
                e.currentSprite.color ? a = e.currentSprite.color : (aN[0] = i[0] * e.color.r * c.r,
                aN[1] = i[1] * e.color.g * c.g,
                aN[2] = i[2] * e.color.b * c.b,
                e.currentSprite.tint = fg.rgb2hex(aN)),
                e.currentSprite.blendMode = e.blendMode;
                break;
            case CO.Mesh:
                if (e.currentSprite) {
                    e.currentSprite.visible = !1,
                    e.currentSprite = null,
                    e.currentSpriteName = void 0;
                    const t = new Bv;
                    t._parentID = -1,
                    t._worldID = o.transform._worldID,
                    o.transform = t
                }
                if (!l) {
                    e.currentMesh && (e.currentMesh.renderable = !1);
                    break
                }
                const t = r.id;
                if (void 0 === e.currentMeshId || e.currentMeshId !== t) {
                    const n = t;
                    if (e.currentMesh && (e.currentMesh.visible = !1),
                    e.meshes = e.meshes || {},
                    void 0 !== e.meshes[n])
                        e.meshes[n].visible = !0;
                    else {
                        const t = this.createMesh(e, r);
                        o.addChild(t)
                    }
                    e.currentMesh = e.meshes[n],
                    e.currentMeshName = r.name,
                    e.currentMeshId = n
                }
                e.currentMesh.renderable = !0,
                r.computeWorldVerticesOld(e, e.currentMesh.vertices),
                e.currentMesh.color ? a = e.currentMesh.color : (aN[0] = i[0] * e.color.r * c.r,
                aN[1] = i[1] * e.color.g * c.g,
                aN[2] = i[2] * e.color.b * c.b,
                e.currentMesh.tint = fg.rgb2hex(aN)),
                e.currentMesh.blendMode = e.blendMode,
                e.hackRegion || this.setMeshRegion(r, e.currentMesh, l);
                break;
            case CO.Clipping:
                e.currentGraphics || (this.createGraphics(e, r),
                o.addChild(e.clippingContainer),
                o.addChild(e.currentGraphics)),
                this.updateGraphics(e, r),
                o.alpha = 1,
                o.visible = !0;
                continue;
            default:
                o.visible = !1;
                continue
            }
            if (o.visible = !0,
            a) {
                let t = e.color.r * c.r
                  , n = e.color.g * c.g
                  , r = e.color.b * c.b;
                a.setLight(i[0] * t + s[0] * (1 - t), i[1] * n + s[1] * (1 - n), i[2] * r + s[2] * (1 - r)),
                e.darkColor ? (t = e.darkColor.r,
                n = e.darkColor.g,
                r = e.darkColor.b) : (t = 0,
                n = 0,
                r = 0),
                a.setDark(i[0] * t + s[0] * (1 - t), i[1] * n + s[1] * (1 - n), i[2] * r + s[2] * (1 - r))
            }
            o.alpha = e.color.a
        }
        const o = this.skeleton.drawOrder;
        let a = null
          , l = null;
        for (let t = 0, e = o.length; t < e; t++) {
            const e = n[o[t].data.index]
              , r = this.slotContainers[o[t].data.index];
            if (l || null !== r.parent && r.parent !== this && (r.parent.removeChild(r),
            r.parent = this),
            e.currentGraphics && e.getAttachment())
                l = e.clippingContainer,
                a = e.getAttachment(),
                l.children.length = 0,
                this.children[t] = r,
                a.endSlot === e.data && (a.endSlot = null);
            else if (l) {
                let n = this.tempClipContainers[t];
                n || (n = this.tempClipContainers[t] = this.newContainer(),
                n.visible = !1),
                this.children[t] = n,
                r.parent = null,
                l.addChild(r),
                a.endSlot == e.data && (l.renderable = !0,
                l = null,
                a = null)
            } else
                this.children[t] = r
        }
        this._debug?.renderDebug(this)
    }
    setSpriteRegion(t, e, n) {
        e.attachment === t && e.region === n || (e.region = n,
        e.attachment = t,
        e.texture = n.texture,
        e.rotation = t.rotation * QO.degRad,
        e.position.x = t.x,
        e.position.y = t.y,
        e.alpha = t.color.a,
        n.size ? (e.scale.x = n.size.width / n.originalWidth,
        e.scale.y = -n.size.height / n.originalHeight) : (e.scale.x = t.scaleX * t.width / n.originalWidth,
        e.scale.y = -t.scaleY * t.height / n.originalHeight))
    }
    setMeshRegion(t, e, n) {
        e.attachment === t && e.region === n || (e.region = n,
        e.attachment = t,
        e.texture = n.texture,
        n.texture.updateUvs(),
        e.uvBuffer.update(t.regionUVs))
    }
    autoUpdateTransform() {
        if (oN.GLOBAL_AUTO_UPDATE) {
            this.lastTime = this.lastTime || Date.now();
            const t = .001 * (Date.now() - this.lastTime);
            this.lastTime = Date.now(),
            this.update(t)
        } else
            this.lastTime = 0;
        EI.prototype.updateTransform.call(this)
    }
    createSprite(t, e, n) {
        let r = e.region;
        t.hackAttachment === e && (r = t.hackRegion);
        const i = r ? r.texture : null
          , s = this.newSprite(i);
        return s.anchor.set(.5),
        r && this.setSpriteRegion(e, s, e.region),
        t.sprites = t.sprites || {},
        t.sprites[n] = s,
        s
    }
    createMesh(t, e) {
        let n = e.region;
        t.hackAttachment === e && (n = t.hackRegion,
        t.hackAttachment = null,
        t.hackRegion = null);
        const r = this.newMesh(n ? n.texture : null, new Float32Array(e.regionUVs.length), e.regionUVs, new Uint16Array(e.triangles), Nm.TRIANGLES);
        return void 0 !== r._canvasPadding && (r._canvasPadding = 1.5),
        r.alpha = e.color.a,
        r.region = e.region,
        n && this.setMeshRegion(e, r, n),
        t.meshes = t.meshes || {},
        t.meshes[e.id] = r,
        r
    }
    createGraphics(t, e) {
        const n = this.newGraphics()
          , r = new _v([]);
        return n.clear(),
        n.beginFill(16777215, 1),
        n.drawPolygon(r),
        n.renderable = !1,
        t.currentGraphics = n,
        t.clippingContainer = this.newContainer(),
        t.clippingContainer.mask = t.currentGraphics,
        n
    }
    updateGraphics(t, e) {
        const n = t.currentGraphics.geometry
          , r = n.graphicsData[0].shape.points
          , i = e.worldVerticesLength;
        r.length = i,
        e.computeWorldVertices(t, 0, i, r, 0, 2),
        n.invalidate()
    }
    hackTextureBySlotIndex(t, e=null, n=null) {
        const r = this.skeleton.slots[t];
        if (!r)
            return !1;
        const i = r.getAttachment();
        let s = i.region;
        return e ? (s = new UO,
        s.texture = e,
        s.size = n,
        r.hackRegion = s,
        r.hackAttachment = i) : (r.hackRegion = null,
        r.hackAttachment = null),
        r.currentSprite ? this.setSpriteRegion(i, r.currentSprite, s) : r.currentMesh && this.setMeshRegion(i, r.currentMesh, s),
        !0
    }
    hackTextureBySlotName(t, e=null, n=null) {
        const r = this.skeleton.findSlotIndex(t);
        return -1 != r && this.hackTextureBySlotIndex(r, e, n)
    }
    hackTextureAttachment(t, e, n, r=null) {
        const i = this.skeleton.findSlotIndex(t)
          , s = this.skeleton.getAttachmentByName(t, e);
        s.region.texture = n;
        const o = this.skeleton.slots[i];
        if (!o)
            return !1;
        const a = o.getAttachment();
        if (e === a.name) {
            let t = s.region;
            return n ? (t = new UO,
            t.texture = n,
            t.size = r,
            o.hackRegion = t,
            o.hackAttachment = a) : (o.hackRegion = null,
            o.hackAttachment = null),
            o.currentSprite && o.currentSprite.region != t ? (this.setSpriteRegion(a, o.currentSprite, t),
            o.currentSprite.region = t) : o.currentMesh && o.currentMesh.region != t && this.setMeshRegion(a, o.currentMesh, t),
            !0
        }
        return !1
    }
    newContainer() {
        return new EI
    }
    newSprite(t) {
        return new lN(t)
    }
    newGraphics() {
        return new KC
    }
    newMesh(t, e, n, r, i) {
        return new cN(t,e,n,r,i)
    }
    transformHack() {
        return 1
    }
    hackAttachmentGroups(t, e, n) {
        if (!t)
            return;
        const r = []
          , i = [];
        for (let s = 0, o = this.skeleton.slots.length; s < o; s++) {
            const o = this.skeleton.slots[s]
              , a = o.currentSpriteName || o.currentMeshName || ""
              , l = o.currentSprite || o.currentMesh;
            a.endsWith(t) ? (l.parentGroup = e,
            i.push(l)) : n && l && (l.parentGroup = n,
            r.push(l))
        }
        return [r, i]
    }
    destroy(t) {
        this.debug = null;
        for (let e = 0, n = this.skeleton.slots.length; e < n; e++) {
            const n = this.skeleton.slots[e];
            for (const e in n.meshes)
                n.meshes[e].destroy(t);
            n.meshes = null;
            for (const e in n.sprites)
                n.sprites[e].destroy(t);
            n.sprites = null
        }
        for (let e = 0, n = this.slotContainers.length; e < n; e++)
            this.slotContainers[e].destroy(t);
        this.spineData = null,
        this.skeleton = null,
        this.slotContainers = null,
        this.stateData = null,
        this.state = null,
        this.tempClipContainers = null,
        super.destroy(t)
    }
}
;
let hN = uN;
hN.clippingPolygon = [],
Object.defineProperty(hN.prototype, "visible", {
    get() {
        return this._visible
    },
    set(t) {
        t !== this._visible && (this._visible = t,
        t && (this.lastTime = 0))
    }
});
const dN = {
    extension: Ub.Asset,
    loader: {
        extension: {
            type: Ub.LoadParser,
            priority: NE.Normal
        },
        test: t=>SE(t, ".atlas"),
        async load(t) {
            const e = await Xm.ADAPTER.fetch(t);
            return await e.text()
        },
        testParse(t, e) {
            const n = SE(e.src, ".atlas")
              , r = "string" == typeof t;
            return Promise.resolve(n && r)
        },
        async parse(t, e, n) {
            const r = e.data;
            let i = fg.path.dirname(e.src);
            i && i.lastIndexOf("/") !== i.length - 1 && (i += "/");
            let s = null
              , o = null;
            const a = new Promise(((t,e)=>{
                s = t,
                o = e
            }
            ));
            let l;
            const c = t=>{
                t || o("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load."),
                s(l)
            }
            ;
            if (r.image || r.images) {
                const e = Object.assign(r.image ? {
                    default: r.image
                } : {}, r.images);
                l = new VO(t,((t,n)=>{
                    const r = e[t] || e.default;
                    r && r.baseTexture ? n(r.baseTexture) : n(r)
                }
                ),c)
            } else
                l = new VO(t,fN(n, i, r.imageMetadata),c);
            return await a
        },
        unload(t) {
            t.dispose()
        }
    }
}
  , fN = (t,e,n)=>async(r,i)=>{
    const s = fg.path.normalize([...e.split(fg.path.sep), r].join(fg.path.sep));
    i((await t.load({
        src: s,
        data: n
    })).baseTexture)
}
;
function pN(t) {
    return t.hasOwnProperty("bones")
}
Wb.add(dN);
class mN {
    constructor() {}
    installLoader() {
        const t = this
          , e = {
            extension: Ub.Asset,
            loader: {
                extension: {
                    type: Ub.LoadParser,
                    priority: NE.Normal
                },
                test: t=>SE(t, ".skel"),
                async load(t) {
                    const e = await Xm.ADAPTER.fetch(t);
                    return await e.arrayBuffer()
                },
                testParse(t, e) {
                    const n = SE(e.src, ".json") && pN(t)
                      , r = SE(e.src, ".skel") && t instanceof ArrayBuffer;
                    const i = !1 === e.data?.spineAtlas;
                    return Promise.resolve(n && !i || r)
                },
                async parse(e, n, r) {
                    const i = fg.path.extname(n.src).toLowerCase()
                      , s = fg.path.basename(n.src, i);
                    let o = fg.path.dirname(n.src);
                    o && o.lastIndexOf("/") !== o.length - 1 && (o += "/");
                    let a = null
                      , l = e;
                    SE(n.src, ".json") && pN(e) ? a = t.createJsonParser() : (a = t.createBinaryParser(),
                    l = new Uint8Array(e));
                    const c = n.data || {}
                      , u = c?.spineSkeletonScale ?? null;
                    u && (a.scale = u);
                    const h = c.spineAtlas;
                    if (h && h.pages)
                        return t.parseData(a, h, l);
                    const d = c.atlasRawData;
                    if (d) {
                        let e = null
                          , n = null;
                        const i = new Promise(((t,r)=>{
                            e = t,
                            n = r
                        }
                        ))
                          , s = new VO(d,fN(r, o, c.imageMetadata),(t=>{
                            t || n("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load."),
                            e(s)
                        }
                        ))
                          , u = await i;
                        return t.parseData(a, u, l)
                    }
                    let f = c.spineAtlasFile;
                    f || (f = `${o + s}.atlas`);
                    const p = await r.load({
                        src: f,
                        data: c,
                        alias: c.spineAtlasAlias
                    });
                    return t.parseData(a, p, l)
                }
            }
        };
        return Wb.add(e),
        e
    }
}
var gN = {};
t(gN, "Attachment", (()=>yN)),
t(gN, "VertexAttachment", (()=>vN)),
t(gN, "BoundingBoxAttachment", (()=>wN)),
t(gN, "ClippingAttachment", (()=>xN)),
t(gN, "MeshAttachment", (()=>EN)),
t(gN, "PathAttachment", (()=>_N)),
t(gN, "PointAttachment", (()=>AN)),
t(gN, "RegionAttachment", (()=>kN)),
t(gN, "JitterEffect", (()=>IN)),
t(gN, "SwirlEffect", (()=>CN)),
t(gN, "Animation", (()=>PN)),
t(gN, "AttachmentTimeline", (()=>HN)),
t(gN, "ColorTimeline", (()=>VN)),
t(gN, "CurveTimeline", (()=>RN)),
t(gN, "DeformTimeline", (()=>GN)),
t(gN, "DrawOrderTimeline", (()=>qN)),
t(gN, "EventTimeline", (()=>XN)),
t(gN, "IkConstraintTimeline", (()=>QN)),
t(gN, "PathConstraintMixTimeline", (()=>iR)),
t(gN, "PathConstraintPositionTimeline", (()=>eR)),
t(gN, "PathConstraintSpacingTimeline", (()=>nR)),
t(gN, "RotateTimeline", (()=>BN)),
t(gN, "ScaleTimeline", (()=>jN)),
t(gN, "ShearTimeline", (()=>UN)),
t(gN, "TimelineType", (()=>ON)),
t(gN, "TransformConstraintTimeline", (()=>JN)),
t(gN, "TranslateTimeline", (()=>FN)),
t(gN, "TwoColorTimeline", (()=>YN)),
t(gN, "AnimationState", (()=>oR)),
t(gN, "AnimationStateAdapter", (()=>dR)),
t(gN, "EventQueue", (()=>uR)),
t(gN, "EventType", (()=>hR)),
t(gN, "TrackEntry", (()=>lR)),
t(gN, "AnimationStateData", (()=>pR)),
t(gN, "AtlasAttachmentLoader", (()=>mR)),
t(gN, "Bone", (()=>gR)),
t(gN, "BoneData", (()=>yR)),
t(gN, "ConstraintData", (()=>bR)),
t(gN, "Event", (()=>vR)),
t(gN, "EventData", (()=>wR)),
t(gN, "IkConstraint", (()=>xR)),
t(gN, "IkConstraintData", (()=>ER)),
t(gN, "PathConstraint", (()=>TR)),
t(gN, "PathConstraintData", (()=>_R)),
t(gN, "SpacingMode", (()=>AR)),
t(gN, "Skeleton", (()=>MR)),
t(gN, "SkeletonBinary", (()=>BR)),
t(gN, "SkeletonBounds", (()=>jR)),
t(gN, "SkeletonData", (()=>CR)),
t(gN, "SkeletonJson", (()=>UR)),
t(gN, "Skin", (()=>RR)),
t(gN, "SkinEntry", (()=>NR)),
t(gN, "Slot", (()=>SN)),
t(gN, "SlotData", (()=>PR)),
t(gN, "TransformConstraint", (()=>kR)),
t(gN, "TransformConstraintData", (()=>OR)),
t(gN, "Spine", (()=>VR));
class yN {
    constructor(t) {
        if (null == t)
            throw new Error("name cannot be null.");
        this.name = t
    }
}
const bN = class extends yN {
    constructor(t) {
        super(t),
        this.id = (65535 & bN.nextID++) << 11,
        this.worldVerticesLength = 0,
        this.deformAttachment = this
    }
    computeWorldVerticesOld(t, e) {
        this.computeWorldVertices(t, 0, this.worldVerticesLength, e, 0, 2)
    }
    computeWorldVertices(t, e, n, r, i, s) {
        n = i + (n >> 1) * s;
        const o = t.bone.skeleton
          , a = t.deform;
        let l = this.vertices;
        const c = this.bones;
        if (null == c) {
            a.length > 0 && (l = a);
            const o = t.bone.matrix
              , c = o.tx
              , u = o.ty
              , h = o.a
              , d = o.c
              , f = o.b
              , p = o.d;
            for (let t = e, o = i; o < n; t += 2,
            o += s) {
                const e = l[t]
                  , n = l[t + 1];
                r[o] = e * h + n * d + c,
                r[o + 1] = e * f + n * p + u
            }
            return
        }
        let u = 0
          , h = 0;
        for (let t = 0; t < e; t += 2) {
            const t = c[u];
            u += t + 1,
            h += t
        }
        const d = o.bones;
        if (0 == a.length)
            for (let t = i, e = 3 * h; t < n; t += s) {
                let n = 0
                  , i = 0
                  , s = c[u++];
                for (s += u; u < s; u++,
                e += 3) {
                    const t = d[c[u]].matrix
                      , r = l[e]
                      , s = l[e + 1]
                      , o = l[e + 2];
                    n += (r * t.a + s * t.c + t.tx) * o,
                    i += (r * t.b + s * t.d + t.ty) * o
                }
                r[t] = n,
                r[t + 1] = i
            }
        else {
            const t = a;
            for (let e = i, o = 3 * h, a = h << 1; e < n; e += s) {
                let n = 0
                  , i = 0
                  , s = c[u++];
                for (s += u; u < s; u++,
                o += 3,
                a += 2) {
                    const e = d[c[u]].matrix
                      , r = l[o] + t[a]
                      , s = l[o + 1] + t[a + 1]
                      , h = l[o + 2];
                    n += (r * e.a + s * e.c + e.tx) * h,
                    i += (r * e.b + s * e.d + e.ty) * h
                }
                r[e] = n,
                r[e + 1] = i
            }
        }
    }
    copyTo(t) {
        null != this.bones ? (t.bones = new Array(this.bones.length),
        nN.arrayCopy(this.bones, 0, t.bones, 0, this.bones.length)) : t.bones = null,
        null != this.vertices ? (t.vertices = nN.newFloatArray(this.vertices.length),
        nN.arrayCopy(this.vertices, 0, t.vertices, 0, this.vertices.length)) : t.vertices = null,
        t.worldVerticesLength = this.worldVerticesLength,
        t.deformAttachment = this.deformAttachment
    }
}
;
let vN = bN;
vN.nextID = 0;
class wN extends vN {
    constructor(t) {
        super(t),
        this.type = CO.BoundingBox,
        this.color = new qO(1,1,1,1)
    }
    copy() {
        const t = new wN(this.name);
        return this.copyTo(t),
        t.color.setFromColor(this.color),
        t
    }
}
class xN extends vN {
    constructor(t) {
        super(t),
        this.type = CO.Clipping,
        this.color = new qO(.2275,.2275,.8078,1)
    }
    copy() {
        const t = new xN(this.name);
        return this.copyTo(t),
        t.endSlot = this.endSlot,
        t.color.setFromColor(this.color),
        t
    }
}
class EN extends vN {
    constructor(t) {
        super(t),
        this.type = CO.Mesh,
        this.color = new qO(1,1,1,1),
        this.tempColor = new qO(0,0,0,0)
    }
    getParentMesh() {
        return this.parentMesh
    }
    setParentMesh(t) {
        this.parentMesh = t,
        null != t && (this.bones = t.bones,
        this.vertices = t.vertices,
        this.worldVerticesLength = t.worldVerticesLength,
        this.regionUVs = t.regionUVs,
        this.triangles = t.triangles,
        this.hullLength = t.hullLength,
        this.worldVerticesLength = t.worldVerticesLength)
    }
    copy() {
        if (null != this.parentMesh)
            return this.newLinkedMesh();
        const t = new EN(this.name);
        return t.region = this.region,
        t.path = this.path,
        t.color.setFromColor(this.color),
        this.copyTo(t),
        t.regionUVs = new Float32Array(this.regionUVs.length),
        nN.arrayCopy(this.regionUVs, 0, t.regionUVs, 0, this.regionUVs.length),
        t.triangles = new Array(this.triangles.length),
        nN.arrayCopy(this.triangles, 0, t.triangles, 0, this.triangles.length),
        t.hullLength = this.hullLength,
        null != this.edges && (t.edges = new Array(this.edges.length),
        nN.arrayCopy(this.edges, 0, t.edges, 0, this.edges.length)),
        t.width = this.width,
        t.height = this.height,
        t
    }
    newLinkedMesh() {
        const t = new EN(this.name);
        return t.region = this.region,
        t.path = this.path,
        t.color.setFromColor(this.color),
        t.deformAttachment = this.deformAttachment,
        t.setParentMesh(null != this.parentMesh ? this.parentMesh : this),
        t
    }
}
class _N extends vN {
    constructor(t) {
        super(t),
        this.type = CO.Path,
        this.closed = !1,
        this.constantSpeed = !1,
        this.color = new qO(1,1,1,1)
    }
    copy() {
        const t = new _N(this.name);
        return this.copyTo(t),
        t.lengths = new Array(this.lengths.length),
        nN.arrayCopy(this.lengths, 0, t.lengths, 0, this.lengths.length),
        t.closed = closed,
        t.constantSpeed = this.constantSpeed,
        t.color.setFromColor(this.color),
        t
    }
}
class AN extends vN {
    constructor(t) {
        super(t),
        this.type = CO.Point,
        this.color = new qO(.38,.94,0,1)
    }
    computeWorldPosition(t, e) {
        const n = t.matrix;
        return e.x = this.x * n.a + this.y * n.c + t.worldX,
        e.y = this.x * n.b + this.y * n.d + t.worldY,
        e
    }
    computeWorldRotation(t) {
        const e = t.matrix
          , n = QO.cosDeg(this.rotation)
          , r = QO.sinDeg(this.rotation)
          , i = n * e.a + r * e.c
          , s = n * e.b + r * e.d;
        return Math.atan2(s, i) * QO.radDeg
    }
    copy() {
        const t = new AN(this.name);
        return t.x = this.x,
        t.y = this.y,
        t.rotation = this.rotation,
        t.color.setFromColor(this.color),
        t
    }
}
class SN {
    constructor(t, e) {
        if (this.deform = new Array,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("bone cannot be null.");
        this.data = t,
        this.bone = e,
        this.color = new qO,
        this.darkColor = null == t.darkColor ? null : new qO,
        this.setToSetupPose(),
        this.blendMode = this.data.blendMode
    }
    getAttachment() {
        return this.attachment
    }
    setAttachment(t) {
        this.attachment != t && (this.attachment = t,
        this.attachmentTime = this.bone.skeleton.time,
        this.deform.length = 0)
    }
    setAttachmentTime(t) {
        this.attachmentTime = this.bone.skeleton.time - t
    }
    getAttachmentTime() {
        return this.bone.skeleton.time - this.attachmentTime
    }
    setToSetupPose() {
        this.color.setFromColor(this.data.color),
        null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor),
        null == this.data.attachmentName ? this.attachment = null : (this.attachment = null,
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
    }
}
const TN = class extends yN {
    constructor(t) {
        super(t),
        this.type = CO.Region,
        this.x = 0,
        this.y = 0,
        this.scaleX = 1,
        this.scaleY = 1,
        this.rotation = 0,
        this.width = 0,
        this.height = 0,
        this.color = new qO(1,1,1,1),
        this.offset = nN.newFloatArray(8),
        this.uvs = nN.newFloatArray(8),
        this.tempColor = new qO(1,1,1,1)
    }
    updateOffset() {
        const t = this.width / this.region.originalWidth * this.scaleX
          , e = this.height / this.region.originalHeight * this.scaleY
          , n = -this.width / 2 * this.scaleX + this.region.offsetX * t
          , r = -this.height / 2 * this.scaleY + this.region.offsetY * e
          , i = n + this.region.width * t
          , s = r + this.region.height * e
          , o = this.rotation * Math.PI / 180
          , a = Math.cos(o)
          , l = Math.sin(o)
          , c = n * a + this.x
          , u = n * l
          , h = r * a + this.y
          , d = r * l
          , f = i * a + this.x
          , p = i * l
          , m = s * a + this.y
          , g = s * l
          , y = this.offset;
        y[TN.OX1] = c - d,
        y[TN.OY1] = h + u,
        y[TN.OX2] = c - g,
        y[TN.OY2] = m + u,
        y[TN.OX3] = f - g,
        y[TN.OY3] = m + p,
        y[TN.OX4] = f - d,
        y[TN.OY4] = h + p
    }
    setRegion(t) {
        this.region = t;
        const e = this.uvs;
        t.rotate ? (e[2] = t.u,
        e[3] = t.v2,
        e[4] = t.u,
        e[5] = t.v,
        e[6] = t.u2,
        e[7] = t.v,
        e[0] = t.u2,
        e[1] = t.v2) : (e[0] = t.u,
        e[1] = t.v2,
        e[2] = t.u,
        e[3] = t.v,
        e[4] = t.u2,
        e[5] = t.v,
        e[6] = t.u2,
        e[7] = t.v2)
    }
    computeWorldVertices(t, e, n, r) {
        const i = this.offset
          , s = t instanceof SN ? t.bone.matrix : t.matrix
          , o = s.tx
          , a = s.ty
          , l = s.a
          , c = s.c
          , u = s.b
          , h = s.d;
        let d = 0
          , f = 0;
        d = i[TN.OX1],
        f = i[TN.OY1],
        e[n] = d * l + f * c + o,
        e[n + 1] = d * u + f * h + a,
        n += r,
        d = i[TN.OX2],
        f = i[TN.OY2],
        e[n] = d * l + f * c + o,
        e[n + 1] = d * u + f * h + a,
        n += r,
        d = i[TN.OX3],
        f = i[TN.OY3],
        e[n] = d * l + f * c + o,
        e[n + 1] = d * u + f * h + a,
        n += r,
        d = i[TN.OX4],
        f = i[TN.OY4],
        e[n] = d * l + f * c + o,
        e[n + 1] = d * u + f * h + a
    }
    copy() {
        const t = new TN(this.name);
        return t.region = this.region,
        t.rendererObject = this.rendererObject,
        t.path = this.path,
        t.x = this.x,
        t.y = this.y,
        t.scaleX = this.scaleX,
        t.scaleY = this.scaleY,
        t.rotation = this.rotation,
        t.width = this.width,
        t.height = this.height,
        nN.arrayCopy(this.uvs, 0, t.uvs, 0, 8),
        nN.arrayCopy(this.offset, 0, t.offset, 0, 8),
        t.color.setFromColor(this.color),
        t
    }
}
;
let kN = TN;
kN.OX1 = 0,
kN.OY1 = 1,
kN.OX2 = 2,
kN.OY2 = 3,
kN.OX3 = 4,
kN.OY3 = 5,
kN.OX4 = 6,
kN.OY4 = 7,
kN.X1 = 0,
kN.Y1 = 1,
kN.C1R = 2,
kN.C1G = 3,
kN.C1B = 4,
kN.C1A = 5,
kN.U1 = 6,
kN.V1 = 7,
kN.X2 = 8,
kN.Y2 = 9,
kN.C2R = 10,
kN.C2G = 11,
kN.C2B = 12,
kN.C2A = 13,
kN.U2 = 14,
kN.V2 = 15,
kN.X3 = 16,
kN.Y3 = 17,
kN.C3R = 18,
kN.C3G = 19,
kN.C3B = 20,
kN.C3A = 21,
kN.U3 = 22,
kN.V3 = 23,
kN.X4 = 24,
kN.Y4 = 25,
kN.C4R = 26,
kN.C4G = 27,
kN.C4B = 28,
kN.C4A = 29,
kN.U4 = 30,
kN.V4 = 31;
class IN {
    constructor(t, e) {
        this.jitterX = 0,
        this.jitterY = 0,
        this.jitterX = t,
        this.jitterY = e
    }
    begin(t) {}
    transform(t, e, n, r) {
        t.x += QO.randomTriangular(-this.jitterX, this.jitterY),
        t.y += QO.randomTriangular(-this.jitterX, this.jitterY)
    }
    end() {}
}
const MN = class {
    constructor(t) {
        this.centerX = 0,
        this.centerY = 0,
        this.radius = 0,
        this.angle = 0,
        this.worldX = 0,
        this.worldY = 0,
        this.radius = t
    }
    begin(t) {
        this.worldX = t.x + this.centerX,
        this.worldY = t.y + this.centerY
    }
    transform(t, e, n, r) {
        const i = this.angle * QO.degreesToRadians
          , s = t.x - this.worldX
          , o = t.y - this.worldY
          , a = Math.sqrt(s * s + o * o);
        if (a < this.radius) {
            const e = MN.interpolation.apply(0, i, (this.radius - a) / this.radius)
              , n = Math.cos(e)
              , r = Math.sin(e);
            t.x = n * s - r * o + this.worldX,
            t.y = r * s + n * o + this.worldY
        }
    }
    end() {}
}
;
let CN = MN;
CN.interpolation = new tN(2);
class PN {
    constructor(t, e, n) {
        if (null == t)
            throw new Error("name cannot be null.");
        if (null == e)
            throw new Error("timelines cannot be null.");
        this.name = t,
        this.timelines = e,
        this.timelineIds = [];
        for (let t = 0; t < e.length; t++)
            this.timelineIds[e[t].getPropertyId()] = !0;
        this.duration = n
    }
    hasTimeline(t) {
        return 1 == this.timelineIds[t]
    }
    apply(t, e, n, r, i, s, o, a) {
        if (null == t)
            throw new Error("skeleton cannot be null.");
        r && 0 != this.duration && (n %= this.duration,
        e > 0 && (e %= this.duration));
        const l = this.timelines;
        for (let r = 0, c = l.length; r < c; r++)
            l[r].apply(t, e, n, i, s, o, a)
    }
    static binarySearch(t, e, n=1) {
        let r = 0
          , i = t.length / n - 2;
        if (0 == i)
            return n;
        let s = i >>> 1;
        for (; ; ) {
            if (t[(s + 1) * n] <= e ? r = s + 1 : i = s,
            r == i)
                return (r + 1) * n;
            s = r + i >>> 1
        }
    }
    static linearSearch(t, e, n) {
        for (let r = 0, i = t.length - n; r <= i; r += n)
            if (t[r] > e)
                return r;
        return -1
    }
}
var ON = (t=>(t[t.rotate = 0] = "rotate",
t[t.translate = 1] = "translate",
t[t.scale = 2] = "scale",
t[t.shear = 3] = "shear",
t[t.attachment = 4] = "attachment",
t[t.color = 5] = "color",
t[t.deform = 6] = "deform",
t[t.event = 7] = "event",
t[t.drawOrder = 8] = "drawOrder",
t[t.ikConstraint = 9] = "ikConstraint",
t[t.transformConstraint = 10] = "transformConstraint",
t[t.pathConstraintPosition = 11] = "pathConstraintPosition",
t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing",
t[t.pathConstraintMix = 13] = "pathConstraintMix",
t[t.twoColor = 14] = "twoColor",
t))(ON || {});
const NN = class {
    constructor(t) {
        if (t <= 0)
            throw new Error(`frameCount must be > 0: ${t}`);
        this.curves = nN.newFloatArray((t - 1) * NN.BEZIER_SIZE)
    }
    getFrameCount() {
        return this.curves.length / NN.BEZIER_SIZE + 1
    }
    setLinear(t) {
        this.curves[t * NN.BEZIER_SIZE] = NN.LINEAR
    }
    setStepped(t) {
        this.curves[t * NN.BEZIER_SIZE] = NN.STEPPED
    }
    getCurveType(t) {
        const e = t * NN.BEZIER_SIZE;
        if (e == this.curves.length)
            return NN.LINEAR;
        const n = this.curves[e];
        return n == NN.LINEAR ? NN.LINEAR : n == NN.STEPPED ? NN.STEPPED : NN.BEZIER
    }
    setCurve(t, e, n, r, i) {
        const s = .03 * (2 * -e + r)
          , o = .03 * (2 * -n + i)
          , a = .006 * (3 * (e - r) + 1)
          , l = .006 * (3 * (n - i) + 1);
        let c = 2 * s + a
          , u = 2 * o + l
          , h = .3 * e + s + .16666667 * a
          , d = .3 * n + o + .16666667 * l
          , f = t * NN.BEZIER_SIZE;
        const p = this.curves;
        p[f++] = NN.BEZIER;
        let m = h
          , g = d;
        for (let t = f + NN.BEZIER_SIZE - 1; f < t; f += 2)
            p[f] = m,
            p[f + 1] = g,
            h += c,
            d += u,
            c += a,
            u += l,
            m += h,
            g += d
    }
    getCurvePercent(t, e) {
        e = QO.clamp(e, 0, 1);
        const n = this.curves;
        let r = t * NN.BEZIER_SIZE;
        const i = n[r];
        if (i == NN.LINEAR)
            return e;
        if (i == NN.STEPPED)
            return 0;
        r++;
        let s = 0;
        for (let t = r, i = r + NN.BEZIER_SIZE - 1; r < i; r += 2)
            if (s = n[r],
            s >= e) {
                let i, o;
                return r == t ? (i = 0,
                o = 0) : (i = n[r - 2],
                o = n[r - 1]),
                o + (n[r + 1] - o) * (e - i) / (s - i)
            }
        const o = n[r - 1];
        return o + (1 - o) * (e - s) / (1 - s)
    }
}
;
let RN = NN;
RN.LINEAR = 0,
RN.STEPPED = 1,
RN.BEZIER = 2,
RN.BEZIER_SIZE = 19;
const DN = class extends RN {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t << 1)
    }
    getPropertyId() {
        return 0 + this.boneIndex
    }
    setFrame(t, e, n) {
        t <<= 1,
        this.frames[t] = e,
        this.frames[t + DN.ROTATION] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.bones[this.boneIndex];
        if (!l.active)
            return;
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return void (l.rotation = l.data.rotation);
            case OO.first:
                const t = l.data.rotation - l.rotation;
                l.rotation += (t - 360 * (16384 - (16384.499999999996 - t / 360 | 0))) * i
            }
            return
        }
        if (n >= a[a.length - DN.ENTRIES]) {
            let t = a[a.length + DN.PREV_ROTATION];
            switch (s) {
            case OO.setup:
                l.rotation = l.data.rotation + t * i;
                break;
            case OO.first:
            case OO.replace:
                t += l.data.rotation - l.rotation,
                t -= 360 * (16384 - (16384.499999999996 - t / 360 | 0));
            case OO.add:
                l.rotation += t * i
            }
            return
        }
        const c = PN.binarySearch(a, n, DN.ENTRIES)
          , u = a[c + DN.PREV_ROTATION]
          , h = a[c]
          , d = this.getCurvePercent((c >> 1) - 1, 1 - (n - h) / (a[c + DN.PREV_TIME] - h));
        let f = a[c + DN.ROTATION] - u;
        switch (f = u + (f - 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * d,
        s) {
        case OO.setup:
            l.rotation = l.data.rotation + (f - 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * i;
            break;
        case OO.first:
        case OO.replace:
            f += l.data.rotation - l.rotation;
        case OO.add:
            l.rotation += (f - 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * i
        }
    }
}
;
let BN = DN;
BN.ENTRIES = 2,
BN.PREV_TIME = -2,
BN.PREV_ROTATION = -1,
BN.ROTATION = 1;
const LN = class extends RN {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * LN.ENTRIES)
    }
    getPropertyId() {
        return 16777216 + this.boneIndex
    }
    setFrame(t, e, n, r) {
        t *= LN.ENTRIES,
        this.frames[t] = e,
        this.frames[t + LN.X] = n,
        this.frames[t + LN.Y] = r
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.bones[this.boneIndex];
        if (!l.active)
            return;
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.x = l.data.x,
                void (l.y = l.data.y);
            case OO.first:
                l.x += (l.data.x - l.x) * i,
                l.y += (l.data.y - l.y) * i
            }
            return
        }
        let c = 0
          , u = 0;
        if (n >= a[a.length - LN.ENTRIES])
            c = a[a.length + LN.PREV_X],
            u = a[a.length + LN.PREV_Y];
        else {
            const t = PN.binarySearch(a, n, LN.ENTRIES);
            c = a[t + LN.PREV_X],
            u = a[t + LN.PREV_Y];
            const e = a[t]
              , r = this.getCurvePercent(t / LN.ENTRIES - 1, 1 - (n - e) / (a[t + LN.PREV_TIME] - e));
            c += (a[t + LN.X] - c) * r,
            u += (a[t + LN.Y] - u) * r
        }
        switch (s) {
        case OO.setup:
            l.x = l.data.x + c * i,
            l.y = l.data.y + u * i;
            break;
        case OO.first:
        case OO.replace:
            l.x += (l.data.x + c - l.x) * i,
            l.y += (l.data.y + u - l.y) * i;
            break;
        case OO.add:
            l.x += c * i,
            l.y += u * i
        }
    }
}
;
let FN = LN;
FN.ENTRIES = 3,
FN.PREV_TIME = -3,
FN.PREV_X = -2,
FN.PREV_Y = -1,
FN.X = 1,
FN.Y = 2;
class jN extends FN {
    constructor(t) {
        super(t)
    }
    getPropertyId() {
        return 33554432 + this.boneIndex
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.bones[this.boneIndex];
        if (!l.active)
            return;
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.scaleX = l.data.scaleX,
                void (l.scaleY = l.data.scaleY);
            case OO.first:
                l.scaleX += (l.data.scaleX - l.scaleX) * i,
                l.scaleY += (l.data.scaleY - l.scaleY) * i
            }
            return
        }
        let c = 0
          , u = 0;
        if (n >= a[a.length - jN.ENTRIES])
            c = a[a.length + jN.PREV_X] * l.data.scaleX,
            u = a[a.length + jN.PREV_Y] * l.data.scaleY;
        else {
            const t = PN.binarySearch(a, n, jN.ENTRIES);
            c = a[t + jN.PREV_X],
            u = a[t + jN.PREV_Y];
            const e = a[t]
              , r = this.getCurvePercent(t / jN.ENTRIES - 1, 1 - (n - e) / (a[t + jN.PREV_TIME] - e));
            c = (c + (a[t + jN.X] - c) * r) * l.data.scaleX,
            u = (u + (a[t + jN.Y] - u) * r) * l.data.scaleY
        }
        if (1 == i)
            s == OO.add ? (l.scaleX += c - l.data.scaleX,
            l.scaleY += u - l.data.scaleY) : (l.scaleX = c,
            l.scaleY = u);
        else {
            let t = 0
              , e = 0;
            if (o == NO.mixOut)
                switch (s) {
                case OO.setup:
                    t = l.data.scaleX,
                    e = l.data.scaleY,
                    l.scaleX = t + (Math.abs(c) * QO.signum(t) - t) * i,
                    l.scaleY = e + (Math.abs(u) * QO.signum(e) - e) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = l.scaleX,
                    e = l.scaleY,
                    l.scaleX = t + (Math.abs(c) * QO.signum(t) - t) * i,
                    l.scaleY = e + (Math.abs(u) * QO.signum(e) - e) * i;
                    break;
                case OO.add:
                    t = l.scaleX,
                    e = l.scaleY,
                    l.scaleX = t + (Math.abs(c) * QO.signum(t) - l.data.scaleX) * i,
                    l.scaleY = e + (Math.abs(u) * QO.signum(e) - l.data.scaleY) * i
                }
            else
                switch (s) {
                case OO.setup:
                    t = Math.abs(l.data.scaleX) * QO.signum(c),
                    e = Math.abs(l.data.scaleY) * QO.signum(u),
                    l.scaleX = t + (c - t) * i,
                    l.scaleY = e + (u - e) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = Math.abs(l.scaleX) * QO.signum(c),
                    e = Math.abs(l.scaleY) * QO.signum(u),
                    l.scaleX = t + (c - t) * i,
                    l.scaleY = e + (u - e) * i;
                    break;
                case OO.add:
                    t = QO.signum(c),
                    e = QO.signum(u),
                    l.scaleX = Math.abs(l.scaleX) * t + (c - Math.abs(l.data.scaleX) * t) * i,
                    l.scaleY = Math.abs(l.scaleY) * e + (u - Math.abs(l.data.scaleY) * e) * i
                }
        }
    }
}
class UN extends FN {
    constructor(t) {
        super(t)
    }
    getPropertyId() {
        return 50331648 + this.boneIndex
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.bones[this.boneIndex];
        if (!l.active)
            return;
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.shearX = l.data.shearX,
                void (l.shearY = l.data.shearY);
            case OO.first:
                l.shearX += (l.data.shearX - l.shearX) * i,
                l.shearY += (l.data.shearY - l.shearY) * i
            }
            return
        }
        let c = 0
          , u = 0;
        if (n >= a[a.length - UN.ENTRIES])
            c = a[a.length + UN.PREV_X],
            u = a[a.length + UN.PREV_Y];
        else {
            const t = PN.binarySearch(a, n, UN.ENTRIES);
            c = a[t + UN.PREV_X],
            u = a[t + UN.PREV_Y];
            const e = a[t]
              , r = this.getCurvePercent(t / UN.ENTRIES - 1, 1 - (n - e) / (a[t + UN.PREV_TIME] - e));
            c += (a[t + UN.X] - c) * r,
            u += (a[t + UN.Y] - u) * r
        }
        switch (s) {
        case OO.setup:
            l.shearX = l.data.shearX + c * i,
            l.shearY = l.data.shearY + u * i;
            break;
        case OO.first:
        case OO.replace:
            l.shearX += (l.data.shearX + c - l.shearX) * i,
            l.shearY += (l.data.shearY + u - l.shearY) * i;
            break;
        case OO.add:
            l.shearX += c * i,
            l.shearY += u * i
        }
    }
}
const zN = class extends RN {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * zN.ENTRIES)
    }
    getPropertyId() {
        return 83886080 + this.slotIndex
    }
    setFrame(t, e, n, r, i, s) {
        t *= zN.ENTRIES,
        this.frames[t] = e,
        this.frames[t + zN.R] = n,
        this.frames[t + zN.G] = r,
        this.frames[t + zN.B] = i,
        this.frames[t + zN.A] = s
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = this.frames;
        if (n < l[0]) {
            switch (s) {
            case OO.setup:
                return void a.color.setFromColor(a.data.color);
            case OO.first:
                const t = a.color
                  , e = a.data.color;
                t.add((e.r - t.r) * i, (e.g - t.g) * i, (e.b - t.b) * i, (e.a - t.a) * i)
            }
            return
        }
        let c = 0
          , u = 0
          , h = 0
          , d = 0;
        if (n >= l[l.length - zN.ENTRIES]) {
            const t = l.length;
            c = l[t + zN.PREV_R],
            u = l[t + zN.PREV_G],
            h = l[t + zN.PREV_B],
            d = l[t + zN.PREV_A]
        } else {
            const t = PN.binarySearch(l, n, zN.ENTRIES);
            c = l[t + zN.PREV_R],
            u = l[t + zN.PREV_G],
            h = l[t + zN.PREV_B],
            d = l[t + zN.PREV_A];
            const e = l[t]
              , r = this.getCurvePercent(t / zN.ENTRIES - 1, 1 - (n - e) / (l[t + zN.PREV_TIME] - e));
            c += (l[t + zN.R] - c) * r,
            u += (l[t + zN.G] - u) * r,
            h += (l[t + zN.B] - h) * r,
            d += (l[t + zN.A] - d) * r
        }
        if (1 == i)
            a.color.set(c, u, h, d);
        else {
            const t = a.color;
            s == OO.setup && t.setFromColor(a.data.color),
            t.add((c - t.r) * i, (u - t.g) * i, (h - t.b) * i, (d - t.a) * i)
        }
    }
}
;
let VN = zN;
VN.ENTRIES = 5,
VN.PREV_TIME = -5,
VN.PREV_R = -4,
VN.PREV_G = -3,
VN.PREV_B = -2,
VN.PREV_A = -1,
VN.R = 1,
VN.G = 2,
VN.B = 3,
VN.A = 4;
const WN = class extends RN {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * WN.ENTRIES)
    }
    getPropertyId() {
        return 234881024 + this.slotIndex
    }
    setFrame(t, e, n, r, i, s, o, a, l) {
        t *= WN.ENTRIES,
        this.frames[t] = e,
        this.frames[t + WN.R] = n,
        this.frames[t + WN.G] = r,
        this.frames[t + WN.B] = i,
        this.frames[t + WN.A] = s,
        this.frames[t + WN.R2] = o,
        this.frames[t + WN.G2] = a,
        this.frames[t + WN.B2] = l
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = this.frames;
        if (n < l[0]) {
            switch (s) {
            case OO.setup:
                return a.color.setFromColor(a.data.color),
                void a.darkColor.setFromColor(a.data.darkColor);
            case OO.first:
                const t = a.color
                  , e = a.darkColor
                  , n = a.data.color
                  , r = a.data.darkColor;
                t.add((n.r - t.r) * i, (n.g - t.g) * i, (n.b - t.b) * i, (n.a - t.a) * i),
                e.add((r.r - e.r) * i, (r.g - e.g) * i, (r.b - e.b) * i, 0)
            }
            return
        }
        let c = 0
          , u = 0
          , h = 0
          , d = 0
          , f = 0
          , p = 0
          , m = 0;
        if (n >= l[l.length - WN.ENTRIES]) {
            const t = l.length;
            c = l[t + WN.PREV_R],
            u = l[t + WN.PREV_G],
            h = l[t + WN.PREV_B],
            d = l[t + WN.PREV_A],
            f = l[t + WN.PREV_R2],
            p = l[t + WN.PREV_G2],
            m = l[t + WN.PREV_B2]
        } else {
            const t = PN.binarySearch(l, n, WN.ENTRIES);
            c = l[t + WN.PREV_R],
            u = l[t + WN.PREV_G],
            h = l[t + WN.PREV_B],
            d = l[t + WN.PREV_A],
            f = l[t + WN.PREV_R2],
            p = l[t + WN.PREV_G2],
            m = l[t + WN.PREV_B2];
            const e = l[t]
              , r = this.getCurvePercent(t / WN.ENTRIES - 1, 1 - (n - e) / (l[t + WN.PREV_TIME] - e));
            c += (l[t + WN.R] - c) * r,
            u += (l[t + WN.G] - u) * r,
            h += (l[t + WN.B] - h) * r,
            d += (l[t + WN.A] - d) * r,
            f += (l[t + WN.R2] - f) * r,
            p += (l[t + WN.G2] - p) * r,
            m += (l[t + WN.B2] - m) * r
        }
        if (1 == i)
            a.color.set(c, u, h, d),
            a.darkColor.set(f, p, m, 1);
        else {
            const t = a.color
              , e = a.darkColor;
            s == OO.setup && (t.setFromColor(a.data.color),
            e.setFromColor(a.data.darkColor)),
            t.add((c - t.r) * i, (u - t.g) * i, (h - t.b) * i, (d - t.a) * i),
            e.add((f - e.r) * i, (p - e.g) * i, (m - e.b) * i, 0)
        }
    }
}
;
let YN = WN;
YN.ENTRIES = 8,
YN.PREV_TIME = -8,
YN.PREV_R = -7,
YN.PREV_G = -6,
YN.PREV_B = -5,
YN.PREV_A = -4,
YN.PREV_R2 = -3,
YN.PREV_G2 = -2,
YN.PREV_B2 = -1,
YN.R = 1,
YN.G = 2,
YN.B = 3,
YN.A = 4,
YN.R2 = 5,
YN.G2 = 6,
YN.B2 = 7;
class HN {
    constructor(t) {
        this.frames = nN.newFloatArray(t),
        this.attachmentNames = new Array(t)
    }
    getPropertyId() {
        return 67108864 + this.slotIndex
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
        this.attachmentNames[t] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        if (o == NO.mixOut)
            return void (s == OO.setup && this.setAttachment(t, a, a.data.attachmentName));
        const l = this.frames;
        if (n < l[0])
            return void (s != OO.setup && s != OO.first || this.setAttachment(t, a, a.data.attachmentName));
        let c = 0;
        c = n >= l[l.length - 1] ? l.length - 1 : PN.binarySearch(l, n, 1) - 1;
        const u = this.attachmentNames[c];
        t.slots[this.slotIndex].setAttachment(null == u ? null : t.getAttachment(this.slotIndex, u))
    }
    setAttachment(t, e, n) {
        e.setAttachment(null == n ? null : t.getAttachment(this.slotIndex, n))
    }
}
let $N = null;
class GN extends RN {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t),
        this.frameVertices = new Array(t),
        null == $N && ($N = nN.newFloatArray(64))
    }
    getPropertyId() {
        return 805306368 + Number(this.attachment.id) + this.slotIndex
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
        this.frameVertices[t] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = a.getAttachment();
        if (!(l instanceof vN) || l.deformAttachment != this.attachment)
            return;
        const c = a.deform;
        0 == c.length && (s = OO.setup);
        const u = this.frameVertices
          , h = u[0].length
          , d = this.frames;
        if (n < d[0]) {
            const t = l;
            switch (s) {
            case OO.setup:
                return void (c.length = 0);
            case OO.first:
                if (1 == i) {
                    c.length = 0;
                    break
                }
                const e = nN.setArraySize(c, h);
                if (null == t.bones) {
                    const n = t.vertices;
                    for (let t = 0; t < h; t++)
                        e[t] += (n[t] - e[t]) * i
                } else {
                    i = 1 - i;
                    for (let t = 0; t < h; t++)
                        e[t] *= i
                }
            }
            return
        }
        const f = nN.setArraySize(c, h);
        if (n >= d[d.length - 1]) {
            const t = u[d.length - 1];
            if (1 == i)
                if (s == OO.add) {
                    const e = l;
                    if (null == e.bones) {
                        const n = e.vertices;
                        for (let e = 0; e < h; e++)
                            f[e] += t[e] - n[e]
                    } else
                        for (let e = 0; e < h; e++)
                            f[e] += t[e]
                } else
                    nN.arrayCopy(t, 0, f, 0, h);
            else
                switch (s) {
                case OO.setup:
                    {
                        const e = l;
                        if (null == e.bones) {
                            const n = e.vertices;
                            for (let e = 0; e < h; e++) {
                                const r = n[e];
                                f[e] = r + (t[e] - r) * i
                            }
                        } else
                            for (let e = 0; e < h; e++)
                                f[e] = t[e] * i;
                        break
                    }
                case OO.first:
                case OO.replace:
                    for (let e = 0; e < h; e++)
                        f[e] += (t[e] - f[e]) * i;
                    break;
                case OO.add:
                    const e = l;
                    if (null == e.bones) {
                        const n = e.vertices;
                        for (let e = 0; e < h; e++)
                            f[e] += (t[e] - n[e]) * i
                    } else
                        for (let e = 0; e < h; e++)
                            f[e] += t[e] * i
                }
            return
        }
        const p = PN.binarySearch(d, n)
          , m = u[p - 1]
          , g = u[p]
          , y = d[p]
          , b = this.getCurvePercent(p - 1, 1 - (n - y) / (d[p - 1] - y));
        if (1 == i)
            if (s == OO.add) {
                const t = l;
                if (null == t.bones) {
                    const e = t.vertices;
                    for (let t = 0; t < h; t++) {
                        const n = m[t];
                        f[t] += n + (g[t] - n) * b - e[t]
                    }
                } else
                    for (let t = 0; t < h; t++) {
                        const e = m[t];
                        f[t] += e + (g[t] - e) * b
                    }
            } else
                for (let t = 0; t < h; t++) {
                    const e = m[t];
                    f[t] = e + (g[t] - e) * b
                }
        else
            switch (s) {
            case OO.setup:
                {
                    const t = l;
                    if (null == t.bones) {
                        const e = t.vertices;
                        for (let t = 0; t < h; t++) {
                            const n = m[t]
                              , r = e[t];
                            f[t] = r + (n + (g[t] - n) * b - r) * i
                        }
                    } else
                        for (let t = 0; t < h; t++) {
                            const e = m[t];
                            f[t] = (e + (g[t] - e) * b) * i
                        }
                    break
                }
            case OO.first:
            case OO.replace:
                for (let t = 0; t < h; t++) {
                    const e = m[t];
                    f[t] += (e + (g[t] - e) * b - f[t]) * i
                }
                break;
            case OO.add:
                const t = l;
                if (null == t.bones) {
                    const e = t.vertices;
                    for (let t = 0; t < h; t++) {
                        const n = m[t];
                        f[t] += (n + (g[t] - n) * b - e[t]) * i
                    }
                } else
                    for (let t = 0; t < h; t++) {
                        const e = m[t];
                        f[t] += (e + (g[t] - e) * b) * i
                    }
            }
    }
}
class XN {
    constructor(t) {
        this.frames = nN.newFloatArray(t),
        this.events = new Array(t)
    }
    getPropertyId() {
        return 117440512
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e) {
        this.frames[t] = e.time,
        this.events[t] = e
    }
    apply(t, e, n, r, i, s, o) {
        if (null == r)
            return;
        const a = this.frames
          , l = this.frames.length;
        if (e > n)
            this.apply(t, e, Number.MAX_VALUE, r, i, s, o),
            e = -1;
        else if (e >= a[l - 1])
            return;
        if (n < a[0])
            return;
        let c = 0;
        if (e < a[0])
            c = 0;
        else {
            c = PN.binarySearch(a, e);
            const t = a[c];
            for (; c > 0 && a[c - 1] == t; )
                c--
        }
        for (; c < l && n >= a[c]; c++)
            r.push(this.events[c])
    }
}
class qN {
    constructor(t) {
        this.frames = nN.newFloatArray(t),
        this.drawOrders = new Array(t)
    }
    getPropertyId() {
        return 134217728
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
        this.drawOrders[t] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.drawOrder
          , l = t.slots;
        if (o == NO.mixOut && s == OO.setup)
            return void nN.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
        const c = this.frames;
        if (n < c[0])
            return void (s != OO.setup && s != OO.first || nN.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length));
        let u = 0;
        u = n >= c[c.length - 1] ? c.length - 1 : PN.binarySearch(c, n) - 1;
        const h = this.drawOrders[u];
        if (null == h)
            nN.arrayCopy(l, 0, a, 0, l.length);
        else
            for (let t = 0, e = h.length; t < e; t++)
                a[t] = l[h[t]]
    }
}
const KN = class extends RN {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * KN.ENTRIES)
    }
    getPropertyId() {
        return 150994944 + this.ikConstraintIndex
    }
    setFrame(t, e, n, r, i, s, o) {
        t *= KN.ENTRIES,
        this.frames[t] = e,
        this.frames[t + KN.MIX] = n,
        this.frames[t + KN.SOFTNESS] = r,
        this.frames[t + KN.BEND_DIRECTION] = i,
        this.frames[t + KN.COMPRESS] = s ? 1 : 0,
        this.frames[t + KN.STRETCH] = o ? 1 : 0
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.ikConstraints[this.ikConstraintIndex];
        if (!l.active)
            return;
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.mix = l.data.mix,
                l.softness = l.data.softness,
                l.bendDirection = l.data.bendDirection,
                l.compress = l.data.compress,
                void (l.stretch = l.data.stretch);
            case OO.first:
                l.mix += (l.data.mix - l.mix) * i,
                l.softness += (l.data.softness - l.softness) * i,
                l.bendDirection = l.data.bendDirection,
                l.compress = l.data.compress,
                l.stretch = l.data.stretch
            }
            return
        }
        if (n >= a[a.length - KN.ENTRIES])
            return void (s == OO.setup ? (l.mix = l.data.mix + (a[a.length + KN.PREV_MIX] - l.data.mix) * i,
            l.softness = l.data.softness + (a[a.length + KN.PREV_SOFTNESS] - l.data.softness) * i,
            o == NO.mixOut ? (l.bendDirection = l.data.bendDirection,
            l.compress = l.data.compress,
            l.stretch = l.data.stretch) : (l.bendDirection = a[a.length + KN.PREV_BEND_DIRECTION],
            l.compress = 0 != a[a.length + KN.PREV_COMPRESS],
            l.stretch = 0 != a[a.length + KN.PREV_STRETCH])) : (l.mix += (a[a.length + KN.PREV_MIX] - l.mix) * i,
            l.softness += (a[a.length + KN.PREV_SOFTNESS] - l.softness) * i,
            o == NO.mixIn && (l.bendDirection = a[a.length + KN.PREV_BEND_DIRECTION],
            l.compress = 0 != a[a.length + KN.PREV_COMPRESS],
            l.stretch = 0 != a[a.length + KN.PREV_STRETCH])));
        const c = PN.binarySearch(a, n, KN.ENTRIES)
          , u = a[c + KN.PREV_MIX]
          , h = a[c + KN.PREV_SOFTNESS]
          , d = a[c]
          , f = this.getCurvePercent(c / KN.ENTRIES - 1, 1 - (n - d) / (a[c + KN.PREV_TIME] - d));
        s == OO.setup ? (l.mix = l.data.mix + (u + (a[c + KN.MIX] - u) * f - l.data.mix) * i,
        l.softness = l.data.softness + (h + (a[c + KN.SOFTNESS] - h) * f - l.data.softness) * i,
        o == NO.mixOut ? (l.bendDirection = l.data.bendDirection,
        l.compress = l.data.compress,
        l.stretch = l.data.stretch) : (l.bendDirection = a[c + KN.PREV_BEND_DIRECTION],
        l.compress = 0 != a[c + KN.PREV_COMPRESS],
        l.stretch = 0 != a[c + KN.PREV_STRETCH])) : (l.mix += (u + (a[c + KN.MIX] - u) * f - l.mix) * i,
        l.softness += (h + (a[c + KN.SOFTNESS] - h) * f - l.softness) * i,
        o == NO.mixIn && (l.bendDirection = a[c + KN.PREV_BEND_DIRECTION],
        l.compress = 0 != a[c + KN.PREV_COMPRESS],
        l.stretch = 0 != a[c + KN.PREV_STRETCH]))
    }
}
;
let QN = KN;
QN.ENTRIES = 6,
QN.PREV_TIME = -6,
QN.PREV_MIX = -5,
QN.PREV_SOFTNESS = -4,
QN.PREV_BEND_DIRECTION = -3,
QN.PREV_COMPRESS = -2,
QN.PREV_STRETCH = -1,
QN.MIX = 1,
QN.SOFTNESS = 2,
QN.BEND_DIRECTION = 3,
QN.COMPRESS = 4,
QN.STRETCH = 5;
const ZN = class extends RN {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * ZN.ENTRIES)
    }
    getPropertyId() {
        return 167772160 + this.transformConstraintIndex
    }
    setFrame(t, e, n, r, i, s) {
        t *= ZN.ENTRIES,
        this.frames[t] = e,
        this.frames[t + ZN.ROTATE] = n,
        this.frames[t + ZN.TRANSLATE] = r,
        this.frames[t + ZN.SCALE] = i,
        this.frames[t + ZN.SHEAR] = s
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.transformConstraints[this.transformConstraintIndex];
        if (!l.active)
            return;
        if (n < a[0]) {
            const t = l.data;
            switch (s) {
            case OO.setup:
                return l.rotateMix = t.rotateMix,
                l.translateMix = t.translateMix,
                l.scaleMix = t.scaleMix,
                void (l.shearMix = t.shearMix);
            case OO.first:
                l.rotateMix += (t.rotateMix - l.rotateMix) * i,
                l.translateMix += (t.translateMix - l.translateMix) * i,
                l.scaleMix += (t.scaleMix - l.scaleMix) * i,
                l.shearMix += (t.shearMix - l.shearMix) * i
            }
            return
        }
        let c = 0
          , u = 0
          , h = 0
          , d = 0;
        if (n >= a[a.length - ZN.ENTRIES]) {
            const t = a.length;
            c = a[t + ZN.PREV_ROTATE],
            u = a[t + ZN.PREV_TRANSLATE],
            h = a[t + ZN.PREV_SCALE],
            d = a[t + ZN.PREV_SHEAR]
        } else {
            const t = PN.binarySearch(a, n, ZN.ENTRIES);
            c = a[t + ZN.PREV_ROTATE],
            u = a[t + ZN.PREV_TRANSLATE],
            h = a[t + ZN.PREV_SCALE],
            d = a[t + ZN.PREV_SHEAR];
            const e = a[t]
              , r = this.getCurvePercent(t / ZN.ENTRIES - 1, 1 - (n - e) / (a[t + ZN.PREV_TIME] - e));
            c += (a[t + ZN.ROTATE] - c) * r,
            u += (a[t + ZN.TRANSLATE] - u) * r,
            h += (a[t + ZN.SCALE] - h) * r,
            d += (a[t + ZN.SHEAR] - d) * r
        }
        if (s == OO.setup) {
            const t = l.data;
            l.rotateMix = t.rotateMix + (c - t.rotateMix) * i,
            l.translateMix = t.translateMix + (u - t.translateMix) * i,
            l.scaleMix = t.scaleMix + (h - t.scaleMix) * i,
            l.shearMix = t.shearMix + (d - t.shearMix) * i
        } else
            l.rotateMix += (c - l.rotateMix) * i,
            l.translateMix += (u - l.translateMix) * i,
            l.scaleMix += (h - l.scaleMix) * i,
            l.shearMix += (d - l.shearMix) * i
    }
}
;
let JN = ZN;
JN.ENTRIES = 5,
JN.PREV_TIME = -5,
JN.PREV_ROTATE = -4,
JN.PREV_TRANSLATE = -3,
JN.PREV_SCALE = -2,
JN.PREV_SHEAR = -1,
JN.ROTATE = 1,
JN.TRANSLATE = 2,
JN.SCALE = 3,
JN.SHEAR = 4;
const tR = class extends RN {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * tR.ENTRIES)
    }
    getPropertyId() {
        return 184549376 + this.pathConstraintIndex
    }
    setFrame(t, e, n) {
        t *= tR.ENTRIES,
        this.frames[t] = e,
        this.frames[t + tR.VALUE] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.pathConstraints[this.pathConstraintIndex];
        if (!l.active)
            return;
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return void (l.position = l.data.position);
            case OO.first:
                l.position += (l.data.position - l.position) * i
            }
            return
        }
        let c = 0;
        if (n >= a[a.length - tR.ENTRIES])
            c = a[a.length + tR.PREV_VALUE];
        else {
            const t = PN.binarySearch(a, n, tR.ENTRIES);
            c = a[t + tR.PREV_VALUE];
            const e = a[t]
              , r = this.getCurvePercent(t / tR.ENTRIES - 1, 1 - (n - e) / (a[t + tR.PREV_TIME] - e));
            c += (a[t + tR.VALUE] - c) * r
        }
        s == OO.setup ? l.position = l.data.position + (c - l.data.position) * i : l.position += (c - l.position) * i
    }
}
;
let eR = tR;
eR.ENTRIES = 2,
eR.PREV_TIME = -2,
eR.PREV_VALUE = -1,
eR.VALUE = 1;
class nR extends eR {
    constructor(t) {
        super(t)
    }
    getPropertyId() {
        return 201326592 + this.pathConstraintIndex
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.pathConstraints[this.pathConstraintIndex];
        if (!l.active)
            return;
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return void (l.spacing = l.data.spacing);
            case OO.first:
                l.spacing += (l.data.spacing - l.spacing) * i
            }
            return
        }
        let c = 0;
        if (n >= a[a.length - nR.ENTRIES])
            c = a[a.length + nR.PREV_VALUE];
        else {
            const t = PN.binarySearch(a, n, nR.ENTRIES);
            c = a[t + nR.PREV_VALUE];
            const e = a[t]
              , r = this.getCurvePercent(t / nR.ENTRIES - 1, 1 - (n - e) / (a[t + nR.PREV_TIME] - e));
            c += (a[t + nR.VALUE] - c) * r
        }
        s == OO.setup ? l.spacing = l.data.spacing + (c - l.data.spacing) * i : l.spacing += (c - l.spacing) * i
    }
}
const rR = class extends RN {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * rR.ENTRIES)
    }
    getPropertyId() {
        return 218103808 + this.pathConstraintIndex
    }
    setFrame(t, e, n, r) {
        t *= rR.ENTRIES,
        this.frames[t] = e,
        this.frames[t + rR.ROTATE] = n,
        this.frames[t + rR.TRANSLATE] = r
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.pathConstraints[this.pathConstraintIndex];
        if (!l.active)
            return;
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.rotateMix = l.data.rotateMix,
                void (l.translateMix = l.data.translateMix);
            case OO.first:
                l.rotateMix += (l.data.rotateMix - l.rotateMix) * i,
                l.translateMix += (l.data.translateMix - l.translateMix) * i
            }
            return
        }
        let c = 0
          , u = 0;
        if (n >= a[a.length - rR.ENTRIES])
            c = a[a.length + rR.PREV_ROTATE],
            u = a[a.length + rR.PREV_TRANSLATE];
        else {
            const t = PN.binarySearch(a, n, rR.ENTRIES);
            c = a[t + rR.PREV_ROTATE],
            u = a[t + rR.PREV_TRANSLATE];
            const e = a[t]
              , r = this.getCurvePercent(t / rR.ENTRIES - 1, 1 - (n - e) / (a[t + rR.PREV_TIME] - e));
            c += (a[t + rR.ROTATE] - c) * r,
            u += (a[t + rR.TRANSLATE] - u) * r
        }
        s == OO.setup ? (l.rotateMix = l.data.rotateMix + (c - l.data.rotateMix) * i,
        l.translateMix = l.data.translateMix + (u - l.data.translateMix) * i) : (l.rotateMix += (c - l.rotateMix) * i,
        l.translateMix += (u - l.translateMix) * i)
    }
}
;
let iR = rR;
iR.ENTRIES = 3,
iR.PREV_TIME = -3,
iR.PREV_ROTATE = -2,
iR.PREV_TRANSLATE = -1,
iR.ROTATE = 1,
iR.TRANSLATE = 2;
const sR = class {
    constructor(t) {
        this.tracks = new Array,
        this.timeScale = 1,
        this.unkeyedState = 0,
        this.events = new Array,
        this.listeners = new Array,
        this.queue = new uR(this),
        this.propertyIDs = new $O,
        this.animationsChanged = !1,
        this.trackEntryPool = new rN((()=>new lR)),
        this.data = t
    }
    update(t) {
        t *= this.timeScale;
        const e = this.tracks;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (null == r)
                continue;
            r.animationLast = r.nextAnimationLast,
            r.trackLast = r.nextTrackLast;
            let i = t * r.timeScale;
            if (r.delay > 0) {
                if (r.delay -= i,
                r.delay > 0)
                    continue;
                i = -r.delay,
                r.delay = 0
            }
            let s = r.next;
            if (null != s) {
                const e = r.trackLast - s.delay;
                if (e >= 0) {
                    for (s.delay = 0,
                    s.trackTime += 0 == r.timeScale ? 0 : (e / r.timeScale + t) * s.timeScale,
                    r.trackTime += i,
                    this.setCurrent(n, s, !0); null != s.mixingFrom; )
                        s.mixTime += t,
                        s = s.mixingFrom;
                    continue
                }
            } else if (r.trackLast >= r.trackEnd && null == r.mixingFrom) {
                e[n] = null,
                this.queue.end(r),
                this.disposeNext(r);
                continue
            }
            if (null != r.mixingFrom && this.updateMixingFrom(r, t)) {
                let t = r.mixingFrom;
                for (r.mixingFrom = null,
                null != t && (t.mixingTo = null); null != t; )
                    this.queue.end(t),
                    t = t.mixingFrom
            }
            r.trackTime += i
        }
        this.queue.drain()
    }
    updateMixingFrom(t, e) {
        const n = t.mixingFrom;
        if (null == n)
            return !0;
        const r = this.updateMixingFrom(n, e);
        return n.animationLast = n.nextAnimationLast,
        n.trackLast = n.nextTrackLast,
        t.mixTime > 0 && t.mixTime >= t.mixDuration ? (0 != n.totalAlpha && 0 != t.mixDuration || (t.mixingFrom = n.mixingFrom,
        null != n.mixingFrom && (n.mixingFrom.mixingTo = t),
        t.interruptAlpha = n.interruptAlpha,
        this.queue.end(n)),
        r) : (n.trackTime += e * n.timeScale,
        t.mixTime += e,
        !1)
    }
    apply(t) {
        if (null == t)
            throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        const e = this.events
          , n = this.tracks;
        let r = !1;
        for (let i = 0, s = n.length; i < s; i++) {
            const s = n[i];
            if (null == s || s.delay > 0)
                continue;
            r = !0;
            const o = 0 == i ? OO.first : s.mixBlend;
            let a = s.alpha;
            null != s.mixingFrom ? a *= this.applyMixingFrom(s, t, o) : s.trackTime >= s.trackEnd && null == s.next && (a = 0);
            const l = s.animationLast
              , c = s.getAnimationTime()
              , u = s.animation.timelines.length
              , h = s.animation.timelines;
            if (0 == i && 1 == a || o == OO.add)
                for (let n = 0; n < u; n++) {
                    nN.webkit602BugfixHelper(a, o);
                    const r = h[n];
                    r instanceof HN ? this.applyAttachmentTimeline(r, t, c, o, !0) : r.apply(t, l, c, e, a, o, NO.mixIn)
                }
            else {
                const n = s.timelineMode
                  , r = 0 == s.timelinesRotation.length;
                r && nN.setArraySize(s.timelinesRotation, u << 1, null);
                const i = s.timelinesRotation;
                for (let s = 0; s < u; s++) {
                    const u = h[s]
                      , d = n[s] == sR.SUBSEQUENT ? o : OO.setup;
                    u instanceof BN ? this.applyRotateTimeline(u, t, c, a, d, i, s << 1, r) : u instanceof HN ? this.applyAttachmentTimeline(u, t, c, o, !0) : (nN.webkit602BugfixHelper(a, o),
                    u.apply(t, l, c, e, a, d, NO.mixIn))
                }
            }
            this.queueEvents(s, c),
            e.length = 0,
            s.nextAnimationLast = c,
            s.nextTrackLast = s.trackTime
        }
        const i = this.unkeyedState + sR.SETUP
          , s = t.slots;
        for (let e = 0, n = t.slots.length; e < n; e++) {
            const n = s[e];
            if (n.attachmentState == i) {
                const e = n.data.attachmentName;
                n.setAttachment(null == e ? null : t.getAttachment(n.data.index, e))
            }
        }
        return this.unkeyedState += 2,
        this.queue.drain(),
        r
    }
    applyMixingFrom(t, e, n) {
        const r = t.mixingFrom;
        null != r.mixingFrom && this.applyMixingFrom(r, e, n);
        let i = 0;
        0 == t.mixDuration ? (i = 1,
        n == OO.first && (n = OO.setup)) : (i = t.mixTime / t.mixDuration,
        i > 1 && (i = 1),
        n != OO.first && (n = r.mixBlend));
        const s = i < r.eventThreshold ? this.events : null
          , o = i < r.attachmentThreshold
          , a = i < r.drawOrderThreshold
          , l = r.animationLast
          , c = r.getAnimationTime()
          , u = r.animation.timelines.length
          , h = r.animation.timelines
          , d = r.alpha * t.interruptAlpha
          , f = d * (1 - i);
        if (n == OO.add)
            for (let t = 0; t < u; t++)
                h[t].apply(e, l, c, s, f, n, NO.mixOut);
        else {
            const t = r.timelineMode
              , i = r.timelineHoldMix
              , p = 0 == r.timelinesRotation.length;
            p && nN.setArraySize(r.timelinesRotation, u << 1, null);
            const m = r.timelinesRotation;
            r.totalAlpha = 0;
            for (let g = 0; g < u; g++) {
                const u = h[g];
                let y, b = NO.mixOut, v = 0;
                switch (t[g]) {
                case sR.SUBSEQUENT:
                    if (!a && u instanceof qN)
                        continue;
                    y = n,
                    v = f;
                    break;
                case sR.FIRST:
                    y = OO.setup,
                    v = f;
                    break;
                case sR.HOLD_SUBSEQUENT:
                    y = n,
                    v = d;
                    break;
                case sR.HOLD_FIRST:
                    y = OO.setup,
                    v = d;
                    break;
                default:
                    y = OO.setup;
                    const t = i[g];
                    v = d * Math.max(0, 1 - t.mixTime / t.mixDuration)
                }
                r.totalAlpha += v,
                u instanceof BN ? this.applyRotateTimeline(u, e, c, v, y, m, g << 1, p) : u instanceof HN ? this.applyAttachmentTimeline(u, e, c, y, o) : (nN.webkit602BugfixHelper(v, n),
                a && u instanceof qN && y == OO.setup && (b = NO.mixIn),
                u.apply(e, l, c, s, v, y, b))
            }
        }
        return t.mixDuration > 0 && this.queueEvents(r, c),
        this.events.length = 0,
        r.nextAnimationLast = c,
        r.nextTrackLast = r.trackTime,
        i
    }
    applyAttachmentTimeline(t, e, n, r, i) {
        const s = e.slots[t.slotIndex];
        if (!s.bone.active)
            return;
        const o = t.frames;
        if (n < o[0])
            r != OO.setup && r != OO.first || this.setAttachment(e, s, s.data.attachmentName, i);
        else {
            let r;
            r = n >= o[o.length - 1] ? o.length - 1 : PN.binarySearch(o, n) - 1,
            this.setAttachment(e, s, t.attachmentNames[r], i)
        }
        s.attachmentState <= this.unkeyedState && (s.attachmentState = this.unkeyedState + sR.SETUP)
    }
    setAttachment(t, e, n, r) {
        e.setAttachment(null == n ? null : t.getAttachment(e.data.index, n)),
        r && (e.attachmentState = this.unkeyedState + sR.CURRENT)
    }
    applyRotateTimeline(t, e, n, r, i, s, o, a) {
        if (a && (s[o] = 0),
        1 == r)
            return void t.apply(e, 0, n, null, 1, i, NO.mixIn);
        const l = t
          , c = l.frames
          , u = e.bones[l.boneIndex];
        if (!u.active)
            return;
        let h = 0
          , d = 0;
        if (n < c[0])
            switch (i) {
            case OO.setup:
                u.rotation = u.data.rotation;
            default:
                return;
            case OO.first:
                h = u.rotation,
                d = u.data.rotation
            }
        else if (h = i == OO.setup ? u.data.rotation : u.rotation,
        n >= c[c.length - BN.ENTRIES])
            d = u.data.rotation + c[c.length + BN.PREV_ROTATION];
        else {
            const t = PN.binarySearch(c, n, BN.ENTRIES)
              , e = c[t + BN.PREV_ROTATION]
              , r = c[t]
              , i = l.getCurvePercent((t >> 1) - 1, 1 - (n - r) / (c[t + BN.PREV_TIME] - r));
            d = c[t + BN.ROTATION] - e,
            d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0)),
            d = e + d * i + u.data.rotation,
            d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0))
        }
        let f = 0
          , p = d - h;
        if (p -= 360 * (16384 - (16384.499999999996 - p / 360 | 0)),
        0 == p)
            f = s[o];
        else {
            let t = 0
              , e = 0;
            a ? (t = 0,
            e = p) : (t = s[o],
            e = s[o + 1]);
            const n = p > 0;
            let r = t >= 0;
            QO.signum(e) != QO.signum(p) && Math.abs(e) <= 90 && (Math.abs(t) > 180 && (t += 360 * QO.signum(t)),
            r = n),
            f = p + t - t % 360,
            r != n && (f += 360 * QO.signum(t)),
            s[o] = f
        }
        s[o + 1] = p,
        h += f * r,
        u.rotation = h - 360 * (16384 - (16384.499999999996 - h / 360 | 0))
    }
    queueEvents(t, e) {
        const n = t.animationStart
          , r = t.animationEnd
          , i = r - n
          , s = t.trackLast % i
          , o = this.events;
        let a = 0;
        const l = o.length;
        for (; a < l; a++) {
            const e = o[a];
            if (e.time < s)
                break;
            e.time > r || this.queue.event(t, e)
        }
        let c = !1;
        for (c = t.loop ? 0 == i || s > t.trackTime % i : e >= r && t.animationLast < r,
        c && this.queue.complete(t); a < l; a++) {
            o[a].time < n || this.queue.event(t, o[a])
        }
    }
    clearTracks() {
        const t = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let t = 0, e = this.tracks.length; t < e; t++)
            this.clearTrack(t);
        this.tracks.length = 0,
        this.queue.drainDisabled = t,
        this.queue.drain()
    }
    clearTrack(t) {
        if (t >= this.tracks.length)
            return;
        const e = this.tracks[t];
        if (null == e)
            return;
        this.queue.end(e),
        this.disposeNext(e);
        let n = e;
        for (; ; ) {
            const t = n.mixingFrom;
            if (null == t)
                break;
            this.queue.end(t),
            n.mixingFrom = null,
            n.mixingTo = null,
            n = t
        }
        this.tracks[e.trackIndex] = null,
        this.queue.drain()
    }
    setCurrent(t, e, n) {
        const r = this.expandToIndex(t);
        this.tracks[t] = e,
        null != r && (n && this.queue.interrupt(r),
        e.mixingFrom = r,
        r.mixingTo = e,
        e.mixTime = 0,
        null != r.mixingFrom && r.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, r.mixTime / r.mixDuration)),
        r.timelinesRotation.length = 0),
        this.queue.start(e)
    }
    setAnimation(t, e, n) {
        const r = this.data.skeletonData.findAnimation(e);
        if (null == r)
            throw new Error(`Animation not found: ${e}`);
        return this.setAnimationWith(t, r, n)
    }
    setAnimationWith(t, e, n) {
        if (null == e)
            throw new Error("animation cannot be null.");
        let r = !0
          , i = this.expandToIndex(t);
        null != i && (-1 == i.nextTrackLast ? (this.tracks[t] = i.mixingFrom,
        this.queue.interrupt(i),
        this.queue.end(i),
        this.disposeNext(i),
        i = i.mixingFrom,
        r = !1) : this.disposeNext(i));
        const s = this.trackEntry(t, e, n, i);
        return this.setCurrent(t, s, r),
        this.queue.drain(),
        s
    }
    addAnimation(t, e, n, r) {
        const i = this.data.skeletonData.findAnimation(e);
        if (null == i)
            throw new Error(`Animation not found: ${e}`);
        return this.addAnimationWith(t, i, n, r)
    }
    addAnimationWith(t, e, n, r) {
        if (null == e)
            throw new Error("animation cannot be null.");
        let i = this.expandToIndex(t);
        if (null != i)
            for (; null != i.next; )
                i = i.next;
        const s = this.trackEntry(t, e, n, i);
        if (null == i)
            this.setCurrent(t, s, !0),
            this.queue.drain();
        else if (i.next = s,
        r <= 0) {
            const t = i.animationEnd - i.animationStart;
            0 != t ? (i.loop ? r += t * (1 + (i.trackTime / t | 0)) : r += Math.max(t, i.trackTime),
            r -= this.data.getMix(i.animation, e)) : r = i.trackTime
        }
        return s.delay = r,
        s
    }
    setEmptyAnimation(t, e) {
        const n = this.setAnimationWith(t, sR.emptyAnimation, !1);
        return n.mixDuration = e,
        n.trackEnd = e,
        n
    }
    addEmptyAnimation(t, e, n) {
        n <= 0 && (n -= e);
        const r = this.addAnimationWith(t, sR.emptyAnimation, !1, n);
        return r.mixDuration = e,
        r.trackEnd = e,
        r
    }
    setEmptyAnimations(t) {
        const e = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let e = 0, n = this.tracks.length; e < n; e++) {
            const n = this.tracks[e];
            null != n && this.setEmptyAnimation(n.trackIndex, t)
        }
        this.queue.drainDisabled = e,
        this.queue.drain()
    }
    expandToIndex(t) {
        return t < this.tracks.length ? this.tracks[t] : (nN.ensureArrayCapacity(this.tracks, t + 1, null),
        this.tracks.length = t + 1,
        null)
    }
    trackEntry(t, e, n, r) {
        const i = this.trackEntryPool.obtain();
        return i.trackIndex = t,
        i.animation = e,
        i.loop = n,
        i.holdPrevious = !1,
        i.eventThreshold = 0,
        i.attachmentThreshold = 0,
        i.drawOrderThreshold = 0,
        i.animationStart = 0,
        i.animationEnd = e.duration,
        i.animationLast = -1,
        i.nextAnimationLast = -1,
        i.delay = 0,
        i.trackTime = 0,
        i.trackLast = -1,
        i.nextTrackLast = -1,
        i.trackEnd = Number.MAX_VALUE,
        i.timeScale = 1,
        i.alpha = 1,
        i.interruptAlpha = 1,
        i.mixTime = 0,
        i.mixDuration = null == r ? 0 : this.data.getMix(r.animation, e),
        i.mixBlend = OO.replace,
        i
    }
    disposeNext(t) {
        let e = t.next;
        for (; null != e; )
            this.queue.dispose(e),
            e = e.next;
        t.next = null
    }
    _animationsChanged() {
        this.animationsChanged = !1,
        this.propertyIDs.clear();
        for (let t = 0, e = this.tracks.length; t < e; t++) {
            let e = this.tracks[t];
            if (null != e) {
                for (; null != e.mixingFrom; )
                    e = e.mixingFrom;
                do {
                    null != e.mixingFrom && e.mixBlend == OO.add || this.computeHold(e),
                    e = e.mixingTo
                } while (null != e)
            }
        }
    }
    computeHold(t) {
        const e = t.mixingTo
          , n = t.animation.timelines
          , r = t.animation.timelines.length
          , i = nN.setArraySize(t.timelineMode, r);
        t.timelineHoldMix.length = 0;
        const s = nN.setArraySize(t.timelineHoldMix, r)
          , o = this.propertyIDs;
        if (null != e && e.holdPrevious)
            for (let t = 0; t < r; t++)
                i[t] = o.add(n[t].getPropertyId()) ? sR.HOLD_FIRST : sR.HOLD_SUBSEQUENT;
        else
            t: for (let a = 0; a < r; a++) {
                const r = n[a]
                  , l = r.getPropertyId();
                if (o.add(l))
                    if (null == e || r instanceof HN || r instanceof qN || r instanceof XN || !e.animation.hasTimeline(l))
                        i[a] = sR.FIRST;
                    else {
                        for (let n = e.mixingTo; null != n; n = n.mixingTo)
                            if (!n.animation.hasTimeline(l)) {
                                if (t.mixDuration > 0) {
                                    i[a] = sR.HOLD_MIX,
                                    s[a] = n;
                                    continue t
                                }
                                break
                            }
                        i[a] = sR.HOLD_FIRST
                    }
                else
                    i[a] = sR.SUBSEQUENT
            }
    }
    getCurrent(t) {
        return t >= this.tracks.length ? null : this.tracks[t]
    }
    addListener(t) {
        if (null == t)
            throw new Error("listener cannot be null.");
        this.listeners.push(t)
    }
    removeListener(t) {
        const e = this.listeners.indexOf(t);
        e >= 0 && this.listeners.splice(e, 1)
    }
    clearListeners() {
        this.listeners.length = 0
    }
    clearListenerNotifications() {
        this.queue.clear()
    }
    setAnimationByName(t, e, n) {
        sR.deprecatedWarning1 || (sR.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),
        this.setAnimation(t, e, n)
    }
    addAnimationByName(t, e, n, r) {
        sR.deprecatedWarning2 || (sR.deprecatedWarning2 = !0,
        console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),
        this.addAnimation(t, e, n, r)
    }
    hasAnimation(t) {
        return null !== this.data.skeletonData.findAnimation(t)
    }
    hasAnimationByName(t) {
        return sR.deprecatedWarning3 || (sR.deprecatedWarning3 = !0,
        console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),
        this.hasAnimation(t)
    }
}
;
let oR = sR;
oR.emptyAnimation = new PN("<empty>",[],0),
oR.SUBSEQUENT = 0,
oR.FIRST = 1,
oR.HOLD_SUBSEQUENT = 2,
oR.HOLD_FIRST = 3,
oR.HOLD_MIX = 4,
oR.SETUP = 1,
oR.CURRENT = 2,
oR.deprecatedWarning1 = !1,
oR.deprecatedWarning2 = !1,
oR.deprecatedWarning3 = !1;
const aR = class {
    constructor() {
        this.mixBlend = OO.replace,
        this.timelineMode = new Array,
        this.timelineHoldMix = new Array,
        this.timelinesRotation = new Array
    }
    reset() {
        this.next = null,
        this.mixingFrom = null,
        this.mixingTo = null,
        this.animation = null,
        this.listener = null,
        this.timelineMode.length = 0,
        this.timelineHoldMix.length = 0,
        this.timelinesRotation.length = 0
    }
    getAnimationTime() {
        if (this.loop) {
            const t = this.animationEnd - this.animationStart;
            return 0 == t ? this.animationStart : this.trackTime % t + this.animationStart
        }
        return Math.min(this.trackTime + this.animationStart, this.animationEnd)
    }
    setAnimationLast(t) {
        this.animationLast = t,
        this.nextAnimationLast = t
    }
    isComplete() {
        return this.trackTime >= this.animationEnd - this.animationStart
    }
    resetRotationDirections() {
        this.timelinesRotation.length = 0
    }
    get time() {
        return aR.deprecatedWarning1 || (aR.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
        this.trackTime
    }
    set time(t) {
        aR.deprecatedWarning1 || (aR.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
        this.trackTime = t
    }
    get endTime() {
        return aR.deprecatedWarning2 || (aR.deprecatedWarning2 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
        this.trackTime
    }
    set endTime(t) {
        aR.deprecatedWarning2 || (aR.deprecatedWarning2 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
        this.trackTime = t
    }
    loopsCount() {
        return Math.floor(this.trackTime / this.trackEnd)
    }
}
;
let lR = aR;
lR.deprecatedWarning1 = !1,
lR.deprecatedWarning2 = !1;
const cR = class {
    constructor(t) {
        this.objects = [],
        this.drainDisabled = !1,
        this.animState = t
    }
    start(t) {
        this.objects.push(hR.start),
        this.objects.push(t),
        this.animState.animationsChanged = !0
    }
    interrupt(t) {
        this.objects.push(hR.interrupt),
        this.objects.push(t)
    }
    end(t) {
        this.objects.push(hR.end),
        this.objects.push(t),
        this.animState.animationsChanged = !0
    }
    dispose(t) {
        this.objects.push(hR.dispose),
        this.objects.push(t)
    }
    complete(t) {
        this.objects.push(hR.complete),
        this.objects.push(t)
    }
    event(t, e) {
        this.objects.push(hR.event),
        this.objects.push(t),
        this.objects.push(e)
    }
    deprecateStuff() {
        return cR.deprecatedWarning1 || (cR.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),
        !0
    }
    drain() {
        if (this.drainDisabled)
            return;
        this.drainDisabled = !0;
        const t = this.objects
          , e = this.animState.listeners;
        for (let n = 0; n < t.length; n += 2) {
            const r = t[n]
              , i = t[n + 1];
            switch (r) {
            case hR.start:
                null != i.listener && i.listener.start && i.listener.start(i);
                for (let t = 0; t < e.length; t++)
                    e[t].start && e[t].start(i);
                i.onStart && this.deprecateStuff() && i.onStart(i.trackIndex),
                this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(i.trackIndex);
                break;
            case hR.interrupt:
                null != i.listener && i.listener.interrupt && i.listener.interrupt(i);
                for (let t = 0; t < e.length; t++)
                    e[t].interrupt && e[t].interrupt(i);
                break;
            case hR.end:
                null != i.listener && i.listener.end && i.listener.end(i);
                for (let t = 0; t < e.length; t++)
                    e[t].end && e[t].end(i);
                i.onEnd && this.deprecateStuff() && i.onEnd(i.trackIndex),
                this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(i.trackIndex);
            case hR.dispose:
                null != i.listener && i.listener.dispose && i.listener.dispose(i);
                for (let t = 0; t < e.length; t++)
                    e[t].dispose && e[t].dispose(i);
                this.animState.trackEntryPool.free(i);
                break;
            case hR.complete:
                null != i.listener && i.listener.complete && i.listener.complete(i);
                for (let t = 0; t < e.length; t++)
                    e[t].complete && e[t].complete(i);
                const r = QO.toInt(i.loopsCount());
                i.onComplete && this.deprecateStuff() && i.onComplete(i.trackIndex, r),
                this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(i.trackIndex, r);
                break;
            case hR.event:
                const s = t[2 + n++];
                null != i.listener && i.listener.event && i.listener.event(i, s);
                for (let t = 0; t < e.length; t++)
                    e[t].event && e[t].event(i, s);
                i.onEvent && this.deprecateStuff() && i.onEvent(i.trackIndex, s),
                this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(i.trackIndex, s)
            }
        }
        this.clear(),
        this.drainDisabled = !1
    }
    clear() {
        this.objects.length = 0
    }
}
;
let uR = cR;
uR.deprecatedWarning1 = !1;
var hR = (t=>(t[t.start = 0] = "start",
t[t.interrupt = 1] = "interrupt",
t[t.end = 2] = "end",
t[t.dispose = 3] = "dispose",
t[t.complete = 4] = "complete",
t[t.event = 5] = "event",
t))(hR || {});
class dR {
    start(t) {}
    interrupt(t) {}
    end(t) {}
    dispose(t) {}
    complete(t) {}
    event(t, e) {}
}
const fR = class {
    constructor(t) {
        if (this.animationToMixTime = {},
        this.defaultMix = 0,
        null == t)
            throw new Error("skeletonData cannot be null.");
        this.skeletonData = t
    }
    setMix(t, e, n) {
        const r = this.skeletonData.findAnimation(t);
        if (null == r)
            throw new Error(`Animation not found: ${t}`);
        const i = this.skeletonData.findAnimation(e);
        if (null == i)
            throw new Error(`Animation not found: ${e}`);
        this.setMixWith(r, i, n)
    }
    setMixByName(t, e, n) {
        fR.deprecatedWarning1 || (fR.deprecatedWarning1 = !0,
        console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),
        this.setMix(t, e, n)
    }
    setMixWith(t, e, n) {
        if (null == t)
            throw new Error("from cannot be null.");
        if (null == e)
            throw new Error("to cannot be null.");
        const r = `${t.name}.${e.name}`;
        this.animationToMixTime[r] = n
    }
    getMix(t, e) {
        const n = `${t.name}.${e.name}`
          , r = this.animationToMixTime[n];
        return void 0 === r ? this.defaultMix : r
    }
}
;
let pR = fR;
pR.deprecatedWarning1 = !1;
class mR {
    constructor(t) {
        this.atlas = t
    }
    newRegionAttachment(t, e, n) {
        const r = this.atlas.findRegion(n);
        if (null == r)
            throw new Error(`Region not found in atlas: ${n} (region attachment: ${e})`);
        const i = new kN(e);
        return i.region = r,
        i
    }
    newMeshAttachment(t, e, n) {
        const r = this.atlas.findRegion(n);
        if (null == r)
            throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${e})`);
        const i = new EN(e);
        return i.region = r,
        i
    }
    newBoundingBoxAttachment(t, e) {
        return new wN(e)
    }
    newPathAttachment(t, e) {
        return new _N(e)
    }
    newPointAttachment(t, e) {
        return new AN(e)
    }
    newClippingAttachment(t, e) {
        return new xN(e)
    }
}
class gR {
    constructor(t, e, n) {
        if (this.matrix = new Sv,
        this.children = new Array,
        this.x = 0,
        this.y = 0,
        this.rotation = 0,
        this.scaleX = 0,
        this.scaleY = 0,
        this.shearX = 0,
        this.shearY = 0,
        this.ax = 0,
        this.ay = 0,
        this.arotation = 0,
        this.ascaleX = 0,
        this.ascaleY = 0,
        this.ashearX = 0,
        this.ashearY = 0,
        this.appliedValid = !1,
        this.sorted = !1,
        this.active = !1,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.skeleton = e,
        this.parent = n,
        this.setToSetupPose()
    }
    get worldX() {
        return this.matrix.tx
    }
    get worldY() {
        return this.matrix.ty
    }
    isActive() {
        return this.active
    }
    update() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
    }
    updateWorldTransform() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
    }
    updateWorldTransformWith(t, e, n, r, i, s, o) {
        this.ax = t,
        this.ay = e,
        this.arotation = n,
        this.ascaleX = r,
        this.ascaleY = i,
        this.ashearX = s,
        this.ashearY = o,
        this.appliedValid = !0;
        const a = this.parent
          , l = this.matrix
          , c = this.skeleton.scaleX
          , u = oN.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
        if (null == a) {
            const a = this.skeleton
              , h = n + 90 + o;
            return l.a = QO.cosDeg(n + s) * r * c,
            l.c = QO.cosDeg(h) * i * c,
            l.b = QO.sinDeg(n + s) * r * u,
            l.d = QO.sinDeg(h) * i * u,
            l.tx = t * c + a.x,
            void (l.ty = e * u + a.y)
        }
        let h = a.matrix.a
          , d = a.matrix.c
          , f = a.matrix.b
          , p = a.matrix.d;
        switch (l.tx = h * t + d * e + a.matrix.tx,
        l.ty = f * t + p * e + a.matrix.ty,
        this.data.transformMode) {
        case BO.Normal:
            {
                const t = n + 90 + o
                  , e = QO.cosDeg(n + s) * r
                  , a = QO.cosDeg(t) * i
                  , c = QO.sinDeg(n + s) * r
                  , u = QO.sinDeg(t) * i;
                return l.a = h * e + d * c,
                l.c = h * a + d * u,
                l.b = f * e + p * c,
                void (l.d = f * a + p * u)
            }
        case BO.OnlyTranslation:
            {
                const t = n + 90 + o;
                l.a = QO.cosDeg(n + s) * r,
                l.c = QO.cosDeg(t) * i,
                l.b = QO.sinDeg(n + s) * r,
                l.d = QO.sinDeg(t) * i;
                break
            }
        case BO.NoRotationOrReflection:
            {
                let t = h * h + f * f
                  , e = 0;
                t > 1e-4 ? (t = Math.abs(h * p - d * f) / t,
                h /= this.skeleton.scaleX,
                f /= this.skeleton.scaleY,
                d = f * t,
                p = h * t,
                e = Math.atan2(f, h) * QO.radDeg) : (h = 0,
                f = 0,
                e = 90 - Math.atan2(p, d) * QO.radDeg);
                const a = n + s - e
                  , c = n + o - e + 90
                  , u = QO.cosDeg(a) * r
                  , m = QO.cosDeg(c) * i
                  , g = QO.sinDeg(a) * r
                  , y = QO.sinDeg(c) * i;
                l.a = h * u - d * g,
                l.c = h * m - d * y,
                l.b = f * u + p * g,
                l.d = f * m + p * y;
                break
            }
        case BO.NoScale:
        case BO.NoScaleOrReflection:
            {
                const t = QO.cosDeg(n)
                  , e = QO.sinDeg(n);
                let a = (h * t + d * e) / c
                  , m = (f * t + p * e) / u
                  , g = Math.sqrt(a * a + m * m);
                g > 1e-5 && (g = 1 / g),
                a *= g,
                m *= g,
                g = Math.sqrt(a * a + m * m),
                this.data.transformMode == BO.NoScale && h * p - d * f < 0 != (oN.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (g = -g);
                const y = Math.PI / 2 + Math.atan2(m, a)
                  , b = Math.cos(y) * g
                  , v = Math.sin(y) * g
                  , w = QO.cosDeg(s) * r
                  , x = QO.cosDeg(90 + o) * i
                  , E = QO.sinDeg(s) * r
                  , _ = QO.sinDeg(90 + o) * i;
                l.a = a * w + b * E,
                l.c = a * x + b * _,
                l.b = m * w + v * E,
                l.d = m * x + v * _;
                break
            }
        }
        l.a *= c,
        l.c *= c,
        l.b *= u,
        l.d *= u
    }
    setToSetupPose() {
        const t = this.data;
        this.x = t.x,
        this.y = t.y,
        this.rotation = t.rotation,
        this.scaleX = t.scaleX,
        this.scaleY = t.scaleY,
        this.shearX = t.shearX,
        this.shearY = t.shearY
    }
    getWorldRotationX() {
        return Math.atan2(this.matrix.b, this.matrix.a) * QO.radDeg
    }
    getWorldRotationY() {
        return Math.atan2(this.matrix.d, this.matrix.c) * QO.radDeg
    }
    getWorldScaleX() {
        const t = this.matrix;
        return Math.sqrt(t.a * t.a + t.c * t.c)
    }
    getWorldScaleY() {
        const t = this.matrix;
        return Math.sqrt(t.b * t.b + t.d * t.d)
    }
    updateAppliedTransform() {
        this.appliedValid = !0;
        const t = this.parent
          , e = this.matrix;
        if (null == t)
            return this.ax = e.tx,
            this.ay = e.ty,
            this.arotation = Math.atan2(e.b, e.a) * QO.radDeg,
            this.ascaleX = Math.sqrt(e.a * e.a + e.b * e.b),
            this.ascaleY = Math.sqrt(e.c * e.c + e.d * e.d),
            this.ashearX = 0,
            void (this.ashearY = Math.atan2(e.a * e.c + e.b * e.d, e.a * e.d - e.b * e.c) * QO.radDeg);
        const n = t.matrix
          , r = 1 / (n.a * n.d - n.b * n.c)
          , i = e.tx - n.tx
          , s = e.ty - n.ty;
        this.ax = i * n.d * r - s * n.c * r,
        this.ay = s * n.a * r - i * n.b * r;
        const o = r * n.d
          , a = r * n.a
          , l = r * n.c
          , c = r * n.b
          , u = o * e.a - l * e.b
          , h = o * e.c - l * e.d
          , d = a * e.b - c * e.a
          , f = a * e.d - c * e.c;
        if (this.ashearX = 0,
        this.ascaleX = Math.sqrt(u * u + d * d),
        this.ascaleX > 1e-4) {
            const t = u * f - h * d;
            this.ascaleY = t / this.ascaleX,
            this.ashearY = Math.atan2(u * h + d * f, t) * QO.radDeg,
            this.arotation = Math.atan2(d, u) * QO.radDeg
        } else
            this.ascaleX = 0,
            this.ascaleY = Math.sqrt(h * h + f * f),
            this.ashearY = 0,
            this.arotation = 90 - Math.atan2(f, h) * QO.radDeg
    }
    worldToLocal(t) {
        const e = this.matrix
          , n = e.a
          , r = e.c
          , i = e.b
          , s = e.d
          , o = 1 / (n * s - r * i)
          , a = t.x - e.tx
          , l = t.y - e.ty;
        return t.x = a * s * o - l * r * o,
        t.y = l * n * o - a * i * o,
        t
    }
    localToWorld(t) {
        const e = this.matrix
          , n = t.x
          , r = t.y;
        return t.x = n * e.a + r * e.c + e.tx,
        t.y = n * e.b + r * e.d + e.ty,
        t
    }
    worldToLocalRotation(t) {
        const e = QO.sinDeg(t)
          , n = QO.cosDeg(t)
          , r = this.matrix;
        return Math.atan2(r.a * e - r.b * n, r.d * n - r.c * e) * QO.radDeg
    }
    localToWorldRotation(t) {
        const e = QO.sinDeg(t)
          , n = QO.cosDeg(t)
          , r = this.matrix;
        return Math.atan2(n * r.b + e * r.d, n * r.a + e * r.c) * QO.radDeg
    }
    rotateWorld(t) {
        const e = this.matrix
          , n = e.a
          , r = e.c
          , i = e.b
          , s = e.d
          , o = QO.cosDeg(t)
          , a = QO.sinDeg(t);
        e.a = o * n - a * i,
        e.c = o * r - a * s,
        e.b = a * n + o * i,
        e.d = a * r + o * s,
        this.appliedValid = !1
    }
}
class yR {
    constructor(t, e, n) {
        if (this.x = 0,
        this.y = 0,
        this.rotation = 0,
        this.scaleX = 1,
        this.scaleY = 1,
        this.shearX = 0,
        this.shearY = 0,
        this.transformMode = BO.Normal,
        this.skinRequired = !1,
        this.color = new qO,
        t < 0)
            throw new Error("index must be >= 0.");
        if (null == e)
            throw new Error("name cannot be null.");
        this.index = t,
        this.name = e,
        this.parent = n
    }
}
class bR {
    constructor(t, e, n) {
        this.name = t,
        this.order = e,
        this.skinRequired = n
    }
}
class vR {
    constructor(t, e) {
        if (null == e)
            throw new Error("data cannot be null.");
        this.time = t,
        this.data = e
    }
}
class wR {
    constructor(t) {
        this.name = t
    }
}
class xR {
    constructor(t, e) {
        if (this.bendDirection = 0,
        this.compress = !1,
        this.stretch = !1,
        this.mix = 1,
        this.softness = 0,
        this.active = !1,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.mix = t.mix,
        this.softness = t.softness,
        this.bendDirection = t.bendDirection,
        this.compress = t.compress,
        this.stretch = t.stretch,
        this.bones = new Array;
        for (let n = 0; n < t.bones.length; n++)
            this.bones.push(e.findBone(t.bones[n].name));
        this.target = e.findBone(t.target.name)
    }
    isActive() {
        return this.active
    }
    apply() {
        this.update()
    }
    update() {
        const t = this.target
          , e = this.bones;
        switch (e.length) {
        case 1:
            this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
            break;
        case 2:
            this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.softness, this.mix)
        }
    }
    apply1(t, e, n, r, i, s, o) {
        t.appliedValid || t.updateAppliedTransform();
        const a = t.parent.matrix
          , l = a.a;
        let c = a.c;
        const u = a.b;
        let h = a.d
          , d = -t.ashearX - t.arotation
          , f = 0
          , p = 0;
        switch (t.data.transformMode) {
        case BO.OnlyTranslation:
            f = e - t.worldX,
            p = n - t.worldY;
            break;
        case BO.NoRotationOrReflection:
            const r = Math.abs(l * h - c * u) / (l * l + u * u)
              , i = l / t.skeleton.scaleX
              , s = u / t.skeleton.scaleY;
            c = -s * r * t.skeleton.scaleX,
            h = i * r * t.skeleton.scaleY,
            d += Math.atan2(s, i) * QO.radDeg;
        default:
            const o = e - a.tx
              , m = n - a.ty
              , g = l * h - c * u;
            f = (o * h - m * c) / g - t.ax,
            p = (m * l - o * u) / g - t.ay
        }
        d += Math.atan2(p, f) * QO.radDeg,
        t.ascaleX < 0 && (d += 180),
        d > 180 ? d -= 360 : d < -180 && (d += 360);
        let m = t.ascaleX
          , g = t.ascaleY;
        if (r || i) {
            switch (t.data.transformMode) {
            case BO.NoScale:
            case BO.NoScaleOrReflection:
                f = e - t.worldX,
                p = n - t.worldY
            }
            const a = t.data.length * m
              , l = Math.sqrt(f * f + p * p);
            if (r && l < a || i && l > a && a > 1e-4) {
                const t = (l / a - 1) * o + 1;
                m *= t,
                s && (g *= t)
            }
        }
        t.updateWorldTransformWith(t.ax, t.ay, t.arotation + d * o, m, g, t.ashearX, t.ashearY)
    }
    apply2(t, e, n, r, i, s, o, a) {
        if (0 == a)
            return void e.updateWorldTransform();
        t.appliedValid || t.updateAppliedTransform(),
        e.appliedValid || e.updateAppliedTransform();
        const l = t.ax
          , c = t.ay;
        let u = t.ascaleX
          , h = u
          , d = t.ascaleY
          , f = e.ascaleX;
        const p = t.matrix;
        let m = 0
          , g = 0
          , y = 0;
        u < 0 ? (u = -u,
        m = 180,
        y = -1) : (m = 0,
        y = 1),
        d < 0 && (d = -d,
        y = -y),
        f < 0 ? (f = -f,
        g = 180) : g = 0;
        const b = e.ax;
        let v = 0
          , w = 0
          , x = 0
          , E = p.a
          , _ = p.c
          , A = p.b
          , S = p.d;
        const T = Math.abs(u - d) <= 1e-4;
        T ? (v = e.ay,
        w = E * b + _ * v + p.tx,
        x = A * b + S * v + p.ty) : (v = 0,
        w = E * b + p.tx,
        x = A * b + p.ty);
        const k = t.parent.matrix;
        E = k.a,
        _ = k.c,
        A = k.b,
        S = k.d;
        const I = 1 / (E * S - _ * A);
        let M = w - k.tx
          , C = x - k.ty;
        const P = (M * S - C * _) * I - l
          , O = (C * E - M * A) * I - c
          , N = Math.sqrt(P * P + O * O);
        let R, D, B = e.data.length * f;
        if (N < 1e-4)
            return this.apply1(t, n, r, !1, s, !1, a),
            void e.updateWorldTransformWith(b, v, 0, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY);
        M = n - k.tx,
        C = r - k.ty;
        let L = (M * S - C * _) * I - l
          , F = (C * E - M * A) * I - c
          , j = L * L + F * F;
        if (0 != o) {
            o *= u * (f + 1) / 2;
            const t = Math.sqrt(j)
              , e = t - N - B * u + o;
            if (e > 0) {
                let n = Math.min(1, e / (2 * o)) - 1;
                n = (e - o * (1 - n * n)) / t,
                L -= n * L,
                F -= n * F,
                j = L * L + F * F
            }
        }
        t: if (T) {
            B *= u;
            let t = (j - N * N - B * B) / (2 * N * B);
            t < -1 ? t = -1 : t > 1 && (t = 1,
            s && (h *= (Math.sqrt(j) / (N + B) - 1) * a + 1)),
            D = Math.acos(t) * i,
            E = N + B * t,
            _ = B * Math.sin(D),
            R = Math.atan2(F * E - L * _, L * E + F * _)
        } else {
            E = u * B,
            _ = d * B;
            const t = E * E
              , e = _ * _
              , n = Math.atan2(F, L);
            A = e * N * N + t * j - t * e;
            const r = -2 * e * N
              , s = e - t;
            if (S = r * r - 4 * s * A,
            S >= 0) {
                let t = Math.sqrt(S);
                r < 0 && (t = -t),
                t = -(r + t) / 2;
                const e = t / s
                  , o = A / t
                  , a = Math.abs(e) < Math.abs(o) ? e : o;
                if (a * a <= j) {
                    C = Math.sqrt(j - a * a) * i,
                    R = n - Math.atan2(C, a),
                    D = Math.atan2(C / d, (a - N) / u);
                    break t
                }
            }
            let o = QO.PI
              , a = N - E
              , l = a * a
              , c = 0
              , h = 0
              , f = N + E
              , p = f * f
              , m = 0;
            A = -E * N / (t - e),
            A >= -1 && A <= 1 && (A = Math.acos(A),
            M = E * Math.cos(A) + N,
            C = _ * Math.sin(A),
            S = M * M + C * C,
            S < l && (o = A,
            l = S,
            a = M,
            c = C),
            S > p && (h = A,
            p = S,
            f = M,
            m = C)),
            j <= (l + p) / 2 ? (R = n - Math.atan2(c * i, a),
            D = o * i) : (R = n - Math.atan2(m * i, f),
            D = h * i)
        }
        const U = Math.atan2(v, b) * y;
        let z = t.arotation;
        R = (R - U) * QO.radDeg + m - z,
        R > 180 ? R -= 360 : R < -180 && (R += 360),
        t.updateWorldTransformWith(l, c, z + R * a, h, t.ascaleY, 0, 0),
        z = e.arotation,
        D = ((D + U) * QO.radDeg - e.ashearX) * y + g - z,
        D > 180 ? D -= 360 : D < -180 && (D += 360),
        e.updateWorldTransformWith(b, v, z + D * a, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY)
    }
}
class ER extends bR {
    constructor(t) {
        super(t, 0, !1),
        this.bones = new Array,
        this.bendDirection = 1,
        this.compress = !1,
        this.stretch = !1,
        this.uniform = !1,
        this.mix = 1,
        this.softness = 0
    }
}
class _R extends bR {
    constructor(t) {
        super(t, 0, !1),
        this.bones = new Array
    }
}
var AR = (t=>(t[t.Length = 0] = "Length",
t[t.Fixed = 1] = "Fixed",
t[t.Percent = 2] = "Percent",
t))(AR || {});
const SR = class {
    constructor(t, e) {
        if (this.position = 0,
        this.spacing = 0,
        this.rotateMix = 0,
        this.translateMix = 0,
        this.spaces = new Array,
        this.positions = new Array,
        this.world = new Array,
        this.curves = new Array,
        this.lengths = new Array,
        this.segments = new Array,
        this.active = !1,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.bones = new Array;
        for (let n = 0, r = t.bones.length; n < r; n++)
            this.bones.push(e.findBone(t.bones[n].name));
        this.target = e.findSlot(t.target.name),
        this.position = t.position,
        this.spacing = t.spacing,
        this.rotateMix = t.rotateMix,
        this.translateMix = t.translateMix
    }
    isActive() {
        return this.active
    }
    apply() {
        this.update()
    }
    update() {
        const t = this.target.getAttachment();
        if (!(t instanceof _N))
            return;
        const e = this.rotateMix
          , n = this.translateMix
          , r = e > 0;
        if (!(n > 0) && !r)
            return;
        const i = this.data
          , s = i.spacingMode
          , o = s == AR.Length
          , a = i.rotateMode
          , l = a == DO.Tangent
          , c = a == DO.ChainScale
          , u = this.bones.length
          , h = l ? u : u + 1
          , d = this.bones
          , f = nN.setArraySize(this.spaces, h);
        let p = null;
        const m = this.spacing;
        if (c || o) {
            c && (p = nN.setArraySize(this.lengths, u));
            for (let t = 0, e = h - 1; t < e; ) {
                const e = d[t]
                  , n = e.data.length;
                if (n < SR.epsilon)
                    c && (p[t] = 0),
                    f[++t] = 0;
                else {
                    const r = n * e.matrix.a
                      , i = n * e.matrix.b
                      , s = Math.sqrt(r * r + i * i);
                    c && (p[t] = s),
                    f[++t] = (o ? n + m : m) * s / n
                }
            }
        } else
            for (let t = 1; t < h; t++)
                f[t] = m;
        const g = this.computeWorldPositions(t, h, l, i.positionMode == RO.Percent, s == AR.Percent);
        let y = g[0]
          , b = g[1]
          , v = i.offsetRotation
          , w = !1;
        if (0 == v)
            w = a == DO.Chain;
        else {
            w = !1;
            const t = this.target.bone.matrix;
            v *= t.a * t.d - t.b * t.c > 0 ? QO.degRad : -QO.degRad
        }
        for (let t = 0, i = 3; t < u; t++,
        i += 3) {
            const s = d[t]
              , o = s.matrix;
            o.tx += (y - o.tx) * n,
            o.ty += (b - o.ty) * n;
            const a = g[i]
              , u = g[i + 1]
              , h = a - y
              , m = u - b;
            if (c) {
                const n = p[t];
                if (0 != n) {
                    const t = (Math.sqrt(h * h + m * m) / n - 1) * e + 1;
                    o.a *= t,
                    o.b *= t
                }
            }
            if (y = a,
            b = u,
            r) {
                const n = o.a
                  , r = o.c
                  , a = o.b
                  , c = o.d;
                let u = 0
                  , d = 0
                  , p = 0;
                if (l && (u = l ? g[i - 1] : 0 == f[t + 1] ? g[i + 2] : Math.atan2(m, h)),
                u -= Math.atan2(a, n),
                w) {
                    d = Math.cos(u),
                    p = Math.sin(u);
                    const t = s.data.length;
                    y += (t * (d * n - p * a) - h) * e,
                    b += (t * (p * n + d * a) - m) * e
                } else
                    u += v;
                u > QO.PI ? u -= QO.PI2 : u < -QO.PI && (u += QO.PI2),
                u *= e,
                d = Math.cos(u),
                p = Math.sin(u),
                o.a = d * n - p * a,
                o.c = d * r - p * c,
                o.b = p * n + d * a,
                o.d = p * r + d * c
            }
            s.appliedValid = !1
        }
    }
    computeWorldPositions(t, e, n, r, i) {
        const s = this.target;
        let o = this.position;
        const a = this.spaces
          , l = nN.setArraySize(this.positions, 3 * e + 2);
        let c = null;
        const u = t.closed;
        let h = t.worldVerticesLength
          , d = h / 6
          , f = SR.NONE;
        if (!t.constantSpeed) {
            const p = t.lengths;
            d -= u ? 1 : 2;
            const m = p[d];
            if (r && (o *= m),
            i)
                for (let t = 0; t < e; t++)
                    a[t] *= m;
            c = nN.setArraySize(this.world, 8);
            for (let r = 0, i = 0, g = 0; r < e; r++,
            i += 3) {
                const e = a[r];
                o += e;
                let y = o;
                if (u)
                    y %= m,
                    y < 0 && (y += m),
                    g = 0;
                else {
                    if (y < 0) {
                        f != SR.BEFORE && (f = SR.BEFORE,
                        t.computeWorldVertices(s, 2, 4, c, 0, 2)),
                        this.addBeforePosition(y, c, 0, l, i);
                        continue
                    }
                    if (y > m) {
                        f != SR.AFTER && (f = SR.AFTER,
                        t.computeWorldVertices(s, h - 6, 4, c, 0, 2)),
                        this.addAfterPosition(y - m, c, 0, l, i);
                        continue
                    }
                }
                for (; ; g++) {
                    const t = p[g];
                    if (!(y > t)) {
                        if (0 == g)
                            y /= t;
                        else {
                            const e = p[g - 1];
                            y = (y - e) / (t - e)
                        }
                        break
                    }
                }
                g != f && (f = g,
                u && g == d ? (t.computeWorldVertices(s, h - 4, 4, c, 0, 2),
                t.computeWorldVertices(s, 0, 4, c, 4, 2)) : t.computeWorldVertices(s, 6 * g + 2, 8, c, 0, 2)),
                this.addCurvePosition(y, c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], l, i, n || r > 0 && 0 == e)
            }
            return l
        }
        u ? (h += 2,
        c = nN.setArraySize(this.world, h),
        t.computeWorldVertices(s, 2, h - 4, c, 0, 2),
        t.computeWorldVertices(s, 0, 2, c, h - 4, 2),
        c[h - 2] = c[0],
        c[h - 1] = c[1]) : (d--,
        h -= 4,
        c = nN.setArraySize(this.world, h),
        t.computeWorldVertices(s, 2, h, c, 0, 2));
        const p = nN.setArraySize(this.curves, d);
        let m = 0
          , g = c[0]
          , y = c[1]
          , b = 0
          , v = 0
          , w = 0
          , x = 0
          , E = 0
          , _ = 0
          , A = 0
          , S = 0
          , T = 0
          , k = 0
          , I = 0
          , M = 0
          , C = 0
          , P = 0;
        for (let t = 0, e = 2; t < d; t++,
        e += 6)
            b = c[e],
            v = c[e + 1],
            w = c[e + 2],
            x = c[e + 3],
            E = c[e + 4],
            _ = c[e + 5],
            A = .1875 * (g - 2 * b + w),
            S = .1875 * (y - 2 * v + x),
            T = .09375 * (3 * (b - w) - g + E),
            k = .09375 * (3 * (v - x) - y + _),
            I = 2 * A + T,
            M = 2 * S + k,
            C = .75 * (b - g) + A + .16666667 * T,
            P = .75 * (v - y) + S + .16666667 * k,
            m += Math.sqrt(C * C + P * P),
            C += I,
            P += M,
            I += T,
            M += k,
            m += Math.sqrt(C * C + P * P),
            C += I,
            P += M,
            m += Math.sqrt(C * C + P * P),
            C += I + T,
            P += M + k,
            m += Math.sqrt(C * C + P * P),
            p[t] = m,
            g = E,
            y = _;
        if (r && (o *= m),
        i)
            for (let t = 0; t < e; t++)
                a[t] *= m;
        const O = this.segments;
        let N = 0;
        for (let t = 0, r = 0, i = 0, s = 0; t < e; t++,
        r += 3) {
            const e = a[t];
            o += e;
            let d = o;
            if (u)
                d %= m,
                d < 0 && (d += m),
                i = 0;
            else {
                if (d < 0) {
                    this.addBeforePosition(d, c, 0, l, r);
                    continue
                }
                if (d > m) {
                    this.addAfterPosition(d - m, c, h - 4, l, r);
                    continue
                }
            }
            for (; ; i++) {
                const t = p[i];
                if (!(d > t)) {
                    if (0 == i)
                        d /= t;
                    else {
                        const e = p[i - 1];
                        d = (d - e) / (t - e)
                    }
                    break
                }
            }
            if (i != f) {
                f = i;
                let t = 6 * i;
                for (g = c[t],
                y = c[t + 1],
                b = c[t + 2],
                v = c[t + 3],
                w = c[t + 4],
                x = c[t + 5],
                E = c[t + 6],
                _ = c[t + 7],
                A = .03 * (g - 2 * b + w),
                S = .03 * (y - 2 * v + x),
                T = .006 * (3 * (b - w) - g + E),
                k = .006 * (3 * (v - x) - y + _),
                I = 2 * A + T,
                M = 2 * S + k,
                C = .3 * (b - g) + A + .16666667 * T,
                P = .3 * (v - y) + S + .16666667 * k,
                N = Math.sqrt(C * C + P * P),
                O[0] = N,
                t = 1; t < 8; t++)
                    C += I,
                    P += M,
                    I += T,
                    M += k,
                    N += Math.sqrt(C * C + P * P),
                    O[t] = N;
                C += I,
                P += M,
                N += Math.sqrt(C * C + P * P),
                O[8] = N,
                C += I + T,
                P += M + k,
                N += Math.sqrt(C * C + P * P),
                O[9] = N,
                s = 0
            }
            for (d *= N; ; s++) {
                const t = O[s];
                if (!(d > t)) {
                    if (0 == s)
                        d /= t;
                    else {
                        const e = O[s - 1];
                        d = s + (d - e) / (t - e)
                    }
                    break
                }
            }
            this.addCurvePosition(.1 * d, g, y, b, v, w, x, E, _, l, r, n || t > 0 && 0 == e)
        }
        return l
    }
    addBeforePosition(t, e, n, r, i) {
        const s = e[n]
          , o = e[n + 1]
          , a = e[n + 2] - s
          , l = e[n + 3] - o
          , c = Math.atan2(l, a);
        r[i] = s + t * Math.cos(c),
        r[i + 1] = o + t * Math.sin(c),
        r[i + 2] = c
    }
    addAfterPosition(t, e, n, r, i) {
        const s = e[n + 2]
          , o = e[n + 3]
          , a = s - e[n]
          , l = o - e[n + 1]
          , c = Math.atan2(l, a);
        r[i] = s + t * Math.cos(c),
        r[i + 1] = o + t * Math.sin(c),
        r[i + 2] = c
    }
    addCurvePosition(t, e, n, r, i, s, o, a, l, c, u, h) {
        (0 == t || isNaN(t)) && (t = 1e-4);
        const d = t * t
          , f = d * t
          , p = 1 - t
          , m = p * p
          , g = m * p
          , y = p * t
          , b = 3 * y
          , v = p * b
          , w = b * t
          , x = e * g + r * v + s * w + a * f
          , E = n * g + i * v + o * w + l * f;
        c[u] = x,
        c[u + 1] = E,
        h && (c[u + 2] = Math.atan2(E - (n * m + i * y * 2 + o * d), x - (e * m + r * y * 2 + s * d)))
    }
}
;
let TR = SR;
TR.NONE = -1,
TR.BEFORE = -2,
TR.AFTER = -3,
TR.epsilon = 1e-5;
class kR {
    constructor(t, e) {
        if (this.rotateMix = 0,
        this.translateMix = 0,
        this.scaleMix = 0,
        this.shearMix = 0,
        this.temp = new iN,
        this.active = !1,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.rotateMix = t.rotateMix,
        this.translateMix = t.translateMix,
        this.scaleMix = t.scaleMix,
        this.shearMix = t.shearMix,
        this.bones = new Array;
        for (let n = 0; n < t.bones.length; n++)
            this.bones.push(e.findBone(t.bones[n].name));
        this.target = e.findBone(t.target.name)
    }
    isActive() {
        return this.active
    }
    apply() {
        this.update()
    }
    update() {
        this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
    }
    applyAbsoluteWorld() {
        const t = this.rotateMix
          , e = this.translateMix
          , n = this.scaleMix
          , r = this.shearMix
          , i = this.target
          , s = i.matrix
          , o = s.a
          , a = s.c
          , l = s.b
          , c = s.d
          , u = o * c - a * l > 0 ? QO.degRad : -QO.degRad
          , h = this.data.offsetRotation * u
          , d = this.data.offsetShearY * u
          , f = this.bones;
        for (let s = 0, u = f.length; s < u; s++) {
            const u = f[s];
            let p = !1;
            const m = u.matrix;
            if (0 != t) {
                const e = m.a
                  , n = m.c
                  , r = m.b
                  , i = m.d;
                let s = Math.atan2(l, o) - Math.atan2(r, e) + h;
                s > QO.PI ? s -= QO.PI2 : s < -QO.PI && (s += QO.PI2),
                s *= t;
                const a = Math.cos(s)
                  , c = Math.sin(s);
                m.a = a * e - c * r,
                m.c = a * n - c * i,
                m.b = c * e + a * r,
                m.d = c * n + a * i,
                p = !0
            }
            if (0 != e) {
                const t = this.temp;
                i.localToWorld(t.set(this.data.offsetX, this.data.offsetY)),
                m.tx += (t.x - m.tx) * e,
                m.ty += (t.y - m.ty) * e,
                p = !0
            }
            if (n > 0) {
                let t = Math.sqrt(m.a * m.a + m.b * m.b)
                  , e = Math.sqrt(o * o + l * l);
                t > 1e-5 && (t = (t + (e - t + this.data.offsetScaleX) * n) / t),
                m.a *= t,
                m.b *= t,
                t = Math.sqrt(m.c * m.c + m.d * m.d),
                e = Math.sqrt(a * a + c * c),
                t > 1e-5 && (t = (t + (e - t + this.data.offsetScaleY) * n) / t),
                m.c *= t,
                m.d *= t,
                p = !0
            }
            if (r > 0) {
                const t = m.c
                  , e = m.d
                  , n = Math.atan2(e, t);
                let i = Math.atan2(c, a) - Math.atan2(l, o) - (n - Math.atan2(m.b, m.a));
                i > QO.PI ? i -= QO.PI2 : i < -QO.PI && (i += QO.PI2),
                i = n + (i + d) * r;
                const s = Math.sqrt(t * t + e * e);
                m.c = Math.cos(i) * s,
                m.d = Math.sin(i) * s,
                p = !0
            }
            p && (u.appliedValid = !1)
        }
    }
    applyRelativeWorld() {
        const t = this.rotateMix
          , e = this.translateMix
          , n = this.scaleMix
          , r = this.shearMix
          , i = this.target
          , s = i.matrix
          , o = s.a
          , a = s.c
          , l = s.b
          , c = s.d
          , u = o * c - a * l > 0 ? QO.degRad : -QO.degRad
          , h = this.data.offsetRotation * u
          , d = this.data.offsetShearY * u
          , f = this.bones;
        for (let s = 0, u = f.length; s < u; s++) {
            const u = f[s];
            let p = !1;
            const m = u.matrix;
            if (0 != t) {
                const e = m.a
                  , n = m.c
                  , r = m.b
                  , i = m.d;
                let s = Math.atan2(l, o) + h;
                s > QO.PI ? s -= QO.PI2 : s < -QO.PI && (s += QO.PI2),
                s *= t;
                const a = Math.cos(s)
                  , c = Math.sin(s);
                m.a = a * e - c * r,
                m.c = a * n - c * i,
                m.b = c * e + a * r,
                m.d = c * n + a * i,
                p = !0
            }
            if (0 != e) {
                const t = this.temp;
                i.localToWorld(t.set(this.data.offsetX, this.data.offsetY)),
                m.tx += t.x * e,
                m.ty += t.y * e,
                p = !0
            }
            if (n > 0) {
                let t = (Math.sqrt(o * o + l * l) - 1 + this.data.offsetScaleX) * n + 1;
                m.a *= t,
                m.b *= t,
                t = (Math.sqrt(a * a + c * c) - 1 + this.data.offsetScaleY) * n + 1,
                m.c *= t,
                m.d *= t,
                p = !0
            }
            if (r > 0) {
                let t = Math.atan2(c, a) - Math.atan2(l, o);
                t > QO.PI ? t -= QO.PI2 : t < -QO.PI && (t += QO.PI2);
                const e = m.c
                  , n = m.d;
                t = Math.atan2(n, e) + (t - QO.PI / 2 + d) * r;
                const i = Math.sqrt(e * e + n * n);
                m.c = Math.cos(t) * i,
                m.d = Math.sin(t) * i,
                p = !0
            }
            p && (u.appliedValid = !1)
        }
    }
    applyAbsoluteLocal() {
        const t = this.rotateMix
          , e = this.translateMix
          , n = this.scaleMix
          , r = this.shearMix
          , i = this.target;
        i.appliedValid || i.updateAppliedTransform();
        const s = this.bones;
        for (let o = 0, a = s.length; o < a; o++) {
            const a = s[o];
            a.appliedValid || a.updateAppliedTransform();
            let l = a.arotation;
            if (0 != t) {
                let e = i.arotation - l + this.data.offsetRotation;
                e -= 360 * (16384 - (16384.499999999996 - e / 360 | 0)),
                l += e * t
            }
            let c = a.ax
              , u = a.ay;
            0 != e && (c += (i.ax - c + this.data.offsetX) * e,
            u += (i.ay - u + this.data.offsetY) * e);
            let h = a.ascaleX
              , d = a.ascaleY;
            n > 0 && (h > 1e-5 && (h = (h + (i.ascaleX - h + this.data.offsetScaleX) * n) / h),
            d > 1e-5 && (d = (d + (i.ascaleY - d + this.data.offsetScaleY) * n) / d));
            const f = a.ashearY;
            if (r > 0) {
                let t = i.ashearY - f + this.data.offsetShearY;
                t -= 360 * (16384 - (16384.499999999996 - t / 360 | 0)),
                a.shearY += t * r
            }
            a.updateWorldTransformWith(c, u, l, h, d, a.ashearX, f)
        }
    }
    applyRelativeLocal() {
        const t = this.rotateMix
          , e = this.translateMix
          , n = this.scaleMix
          , r = this.shearMix
          , i = this.target;
        i.appliedValid || i.updateAppliedTransform();
        const s = this.bones;
        for (let o = 0, a = s.length; o < a; o++) {
            const a = s[o];
            a.appliedValid || a.updateAppliedTransform();
            let l = a.arotation;
            0 != t && (l += (i.arotation + this.data.offsetRotation) * t);
            let c = a.ax
              , u = a.ay;
            0 != e && (c += (i.ax + this.data.offsetX) * e,
            u += (i.ay + this.data.offsetY) * e);
            let h = a.ascaleX
              , d = a.ascaleY;
            n > 0 && (h > 1e-5 && (h *= (i.ascaleX - 1 + this.data.offsetScaleX) * n + 1),
            d > 1e-5 && (d *= (i.ascaleY - 1 + this.data.offsetScaleY) * n + 1));
            let f = a.ashearY;
            r > 0 && (f += (i.ashearY + this.data.offsetShearY) * r),
            a.updateWorldTransformWith(c, u, l, h, d, a.ashearX, f)
        }
    }
}
const IR = class {
    constructor(t) {
        if (this._updateCache = new Array,
        this.updateCacheReset = new Array,
        this.time = 0,
        this.scaleX = 1,
        this.scaleY = 1,
        this.x = 0,
        this.y = 0,
        null == t)
            throw new Error("data cannot be null.");
        this.data = t,
        this.bones = new Array;
        for (let e = 0; e < t.bones.length; e++) {
            const n = t.bones[e];
            let r;
            if (null == n.parent)
                r = new gR(n,this,null);
            else {
                const t = this.bones[n.parent.index];
                r = new gR(n,this,t),
                t.children.push(r)
            }
            this.bones.push(r)
        }
        this.slots = new Array,
        this.drawOrder = new Array;
        for (let e = 0; e < t.slots.length; e++) {
            const n = t.slots[e]
              , r = this.bones[n.boneData.index]
              , i = new SN(n,r);
            this.slots.push(i),
            this.drawOrder.push(i)
        }
        this.ikConstraints = new Array;
        for (let e = 0; e < t.ikConstraints.length; e++) {
            const n = t.ikConstraints[e];
            this.ikConstraints.push(new xR(n,this))
        }
        this.transformConstraints = new Array;
        for (let e = 0; e < t.transformConstraints.length; e++) {
            const n = t.transformConstraints[e];
            this.transformConstraints.push(new kR(n,this))
        }
        this.pathConstraints = new Array;
        for (let e = 0; e < t.pathConstraints.length; e++) {
            const n = t.pathConstraints[e];
            this.pathConstraints.push(new TR(n,this))
        }
        this.color = new qO(1,1,1,1),
        this.updateCache()
    }
    updateCache() {
        this._updateCache.length = 0,
        this.updateCacheReset.length = 0;
        const t = this.bones;
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            n.sorted = n.data.skinRequired,
            n.active = !n.sorted
        }
        if (null != this.skin) {
            const t = this.skin.bones;
            for (let e = 0, n = this.skin.bones.length; e < n; e++) {
                let n = this.bones[t[e].index];
                do {
                    n.sorted = !1,
                    n.active = !0,
                    n = n.parent
                } while (null != n)
            }
        }
        const e = this.ikConstraints
          , n = this.transformConstraints
          , r = this.pathConstraints
          , i = e.length
          , s = n.length
          , o = r.length
          , a = i + s + o;
        t: for (let t = 0; t < a; t++) {
            for (let n = 0; n < i; n++) {
                const r = e[n];
                if (r.data.order == t) {
                    this.sortIkConstraint(r);
                    continue t
                }
            }
            for (let e = 0; e < s; e++) {
                const r = n[e];
                if (r.data.order == t) {
                    this.sortTransformConstraint(r);
                    continue t
                }
            }
            for (let e = 0; e < o; e++) {
                const n = r[e];
                if (n.data.order == t) {
                    this.sortPathConstraint(n);
                    continue t
                }
            }
        }
        for (let e = 0, n = t.length; e < n; e++)
            this.sortBone(t[e])
    }
    sortIkConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || null != this.skin && nN.contains(this.skin.constraints, t.data, !0)),
        !t.active)
            return;
        const e = t.target;
        this.sortBone(e);
        const n = t.bones
          , r = n[0];
        if (this.sortBone(r),
        n.length > 1) {
            const t = n[n.length - 1];
            this._updateCache.indexOf(t) > -1 || this.updateCacheReset.push(t)
        }
        this._updateCache.push(t),
        this.sortReset(r.children),
        n[n.length - 1].sorted = !0
    }
    sortPathConstraint(t) {
        if (t.active = t.target.bone.isActive() && (!t.data.skinRequired || null != this.skin && nN.contains(this.skin.constraints, t.data, !0)),
        !t.active)
            return;
        const e = t.target
          , n = e.data.index
          , r = e.bone;
        null != this.skin && this.sortPathConstraintAttachment(this.skin, n, r),
        null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, r);
        for (let t = 0, e = this.data.skins.length; t < e; t++)
            this.sortPathConstraintAttachment(this.data.skins[t], n, r);
        const i = e.getAttachment();
        i instanceof _N && this.sortPathConstraintAttachmentWith(i, r);
        const s = t.bones
          , o = s.length;
        for (let t = 0; t < o; t++)
            this.sortBone(s[t]);
        this._updateCache.push(t);
        for (let t = 0; t < o; t++)
            this.sortReset(s[t].children);
        for (let t = 0; t < o; t++)
            s[t].sorted = !0
    }
    sortTransformConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || null != this.skin && nN.contains(this.skin.constraints, t.data, !0)),
        !t.active)
            return;
        this.sortBone(t.target);
        const e = t.bones
          , n = e.length;
        if (t.data.local)
            for (let t = 0; t < n; t++) {
                const n = e[t];
                this.sortBone(n.parent),
                this._updateCache.indexOf(n) > -1 || this.updateCacheReset.push(n)
            }
        else
            for (let t = 0; t < n; t++)
                this.sortBone(e[t]);
        this._updateCache.push(t);
        for (let t = 0; t < n; t++)
            this.sortReset(e[t].children);
        for (let t = 0; t < n; t++)
            e[t].sorted = !0
    }
    sortPathConstraintAttachment(t, e, n) {
        const r = t.attachments[e];
        if (r)
            for (const t in r)
                this.sortPathConstraintAttachmentWith(r[t], n)
    }
    sortPathConstraintAttachmentWith(t, e) {
        if (!(t instanceof _N))
            return;
        const n = t.bones;
        if (null == n)
            this.sortBone(e);
        else {
            const t = this.bones;
            let e = 0;
            for (; e < n.length; ) {
                const r = n[e++];
                for (let i = e + r; e < i; e++) {
                    const r = n[e];
                    this.sortBone(t[r])
                }
            }
        }
    }
    sortBone(t) {
        if (t.sorted)
            return;
        const e = t.parent;
        null != e && this.sortBone(e),
        t.sorted = !0,
        this._updateCache.push(t)
    }
    sortReset(t) {
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            n.active && (n.sorted && this.sortReset(n.children),
            n.sorted = !1)
        }
    }
    updateWorldTransform() {
        const t = this.updateCacheReset;
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            n.ax = n.x,
            n.ay = n.y,
            n.arotation = n.rotation,
            n.ascaleX = n.scaleX,
            n.ascaleY = n.scaleY,
            n.ashearX = n.shearX,
            n.ashearY = n.shearY,
            n.appliedValid = !0
        }
        const e = this._updateCache;
        for (let t = 0, n = e.length; t < n; t++)
            e[t].update()
    }
    setToSetupPose() {
        this.setBonesToSetupPose(),
        this.setSlotsToSetupPose()
    }
    setBonesToSetupPose() {
        const t = this.bones;
        for (let e = 0, n = t.length; e < n; e++)
            t[e].setToSetupPose();
        const e = this.ikConstraints;
        for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t];
            n.mix = n.data.mix,
            n.softness = n.data.softness,
            n.bendDirection = n.data.bendDirection,
            n.compress = n.data.compress,
            n.stretch = n.data.stretch
        }
        const n = this.transformConstraints;
        for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t]
              , r = e.data;
            e.rotateMix = r.rotateMix,
            e.translateMix = r.translateMix,
            e.scaleMix = r.scaleMix,
            e.shearMix = r.shearMix
        }
        const r = this.pathConstraints;
        for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t]
              , n = e.data;
            e.position = n.position,
            e.spacing = n.spacing,
            e.rotateMix = n.rotateMix,
            e.translateMix = n.translateMix
        }
    }
    setSlotsToSetupPose() {
        const t = this.slots;
        nN.arrayCopy(t, 0, this.drawOrder, 0, t.length);
        for (let e = 0, n = t.length; e < n; e++)
            t[e].setToSetupPose()
    }
    getRootBone() {
        return 0 == this.bones.length ? null : this.bones[0]
    }
    findBone(t) {
        if (null == t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findBoneIndex(t) {
        if (null == t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].data.name == t)
                return n;
        return -1
    }
    findSlot(t) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findSlotIndex(t) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].data.name == t)
                return n;
        return -1
    }
    setSkinByName(t) {
        const e = this.data.findSkin(t);
        if (null == e)
            throw new Error(`Skin not found: ${t}`);
        this.setSkin(e)
    }
    setSkin(t) {
        if (t != this.skin) {
            if (null != t)
                if (null != this.skin)
                    t.attachAll(this, this.skin);
                else {
                    const e = this.slots;
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = e[n]
                          , i = r.data.attachmentName;
                        if (null != i) {
                            const e = t.getAttachment(n, i);
                            null != e && r.setAttachment(e)
                        }
                    }
                }
            this.skin = t,
            this.updateCache()
        }
    }
    getAttachmentByName(t, e) {
        return this.getAttachment(this.data.findSlotIndex(t), e)
    }
    getAttachment(t, e) {
        if (null == e)
            throw new Error("attachmentName cannot be null.");
        if (null != this.skin) {
            const n = this.skin.getAttachment(t, e);
            if (null != n)
                return n
        }
        return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
    }
    setAttachment(t, e) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let r = 0, i = n.length; r < i; r++) {
            const i = n[r];
            if (i.data.name == t) {
                let n = null;
                if (null != e && (n = this.getAttachment(r, e),
                null == n))
                    throw new Error(`Attachment not found: ${e}, for slot: ${t}`);
                return void i.setAttachment(n)
            }
        }
        throw new Error(`Slot not found: ${t}`)
    }
    findIkConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.ikConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findTransformConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.transformConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findPathConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    getBounds(t, e, n=new Array(2)) {
        if (null == t)
            throw new Error("offset cannot be null.");
        if (null == e)
            throw new Error("size cannot be null.");
        const r = this.drawOrder;
        let i = Number.POSITIVE_INFINITY
          , s = Number.POSITIVE_INFINITY
          , o = Number.NEGATIVE_INFINITY
          , a = Number.NEGATIVE_INFINITY;
        for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t];
            if (!e.bone.active)
                continue;
            let l = 0
              , c = null;
            const u = e.getAttachment();
            if (u instanceof kN)
                l = 8,
                c = nN.setArraySize(n, l, 0),
                u.computeWorldVertices(e.bone, c, 0, 2);
            else if (u instanceof EN) {
                const t = u;
                l = t.worldVerticesLength,
                c = nN.setArraySize(n, l, 0),
                t.computeWorldVertices(e, 0, l, c, 0, 2)
            }
            if (null != c)
                for (let t = 0, e = c.length; t < e; t += 2) {
                    const e = c[t]
                      , n = c[t + 1];
                    i = Math.min(i, e),
                    s = Math.min(s, n),
                    o = Math.max(o, e),
                    a = Math.max(a, n)
                }
        }
        t.set(i, s),
        e.set(o - i, a - s)
    }
    update(t) {
        this.time += t
    }
    get flipX() {
        return -1 == this.scaleX
    }
    set flipX(t) {
        IR.deprecatedWarning1 || (IR.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
        this.scaleX = t ? 1 : -1
    }
    get flipY() {
        return -1 == this.scaleY
    }
    set flipY(t) {
        IR.deprecatedWarning1 || (IR.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
        this.scaleY = t ? 1 : -1
    }
}
;
let MR = IR;
MR.deprecatedWarning1 = !1;
class CR {
    constructor() {
        this.bones = new Array,
        this.slots = new Array,
        this.skins = new Array,
        this.events = new Array,
        this.animations = new Array,
        this.ikConstraints = new Array,
        this.transformConstraints = new Array,
        this.pathConstraints = new Array,
        this.fps = 0
    }
    findBone(t) {
        if (null == t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findBoneIndex(t) {
        if (null == t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].name == t)
                return n;
        return -1
    }
    findSlot(t) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findSlotIndex(t) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].name == t)
                return n;
        return -1
    }
    findSkin(t) {
        if (null == t)
            throw new Error("skinName cannot be null.");
        const e = this.skins;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findEvent(t) {
        if (null == t)
            throw new Error("eventDataName cannot be null.");
        const e = this.events;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findAnimation(t) {
        if (null == t)
            throw new Error("animationName cannot be null.");
        const e = this.animations;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findIkConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.ikConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findTransformConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.transformConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findPathConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findPathConstraintIndex(t) {
        if (null == t)
            throw new Error("pathConstraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].name == t)
                return n;
        return -1
    }
}
class PR {
    constructor(t, e, n) {
        if (this.color = new qO(1,1,1,1),
        t < 0)
            throw new Error("index must be >= 0.");
        if (null == e)
            throw new Error("name cannot be null.");
        if (null == n)
            throw new Error("boneData cannot be null.");
        this.index = t,
        this.name = e,
        this.boneData = n
    }
}
class OR extends bR {
    constructor(t) {
        super(t, 0, !1),
        this.bones = new Array,
        this.rotateMix = 0,
        this.translateMix = 0,
        this.scaleMix = 0,
        this.shearMix = 0,
        this.offsetRotation = 0,
        this.offsetX = 0,
        this.offsetY = 0,
        this.offsetScaleX = 0,
        this.offsetScaleY = 0,
        this.offsetShearY = 0,
        this.relative = !1,
        this.local = !1
    }
}
class NR {
    constructor(t, e, n) {
        this.slotIndex = t,
        this.name = e,
        this.attachment = n
    }
}
class RR {
    constructor(t) {
        if (this.attachments = new Array,
        this.bones = Array(),
        this.constraints = new Array,
        null == t)
            throw new Error("name cannot be null.");
        this.name = t
    }
    setAttachment(t, e, n) {
        if (null == n)
            throw new Error("attachment cannot be null.");
        const r = this.attachments;
        t >= r.length && (r.length = t + 1),
        r[t] || (r[t] = {}),
        r[t][e] = n
    }
    addSkin(t) {
        for (let e = 0; e < t.bones.length; e++) {
            const n = t.bones[e];
            let r = !1;
            for (let t = 0; t < this.bones.length; t++)
                if (this.bones[t] == n) {
                    r = !0;
                    break
                }
            r || this.bones.push(n)
        }
        for (let e = 0; e < t.constraints.length; e++) {
            const n = t.constraints[e];
            let r = !1;
            for (let t = 0; t < this.constraints.length; t++)
                if (this.constraints[t] == n) {
                    r = !0;
                    break
                }
            r || this.constraints.push(n)
        }
        const e = t.getAttachments();
        for (let t = 0; t < e.length; t++) {
            const n = e[t];
            this.setAttachment(n.slotIndex, n.name, n.attachment)
        }
    }
    copySkin(t) {
        for (let e = 0; e < t.bones.length; e++) {
            const n = t.bones[e];
            let r = !1;
            for (let t = 0; t < this.bones.length; t++)
                if (this.bones[t] == n) {
                    r = !0;
                    break
                }
            r || this.bones.push(n)
        }
        for (let e = 0; e < t.constraints.length; e++) {
            const n = t.constraints[e];
            let r = !1;
            for (let t = 0; t < this.constraints.length; t++)
                if (this.constraints[t] == n) {
                    r = !0;
                    break
                }
            r || this.constraints.push(n)
        }
        const e = t.getAttachments();
        for (let t = 0; t < e.length; t++) {
            const n = e[t];
            null != n.attachment && (n.attachment instanceof EN ? (n.attachment = n.attachment.newLinkedMesh(),
            this.setAttachment(n.slotIndex, n.name, n.attachment)) : (n.attachment = n.attachment.copy(),
            this.setAttachment(n.slotIndex, n.name, n.attachment)))
        }
    }
    getAttachment(t, e) {
        const n = this.attachments[t];
        return n ? n[e] : null
    }
    removeAttachment(t, e) {
        const n = this.attachments[t];
        n && (n[e] = null)
    }
    getAttachments() {
        const t = new Array;
        for (let e = 0; e < this.attachments.length; e++) {
            const n = this.attachments[e];
            if (n)
                for (const r in n) {
                    const i = n[r];
                    i && t.push(new NR(e,r,i))
                }
        }
        return t
    }
    getAttachmentsForSlot(t, e) {
        const n = this.attachments[t];
        if (n)
            for (const r in n) {
                const i = n[r];
                i && e.push(new NR(t,r,i))
            }
    }
    clear() {
        this.attachments.length = 0,
        this.bones.length = 0,
        this.constraints.length = 0
    }
    attachAll(t, e) {
        let n = 0;
        for (let r = 0; r < t.slots.length; r++) {
            const i = t.slots[r]
              , s = i.getAttachment();
            if (s && n < e.attachments.length) {
                const t = e.attachments[n];
                for (const e in t) {
                    if (s == t[e]) {
                        const t = this.getAttachment(n, e);
                        null != t && i.setAttachment(t);
                        break
                    }
                }
            }
            n++
        }
    }
}
const DR = class {
    constructor(t) {
        this.scale = 1,
        this.linkedMeshes = new Array,
        this.attachmentLoader = t
    }
    readSkeletonData(t) {
        const e = this.scale
          , n = new CR;
        n.name = "";
        const r = new PO(t);
        if (n.hash = r.readString(),
        n.version = r.readString(),
        "3.8.75" === n.version) {
            const t = "Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";
            console.error(t)
        }
        n.x = r.readFloat(),
        n.y = r.readFloat(),
        n.width = r.readFloat(),
        n.height = r.readFloat();
        const i = r.readBoolean();
        i && (n.fps = r.readFloat(),
        n.imagesPath = r.readString(),
        n.audioPath = r.readString());
        let s = 0;
        s = r.readInt(!0);
        for (let t = 0; t < s; t++)
            r.strings.push(r.readString());
        s = r.readInt(!0);
        for (let t = 0; t < s; t++) {
            const s = r.readString()
              , o = 0 == t ? null : n.bones[r.readInt(!0)]
              , a = new yR(t,s,o);
            a.rotation = r.readFloat(),
            a.x = r.readFloat() * e,
            a.y = r.readFloat() * e,
            a.scaleX = r.readFloat(),
            a.scaleY = r.readFloat(),
            a.shearX = r.readFloat(),
            a.shearY = r.readFloat(),
            a.length = r.readFloat() * e,
            a.transformMode = DR.TransformModeValues[r.readInt(!0)],
            a.skinRequired = r.readBoolean(),
            i && qO.rgba8888ToColor(a.color, r.readInt32()),
            n.bones.push(a)
        }
        s = r.readInt(!0);
        for (let t = 0; t < s; t++) {
            const e = r.readString()
              , i = n.bones[r.readInt(!0)]
              , s = new PR(t,e,i);
            qO.rgba8888ToColor(s.color, r.readInt32());
            const o = r.readInt32();
            -1 != o && qO.rgb888ToColor(s.darkColor = new qO, o),
            s.attachmentName = r.readStringRef(),
            s.blendMode = DR.BlendModeValues[r.readInt(!0)],
            n.slots.push(s)
        }
        s = r.readInt(!0);
        for (let t, i = 0; i < s; i++) {
            const i = new ER(r.readString());
            i.order = r.readInt(!0),
            i.skinRequired = r.readBoolean(),
            t = r.readInt(!0);
            for (let e = 0; e < t; e++)
                i.bones.push(n.bones[r.readInt(!0)]);
            i.target = n.bones[r.readInt(!0)],
            i.mix = r.readFloat(),
            i.softness = r.readFloat() * e,
            i.bendDirection = r.readByte(),
            i.compress = r.readBoolean(),
            i.stretch = r.readBoolean(),
            i.uniform = r.readBoolean(),
            n.ikConstraints.push(i)
        }
        s = r.readInt(!0);
        for (let t, i = 0; i < s; i++) {
            const i = new OR(r.readString());
            i.order = r.readInt(!0),
            i.skinRequired = r.readBoolean(),
            t = r.readInt(!0);
            for (let e = 0; e < t; e++)
                i.bones.push(n.bones[r.readInt(!0)]);
            i.target = n.bones[r.readInt(!0)],
            i.local = r.readBoolean(),
            i.relative = r.readBoolean(),
            i.offsetRotation = r.readFloat(),
            i.offsetX = r.readFloat() * e,
            i.offsetY = r.readFloat() * e,
            i.offsetScaleX = r.readFloat(),
            i.offsetScaleY = r.readFloat(),
            i.offsetShearY = r.readFloat(),
            i.rotateMix = r.readFloat(),
            i.translateMix = r.readFloat(),
            i.scaleMix = r.readFloat(),
            i.shearMix = r.readFloat(),
            n.transformConstraints.push(i)
        }
        s = r.readInt(!0);
        for (let t, i = 0; i < s; i++) {
            const i = new _R(r.readString());
            i.order = r.readInt(!0),
            i.skinRequired = r.readBoolean(),
            t = r.readInt(!0);
            for (let e = 0; e < t; e++)
                i.bones.push(n.bones[r.readInt(!0)]);
            i.target = n.slots[r.readInt(!0)],
            i.positionMode = DR.PositionModeValues[r.readInt(!0)],
            i.spacingMode = DR.SpacingModeValues[r.readInt(!0)],
            i.rotateMode = DR.RotateModeValues[r.readInt(!0)],
            i.offsetRotation = r.readFloat(),
            i.position = r.readFloat(),
            i.positionMode == RO.Fixed && (i.position *= e),
            i.spacing = r.readFloat(),
            i.spacingMode != AR.Length && i.spacingMode != AR.Fixed || (i.spacing *= e),
            i.rotateMix = r.readFloat(),
            i.translateMix = r.readFloat(),
            n.pathConstraints.push(i)
        }
        const o = this.readSkin(r, n, !0, i);
        null != o && (n.defaultSkin = o,
        n.skins.push(o));
        {
            let t = n.skins.length;
            for (nN.setArraySize(n.skins, s = t + r.readInt(!0)); t < s; t++)
                n.skins[t] = this.readSkin(r, n, !1, i)
        }
        s = this.linkedMeshes.length;
        for (let t = 0; t < s; t++) {
            const e = this.linkedMeshes[t]
              , r = null == e.skin ? n.defaultSkin : n.findSkin(e.skin);
            if (null == r)
                throw new Error(`Skin not found: ${e.skin}`);
            const i = r.getAttachment(e.slotIndex, e.parent);
            if (null == i)
                throw new Error(`Parent mesh not found: ${e.parent}`);
            e.mesh.deformAttachment = e.inheritDeform ? i : e.mesh,
            e.mesh.setParentMesh(i)
        }
        this.linkedMeshes.length = 0,
        s = r.readInt(!0);
        for (let t = 0; t < s; t++) {
            const t = new wR(r.readStringRef());
            t.intValue = r.readInt(!1),
            t.floatValue = r.readFloat(),
            t.stringValue = r.readString(),
            t.audioPath = r.readString(),
            null != t.audioPath && (t.volume = r.readFloat(),
            t.balance = r.readFloat()),
            n.events.push(t)
        }
        s = r.readInt(!0);
        for (let t = 0; t < s; t++)
            n.animations.push(this.readAnimation(r, r.readString(), n));
        return n
    }
    readSkin(t, e, n, r) {
        let i = null
          , s = 0;
        if (n) {
            if (s = t.readInt(!0),
            0 == s)
                return null;
            i = new RR("default")
        } else {
            i = new RR(t.readStringRef()),
            i.bones.length = t.readInt(!0);
            for (let n = 0, r = i.bones.length; n < r; n++)
                i.bones[n] = e.bones[t.readInt(!0)];
            for (let n = 0, r = t.readInt(!0); n < r; n++)
                i.constraints.push(e.ikConstraints[t.readInt(!0)]);
            for (let n = 0, r = t.readInt(!0); n < r; n++)
                i.constraints.push(e.transformConstraints[t.readInt(!0)]);
            for (let n = 0, r = t.readInt(!0); n < r; n++)
                i.constraints.push(e.pathConstraints[t.readInt(!0)]);
            s = t.readInt(!0)
        }
        for (let n = 0; n < s; n++) {
            const n = t.readInt(!0);
            for (let s = 0, o = t.readInt(!0); s < o; s++) {
                const s = t.readStringRef()
                  , o = this.readAttachment(t, e, i, n, s, r);
                null != o && i.setAttachment(n, s, o)
            }
        }
        return i
    }
    readAttachment(t, e, n, r, i, s) {
        const o = this.scale;
        let a = t.readStringRef();
        null == a && (a = i);
        const l = t.readByte();
        switch (DR.AttachmentTypeValues[l]) {
        case CO.Region:
            {
                let e = t.readStringRef();
                const r = t.readFloat()
                  , i = t.readFloat()
                  , s = t.readFloat()
                  , l = t.readFloat()
                  , c = t.readFloat()
                  , u = t.readFloat()
                  , h = t.readFloat()
                  , d = t.readInt32();
                null == e && (e = a);
                const f = this.attachmentLoader.newRegionAttachment(n, a, e);
                return null == f ? null : (f.path = e,
                f.x = i * o,
                f.y = s * o,
                f.scaleX = l,
                f.scaleY = c,
                f.rotation = r,
                f.width = u * o,
                f.height = h * o,
                qO.rgba8888ToColor(f.color, d),
                f)
            }
        case CO.BoundingBox:
            {
                const e = t.readInt(!0)
                  , r = this.readVertices(t, e)
                  , i = s ? t.readInt32() : 0
                  , o = this.attachmentLoader.newBoundingBoxAttachment(n, a);
                return null == o ? null : (o.worldVerticesLength = e << 1,
                o.vertices = r.vertices,
                o.bones = r.bones,
                s && qO.rgba8888ToColor(o.color, i),
                o)
            }
        case CO.Mesh:
            {
                let e = t.readStringRef();
                const r = t.readInt32()
                  , i = t.readInt(!0)
                  , l = this.readFloatArray(t, i << 1, 1)
                  , c = this.readShortArray(t)
                  , u = this.readVertices(t, i)
                  , h = t.readInt(!0);
                let d = null
                  , f = 0
                  , p = 0;
                s && (d = this.readShortArray(t),
                f = t.readFloat(),
                p = t.readFloat()),
                null == e && (e = a);
                const m = this.attachmentLoader.newMeshAttachment(n, a, e);
                return null == m ? null : (m.path = e,
                qO.rgba8888ToColor(m.color, r),
                m.bones = u.bones,
                m.vertices = u.vertices,
                m.worldVerticesLength = i << 1,
                m.triangles = c,
                m.regionUVs = new Float32Array(l),
                m.hullLength = h << 1,
                s && (m.edges = d,
                m.width = f * o,
                m.height = p * o),
                m)
            }
        case CO.LinkedMesh:
            {
                let e = t.readStringRef();
                const i = t.readInt32()
                  , l = t.readStringRef()
                  , c = t.readStringRef()
                  , u = t.readBoolean();
                let h = 0
                  , d = 0;
                s && (h = t.readFloat(),
                d = t.readFloat()),
                null == e && (e = a);
                const f = this.attachmentLoader.newMeshAttachment(n, a, e);
                return null == f ? null : (f.path = e,
                qO.rgba8888ToColor(f.color, i),
                s && (f.width = h * o,
                f.height = d * o),
                this.linkedMeshes.push(new LR(f,l,r,c,u)),
                f)
            }
        case CO.Path:
            {
                const e = t.readBoolean()
                  , r = t.readBoolean()
                  , i = t.readInt(!0)
                  , l = this.readVertices(t, i)
                  , c = nN.newArray(i / 3, 0);
                for (let e = 0, n = c.length; e < n; e++)
                    c[e] = t.readFloat() * o;
                const u = s ? t.readInt32() : 0
                  , h = this.attachmentLoader.newPathAttachment(n, a);
                return null == h ? null : (h.closed = e,
                h.constantSpeed = r,
                h.worldVerticesLength = i << 1,
                h.vertices = l.vertices,
                h.bones = l.bones,
                h.lengths = c,
                s && qO.rgba8888ToColor(h.color, u),
                h)
            }
        case CO.Point:
            {
                const e = t.readFloat()
                  , r = t.readFloat()
                  , i = t.readFloat()
                  , l = s ? t.readInt32() : 0
                  , c = this.attachmentLoader.newPointAttachment(n, a);
                return null == c ? null : (c.x = r * o,
                c.y = i * o,
                c.rotation = e,
                s && qO.rgba8888ToColor(c.color, l),
                c)
            }
        case CO.Clipping:
            {
                const r = t.readInt(!0)
                  , i = t.readInt(!0)
                  , o = this.readVertices(t, i)
                  , l = s ? t.readInt32() : 0
                  , c = this.attachmentLoader.newClippingAttachment(n, a);
                return null == c ? null : (c.endSlot = e.slots[r],
                c.worldVerticesLength = i << 1,
                c.vertices = o.vertices,
                c.bones = o.bones,
                s && qO.rgba8888ToColor(c.color, l),
                c)
            }
        }
        return null
    }
    readVertices(t, e) {
        const n = e << 1
          , r = new FR
          , i = this.scale;
        if (!t.readBoolean())
            return r.vertices = this.readFloatArray(t, n, i),
            r;
        const s = new Array
          , o = new Array;
        for (let n = 0; n < e; n++) {
            const e = t.readInt(!0);
            o.push(e);
            for (let n = 0; n < e; n++)
                o.push(t.readInt(!0)),
                s.push(t.readFloat() * i),
                s.push(t.readFloat() * i),
                s.push(t.readFloat())
        }
        return r.vertices = nN.toFloatArray(s),
        r.bones = o,
        r
    }
    readFloatArray(t, e, n) {
        const r = new Array(e);
        if (1 == n)
            for (let n = 0; n < e; n++)
                r[n] = t.readFloat();
        else
            for (let i = 0; i < e; i++)
                r[i] = t.readFloat() * n;
        return r
    }
    readShortArray(t) {
        const e = t.readInt(!0)
          , n = new Array(e);
        for (let r = 0; r < e; r++)
            n[r] = t.readShort();
        return n
    }
    readAnimation(t, e, n) {
        const r = new Array
          , i = this.scale;
        let s = 0;
        const o = new qO
          , a = new qO;
        for (let e = 0, n = t.readInt(!0); e < n; e++) {
            const e = t.readInt(!0);
            for (let n = 0, i = t.readInt(!0); n < i; n++) {
                const n = t.readByte()
                  , i = t.readInt(!0);
                switch (n) {
                case DR.SLOT_ATTACHMENT:
                    {
                        const n = new HN(i);
                        n.slotIndex = e;
                        for (let e = 0; e < i; e++)
                            n.setFrame(e, t.readFloat(), t.readStringRef());
                        r.push(n),
                        s = Math.max(s, n.frames[i - 1]);
                        break
                    }
                case DR.SLOT_COLOR:
                    {
                        const n = new VN(i);
                        n.slotIndex = e;
                        for (let e = 0; e < i; e++) {
                            const r = t.readFloat();
                            qO.rgba8888ToColor(o, t.readInt32()),
                            n.setFrame(e, r, o.r, o.g, o.b, o.a),
                            e < i - 1 && this.readCurve(t, e, n)
                        }
                        r.push(n),
                        s = Math.max(s, n.frames[(i - 1) * VN.ENTRIES]);
                        break
                    }
                case DR.SLOT_TWO_COLOR:
                    {
                        const n = new YN(i);
                        n.slotIndex = e;
                        for (let e = 0; e < i; e++) {
                            const r = t.readFloat();
                            qO.rgba8888ToColor(o, t.readInt32()),
                            qO.rgb888ToColor(a, t.readInt32()),
                            n.setFrame(e, r, o.r, o.g, o.b, o.a, a.r, a.g, a.b),
                            e < i - 1 && this.readCurve(t, e, n)
                        }
                        r.push(n),
                        s = Math.max(s, n.frames[(i - 1) * YN.ENTRIES]);
                        break
                    }
                }
            }
        }
        for (let e = 0, n = t.readInt(!0); e < n; e++) {
            const e = t.readInt(!0);
            for (let n = 0, o = t.readInt(!0); n < o; n++) {
                const n = t.readByte()
                  , o = t.readInt(!0);
                switch (n) {
                case DR.BONE_ROTATE:
                    {
                        const n = new BN(o);
                        n.boneIndex = e;
                        for (let e = 0; e < o; e++)
                            n.setFrame(e, t.readFloat(), t.readFloat()),
                            e < o - 1 && this.readCurve(t, e, n);
                        r.push(n),
                        s = Math.max(s, n.frames[(o - 1) * BN.ENTRIES]);
                        break
                    }
                case DR.BONE_TRANSLATE:
                case DR.BONE_SCALE:
                case DR.BONE_SHEAR:
                    {
                        let a, l = 1;
                        n == DR.BONE_SCALE ? a = new jN(o) : n == DR.BONE_SHEAR ? a = new UN(o) : (a = new FN(o),
                        l = i),
                        a.boneIndex = e;
                        for (let e = 0; e < o; e++)
                            a.setFrame(e, t.readFloat(), t.readFloat() * l, t.readFloat() * l),
                            e < o - 1 && this.readCurve(t, e, a);
                        r.push(a),
                        s = Math.max(s, a.frames[(o - 1) * FN.ENTRIES]);
                        break
                    }
                }
            }
        }
        for (let e = 0, n = t.readInt(!0); e < n; e++) {
            const e = t.readInt(!0)
              , n = t.readInt(!0)
              , o = new QN(n);
            o.ikConstraintIndex = e;
            for (let e = 0; e < n; e++)
                o.setFrame(e, t.readFloat(), t.readFloat(), t.readFloat() * i, t.readByte(), t.readBoolean(), t.readBoolean()),
                e < n - 1 && this.readCurve(t, e, o);
            r.push(o),
            s = Math.max(s, o.frames[(n - 1) * QN.ENTRIES])
        }
        for (let e = 0, n = t.readInt(!0); e < n; e++) {
            const e = t.readInt(!0)
              , n = t.readInt(!0)
              , i = new JN(n);
            i.transformConstraintIndex = e;
            for (let e = 0; e < n; e++)
                i.setFrame(e, t.readFloat(), t.readFloat(), t.readFloat(), t.readFloat(), t.readFloat()),
                e < n - 1 && this.readCurve(t, e, i);
            r.push(i),
            s = Math.max(s, i.frames[(n - 1) * JN.ENTRIES])
        }
        for (let e = 0, o = t.readInt(!0); e < o; e++) {
            const e = t.readInt(!0)
              , o = n.pathConstraints[e];
            for (let n = 0, a = t.readInt(!0); n < a; n++) {
                const n = t.readByte()
                  , a = t.readInt(!0);
                switch (n) {
                case DR.PATH_POSITION:
                case DR.PATH_SPACING:
                    {
                        let l, c = 1;
                        n == DR.PATH_SPACING ? (l = new nR(a),
                        o.spacingMode != AR.Length && o.spacingMode != AR.Fixed || (c = i)) : (l = new eR(a),
                        o.positionMode == RO.Fixed && (c = i)),
                        l.pathConstraintIndex = e;
                        for (let e = 0; e < a; e++)
                            l.setFrame(e, t.readFloat(), t.readFloat() * c),
                            e < a - 1 && this.readCurve(t, e, l);
                        r.push(l),
                        s = Math.max(s, l.frames[(a - 1) * eR.ENTRIES]);
                        break
                    }
                case DR.PATH_MIX:
                    {
                        const n = new iR(a);
                        n.pathConstraintIndex = e;
                        for (let e = 0; e < a; e++)
                            n.setFrame(e, t.readFloat(), t.readFloat(), t.readFloat()),
                            e < a - 1 && this.readCurve(t, e, n);
                        r.push(n),
                        s = Math.max(s, n.frames[(a - 1) * iR.ENTRIES]);
                        break
                    }
                }
            }
        }
        for (let e = 0, o = t.readInt(!0); e < o; e++) {
            const e = n.skins[t.readInt(!0)];
            for (let n = 0, o = t.readInt(!0); n < o; n++) {
                const n = t.readInt(!0);
                for (let o = 0, a = t.readInt(!0); o < a; o++) {
                    const o = e.getAttachment(n, t.readStringRef())
                      , a = null != o.bones
                      , l = o.vertices
                      , c = a ? l.length / 3 * 2 : l.length
                      , u = t.readInt(!0)
                      , h = new GN(u);
                    h.slotIndex = n,
                    h.attachment = o;
                    for (let e = 0; e < u; e++) {
                        const n = t.readFloat();
                        let r, s = t.readInt(!0);
                        if (0 == s)
                            r = a ? nN.newFloatArray(c) : l;
                        else {
                            r = nN.newFloatArray(c);
                            const e = t.readInt(!0);
                            if (s += e,
                            1 == i)
                                for (let n = e; n < s; n++)
                                    r[n] = t.readFloat();
                            else
                                for (let n = e; n < s; n++)
                                    r[n] = t.readFloat() * i;
                            if (!a)
                                for (let t = 0, e = r.length; t < e; t++)
                                    r[t] += l[t]
                        }
                        h.setFrame(e, n, r),
                        e < u - 1 && this.readCurve(t, e, h)
                    }
                    r.push(h),
                    s = Math.max(s, h.frames[u - 1])
                }
            }
        }
        const l = t.readInt(!0);
        if (l > 0) {
            const e = new qN(l)
              , i = n.slots.length;
            for (let n = 0; n < l; n++) {
                const r = t.readFloat()
                  , s = t.readInt(!0)
                  , o = nN.newArray(i, 0);
                for (let t = i - 1; t >= 0; t--)
                    o[t] = -1;
                const a = nN.newArray(i - s, 0);
                let l = 0
                  , c = 0;
                for (let e = 0; e < s; e++) {
                    const e = t.readInt(!0);
                    for (; l != e; )
                        a[c++] = l++;
                    o[l + t.readInt(!0)] = l++
                }
                for (; l < i; )
                    a[c++] = l++;
                for (let t = i - 1; t >= 0; t--)
                    -1 == o[t] && (o[t] = a[--c]);
                e.setFrame(n, r, o)
            }
            r.push(e),
            s = Math.max(s, e.frames[l - 1])
        }
        const c = t.readInt(!0);
        if (c > 0) {
            const e = new XN(c);
            for (let r = 0; r < c; r++) {
                const i = t.readFloat()
                  , s = n.events[t.readInt(!0)]
                  , o = new vR(i,s);
                o.intValue = t.readInt(!1),
                o.floatValue = t.readFloat(),
                o.stringValue = t.readBoolean() ? t.readString() : s.stringValue,
                null != o.data.audioPath && (o.volume = t.readFloat(),
                o.balance = t.readFloat()),
                e.setFrame(r, o)
            }
            r.push(e),
            s = Math.max(s, e.frames[c - 1])
        }
        return new PN(e,r,s)
    }
    readCurve(t, e, n) {
        switch (t.readByte()) {
        case DR.CURVE_STEPPED:
            n.setStepped(e);
            break;
        case DR.CURVE_BEZIER:
            this.setCurve(n, e, t.readFloat(), t.readFloat(), t.readFloat(), t.readFloat())
        }
    }
    setCurve(t, e, n, r, i, s) {
        t.setCurve(e, n, r, i, s)
    }
}
;
let BR = DR;
BR.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6],
BR.TransformModeValues = [BO.Normal, BO.OnlyTranslation, BO.NoRotationOrReflection, BO.NoScale, BO.NoScaleOrReflection],
BR.PositionModeValues = [RO.Fixed, RO.Percent],
BR.SpacingModeValues = [AR.Length, AR.Fixed, AR.Percent],
BR.RotateModeValues = [DO.Tangent, DO.Chain, DO.ChainScale],
BR.BlendModeValues = [Om.NORMAL, Om.ADD, Om.MULTIPLY, Om.SCREEN],
BR.BONE_ROTATE = 0,
BR.BONE_TRANSLATE = 1,
BR.BONE_SCALE = 2,
BR.BONE_SHEAR = 3,
BR.SLOT_ATTACHMENT = 0,
BR.SLOT_COLOR = 1,
BR.SLOT_TWO_COLOR = 2,
BR.PATH_POSITION = 0,
BR.PATH_SPACING = 1,
BR.PATH_MIX = 2,
BR.CURVE_LINEAR = 0,
BR.CURVE_STEPPED = 1,
BR.CURVE_BEZIER = 2;
class LR {
    constructor(t, e, n, r, i) {
        this.mesh = t,
        this.skin = e,
        this.slotIndex = n,
        this.parent = r,
        this.inheritDeform = i
    }
}
class FR {
    constructor(t=null, e=null) {
        this.bones = t,
        this.vertices = e
    }
}
class jR extends sN {
}
class UR {
    constructor(t) {
        this.scale = 1,
        this.linkedMeshes = new Array,
        this.attachmentLoader = t
    }
    readSkeletonData(t) {
        const e = this.scale
          , n = new CR
          , r = "string" == typeof t ? JSON.parse(t) : t
          , i = r.skeleton;
        if (null != i) {
            if (n.hash = i.hash,
            n.version = i.spine,
            "3.8" !== n.version.substr(0, 3)) {
                const t = `Spine 3.8 loader cant load version ${i.spine}. Please configure your pixi-spine bundle`;
                console.error(t)
            }
            if ("3.8.75" === n.version) {
                const t = "Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.";
                console.error(t)
            }
            n.x = i.x,
            n.y = i.y,
            n.width = i.width,
            n.height = i.height,
            n.fps = i.fps,
            n.imagesPath = i.images
        }
        if (r.bones)
            for (let t = 0; t < r.bones.length; t++) {
                const i = r.bones[t];
                let s = null;
                const o = this.getValue(i, "parent", null);
                if (null != o && (s = n.findBone(o),
                null == s))
                    throw new Error(`Parent bone not found: ${o}`);
                const a = new yR(n.bones.length,i.name,s);
                a.length = this.getValue(i, "length", 0) * e,
                a.x = this.getValue(i, "x", 0) * e,
                a.y = this.getValue(i, "y", 0) * e,
                a.rotation = this.getValue(i, "rotation", 0),
                a.scaleX = this.getValue(i, "scaleX", 1),
                a.scaleY = this.getValue(i, "scaleY", 1),
                a.shearX = this.getValue(i, "shearX", 0),
                a.shearY = this.getValue(i, "shearY", 0),
                a.transformMode = UR.transformModeFromString(this.getValue(i, "transform", "normal")),
                a.skinRequired = this.getValue(i, "skin", !1),
                n.bones.push(a)
            }
        if (r.slots)
            for (let t = 0; t < r.slots.length; t++) {
                const e = r.slots[t]
                  , i = e.name
                  , s = e.bone
                  , o = n.findBone(s);
                if (null == o)
                    throw new Error(`Slot bone not found: ${s}`);
                const a = new PR(n.slots.length,i,o)
                  , l = this.getValue(e, "color", null);
                null != l && a.color.setFromString(l);
                const c = this.getValue(e, "dark", null);
                null != c && (a.darkColor = new qO(1,1,1,1),
                a.darkColor.setFromString(c)),
                a.attachmentName = this.getValue(e, "attachment", null),
                a.blendMode = UR.blendModeFromString(this.getValue(e, "blend", "normal")),
                n.slots.push(a)
            }
        if (r.ik)
            for (let t = 0; t < r.ik.length; t++) {
                const i = r.ik[t]
                  , s = new ER(i.name);
                s.order = this.getValue(i, "order", 0),
                s.skinRequired = this.getValue(i, "skin", !1);
                for (let t = 0; t < i.bones.length; t++) {
                    const e = i.bones[t]
                      , r = n.findBone(e);
                    if (null == r)
                        throw new Error(`IK bone not found: ${e}`);
                    s.bones.push(r)
                }
                const o = i.target;
                if (s.target = n.findBone(o),
                null == s.target)
                    throw new Error(`IK target bone not found: ${o}`);
                s.mix = this.getValue(i, "mix", 1),
                s.softness = this.getValue(i, "softness", 0) * e,
                s.bendDirection = this.getValue(i, "bendPositive", !0) ? 1 : -1,
                s.compress = this.getValue(i, "compress", !1),
                s.stretch = this.getValue(i, "stretch", !1),
                s.uniform = this.getValue(i, "uniform", !1),
                n.ikConstraints.push(s)
            }
        if (r.transform)
            for (let t = 0; t < r.transform.length; t++) {
                const i = r.transform[t]
                  , s = new OR(i.name);
                s.order = this.getValue(i, "order", 0),
                s.skinRequired = this.getValue(i, "skin", !1);
                for (let t = 0; t < i.bones.length; t++) {
                    const e = i.bones[t]
                      , r = n.findBone(e);
                    if (null == r)
                        throw new Error(`Transform constraint bone not found: ${e}`);
                    s.bones.push(r)
                }
                const o = i.target;
                if (s.target = n.findBone(o),
                null == s.target)
                    throw new Error(`Transform constraint target bone not found: ${o}`);
                s.local = this.getValue(i, "local", !1),
                s.relative = this.getValue(i, "relative", !1),
                s.offsetRotation = this.getValue(i, "rotation", 0),
                s.offsetX = this.getValue(i, "x", 0) * e,
                s.offsetY = this.getValue(i, "y", 0) * e,
                s.offsetScaleX = this.getValue(i, "scaleX", 0),
                s.offsetScaleY = this.getValue(i, "scaleY", 0),
                s.offsetShearY = this.getValue(i, "shearY", 0),
                s.rotateMix = this.getValue(i, "rotateMix", 1),
                s.translateMix = this.getValue(i, "translateMix", 1),
                s.scaleMix = this.getValue(i, "scaleMix", 1),
                s.shearMix = this.getValue(i, "shearMix", 1),
                n.transformConstraints.push(s)
            }
        if (r.path)
            for (let t = 0; t < r.path.length; t++) {
                const i = r.path[t]
                  , s = new _R(i.name);
                s.order = this.getValue(i, "order", 0),
                s.skinRequired = this.getValue(i, "skin", !1);
                for (let t = 0; t < i.bones.length; t++) {
                    const e = i.bones[t]
                      , r = n.findBone(e);
                    if (null == r)
                        throw new Error(`Transform constraint bone not found: ${e}`);
                    s.bones.push(r)
                }
                const o = i.target;
                if (s.target = n.findSlot(o),
                null == s.target)
                    throw new Error(`Path target slot not found: ${o}`);
                s.positionMode = UR.positionModeFromString(this.getValue(i, "positionMode", "percent")),
                s.spacingMode = UR.spacingModeFromString(this.getValue(i, "spacingMode", "length")),
                s.rotateMode = UR.rotateModeFromString(this.getValue(i, "rotateMode", "tangent")),
                s.offsetRotation = this.getValue(i, "rotation", 0),
                s.position = this.getValue(i, "position", 0),
                s.positionMode == RO.Fixed && (s.position *= e),
                s.spacing = this.getValue(i, "spacing", 0),
                s.spacingMode != AR.Length && s.spacingMode != AR.Fixed || (s.spacing *= e),
                s.rotateMix = this.getValue(i, "rotateMix", 1),
                s.translateMix = this.getValue(i, "translateMix", 1),
                n.pathConstraints.push(s)
            }
        if (r.skins)
            for (let t = 0; t < r.skins.length; t++) {
                const e = r.skins[t]
                  , i = new RR(e.name);
                if (e.bones)
                    for (let r = 0; r < e.bones.length; r++) {
                        const s = n.findBone(e.bones[r]);
                        if (null == s)
                            throw new Error(`Skin bone not found: ${e.bones[t]}`);
                        i.bones.push(s)
                    }
                if (e.ik)
                    for (let r = 0; r < e.ik.length; r++) {
                        const s = n.findIkConstraint(e.ik[r]);
                        if (null == s)
                            throw new Error(`Skin IK constraint not found: ${e.ik[t]}`);
                        i.constraints.push(s)
                    }
                if (e.transform)
                    for (let r = 0; r < e.transform.length; r++) {
                        const s = n.findTransformConstraint(e.transform[r]);
                        if (null == s)
                            throw new Error(`Skin transform constraint not found: ${e.transform[t]}`);
                        i.constraints.push(s)
                    }
                if (e.path)
                    for (let r = 0; r < e.path.length; r++) {
                        const s = n.findPathConstraint(e.path[r]);
                        if (null == s)
                            throw new Error(`Skin path constraint not found: ${e.path[t]}`);
                        i.constraints.push(s)
                    }
                for (const t in e.attachments) {
                    const r = n.findSlot(t);
                    if (null == r)
                        throw new Error(`Slot not found: ${t}`);
                    const s = e.attachments[t];
                    for (const t in s) {
                        const e = this.readAttachment(s[t], i, r.index, t, n);
                        null != e && i.setAttachment(r.index, t, e)
                    }
                }
                n.skins.push(i),
                "default" == i.name && (n.defaultSkin = i)
            }
        for (let t = 0, e = this.linkedMeshes.length; t < e; t++) {
            const e = this.linkedMeshes[t]
              , r = null == e.skin ? n.defaultSkin : n.findSkin(e.skin);
            if (null == r)
                throw new Error(`Skin not found: ${e.skin}`);
            const i = r.getAttachment(e.slotIndex, e.parent);
            if (null == i)
                throw new Error(`Parent mesh not found: ${e.parent}`);
            e.mesh.deformAttachment = e.inheritDeform ? i : e.mesh,
            e.mesh.setParentMesh(i)
        }
        if (this.linkedMeshes.length = 0,
        r.events)
            for (const t in r.events) {
                const e = r.events[t]
                  , i = new wR(t);
                i.intValue = this.getValue(e, "int", 0),
                i.floatValue = this.getValue(e, "float", 0),
                i.stringValue = this.getValue(e, "string", ""),
                i.audioPath = this.getValue(e, "audio", null),
                null != i.audioPath && (i.volume = this.getValue(e, "volume", 1),
                i.balance = this.getValue(e, "balance", 0)),
                n.events.push(i)
            }
        if (r.animations)
            for (const t in r.animations) {
                const e = r.animations[t];
                this.readAnimation(e, t, n)
            }
        return n
    }
    readAttachment(t, e, n, r, i) {
        const s = this.scale;
        r = this.getValue(t, "name", r);
        switch (this.getValue(t, "type", "region")) {
        case "region":
            {
                const n = this.getValue(t, "path", r)
                  , i = this.attachmentLoader.newRegionAttachment(e, r, n);
                if (null == i)
                    return null;
                i.path = n,
                i.x = this.getValue(t, "x", 0) * s,
                i.y = this.getValue(t, "y", 0) * s,
                i.scaleX = this.getValue(t, "scaleX", 1),
                i.scaleY = this.getValue(t, "scaleY", 1),
                i.rotation = this.getValue(t, "rotation", 0),
                i.width = t.width * s,
                i.height = t.height * s;
                const o = this.getValue(t, "color", null);
                return null != o && i.color.setFromString(o),
                i
            }
        case "boundingbox":
            {
                const n = this.attachmentLoader.newBoundingBoxAttachment(e, r);
                if (null == n)
                    return null;
                this.readVertices(t, n, t.vertexCount << 1);
                const i = this.getValue(t, "color", null);
                return null != i && n.color.setFromString(i),
                n
            }
        case "mesh":
        case "linkedmesh":
            {
                const i = this.getValue(t, "path", r)
                  , o = this.attachmentLoader.newMeshAttachment(e, r, i);
                if (null == o)
                    return null;
                o.path = i;
                const a = this.getValue(t, "color", null);
                null != a && o.color.setFromString(a),
                o.width = this.getValue(t, "width", 0) * s,
                o.height = this.getValue(t, "height", 0) * s;
                const l = this.getValue(t, "parent", null);
                if (null != l)
                    return this.linkedMeshes.push(new zR(o,this.getValue(t, "skin", null),n,l,this.getValue(t, "deform", !0))),
                    o;
                const c = t.uvs;
                return this.readVertices(t, o, c.length),
                o.triangles = t.triangles,
                o.regionUVs = new Float32Array(c),
                o.edges = this.getValue(t, "edges", null),
                o.hullLength = 2 * this.getValue(t, "hull", 0),
                o
            }
        case "path":
            {
                const n = this.attachmentLoader.newPathAttachment(e, r);
                if (null == n)
                    return null;
                n.closed = this.getValue(t, "closed", !1),
                n.constantSpeed = this.getValue(t, "constantSpeed", !0);
                const i = t.vertexCount;
                this.readVertices(t, n, i << 1);
                const o = nN.newArray(i / 3, 0);
                for (let e = 0; e < t.lengths.length; e++)
                    o[e] = t.lengths[e] * s;
                n.lengths = o;
                const a = this.getValue(t, "color", null);
                return null != a && n.color.setFromString(a),
                n
            }
        case "point":
            {
                const n = this.attachmentLoader.newPointAttachment(e, r);
                if (null == n)
                    return null;
                n.x = this.getValue(t, "x", 0) * s,
                n.y = this.getValue(t, "y", 0) * s,
                n.rotation = this.getValue(t, "rotation", 0);
                const i = this.getValue(t, "color", null);
                return null != i && n.color.setFromString(i),
                n
            }
        case "clipping":
            {
                const n = this.attachmentLoader.newClippingAttachment(e, r);
                if (null == n)
                    return null;
                const s = this.getValue(t, "end", null);
                if (null != s) {
                    const t = i.findSlot(s);
                    if (null == t)
                        throw new Error(`Clipping end slot not found: ${s}`);
                    n.endSlot = t
                }
                const o = t.vertexCount;
                this.readVertices(t, n, o << 1);
                const a = this.getValue(t, "color", null);
                return null != a && n.color.setFromString(a),
                n
            }
        }
        return null
    }
    readVertices(t, e, n) {
        const r = this.scale;
        e.worldVerticesLength = n;
        const i = t.vertices;
        if (n == i.length) {
            const t = nN.toFloatArray(i);
            if (1 != r)
                for (let e = 0, n = i.length; e < n; e++)
                    t[e] *= r;
            return void (e.vertices = t)
        }
        const s = new Array
          , o = new Array;
        for (let t = 0, e = i.length; t < e; ) {
            const e = i[t++];
            o.push(e);
            for (let n = t + 4 * e; t < n; t += 4)
                o.push(i[t]),
                s.push(i[t + 1] * r),
                s.push(i[t + 2] * r),
                s.push(i[t + 3])
        }
        e.bones = o,
        e.vertices = nN.toFloatArray(s)
    }
    readAnimation(t, e, n) {
        const r = this.scale
          , i = new Array;
        let s = 0;
        if (t.slots)
            for (const e in t.slots) {
                const r = t.slots[e]
                  , o = n.findSlotIndex(e);
                if (-1 == o)
                    throw new Error(`Slot not found: ${e}`);
                for (const t in r) {
                    const n = r[t];
                    if ("attachment" == t) {
                        const t = new HN(n.length);
                        t.slotIndex = o;
                        let e = 0;
                        for (let r = 0; r < n.length; r++) {
                            const i = n[r];
                            t.setFrame(e++, this.getValue(i, "time", 0), i.name)
                        }
                        i.push(t),
                        s = Math.max(s, t.frames[t.getFrameCount() - 1])
                    } else if ("color" == t) {
                        const t = new VN(n.length);
                        t.slotIndex = o;
                        let e = 0;
                        for (let r = 0; r < n.length; r++) {
                            const i = n[r]
                              , s = new qO;
                            s.setFromString(i.color || "ffffffff"),
                            t.setFrame(e, this.getValue(i, "time", 0), s.r, s.g, s.b, s.a),
                            this.readCurve(i, t, e),
                            e++
                        }
                        i.push(t),
                        s = Math.max(s, t.frames[(t.getFrameCount() - 1) * VN.ENTRIES])
                    } else {
                        if ("twoColor" != t)
                            throw new Error(`Invalid timeline type for a slot: ${t} (${e})`);
                        {
                            const t = new YN(n.length);
                            t.slotIndex = o;
                            let e = 0;
                            for (let r = 0; r < n.length; r++) {
                                const i = n[r]
                                  , s = new qO
                                  , o = new qO;
                                s.setFromString(i.light),
                                o.setFromString(i.dark),
                                t.setFrame(e, this.getValue(i, "time", 0), s.r, s.g, s.b, s.a, o.r, o.g, o.b),
                                this.readCurve(i, t, e),
                                e++
                            }
                            i.push(t),
                            s = Math.max(s, t.frames[(t.getFrameCount() - 1) * YN.ENTRIES])
                        }
                    }
                }
            }
        if (t.bones)
            for (const e in t.bones) {
                const o = t.bones[e]
                  , a = n.findBoneIndex(e);
                if (-1 == a)
                    throw new Error(`Bone not found: ${e}`);
                for (const t in o) {
                    const n = o[t];
                    if ("rotate" === t) {
                        const t = new BN(n.length);
                        t.boneIndex = a;
                        let e = 0;
                        for (let r = 0; r < n.length; r++) {
                            const i = n[r];
                            t.setFrame(e, this.getValue(i, "time", 0), this.getValue(i, "angle", 0)),
                            this.readCurve(i, t, e),
                            e++
                        }
                        i.push(t),
                        s = Math.max(s, t.frames[(t.getFrameCount() - 1) * BN.ENTRIES])
                    } else {
                        if ("translate" !== t && "scale" !== t && "shear" !== t)
                            throw new Error(`Invalid timeline type for a bone: ${t} (${e})`);
                        {
                            let e = null
                              , o = 1
                              , l = 0;
                            "scale" === t ? (e = new jN(n.length),
                            l = 1) : "shear" === t ? e = new UN(n.length) : (e = new FN(n.length),
                            o = r),
                            e.boneIndex = a;
                            let c = 0;
                            for (let t = 0; t < n.length; t++) {
                                const r = n[t]
                                  , i = this.getValue(r, "x", l)
                                  , s = this.getValue(r, "y", l);
                                e.setFrame(c, this.getValue(r, "time", 0), i * o, s * o),
                                this.readCurve(r, e, c),
                                c++
                            }
                            i.push(e),
                            s = Math.max(s, e.frames[(e.getFrameCount() - 1) * FN.ENTRIES])
                        }
                    }
                }
            }
        if (t.ik)
            for (const e in t.ik) {
                const o = t.ik[e]
                  , a = n.findIkConstraint(e)
                  , l = new QN(o.length);
                l.ikConstraintIndex = n.ikConstraints.indexOf(a);
                let c = 0;
                for (let t = 0; t < o.length; t++) {
                    const e = o[t];
                    l.setFrame(c, this.getValue(e, "time", 0), this.getValue(e, "mix", 1), this.getValue(e, "softness", 0) * r, this.getValue(e, "bendPositive", !0) ? 1 : -1, this.getValue(e, "compress", !1), this.getValue(e, "stretch", !1)),
                    this.readCurve(e, l, c),
                    c++
                }
                i.push(l),
                s = Math.max(s, l.frames[(l.getFrameCount() - 1) * QN.ENTRIES])
            }
        if (t.transform)
            for (const e in t.transform) {
                const r = t.transform[e]
                  , o = n.findTransformConstraint(e)
                  , a = new JN(r.length);
                a.transformConstraintIndex = n.transformConstraints.indexOf(o);
                let l = 0;
                for (let t = 0; t < r.length; t++) {
                    const e = r[t];
                    a.setFrame(l, this.getValue(e, "time", 0), this.getValue(e, "rotateMix", 1), this.getValue(e, "translateMix", 1), this.getValue(e, "scaleMix", 1), this.getValue(e, "shearMix", 1)),
                    this.readCurve(e, a, l),
                    l++
                }
                i.push(a),
                s = Math.max(s, a.frames[(a.getFrameCount() - 1) * JN.ENTRIES])
            }
        if (t.path)
            for (const e in t.path) {
                const o = t.path[e]
                  , a = n.findPathConstraintIndex(e);
                if (-1 == a)
                    throw new Error(`Path constraint not found: ${e}`);
                const l = n.pathConstraints[a];
                for (const t in o) {
                    const e = o[t];
                    if ("position" === t || "spacing" === t) {
                        let n = null
                          , o = 1;
                        "spacing" === t ? (n = new nR(e.length),
                        l.spacingMode != AR.Length && l.spacingMode != AR.Fixed || (o = r)) : (n = new eR(e.length),
                        l.positionMode == RO.Fixed && (o = r)),
                        n.pathConstraintIndex = a;
                        let c = 0;
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r];
                            n.setFrame(c, this.getValue(i, "time", 0), this.getValue(i, t, 0) * o),
                            this.readCurve(i, n, c),
                            c++
                        }
                        i.push(n),
                        s = Math.max(s, n.frames[(n.getFrameCount() - 1) * eR.ENTRIES])
                    } else if ("mix" === t) {
                        const t = new iR(e.length);
                        t.pathConstraintIndex = a;
                        let n = 0;
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r];
                            t.setFrame(n, this.getValue(i, "time", 0), this.getValue(i, "rotateMix", 1), this.getValue(i, "translateMix", 1)),
                            this.readCurve(i, t, n),
                            n++
                        }
                        i.push(t),
                        s = Math.max(s, t.frames[(t.getFrameCount() - 1) * iR.ENTRIES])
                    }
                }
            }
        if (t.deform)
            for (const e in t.deform) {
                const o = t.deform[e]
                  , a = n.findSkin(e);
                if (null != a)
                    for (const t in o) {
                        const e = o[t]
                          , l = n.findSlotIndex(t);
                        if (-1 == l)
                            throw new Error(`Slot not found: ${e.name}`);
                        for (const t in e) {
                            const n = e[t]
                              , o = a.getAttachment(l, t);
                            if (null == o)
                                throw new Error(`Deform attachment not found: ${n.name}`);
                            const c = null != o.bones
                              , u = o.vertices
                              , h = c ? u.length / 3 * 2 : u.length
                              , d = new GN(n.length);
                            d.slotIndex = l,
                            d.attachment = o;
                            let f = 0;
                            for (let t = 0; t < n.length; t++) {
                                const e = n[t];
                                let i;
                                const s = this.getValue(e, "vertices", null);
                                if (null == s)
                                    i = c ? nN.newFloatArray(h) : u;
                                else {
                                    i = nN.newFloatArray(h);
                                    const t = this.getValue(e, "offset", 0);
                                    if (nN.arrayCopy(s, 0, i, t, s.length),
                                    1 != r)
                                        for (let e = t, n = e + s.length; e < n; e++)
                                            i[e] *= r;
                                    if (!c)
                                        for (let t = 0; t < h; t++)
                                            i[t] += u[t]
                                }
                                d.setFrame(f, this.getValue(e, "time", 0), i),
                                this.readCurve(e, d, f),
                                f++
                            }
                            i.push(d),
                            s = Math.max(s, d.frames[d.getFrameCount() - 1])
                        }
                    }
                else if (oN.FAIL_ON_NON_EXISTING_SKIN)
                    throw new Error(`Skin not found: ${e}`)
            }
        let o = t.drawOrder;
        if (null == o && (o = t.draworder),
        null != o) {
            const t = new qN(o.length)
              , e = n.slots.length;
            let r = 0;
            for (let i = 0; i < o.length; i++) {
                const s = o[i];
                let a = null;
                const l = this.getValue(s, "offsets", null);
                if (null != l) {
                    a = nN.newArray(e, -1);
                    const t = nN.newArray(e - l.length, 0);
                    let r = 0
                      , i = 0;
                    for (let e = 0; e < l.length; e++) {
                        const s = l[e]
                          , o = n.findSlotIndex(s.slot);
                        if (-1 == o)
                            throw new Error(`Slot not found: ${s.slot}`);
                        for (; r != o; )
                            t[i++] = r++;
                        a[r + s.offset] = r++
                    }
                    for (; r < e; )
                        t[i++] = r++;
                    for (let n = e - 1; n >= 0; n--)
                        -1 == a[n] && (a[n] = t[--i])
                }
                t.setFrame(r++, this.getValue(s, "time", 0), a)
            }
            i.push(t),
            s = Math.max(s, t.frames[t.getFrameCount() - 1])
        }
        if (t.events) {
            const e = new XN(t.events.length);
            let r = 0;
            for (let i = 0; i < t.events.length; i++) {
                const s = t.events[i]
                  , o = n.findEvent(s.name);
                if (null == o)
                    throw new Error(`Event not found: ${s.name}`);
                const a = new vR(nN.toSinglePrecision(this.getValue(s, "time", 0)),o);
                a.intValue = this.getValue(s, "int", o.intValue),
                a.floatValue = this.getValue(s, "float", o.floatValue),
                a.stringValue = this.getValue(s, "string", o.stringValue),
                null != a.data.audioPath && (a.volume = this.getValue(s, "volume", 1),
                a.balance = this.getValue(s, "balance", 0)),
                e.setFrame(r++, a)
            }
            i.push(e),
            s = Math.max(s, e.frames[e.getFrameCount() - 1])
        }
        if (isNaN(s))
            throw new Error("Error while parsing animation, duration is NaN");
        n.animations.push(new PN(e,i,s))
    }
    readCurve(t, e, n) {
        if (t.hasOwnProperty("curve"))
            if ("stepped" === t.curve)
                e.setStepped(n);
            else {
                const r = t.curve;
                e.setCurve(n, r, this.getValue(t, "c2", 0), this.getValue(t, "c3", 1), this.getValue(t, "c4", 1))
            }
    }
    getValue(t, e, n) {
        return void 0 !== t[e] ? t[e] : n
    }
    static blendModeFromString(t) {
        if ("normal" == (t = t.toLowerCase()))
            return Om.NORMAL;
        if ("additive" == t)
            return Om.ADD;
        if ("multiply" == t)
            return Om.MULTIPLY;
        if ("screen" == t)
            return Om.SCREEN;
        throw new Error(`Unknown blend mode: ${t}`)
    }
    static positionModeFromString(t) {
        if ("fixed" == (t = t.toLowerCase()))
            return RO.Fixed;
        if ("percent" == t)
            return RO.Percent;
        throw new Error(`Unknown position mode: ${t}`)
    }
    static spacingModeFromString(t) {
        if ("length" == (t = t.toLowerCase()))
            return AR.Length;
        if ("fixed" == t)
            return AR.Fixed;
        if ("percent" == t)
            return AR.Percent;
        throw new Error(`Unknown position mode: ${t}`)
    }
    static rotateModeFromString(t) {
        if ("tangent" == (t = t.toLowerCase()))
            return DO.Tangent;
        if ("chain" == t)
            return DO.Chain;
        if ("chainscale" == t)
            return DO.ChainScale;
        throw new Error(`Unknown rotate mode: ${t}`)
    }
    static transformModeFromString(t) {
        if ("normal" == (t = t.toLowerCase()))
            return BO.Normal;
        if ("onlytranslation" == t)
            return BO.OnlyTranslation;
        if ("norotationorreflection" == t)
            return BO.NoRotationOrReflection;
        if ("noscale" == t)
            return BO.NoScale;
        if ("noscaleorreflection" == t)
            return BO.NoScaleOrReflection;
        throw new Error(`Unknown transform mode: ${t}`)
    }
}
class zR {
    constructor(t, e, n, r, i) {
        this.mesh = t,
        this.skin = e,
        this.slotIndex = n,
        this.parent = r,
        this.inheritDeform = i
    }
}
class VR extends hN {
    createSkeleton(t) {
        this.skeleton = new MR(t),
        this.skeleton.updateWorldTransform(),
        this.stateData = new pR(t),
        this.state = new oR(this.stateData)
    }
}
var WR = {};
t(WR, "Attachment", (()=>YR)),
t(WR, "VertexAttachment", (()=>$R)),
t(WR, "BoundingBoxAttachment", (()=>GR)),
t(WR, "ClippingAttachment", (()=>XR)),
t(WR, "MeshAttachment", (()=>qR)),
t(WR, "PathAttachment", (()=>KR)),
t(WR, "PointAttachment", (()=>QR)),
t(WR, "RegionAttachment", (()=>tD)),
t(WR, "JitterEffect", (()=>eD)),
t(WR, "SwirlEffect", (()=>rD)),
t(WR, "Animation", (()=>iD)),
t(WR, "AttachmentTimeline", (()=>bD)),
t(WR, "ColorTimeline", (()=>mD)),
t(WR, "CurveTimeline", (()=>aD)),
t(WR, "DeformTimeline", (()=>wD)),
t(WR, "DrawOrderTimeline", (()=>ED)),
t(WR, "EventTimeline", (()=>xD)),
t(WR, "IkConstraintTimeline", (()=>AD)),
t(WR, "PathConstraintMixTimeline", (()=>PD)),
t(WR, "PathConstraintPositionTimeline", (()=>ID)),
t(WR, "PathConstraintSpacingTimeline", (()=>MD)),
t(WR, "RotateTimeline", (()=>cD)),
t(WR, "ScaleTimeline", (()=>dD)),
t(WR, "ShearTimeline", (()=>fD)),
t(WR, "TimelineType", (()=>sD)),
t(WR, "TransformConstraintTimeline", (()=>TD)),
t(WR, "TranslateTimeline", (()=>hD)),
t(WR, "TwoColorTimeline", (()=>yD)),
t(WR, "AnimationState", (()=>ND)),
t(WR, "AnimationStateAdapter2", (()=>jD)),
t(WR, "EventQueue", (()=>LD)),
t(WR, "EventType", (()=>FD)),
t(WR, "TrackEntry", (()=>DD)),
t(WR, "AnimationStateData", (()=>zD)),
t(WR, "AtlasAttachmentLoader", (()=>VD)),
t(WR, "Bone", (()=>WD)),
t(WR, "BoneData", (()=>YD)),
t(WR, "Event", (()=>HD)),
t(WR, "EventData", (()=>$D)),
t(WR, "IkConstraint", (()=>GD)),
t(WR, "IkConstraintData", (()=>XD)),
t(WR, "PathConstraint", (()=>ZD)),
t(WR, "PathConstraintData", (()=>qD)),
t(WR, "SpacingMode", (()=>KD)),
t(WR, "Skeleton", (()=>eB)),
t(WR, "SkeletonBounds", (()=>nB)),
t(WR, "SkeletonData", (()=>rB)),
t(WR, "SkeletonJson", (()=>aB)),
t(WR, "Skin", (()=>oB)),
t(WR, "Slot", (()=>ZR)),
t(WR, "SlotData", (()=>iB)),
t(WR, "TransformConstraint", (()=>JD)),
t(WR, "TransformConstraintData", (()=>sB)),
t(WR, "Spine", (()=>cB));
class YR {
    constructor(t) {
        if (null == t)
            throw new Error("name cannot be null.");
        this.name = t
    }
}
const HR = class extends YR {
    constructor(t) {
        super(t),
        this.id = (65535 & HR.nextID++) << 11,
        this.worldVerticesLength = 0
    }
    computeWorldVerticesOld(t, e) {
        this.computeWorldVertices(t, 0, this.worldVerticesLength, e, 0, 2)
    }
    computeWorldVertices(t, e, n, r, i, s) {
        n = i + (n >> 1) * s;
        const o = t.bone.skeleton
          , a = t.attachmentVertices;
        let l = this.vertices;
        const c = this.bones;
        if (null == c) {
            a.length > 0 && (l = a);
            const o = t.bone.matrix
              , c = o.tx
              , u = o.ty
              , h = o.a
              , d = o.c
              , f = o.b
              , p = o.d;
            for (let t = e, o = i; o < n; t += 2,
            o += s) {
                const e = l[t]
                  , n = l[t + 1];
                r[o] = e * h + n * d + c,
                r[o + 1] = e * f + n * p + u
            }
            return
        }
        let u = 0
          , h = 0;
        for (let t = 0; t < e; t += 2) {
            const t = c[u];
            u += t + 1,
            h += t
        }
        const d = o.bones;
        if (0 == a.length)
            for (let t = i, e = 3 * h; t < n; t += s) {
                let n = 0
                  , i = 0
                  , s = c[u++];
                for (s += u; u < s; u++,
                e += 3) {
                    const t = d[c[u]].matrix
                      , r = l[e]
                      , s = l[e + 1]
                      , o = l[e + 2];
                    n += (r * t.a + s * t.c + t.tx) * o,
                    i += (r * t.b + s * t.d + t.ty) * o
                }
                r[t] = n,
                r[t + 1] = i
            }
        else {
            const t = a;
            for (let e = i, o = 3 * h, a = h << 1; e < n; e += s) {
                let n = 0
                  , i = 0
                  , s = c[u++];
                for (s += u; u < s; u++,
                o += 3,
                a += 2) {
                    const e = d[c[u]].matrix
                      , r = l[o] + t[a]
                      , s = l[o + 1] + t[a + 1]
                      , h = l[o + 2];
                    n += (r * e.a + s * e.c + e.tx) * h,
                    i += (r * e.b + s * e.d + e.ty) * h
                }
                r[e] = n,
                r[e + 1] = i
            }
        }
    }
    applyDeform(t) {
        return this == t
    }
}
;
let $R = HR;
$R.nextID = 0;
class GR extends $R {
    constructor(t) {
        super(t),
        this.type = CO.BoundingBox,
        this.color = new qO(1,1,1,1)
    }
}
class XR extends $R {
    constructor(t) {
        super(t),
        this.type = CO.Clipping,
        this.color = new qO(.2275,.2275,.8078,1)
    }
}
class qR extends $R {
    constructor(t) {
        super(t),
        this.type = CO.Mesh,
        this.color = new qO(1,1,1,1),
        this.inheritDeform = !1,
        this.tempColor = new qO(0,0,0,0)
    }
    applyDeform(t) {
        return this == t || this.inheritDeform && this.parentMesh == t
    }
    getParentMesh() {
        return this.parentMesh
    }
    setParentMesh(t) {
        this.parentMesh = t,
        null != t && (this.bones = t.bones,
        this.vertices = t.vertices,
        this.worldVerticesLength = t.worldVerticesLength,
        this.regionUVs = t.regionUVs,
        this.triangles = t.triangles,
        this.hullLength = t.hullLength,
        this.worldVerticesLength = t.worldVerticesLength)
    }
}
class KR extends $R {
    constructor(t) {
        super(t),
        this.type = CO.Path,
        this.closed = !1,
        this.constantSpeed = !1,
        this.color = new qO(1,1,1,1)
    }
}
class QR extends $R {
    constructor(t) {
        super(t),
        this.type = CO.Point,
        this.color = new qO(.38,.94,0,1)
    }
    computeWorldPosition(t, e) {
        const n = t.matrix;
        return e.x = this.x * n.a + this.y * n.c + t.worldX,
        e.y = this.x * n.b + this.y * n.d + t.worldY,
        e
    }
    computeWorldRotation(t) {
        const e = t.matrix
          , n = QO.cosDeg(this.rotation)
          , r = QO.sinDeg(this.rotation)
          , i = n * e.a + r * e.c
          , s = n * e.b + r * e.d;
        return Math.atan2(s, i) * QO.radDeg
    }
}
class ZR {
    constructor(t, e) {
        if (this.attachmentVertices = new Array,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("bone cannot be null.");
        this.data = t,
        this.bone = e,
        this.color = new qO,
        this.darkColor = null == t.darkColor ? null : new qO,
        this.setToSetupPose(),
        this.blendMode = this.data.blendMode
    }
    getAttachment() {
        return this.attachment
    }
    setAttachment(t) {
        this.attachment != t && (this.attachment = t,
        this.attachmentTime = this.bone.skeleton.time,
        this.attachmentVertices.length = 0)
    }
    setAttachmentTime(t) {
        this.attachmentTime = this.bone.skeleton.time - t
    }
    getAttachmentTime() {
        return this.bone.skeleton.time - this.attachmentTime
    }
    setToSetupPose() {
        this.color.setFromColor(this.data.color),
        null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor),
        null == this.data.attachmentName ? this.attachment = null : (this.attachment = null,
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
    }
}
const JR = class extends YR {
    constructor(t) {
        super(t),
        this.type = CO.Region,
        this.x = 0,
        this.y = 0,
        this.scaleX = 1,
        this.scaleY = 1,
        this.rotation = 0,
        this.width = 0,
        this.height = 0,
        this.color = new qO(1,1,1,1),
        this.offset = nN.newFloatArray(8),
        this.uvs = nN.newFloatArray(8),
        this.tempColor = new qO(1,1,1,1)
    }
    updateOffset() {
        const t = this.width / this.region.originalWidth * this.scaleX
          , e = this.height / this.region.originalHeight * this.scaleY
          , n = -this.width / 2 * this.scaleX + this.region.offsetX * t
          , r = -this.height / 2 * this.scaleY + this.region.offsetY * e
          , i = n + this.region.width * t
          , s = r + this.region.height * e
          , o = this.rotation * Math.PI / 180
          , a = Math.cos(o)
          , l = Math.sin(o)
          , c = n * a + this.x
          , u = n * l
          , h = r * a + this.y
          , d = r * l
          , f = i * a + this.x
          , p = i * l
          , m = s * a + this.y
          , g = s * l
          , y = this.offset;
        y[JR.OX1] = c - d,
        y[JR.OY1] = h + u,
        y[JR.OX2] = c - g,
        y[JR.OY2] = m + u,
        y[JR.OX3] = f - g,
        y[JR.OY3] = m + p,
        y[JR.OX4] = f - d,
        y[JR.OY4] = h + p
    }
    setRegion(t) {
        this.region = t;
        const e = this.uvs;
        t.rotate ? (e[2] = t.u,
        e[3] = t.v2,
        e[4] = t.u,
        e[5] = t.v,
        e[6] = t.u2,
        e[7] = t.v,
        e[0] = t.u2,
        e[1] = t.v2) : (e[0] = t.u,
        e[1] = t.v2,
        e[2] = t.u,
        e[3] = t.v,
        e[4] = t.u2,
        e[5] = t.v,
        e[6] = t.u2,
        e[7] = t.v2)
    }
    computeWorldVertices(t, e, n, r) {
        const i = this.offset
          , s = t instanceof ZR ? t.bone.matrix : t.matrix
          , o = s.tx
          , a = s.ty
          , l = s.a
          , c = s.c
          , u = s.b
          , h = s.d;
        let d = 0
          , f = 0;
        d = i[JR.OX1],
        f = i[JR.OY1],
        e[n] = d * l + f * c + o,
        e[n + 1] = d * u + f * h + a,
        n += r,
        d = i[JR.OX2],
        f = i[JR.OY2],
        e[n] = d * l + f * c + o,
        e[n + 1] = d * u + f * h + a,
        n += r,
        d = i[JR.OX3],
        f = i[JR.OY3],
        e[n] = d * l + f * c + o,
        e[n + 1] = d * u + f * h + a,
        n += r,
        d = i[JR.OX4],
        f = i[JR.OY4],
        e[n] = d * l + f * c + o,
        e[n + 1] = d * u + f * h + a
    }
}
;
let tD = JR;
tD.OX1 = 0,
tD.OY1 = 1,
tD.OX2 = 2,
tD.OY2 = 3,
tD.OX3 = 4,
tD.OY3 = 5,
tD.OX4 = 6,
tD.OY4 = 7,
tD.X1 = 0,
tD.Y1 = 1,
tD.C1R = 2,
tD.C1G = 3,
tD.C1B = 4,
tD.C1A = 5,
tD.U1 = 6,
tD.V1 = 7,
tD.X2 = 8,
tD.Y2 = 9,
tD.C2R = 10,
tD.C2G = 11,
tD.C2B = 12,
tD.C2A = 13,
tD.U2 = 14,
tD.V2 = 15,
tD.X3 = 16,
tD.Y3 = 17,
tD.C3R = 18,
tD.C3G = 19,
tD.C3B = 20,
tD.C3A = 21,
tD.U3 = 22,
tD.V3 = 23,
tD.X4 = 24,
tD.Y4 = 25,
tD.C4R = 26,
tD.C4G = 27,
tD.C4B = 28,
tD.C4A = 29,
tD.U4 = 30,
tD.V4 = 31;
class eD {
    constructor(t, e) {
        this.jitterX = 0,
        this.jitterY = 0,
        this.jitterX = t,
        this.jitterY = e
    }
    begin(t) {}
    transform(t, e, n, r) {
        t.x += QO.randomTriangular(-this.jitterX, this.jitterY),
        t.y += QO.randomTriangular(-this.jitterX, this.jitterY)
    }
    end() {}
}
const nD = class {
    constructor(t) {
        this.centerX = 0,
        this.centerY = 0,
        this.radius = 0,
        this.angle = 0,
        this.worldX = 0,
        this.worldY = 0,
        this.radius = t
    }
    begin(t) {
        this.worldX = t.x + this.centerX,
        this.worldY = t.y + this.centerY
    }
    transform(t, e, n, r) {
        const i = this.angle * QO.degreesToRadians
          , s = t.x - this.worldX
          , o = t.y - this.worldY
          , a = Math.sqrt(s * s + o * o);
        if (a < this.radius) {
            const e = nD.interpolation.apply(0, i, (this.radius - a) / this.radius)
              , n = Math.cos(e)
              , r = Math.sin(e);
            t.x = n * s - r * o + this.worldX,
            t.y = r * s + n * o + this.worldY
        }
    }
    end() {}
}
;
let rD = nD;
rD.interpolation = new tN(2);
class iD {
    constructor(t, e, n) {
        if (null == t)
            throw new Error("name cannot be null.");
        if (null == e)
            throw new Error("timelines cannot be null.");
        this.name = t,
        this.timelines = e,
        this.duration = n
    }
    apply(t, e, n, r, i, s, o, a) {
        if (null == t)
            throw new Error("skeleton cannot be null.");
        r && 0 != this.duration && (n %= this.duration,
        e > 0 && (e %= this.duration));
        const l = this.timelines;
        for (let r = 0, c = l.length; r < c; r++)
            l[r].apply(t, e, n, i, s, o, a)
    }
    static binarySearch(t, e, n=1) {
        let r = 0
          , i = t.length / n - 2;
        if (0 == i)
            return n;
        let s = i >>> 1;
        for (; ; ) {
            if (t[(s + 1) * n] <= e ? r = s + 1 : i = s,
            r == i)
                return (r + 1) * n;
            s = r + i >>> 1
        }
    }
    static linearSearch(t, e, n) {
        for (let r = 0, i = t.length - n; r <= i; r += n)
            if (t[r] > e)
                return r;
        return -1
    }
}
var sD = (t=>(t[t.rotate = 0] = "rotate",
t[t.translate = 1] = "translate",
t[t.scale = 2] = "scale",
t[t.shear = 3] = "shear",
t[t.attachment = 4] = "attachment",
t[t.color = 5] = "color",
t[t.deform = 6] = "deform",
t[t.event = 7] = "event",
t[t.drawOrder = 8] = "drawOrder",
t[t.ikConstraint = 9] = "ikConstraint",
t[t.transformConstraint = 10] = "transformConstraint",
t[t.pathConstraintPosition = 11] = "pathConstraintPosition",
t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing",
t[t.pathConstraintMix = 13] = "pathConstraintMix",
t[t.twoColor = 14] = "twoColor",
t))(sD || {});
const oD = class {
    constructor(t) {
        if (t <= 0)
            throw new Error(`frameCount must be > 0: ${t}`);
        this.curves = nN.newFloatArray((t - 1) * oD.BEZIER_SIZE)
    }
    getFrameCount() {
        return this.curves.length / oD.BEZIER_SIZE + 1
    }
    setLinear(t) {
        this.curves[t * oD.BEZIER_SIZE] = oD.LINEAR
    }
    setStepped(t) {
        this.curves[t * oD.BEZIER_SIZE] = oD.STEPPED
    }
    getCurveType(t) {
        const e = t * oD.BEZIER_SIZE;
        if (e == this.curves.length)
            return oD.LINEAR;
        const n = this.curves[e];
        return n == oD.LINEAR ? oD.LINEAR : n == oD.STEPPED ? oD.STEPPED : oD.BEZIER
    }
    setCurve(t, e, n, r, i) {
        const s = .03 * (2 * -e + r)
          , o = .03 * (2 * -n + i)
          , a = .006 * (3 * (e - r) + 1)
          , l = .006 * (3 * (n - i) + 1);
        let c = 2 * s + a
          , u = 2 * o + l
          , h = .3 * e + s + .16666667 * a
          , d = .3 * n + o + .16666667 * l
          , f = t * oD.BEZIER_SIZE;
        const p = this.curves;
        p[f++] = oD.BEZIER;
        let m = h
          , g = d;
        for (let t = f + oD.BEZIER_SIZE - 1; f < t; f += 2)
            p[f] = m,
            p[f + 1] = g,
            h += c,
            d += u,
            c += a,
            u += l,
            m += h,
            g += d
    }
    getCurvePercent(t, e) {
        e = QO.clamp(e, 0, 1);
        const n = this.curves;
        let r = t * oD.BEZIER_SIZE;
        const i = n[r];
        if (i == oD.LINEAR)
            return e;
        if (i == oD.STEPPED)
            return 0;
        r++;
        let s = 0;
        for (let t = r, i = r + oD.BEZIER_SIZE - 1; r < i; r += 2)
            if (s = n[r],
            s >= e) {
                let i, o;
                return r == t ? (i = 0,
                o = 0) : (i = n[r - 2],
                o = n[r - 1]),
                o + (n[r + 1] - o) * (e - i) / (s - i)
            }
        const o = n[r - 1];
        return o + (1 - o) * (e - s) / (1 - s)
    }
}
;
let aD = oD;
aD.LINEAR = 0,
aD.STEPPED = 1,
aD.BEZIER = 2,
aD.BEZIER_SIZE = 19;
const lD = class extends aD {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t << 1)
    }
    getPropertyId() {
        return 0 + this.boneIndex
    }
    setFrame(t, e, n) {
        t <<= 1,
        this.frames[t] = e,
        this.frames[t + lD.ROTATION] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.bones[this.boneIndex];
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return void (l.rotation = l.data.rotation);
            case OO.first:
                const t = l.data.rotation - l.rotation;
                l.rotation += (t - 360 * (16384 - (16384.499999999996 - t / 360 | 0))) * i
            }
            return
        }
        if (n >= a[a.length - lD.ENTRIES]) {
            let t = a[a.length + lD.PREV_ROTATION];
            switch (s) {
            case OO.setup:
                l.rotation = l.data.rotation + t * i;
                break;
            case OO.first:
            case OO.replace:
                t += l.data.rotation - l.rotation,
                t -= 360 * (16384 - (16384.499999999996 - t / 360 | 0));
            case OO.add:
                l.rotation += t * i
            }
            return
        }
        const c = iD.binarySearch(a, n, lD.ENTRIES)
          , u = a[c + lD.PREV_ROTATION]
          , h = a[c]
          , d = this.getCurvePercent((c >> 1) - 1, 1 - (n - h) / (a[c + lD.PREV_TIME] - h));
        let f = a[c + lD.ROTATION] - u;
        switch (f = u + (f - 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * d,
        s) {
        case OO.setup:
            l.rotation = l.data.rotation + (f - 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * i;
            break;
        case OO.first:
        case OO.replace:
            f += l.data.rotation - l.rotation;
        case OO.add:
            l.rotation += (f - 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * i
        }
    }
}
;
let cD = lD;
cD.ENTRIES = 2,
cD.PREV_TIME = -2,
cD.PREV_ROTATION = -1,
cD.ROTATION = 1;
const uD = class extends aD {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * uD.ENTRIES)
    }
    getPropertyId() {
        return 16777216 + this.boneIndex
    }
    setFrame(t, e, n, r) {
        t *= uD.ENTRIES,
        this.frames[t] = e,
        this.frames[t + uD.X] = n,
        this.frames[t + uD.Y] = r
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.bones[this.boneIndex];
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.x = l.data.x,
                void (l.y = l.data.y);
            case OO.first:
                l.x += (l.data.x - l.x) * i,
                l.y += (l.data.y - l.y) * i
            }
            return
        }
        let c = 0
          , u = 0;
        if (n >= a[a.length - uD.ENTRIES])
            c = a[a.length + uD.PREV_X],
            u = a[a.length + uD.PREV_Y];
        else {
            const t = iD.binarySearch(a, n, uD.ENTRIES);
            c = a[t + uD.PREV_X],
            u = a[t + uD.PREV_Y];
            const e = a[t]
              , r = this.getCurvePercent(t / uD.ENTRIES - 1, 1 - (n - e) / (a[t + uD.PREV_TIME] - e));
            c += (a[t + uD.X] - c) * r,
            u += (a[t + uD.Y] - u) * r
        }
        switch (s) {
        case OO.setup:
            l.x = l.data.x + c * i,
            l.y = l.data.y + u * i;
            break;
        case OO.first:
        case OO.replace:
            l.x += (l.data.x + c - l.x) * i,
            l.y += (l.data.y + u - l.y) * i;
            break;
        case OO.add:
            l.x += c * i,
            l.y += u * i
        }
    }
}
;
let hD = uD;
hD.ENTRIES = 3,
hD.PREV_TIME = -3,
hD.PREV_X = -2,
hD.PREV_Y = -1,
hD.X = 1,
hD.Y = 2;
class dD extends hD {
    constructor(t) {
        super(t)
    }
    getPropertyId() {
        return 33554432 + this.boneIndex
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.bones[this.boneIndex];
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.scaleX = l.data.scaleX,
                void (l.scaleY = l.data.scaleY);
            case OO.first:
                l.scaleX += (l.data.scaleX - l.scaleX) * i,
                l.scaleY += (l.data.scaleY - l.scaleY) * i
            }
            return
        }
        let c = 0
          , u = 0;
        if (n >= a[a.length - dD.ENTRIES])
            c = a[a.length + dD.PREV_X] * l.data.scaleX,
            u = a[a.length + dD.PREV_Y] * l.data.scaleY;
        else {
            const t = iD.binarySearch(a, n, dD.ENTRIES);
            c = a[t + dD.PREV_X],
            u = a[t + dD.PREV_Y];
            const e = a[t]
              , r = this.getCurvePercent(t / dD.ENTRIES - 1, 1 - (n - e) / (a[t + dD.PREV_TIME] - e));
            c = (c + (a[t + dD.X] - c) * r) * l.data.scaleX,
            u = (u + (a[t + dD.Y] - u) * r) * l.data.scaleY
        }
        if (1 == i)
            s == OO.add ? (l.scaleX += c - l.data.scaleX,
            l.scaleY += u - l.data.scaleY) : (l.scaleX = c,
            l.scaleY = u);
        else {
            let t = 0
              , e = 0;
            if (o == NO.mixOut)
                switch (s) {
                case OO.setup:
                    t = l.data.scaleX,
                    e = l.data.scaleY,
                    l.scaleX = t + (Math.abs(c) * QO.signum(t) - t) * i,
                    l.scaleY = e + (Math.abs(u) * QO.signum(e) - e) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = l.scaleX,
                    e = l.scaleY,
                    l.scaleX = t + (Math.abs(c) * QO.signum(t) - t) * i,
                    l.scaleY = e + (Math.abs(u) * QO.signum(e) - e) * i;
                    break;
                case OO.add:
                    t = l.scaleX,
                    e = l.scaleY,
                    l.scaleX = t + (Math.abs(c) * QO.signum(t) - l.data.scaleX) * i,
                    l.scaleY = e + (Math.abs(u) * QO.signum(e) - l.data.scaleY) * i
                }
            else
                switch (s) {
                case OO.setup:
                    t = Math.abs(l.data.scaleX) * QO.signum(c),
                    e = Math.abs(l.data.scaleY) * QO.signum(u),
                    l.scaleX = t + (c - t) * i,
                    l.scaleY = e + (u - e) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = Math.abs(l.scaleX) * QO.signum(c),
                    e = Math.abs(l.scaleY) * QO.signum(u),
                    l.scaleX = t + (c - t) * i,
                    l.scaleY = e + (u - e) * i;
                    break;
                case OO.add:
                    t = QO.signum(c),
                    e = QO.signum(u),
                    l.scaleX = Math.abs(l.scaleX) * t + (c - Math.abs(l.data.scaleX) * t) * i,
                    l.scaleY = Math.abs(l.scaleY) * e + (u - Math.abs(l.data.scaleY) * e) * i
                }
        }
    }
}
class fD extends hD {
    constructor(t) {
        super(t)
    }
    getPropertyId() {
        return 50331648 + this.boneIndex
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.bones[this.boneIndex];
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.shearX = l.data.shearX,
                void (l.shearY = l.data.shearY);
            case OO.first:
                l.shearX += (l.data.shearX - l.shearX) * i,
                l.shearY += (l.data.shearY - l.shearY) * i
            }
            return
        }
        let c = 0
          , u = 0;
        if (n >= a[a.length - fD.ENTRIES])
            c = a[a.length + fD.PREV_X],
            u = a[a.length + fD.PREV_Y];
        else {
            const t = iD.binarySearch(a, n, fD.ENTRIES);
            c = a[t + fD.PREV_X],
            u = a[t + fD.PREV_Y];
            const e = a[t]
              , r = this.getCurvePercent(t / fD.ENTRIES - 1, 1 - (n - e) / (a[t + fD.PREV_TIME] - e));
            c += (a[t + fD.X] - c) * r,
            u += (a[t + fD.Y] - u) * r
        }
        switch (s) {
        case OO.setup:
            l.shearX = l.data.shearX + c * i,
            l.shearY = l.data.shearY + u * i;
            break;
        case OO.first:
        case OO.replace:
            l.shearX += (l.data.shearX + c - l.shearX) * i,
            l.shearY += (l.data.shearY + u - l.shearY) * i;
            break;
        case OO.add:
            l.shearX += c * i,
            l.shearY += u * i
        }
    }
}
const pD = class extends aD {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * pD.ENTRIES)
    }
    getPropertyId() {
        return 83886080 + this.slotIndex
    }
    setFrame(t, e, n, r, i, s) {
        t *= pD.ENTRIES,
        this.frames[t] = e,
        this.frames[t + pD.R] = n,
        this.frames[t + pD.G] = r,
        this.frames[t + pD.B] = i,
        this.frames[t + pD.A] = s
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex]
          , l = this.frames;
        if (n < l[0]) {
            switch (s) {
            case OO.setup:
                return void a.color.setFromColor(a.data.color);
            case OO.first:
                const t = a.color
                  , e = a.data.color;
                t.add((e.r - t.r) * i, (e.g - t.g) * i, (e.b - t.b) * i, (e.a - t.a) * i)
            }
            return
        }
        let c = 0
          , u = 0
          , h = 0
          , d = 0;
        if (n >= l[l.length - pD.ENTRIES]) {
            const t = l.length;
            c = l[t + pD.PREV_R],
            u = l[t + pD.PREV_G],
            h = l[t + pD.PREV_B],
            d = l[t + pD.PREV_A]
        } else {
            const t = iD.binarySearch(l, n, pD.ENTRIES);
            c = l[t + pD.PREV_R],
            u = l[t + pD.PREV_G],
            h = l[t + pD.PREV_B],
            d = l[t + pD.PREV_A];
            const e = l[t]
              , r = this.getCurvePercent(t / pD.ENTRIES - 1, 1 - (n - e) / (l[t + pD.PREV_TIME] - e));
            c += (l[t + pD.R] - c) * r,
            u += (l[t + pD.G] - u) * r,
            h += (l[t + pD.B] - h) * r,
            d += (l[t + pD.A] - d) * r
        }
        if (1 == i)
            a.color.set(c, u, h, d);
        else {
            const t = a.color;
            s == OO.setup && t.setFromColor(a.data.color),
            t.add((c - t.r) * i, (u - t.g) * i, (h - t.b) * i, (d - t.a) * i)
        }
    }
}
;
let mD = pD;
mD.ENTRIES = 5,
mD.PREV_TIME = -5,
mD.PREV_R = -4,
mD.PREV_G = -3,
mD.PREV_B = -2,
mD.PREV_A = -1,
mD.R = 1,
mD.G = 2,
mD.B = 3,
mD.A = 4;
const gD = class extends aD {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * gD.ENTRIES)
    }
    getPropertyId() {
        return 234881024 + this.slotIndex
    }
    setFrame(t, e, n, r, i, s, o, a, l) {
        t *= gD.ENTRIES,
        this.frames[t] = e,
        this.frames[t + gD.R] = n,
        this.frames[t + gD.G] = r,
        this.frames[t + gD.B] = i,
        this.frames[t + gD.A] = s,
        this.frames[t + gD.R2] = o,
        this.frames[t + gD.G2] = a,
        this.frames[t + gD.B2] = l
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex]
          , l = this.frames;
        if (n < l[0]) {
            switch (s) {
            case OO.setup:
                return a.color.setFromColor(a.data.color),
                void a.darkColor.setFromColor(a.data.darkColor);
            case OO.first:
                const t = a.color
                  , e = a.darkColor
                  , n = a.data.color
                  , r = a.data.darkColor;
                t.add((n.r - t.r) * i, (n.g - t.g) * i, (n.b - t.b) * i, (n.a - t.a) * i),
                e.add((r.r - e.r) * i, (r.g - e.g) * i, (r.b - e.b) * i, 0)
            }
            return
        }
        let c = 0
          , u = 0
          , h = 0
          , d = 0
          , f = 0
          , p = 0
          , m = 0;
        if (n >= l[l.length - gD.ENTRIES]) {
            const t = l.length;
            c = l[t + gD.PREV_R],
            u = l[t + gD.PREV_G],
            h = l[t + gD.PREV_B],
            d = l[t + gD.PREV_A],
            f = l[t + gD.PREV_R2],
            p = l[t + gD.PREV_G2],
            m = l[t + gD.PREV_B2]
        } else {
            const t = iD.binarySearch(l, n, gD.ENTRIES);
            c = l[t + gD.PREV_R],
            u = l[t + gD.PREV_G],
            h = l[t + gD.PREV_B],
            d = l[t + gD.PREV_A],
            f = l[t + gD.PREV_R2],
            p = l[t + gD.PREV_G2],
            m = l[t + gD.PREV_B2];
            const e = l[t]
              , r = this.getCurvePercent(t / gD.ENTRIES - 1, 1 - (n - e) / (l[t + gD.PREV_TIME] - e));
            c += (l[t + gD.R] - c) * r,
            u += (l[t + gD.G] - u) * r,
            h += (l[t + gD.B] - h) * r,
            d += (l[t + gD.A] - d) * r,
            f += (l[t + gD.R2] - f) * r,
            p += (l[t + gD.G2] - p) * r,
            m += (l[t + gD.B2] - m) * r
        }
        if (1 == i)
            a.color.set(c, u, h, d),
            a.darkColor.set(f, p, m, 1);
        else {
            const t = a.color
              , e = a.darkColor;
            s == OO.setup && (t.setFromColor(a.data.color),
            e.setFromColor(a.data.darkColor)),
            t.add((c - t.r) * i, (u - t.g) * i, (h - t.b) * i, (d - t.a) * i),
            e.add((f - e.r) * i, (p - e.g) * i, (m - e.b) * i, 0)
        }
    }
}
;
let yD = gD;
yD.ENTRIES = 8,
yD.PREV_TIME = -8,
yD.PREV_R = -7,
yD.PREV_G = -6,
yD.PREV_B = -5,
yD.PREV_A = -4,
yD.PREV_R2 = -3,
yD.PREV_G2 = -2,
yD.PREV_B2 = -1,
yD.R = 1,
yD.G = 2,
yD.B = 3,
yD.A = 4,
yD.R2 = 5,
yD.G2 = 6,
yD.B2 = 7;
class bD {
    constructor(t) {
        this.frames = nN.newFloatArray(t),
        this.attachmentNames = new Array(t)
    }
    getPropertyId() {
        return 67108864 + this.slotIndex
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
        this.attachmentNames[t] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (o == NO.mixOut && s == OO.setup) {
            const e = a.data.attachmentName;
            return void a.setAttachment(null == e ? null : t.getAttachment(this.slotIndex, e))
        }
        const l = this.frames;
        if (n < l[0]) {
            if (s == OO.setup || s == OO.first) {
                const e = a.data.attachmentName;
                a.setAttachment(null == e ? null : t.getAttachment(this.slotIndex, e))
            }
            return
        }
        let c = 0;
        c = n >= l[l.length - 1] ? l.length - 1 : iD.binarySearch(l, n, 1) - 1;
        const u = this.attachmentNames[c];
        t.slots[this.slotIndex].setAttachment(null == u ? null : t.getAttachment(this.slotIndex, u))
    }
}
let vD = null;
class wD extends aD {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t),
        this.frameVertices = new Array(t),
        null == vD && (vD = nN.newFloatArray(64))
    }
    getPropertyId() {
        return 805306368 + Number(this.attachment.id) + this.slotIndex
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
        this.frameVertices[t] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex]
          , l = a.getAttachment();
        if (!(l instanceof $R && l.applyDeform(this.attachment)))
            return;
        const c = a.attachmentVertices;
        0 == c.length && (s = OO.setup);
        const u = this.frameVertices
          , h = u[0].length
          , d = this.frames;
        if (n < d[0]) {
            const t = l;
            switch (s) {
            case OO.setup:
                return void (c.length = 0);
            case OO.first:
                if (1 == i) {
                    c.length = 0;
                    break
                }
                const e = nN.setArraySize(c, h);
                if (null == t.bones) {
                    const n = t.vertices;
                    for (let t = 0; t < h; t++)
                        e[t] += (n[t] - e[t]) * i
                } else {
                    i = 1 - i;
                    for (let t = 0; t < h; t++)
                        e[t] *= i
                }
            }
            return
        }
        const f = nN.setArraySize(c, h);
        if (n >= d[d.length - 1]) {
            const t = u[d.length - 1];
            if (1 == i)
                if (s == OO.add) {
                    const e = l;
                    if (null == e.bones) {
                        const n = e.vertices;
                        for (let e = 0; e < h; e++)
                            f[e] += t[e] - n[e]
                    } else
                        for (let e = 0; e < h; e++)
                            f[e] += t[e]
                } else
                    nN.arrayCopy(t, 0, f, 0, h);
            else
                switch (s) {
                case OO.setup:
                    {
                        const e = l;
                        if (null == e.bones) {
                            const n = e.vertices;
                            for (let e = 0; e < h; e++) {
                                const r = n[e];
                                f[e] = r + (t[e] - r) * i
                            }
                        } else
                            for (let e = 0; e < h; e++)
                                f[e] = t[e] * i;
                        break
                    }
                case OO.first:
                case OO.replace:
                    for (let e = 0; e < h; e++)
                        f[e] += (t[e] - f[e]) * i;
                case OO.add:
                    const e = l;
                    if (null == e.bones) {
                        const n = e.vertices;
                        for (let e = 0; e < h; e++)
                            f[e] += (t[e] - n[e]) * i
                    } else
                        for (let e = 0; e < h; e++)
                            f[e] += t[e] * i
                }
            return
        }
        const p = iD.binarySearch(d, n)
          , m = u[p - 1]
          , g = u[p]
          , y = d[p]
          , b = this.getCurvePercent(p - 1, 1 - (n - y) / (d[p - 1] - y));
        if (1 == i)
            if (s == OO.add) {
                const t = l;
                if (null == t.bones) {
                    const e = t.vertices;
                    for (let t = 0; t < h; t++) {
                        const n = m[t];
                        f[t] += n + (g[t] - n) * b - e[t]
                    }
                } else
                    for (let t = 0; t < h; t++) {
                        const e = m[t];
                        f[t] += e + (g[t] - e) * b
                    }
            } else
                for (let t = 0; t < h; t++) {
                    const e = m[t];
                    f[t] = e + (g[t] - e) * b
                }
        else
            switch (s) {
            case OO.setup:
                {
                    const t = l;
                    if (null == t.bones) {
                        const e = t.vertices;
                        for (let t = 0; t < h; t++) {
                            const n = m[t]
                              , r = e[t];
                            f[t] = r + (n + (g[t] - n) * b - r) * i
                        }
                    } else
                        for (let t = 0; t < h; t++) {
                            const e = m[t];
                            f[t] = (e + (g[t] - e) * b) * i
                        }
                    break
                }
            case OO.first:
            case OO.replace:
                for (let t = 0; t < h; t++) {
                    const e = m[t];
                    f[t] += (e + (g[t] - e) * b - f[t]) * i
                }
                break;
            case OO.add:
                const t = l;
                if (null == t.bones) {
                    const e = t.vertices;
                    for (let t = 0; t < h; t++) {
                        const n = m[t];
                        f[t] += (n + (g[t] - n) * b - e[t]) * i
                    }
                } else
                    for (let t = 0; t < h; t++) {
                        const e = m[t];
                        f[t] += (e + (g[t] - e) * b) * i
                    }
            }
    }
}
class xD {
    constructor(t) {
        this.frames = nN.newFloatArray(t),
        this.events = new Array(t)
    }
    getPropertyId() {
        return 117440512
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e) {
        this.frames[t] = e.time,
        this.events[t] = e
    }
    apply(t, e, n, r, i, s, o) {
        if (null == r)
            return;
        const a = this.frames
          , l = this.frames.length;
        if (e > n)
            this.apply(t, e, Number.MAX_VALUE, r, i, s, o),
            e = -1;
        else if (e >= a[l - 1])
            return;
        if (n < a[0])
            return;
        let c = 0;
        if (e < a[0])
            c = 0;
        else {
            c = iD.binarySearch(a, e);
            const t = a[c];
            for (; c > 0 && a[c - 1] == t; )
                c--
        }
        for (; c < l && n >= a[c]; c++)
            r.push(this.events[c])
    }
}
class ED {
    constructor(t) {
        this.frames = nN.newFloatArray(t),
        this.drawOrders = new Array(t)
    }
    getPropertyId() {
        return 134217728
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
        this.drawOrders[t] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.drawOrder
          , l = t.slots;
        if (o == NO.mixOut && s == OO.setup)
            return void nN.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
        const c = this.frames;
        if (n < c[0])
            return void (s != OO.setup && s != OO.first || nN.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length));
        let u = 0;
        u = n >= c[c.length - 1] ? c.length - 1 : iD.binarySearch(c, n) - 1;
        const h = this.drawOrders[u];
        if (null == h)
            nN.arrayCopy(l, 0, a, 0, l.length);
        else
            for (let t = 0, e = h.length; t < e; t++)
                a[t] = l[h[t]]
    }
}
const _D = class extends aD {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * _D.ENTRIES)
    }
    getPropertyId() {
        return 150994944 + this.ikConstraintIndex
    }
    setFrame(t, e, n, r, i, s) {
        t *= _D.ENTRIES,
        this.frames[t] = e,
        this.frames[t + _D.MIX] = n,
        this.frames[t + _D.BEND_DIRECTION] = r,
        this.frames[t + _D.COMPRESS] = i ? 1 : 0,
        this.frames[t + _D.STRETCH] = s ? 1 : 0
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.ikConstraints[this.ikConstraintIndex];
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.mix = l.data.mix,
                l.bendDirection = l.data.bendDirection,
                l.compress = l.data.compress,
                void (l.stretch = l.data.stretch);
            case OO.first:
                l.mix += (l.data.mix - l.mix) * i,
                l.bendDirection = l.data.bendDirection,
                l.compress = l.data.compress,
                l.stretch = l.data.stretch
            }
            return
        }
        if (n >= a[a.length - _D.ENTRIES])
            return void (s == OO.setup ? (l.mix = l.data.mix + (a[a.length + _D.PREV_MIX] - l.data.mix) * i,
            o == NO.mixOut ? (l.bendDirection = l.data.bendDirection,
            l.compress = l.data.compress,
            l.stretch = l.data.stretch) : (l.bendDirection = a[a.length + _D.PREV_BEND_DIRECTION],
            l.compress = 0 != a[a.length + _D.PREV_COMPRESS],
            l.stretch = 0 != a[a.length + _D.PREV_STRETCH])) : (l.mix += (a[a.length + _D.PREV_MIX] - l.mix) * i,
            o == NO.mixIn && (l.bendDirection = a[a.length + _D.PREV_BEND_DIRECTION],
            l.compress = 0 != a[a.length + _D.PREV_COMPRESS],
            l.stretch = 0 != a[a.length + _D.PREV_STRETCH])));
        const c = iD.binarySearch(a, n, _D.ENTRIES)
          , u = a[c + _D.PREV_MIX]
          , h = a[c]
          , d = this.getCurvePercent(c / _D.ENTRIES - 1, 1 - (n - h) / (a[c + _D.PREV_TIME] - h));
        s == OO.setup ? (l.mix = l.data.mix + (u + (a[c + _D.MIX] - u) * d - l.data.mix) * i,
        o == NO.mixOut ? (l.bendDirection = l.data.bendDirection,
        l.compress = l.data.compress,
        l.stretch = l.data.stretch) : (l.bendDirection = a[c + _D.PREV_BEND_DIRECTION],
        l.compress = 0 != a[c + _D.PREV_COMPRESS],
        l.stretch = 0 != a[c + _D.PREV_STRETCH])) : (l.mix += (u + (a[c + _D.MIX] - u) * d - l.mix) * i,
        o == NO.mixIn && (l.bendDirection = a[c + _D.PREV_BEND_DIRECTION],
        l.compress = 0 != a[c + _D.PREV_COMPRESS],
        l.stretch = 0 != a[c + _D.PREV_STRETCH]))
    }
}
;
let AD = _D;
AD.ENTRIES = 5,
AD.PREV_TIME = -5,
AD.PREV_MIX = -4,
AD.PREV_BEND_DIRECTION = -3,
AD.PREV_COMPRESS = -2,
AD.PREV_STRETCH = -1,
AD.MIX = 1,
AD.BEND_DIRECTION = 2,
AD.COMPRESS = 3,
AD.STRETCH = 4;
const SD = class extends aD {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * SD.ENTRIES)
    }
    getPropertyId() {
        return 167772160 + this.transformConstraintIndex
    }
    setFrame(t, e, n, r, i, s) {
        t *= SD.ENTRIES,
        this.frames[t] = e,
        this.frames[t + SD.ROTATE] = n,
        this.frames[t + SD.TRANSLATE] = r,
        this.frames[t + SD.SCALE] = i,
        this.frames[t + SD.SHEAR] = s
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.transformConstraints[this.transformConstraintIndex];
        if (n < a[0]) {
            const t = l.data;
            switch (s) {
            case OO.setup:
                return l.rotateMix = t.rotateMix,
                l.translateMix = t.translateMix,
                l.scaleMix = t.scaleMix,
                void (l.shearMix = t.shearMix);
            case OO.first:
                l.rotateMix += (t.rotateMix - l.rotateMix) * i,
                l.translateMix += (t.translateMix - l.translateMix) * i,
                l.scaleMix += (t.scaleMix - l.scaleMix) * i,
                l.shearMix += (t.shearMix - l.shearMix) * i
            }
            return
        }
        let c = 0
          , u = 0
          , h = 0
          , d = 0;
        if (n >= a[a.length - SD.ENTRIES]) {
            const t = a.length;
            c = a[t + SD.PREV_ROTATE],
            u = a[t + SD.PREV_TRANSLATE],
            h = a[t + SD.PREV_SCALE],
            d = a[t + SD.PREV_SHEAR]
        } else {
            const t = iD.binarySearch(a, n, SD.ENTRIES);
            c = a[t + SD.PREV_ROTATE],
            u = a[t + SD.PREV_TRANSLATE],
            h = a[t + SD.PREV_SCALE],
            d = a[t + SD.PREV_SHEAR];
            const e = a[t]
              , r = this.getCurvePercent(t / SD.ENTRIES - 1, 1 - (n - e) / (a[t + SD.PREV_TIME] - e));
            c += (a[t + SD.ROTATE] - c) * r,
            u += (a[t + SD.TRANSLATE] - u) * r,
            h += (a[t + SD.SCALE] - h) * r,
            d += (a[t + SD.SHEAR] - d) * r
        }
        if (s == OO.setup) {
            const t = l.data;
            l.rotateMix = t.rotateMix + (c - t.rotateMix) * i,
            l.translateMix = t.translateMix + (u - t.translateMix) * i,
            l.scaleMix = t.scaleMix + (h - t.scaleMix) * i,
            l.shearMix = t.shearMix + (d - t.shearMix) * i
        } else
            l.rotateMix += (c - l.rotateMix) * i,
            l.translateMix += (u - l.translateMix) * i,
            l.scaleMix += (h - l.scaleMix) * i,
            l.shearMix += (d - l.shearMix) * i
    }
}
;
let TD = SD;
TD.ENTRIES = 5,
TD.PREV_TIME = -5,
TD.PREV_ROTATE = -4,
TD.PREV_TRANSLATE = -3,
TD.PREV_SCALE = -2,
TD.PREV_SHEAR = -1,
TD.ROTATE = 1,
TD.TRANSLATE = 2,
TD.SCALE = 3,
TD.SHEAR = 4;
const kD = class extends aD {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * kD.ENTRIES)
    }
    getPropertyId() {
        return 184549376 + this.pathConstraintIndex
    }
    setFrame(t, e, n) {
        t *= kD.ENTRIES,
        this.frames[t] = e,
        this.frames[t + kD.VALUE] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.pathConstraints[this.pathConstraintIndex];
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return void (l.position = l.data.position);
            case OO.first:
                l.position += (l.data.position - l.position) * i
            }
            return
        }
        let c = 0;
        if (n >= a[a.length - kD.ENTRIES])
            c = a[a.length + kD.PREV_VALUE];
        else {
            const t = iD.binarySearch(a, n, kD.ENTRIES);
            c = a[t + kD.PREV_VALUE];
            const e = a[t]
              , r = this.getCurvePercent(t / kD.ENTRIES - 1, 1 - (n - e) / (a[t + kD.PREV_TIME] - e));
            c += (a[t + kD.VALUE] - c) * r
        }
        s == OO.setup ? l.position = l.data.position + (c - l.data.position) * i : l.position += (c - l.position) * i
    }
}
;
let ID = kD;
ID.ENTRIES = 2,
ID.PREV_TIME = -2,
ID.PREV_VALUE = -1,
ID.VALUE = 1;
class MD extends ID {
    constructor(t) {
        super(t)
    }
    getPropertyId() {
        return 201326592 + this.pathConstraintIndex
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.pathConstraints[this.pathConstraintIndex];
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return void (l.spacing = l.data.spacing);
            case OO.first:
                l.spacing += (l.data.spacing - l.spacing) * i
            }
            return
        }
        let c = 0;
        if (n >= a[a.length - MD.ENTRIES])
            c = a[a.length + MD.PREV_VALUE];
        else {
            const t = iD.binarySearch(a, n, MD.ENTRIES);
            c = a[t + MD.PREV_VALUE];
            const e = a[t]
              , r = this.getCurvePercent(t / MD.ENTRIES - 1, 1 - (n - e) / (a[t + MD.PREV_TIME] - e));
            c += (a[t + MD.VALUE] - c) * r
        }
        s == OO.setup ? l.spacing = l.data.spacing + (c - l.data.spacing) * i : l.spacing += (c - l.spacing) * i
    }
}
const CD = class extends aD {
    constructor(t) {
        super(t),
        this.frames = nN.newFloatArray(t * CD.ENTRIES)
    }
    getPropertyId() {
        return 218103808 + this.pathConstraintIndex
    }
    setFrame(t, e, n, r) {
        t *= CD.ENTRIES,
        this.frames[t] = e,
        this.frames[t + CD.ROTATE] = n,
        this.frames[t + CD.TRANSLATE] = r
    }
    apply(t, e, n, r, i, s, o) {
        const a = this.frames
          , l = t.pathConstraints[this.pathConstraintIndex];
        if (n < a[0]) {
            switch (s) {
            case OO.setup:
                return l.rotateMix = l.data.rotateMix,
                void (l.translateMix = l.data.translateMix);
            case OO.first:
                l.rotateMix += (l.data.rotateMix - l.rotateMix) * i,
                l.translateMix += (l.data.translateMix - l.translateMix) * i
            }
            return
        }
        let c = 0
          , u = 0;
        if (n >= a[a.length - CD.ENTRIES])
            c = a[a.length + CD.PREV_ROTATE],
            u = a[a.length + CD.PREV_TRANSLATE];
        else {
            const t = iD.binarySearch(a, n, CD.ENTRIES);
            c = a[t + CD.PREV_ROTATE],
            u = a[t + CD.PREV_TRANSLATE];
            const e = a[t]
              , r = this.getCurvePercent(t / CD.ENTRIES - 1, 1 - (n - e) / (a[t + CD.PREV_TIME] - e));
            c += (a[t + CD.ROTATE] - c) * r,
            u += (a[t + CD.TRANSLATE] - u) * r
        }
        s == OO.setup ? (l.rotateMix = l.data.rotateMix + (c - l.data.rotateMix) * i,
        l.translateMix = l.data.translateMix + (u - l.data.translateMix) * i) : (l.rotateMix += (c - l.rotateMix) * i,
        l.translateMix += (u - l.translateMix) * i)
    }
}
;
let PD = CD;
PD.ENTRIES = 3,
PD.PREV_TIME = -3,
PD.PREV_ROTATE = -2,
PD.PREV_TRANSLATE = -1,
PD.ROTATE = 1,
PD.TRANSLATE = 2;
const OD = class {
    constructor(t) {
        this.tracks = new Array,
        this.events = new Array,
        this.listeners = new Array,
        this.queue = new LD(this),
        this.propertyIDs = new $O,
        this.animationsChanged = !1,
        this.timeScale = 1,
        this.trackEntryPool = new rN((()=>new DD)),
        this.data = t
    }
    update(t) {
        t *= this.timeScale;
        const e = this.tracks;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (null == r)
                continue;
            r.animationLast = r.nextAnimationLast,
            r.trackLast = r.nextTrackLast;
            let i = t * r.timeScale;
            if (r.delay > 0) {
                if (r.delay -= i,
                r.delay > 0)
                    continue;
                i = -r.delay,
                r.delay = 0
            }
            let s = r.next;
            if (null != s) {
                const e = r.trackLast - s.delay;
                if (e >= 0) {
                    for (s.delay = 0,
                    s.trackTime = 0 == r.timeScale ? 0 : (e / r.timeScale + t) * s.timeScale,
                    r.trackTime += i,
                    this.setCurrent(n, s, !0); null != s.mixingFrom; )
                        s.mixTime += t,
                        s = s.mixingFrom;
                    continue
                }
            } else if (r.trackLast >= r.trackEnd && null == r.mixingFrom) {
                e[n] = null,
                this.queue.end(r),
                this.disposeNext(r);
                continue
            }
            if (null != r.mixingFrom && this.updateMixingFrom(r, t)) {
                let t = r.mixingFrom;
                for (r.mixingFrom = null,
                null != t && (t.mixingTo = null); null != t; )
                    this.queue.end(t),
                    t = t.mixingFrom
            }
            r.trackTime += i
        }
        this.queue.drain()
    }
    updateMixingFrom(t, e) {
        const n = t.mixingFrom;
        if (null == n)
            return !0;
        const r = this.updateMixingFrom(n, e);
        return n.animationLast = n.nextAnimationLast,
        n.trackLast = n.nextTrackLast,
        t.mixTime > 0 && t.mixTime >= t.mixDuration ? (0 != n.totalAlpha && 0 != t.mixDuration || (t.mixingFrom = n.mixingFrom,
        null != n.mixingFrom && (n.mixingFrom.mixingTo = t),
        t.interruptAlpha = n.interruptAlpha,
        this.queue.end(n)),
        r) : (n.trackTime += e * n.timeScale,
        t.mixTime += e,
        !1)
    }
    apply(t) {
        if (null == t)
            throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        const e = this.events
          , n = this.tracks;
        let r = !1;
        for (let i = 0, s = n.length; i < s; i++) {
            const s = n[i];
            if (null == s || s.delay > 0)
                continue;
            r = !0;
            const o = 0 == i ? OO.first : s.mixBlend;
            let a = s.alpha;
            null != s.mixingFrom ? a *= this.applyMixingFrom(s, t, o) : s.trackTime >= s.trackEnd && null == s.next && (a = 0);
            const l = s.animationLast
              , c = s.getAnimationTime()
              , u = s.animation.timelines.length
              , h = s.animation.timelines;
            if (0 == i && 1 == a || o == OO.add)
                for (let n = 0; n < u; n++)
                    nN.webkit602BugfixHelper(a, o),
                    h[n].apply(t, l, c, e, a, o, NO.mixIn);
            else {
                const n = s.timelineMode
                  , r = 0 == s.timelinesRotation.length;
                r && nN.setArraySize(s.timelinesRotation, u << 1, null);
                const i = s.timelinesRotation;
                for (let s = 0; s < u; s++) {
                    const u = h[s]
                      , d = n[s] == OD.SUBSEQUENT ? o : OO.setup;
                    u instanceof cD ? this.applyRotateTimeline(u, t, c, a, d, i, s << 1, r) : (nN.webkit602BugfixHelper(a, o),
                    u.apply(t, l, c, e, a, d, NO.mixIn))
                }
            }
            this.queueEvents(s, c),
            e.length = 0,
            s.nextAnimationLast = c,
            s.nextTrackLast = s.trackTime
        }
        return this.queue.drain(),
        r
    }
    applyMixingFrom(t, e, n) {
        const r = t.mixingFrom;
        null != r.mixingFrom && this.applyMixingFrom(r, e, n);
        let i = 0;
        0 == t.mixDuration ? (i = 1,
        n == OO.first && (n = OO.setup)) : (i = t.mixTime / t.mixDuration,
        i > 1 && (i = 1),
        n != OO.first && (n = r.mixBlend));
        const s = i < r.eventThreshold ? this.events : null
          , o = i < r.attachmentThreshold
          , a = i < r.drawOrderThreshold
          , l = r.animationLast
          , c = r.getAnimationTime()
          , u = r.animation.timelines.length
          , h = r.animation.timelines
          , d = r.alpha * t.interruptAlpha
          , f = d * (1 - i);
        if (n == OO.add)
            for (let t = 0; t < u; t++)
                h[t].apply(e, l, c, s, f, n, NO.mixOut);
        else {
            const t = r.timelineMode
              , i = r.timelineHoldMix
              , p = 0 == r.timelinesRotation.length;
            p && nN.setArraySize(r.timelinesRotation, u << 1, null);
            const m = r.timelinesRotation;
            r.totalAlpha = 0;
            for (let g = 0; g < u; g++) {
                const u = h[g];
                let y, b = NO.mixOut, v = 0;
                switch (t[g]) {
                case OD.SUBSEQUENT:
                    if (!o && u instanceof bD)
                        continue;
                    if (!a && u instanceof ED)
                        continue;
                    y = n,
                    v = f;
                    break;
                case OD.FIRST:
                    y = OO.setup,
                    v = f;
                    break;
                case OD.HOLD:
                    y = OO.setup,
                    v = d;
                    break;
                default:
                    y = OO.setup;
                    const t = i[g];
                    v = d * Math.max(0, 1 - t.mixTime / t.mixDuration)
                }
                r.totalAlpha += v,
                u instanceof cD ? this.applyRotateTimeline(u, e, c, v, y, m, g << 1, p) : (nN.webkit602BugfixHelper(v, n),
                y == OO.setup && (u instanceof bD ? o && (b = NO.mixOut) : u instanceof ED && a && (b = NO.mixOut)),
                u.apply(e, l, c, s, v, y, b))
            }
        }
        return t.mixDuration > 0 && this.queueEvents(r, c),
        this.events.length = 0,
        r.nextAnimationLast = c,
        r.nextTrackLast = r.trackTime,
        i
    }
    applyRotateTimeline(t, e, n, r, i, s, o, a) {
        if (a && (s[o] = 0),
        1 == r)
            return void t.apply(e, 0, n, null, 1, i, NO.mixIn);
        const l = t
          , c = l.frames
          , u = e.bones[l.boneIndex];
        let h = 0
          , d = 0;
        if (n < c[0])
            switch (i) {
            case OO.setup:
                u.rotation = u.data.rotation;
            default:
                return;
            case OO.first:
                h = u.rotation,
                d = u.data.rotation
            }
        else if (h = i == OO.setup ? u.data.rotation : u.rotation,
        n >= c[c.length - cD.ENTRIES])
            d = u.data.rotation + c[c.length + cD.PREV_ROTATION];
        else {
            const t = iD.binarySearch(c, n, cD.ENTRIES)
              , e = c[t + cD.PREV_ROTATION]
              , r = c[t]
              , i = l.getCurvePercent((t >> 1) - 1, 1 - (n - r) / (c[t + cD.PREV_TIME] - r));
            d = c[t + cD.ROTATION] - e,
            d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0)),
            d = e + d * i + u.data.rotation,
            d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0))
        }
        let f = 0
          , p = d - h;
        if (p -= 360 * (16384 - (16384.499999999996 - p / 360 | 0)),
        0 == p)
            f = s[o];
        else {
            let t = 0
              , e = 0;
            a ? (t = 0,
            e = p) : (t = s[o],
            e = s[o + 1]);
            const n = p > 0;
            let r = t >= 0;
            QO.signum(e) != QO.signum(p) && Math.abs(e) <= 90 && (Math.abs(t) > 180 && (t += 360 * QO.signum(t)),
            r = n),
            f = p + t - t % 360,
            r != n && (f += 360 * QO.signum(t)),
            s[o] = f
        }
        s[o + 1] = p,
        h += f * r,
        u.rotation = h - 360 * (16384 - (16384.499999999996 - h / 360 | 0))
    }
    queueEvents(t, e) {
        const n = t.animationStart
          , r = t.animationEnd
          , i = r - n
          , s = t.trackLast % i
          , o = this.events;
        let a = 0;
        const l = o.length;
        for (; a < l; a++) {
            const e = o[a];
            if (e.time < s)
                break;
            e.time > r || this.queue.event(t, e)
        }
        let c = !1;
        for (c = t.loop ? 0 == i || s > t.trackTime % i : e >= r && t.animationLast < r,
        c && this.queue.complete(t); a < l; a++) {
            o[a].time < n || this.queue.event(t, o[a])
        }
    }
    clearTracks() {
        const t = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let t = 0, e = this.tracks.length; t < e; t++)
            this.clearTrack(t);
        this.tracks.length = 0,
        this.queue.drainDisabled = t,
        this.queue.drain()
    }
    clearTrack(t) {
        if (t >= this.tracks.length)
            return;
        const e = this.tracks[t];
        if (null == e)
            return;
        this.queue.end(e),
        this.disposeNext(e);
        let n = e;
        for (; ; ) {
            const t = n.mixingFrom;
            if (null == t)
                break;
            this.queue.end(t),
            n.mixingFrom = null,
            n.mixingTo = null,
            n = t
        }
        this.tracks[e.trackIndex] = null,
        this.queue.drain()
    }
    setCurrent(t, e, n) {
        const r = this.expandToIndex(t);
        this.tracks[t] = e,
        null != r && (n && this.queue.interrupt(r),
        e.mixingFrom = r,
        r.mixingTo = e,
        e.mixTime = 0,
        null != r.mixingFrom && r.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, r.mixTime / r.mixDuration)),
        r.timelinesRotation.length = 0),
        this.queue.start(e)
    }
    setAnimation(t, e, n) {
        const r = this.data.skeletonData.findAnimation(e);
        if (null == r)
            throw new Error(`Animation not found: ${e}`);
        return this.setAnimationWith(t, r, n)
    }
    setAnimationWith(t, e, n) {
        if (null == e)
            throw new Error("animation cannot be null.");
        let r = !0
          , i = this.expandToIndex(t);
        null != i && (-1 == i.nextTrackLast ? (this.tracks[t] = i.mixingFrom,
        this.queue.interrupt(i),
        this.queue.end(i),
        this.disposeNext(i),
        i = i.mixingFrom,
        r = !1) : this.disposeNext(i));
        const s = this.trackEntry(t, e, n, i);
        return this.setCurrent(t, s, r),
        this.queue.drain(),
        s
    }
    addAnimation(t, e, n, r) {
        const i = this.data.skeletonData.findAnimation(e);
        if (null == i)
            throw new Error(`Animation not found: ${e}`);
        return this.addAnimationWith(t, i, n, r)
    }
    addAnimationWith(t, e, n, r) {
        if (null == e)
            throw new Error("animation cannot be null.");
        let i = this.expandToIndex(t);
        if (null != i)
            for (; null != i.next; )
                i = i.next;
        const s = this.trackEntry(t, e, n, i);
        if (null == i)
            this.setCurrent(t, s, !0),
            this.queue.drain();
        else if (i.next = s,
        r <= 0) {
            const t = i.animationEnd - i.animationStart;
            0 != t ? (i.loop ? r += t * (1 + (i.trackTime / t | 0)) : r += Math.max(t, i.trackTime),
            r -= this.data.getMix(i.animation, e)) : r = i.trackTime
        }
        return s.delay = r,
        s
    }
    setEmptyAnimation(t, e) {
        const n = this.setAnimationWith(t, OD.emptyAnimation, !1);
        return n.mixDuration = e,
        n.trackEnd = e,
        n
    }
    addEmptyAnimation(t, e, n) {
        n <= 0 && (n -= e);
        const r = this.addAnimationWith(t, OD.emptyAnimation, !1, n);
        return r.mixDuration = e,
        r.trackEnd = e,
        r
    }
    setEmptyAnimations(t) {
        const e = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let e = 0, n = this.tracks.length; e < n; e++) {
            const n = this.tracks[e];
            null != n && this.setEmptyAnimation(n.trackIndex, t)
        }
        this.queue.drainDisabled = e,
        this.queue.drain()
    }
    expandToIndex(t) {
        return t < this.tracks.length ? this.tracks[t] : (nN.ensureArrayCapacity(this.tracks, t - this.tracks.length + 1, null),
        this.tracks.length = t + 1,
        null)
    }
    trackEntry(t, e, n, r) {
        const i = this.trackEntryPool.obtain();
        return i.trackIndex = t,
        i.animation = e,
        i.loop = n,
        i.holdPrevious = !1,
        i.eventThreshold = 0,
        i.attachmentThreshold = 0,
        i.drawOrderThreshold = 0,
        i.animationStart = 0,
        i.animationEnd = e.duration,
        i.animationLast = -1,
        i.nextAnimationLast = -1,
        i.delay = 0,
        i.trackTime = 0,
        i.trackLast = -1,
        i.nextTrackLast = -1,
        i.trackEnd = Number.MAX_VALUE,
        i.timeScale = 1,
        i.alpha = 1,
        i.interruptAlpha = 1,
        i.mixTime = 0,
        i.mixDuration = null == r ? 0 : this.data.getMix(r.animation, e),
        i
    }
    disposeNext(t) {
        let e = t.next;
        for (; null != e; )
            this.queue.dispose(e),
            e = e.next;
        t.next = null
    }
    _animationsChanged() {
        this.animationsChanged = !1,
        this.propertyIDs.clear();
        for (let t = 0, e = this.tracks.length; t < e; t++) {
            let e = this.tracks[t];
            if (null != e) {
                for (; null != e.mixingFrom; )
                    e = e.mixingFrom;
                do {
                    null != e.mixingFrom && e.mixBlend == OO.add || this.setTimelineModes(e),
                    e = e.mixingTo
                } while (null != e)
            }
        }
    }
    setTimelineModes(t) {
        const e = t.mixingTo
          , n = t.animation.timelines
          , r = t.animation.timelines.length
          , i = nN.setArraySize(t.timelineMode, r);
        t.timelineHoldMix.length = 0;
        const s = nN.setArraySize(t.timelineHoldMix, r)
          , o = this.propertyIDs;
        if (null != e && e.holdPrevious)
            for (let t = 0; t < r; t++)
                o.add(n[t].getPropertyId()),
                i[t] = OD.HOLD;
        else
            t: for (let a = 0; a < r; a++) {
                const r = n[a].getPropertyId();
                if (o.add(r))
                    if (null != e && this.hasTimeline(e, r)) {
                        for (let n = e.mixingTo; null != n; n = n.mixingTo)
                            if (!this.hasTimeline(n, r)) {
                                if (t.mixDuration > 0) {
                                    i[a] = OD.HOLD_MIX,
                                    s[a] = n;
                                    continue t
                                }
                                break
                            }
                        i[a] = OD.HOLD
                    } else
                        i[a] = OD.FIRST;
                else
                    i[a] = OD.SUBSEQUENT
            }
    }
    hasTimeline(t, e) {
        const n = t.animation.timelines;
        for (let t = 0, r = n.length; t < r; t++)
            if (n[t].getPropertyId() == e)
                return !0;
        return !1
    }
    getCurrent(t) {
        return t >= this.tracks.length ? null : this.tracks[t]
    }
    addListener(t) {
        if (null == t)
            throw new Error("listener cannot be null.");
        this.listeners.push(t)
    }
    removeListener(t) {
        const e = this.listeners.indexOf(t);
        e >= 0 && this.listeners.splice(e, 1)
    }
    clearListeners() {
        this.listeners.length = 0
    }
    clearListenerNotifications() {
        this.queue.clear()
    }
    setAnimationByName(t, e, n) {
        OD.deprecatedWarning1 || (OD.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),
        this.setAnimation(t, e, n)
    }
    addAnimationByName(t, e, n, r) {
        OD.deprecatedWarning2 || (OD.deprecatedWarning2 = !0,
        console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),
        this.addAnimation(t, e, n, r)
    }
    hasAnimation(t) {
        return null !== this.data.skeletonData.findAnimation(t)
    }
    hasAnimationByName(t) {
        return OD.deprecatedWarning3 || (OD.deprecatedWarning3 = !0,
        console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),
        this.hasAnimation(t)
    }
}
;
let ND = OD;
ND.emptyAnimation = new iD("<empty>",[],0),
ND.SUBSEQUENT = 0,
ND.FIRST = 1,
ND.HOLD = 2,
ND.HOLD_MIX = 3,
ND.deprecatedWarning1 = !1,
ND.deprecatedWarning2 = !1,
ND.deprecatedWarning3 = !1;
const RD = class {
    constructor() {
        this.mixBlend = OO.replace,
        this.timelineMode = new Array,
        this.timelineHoldMix = new Array,
        this.timelinesRotation = new Array
    }
    reset() {
        this.next = null,
        this.mixingFrom = null,
        this.mixingTo = null,
        this.animation = null,
        this.listener = null,
        this.timelineMode.length = 0,
        this.timelineHoldMix.length = 0,
        this.timelinesRotation.length = 0
    }
    getAnimationTime() {
        if (this.loop) {
            const t = this.animationEnd - this.animationStart;
            return 0 == t ? this.animationStart : this.trackTime % t + this.animationStart
        }
        return Math.min(this.trackTime + this.animationStart, this.animationEnd)
    }
    setAnimationLast(t) {
        this.animationLast = t,
        this.nextAnimationLast = t
    }
    isComplete() {
        return this.trackTime >= this.animationEnd - this.animationStart
    }
    resetRotationDirections() {
        this.timelinesRotation.length = 0
    }
    get time() {
        return RD.deprecatedWarning1 || (RD.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
        this.trackTime
    }
    set time(t) {
        RD.deprecatedWarning1 || (RD.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
        this.trackTime = t
    }
    get endTime() {
        return RD.deprecatedWarning2 || (RD.deprecatedWarning2 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
        this.trackTime
    }
    set endTime(t) {
        RD.deprecatedWarning2 || (RD.deprecatedWarning2 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
        this.trackTime = t
    }
    loopsCount() {
        return Math.floor(this.trackTime / this.trackEnd)
    }
}
;
let DD = RD;
DD.deprecatedWarning1 = !1,
DD.deprecatedWarning2 = !1;
const BD = class {
    constructor(t) {
        this.objects = [],
        this.drainDisabled = !1,
        this.animState = t
    }
    start(t) {
        this.objects.push(FD.start),
        this.objects.push(t),
        this.animState.animationsChanged = !0
    }
    interrupt(t) {
        this.objects.push(FD.interrupt),
        this.objects.push(t)
    }
    end(t) {
        this.objects.push(FD.end),
        this.objects.push(t),
        this.animState.animationsChanged = !0
    }
    dispose(t) {
        this.objects.push(FD.dispose),
        this.objects.push(t)
    }
    complete(t) {
        this.objects.push(FD.complete),
        this.objects.push(t)
    }
    event(t, e) {
        this.objects.push(FD.event),
        this.objects.push(t),
        this.objects.push(e)
    }
    deprecateStuff() {
        return BD.deprecatedWarning1 || (BD.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),
        !0
    }
    drain() {
        if (this.drainDisabled)
            return;
        this.drainDisabled = !0;
        const t = this.objects
          , e = this.animState.listeners;
        for (let n = 0; n < t.length; n += 2) {
            const r = t[n]
              , i = t[n + 1];
            switch (r) {
            case FD.start:
                null != i.listener && i.listener.start && i.listener.start(i);
                for (let t = 0; t < e.length; t++)
                    e[t].start && e[t].start(i);
                i.onStart && this.deprecateStuff() && i.onStart(i.trackIndex),
                this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(i.trackIndex);
                break;
            case FD.interrupt:
                null != i.listener && i.listener.interrupt && i.listener.interrupt(i);
                for (let t = 0; t < e.length; t++)
                    e[t].interrupt && e[t].interrupt(i);
                break;
            case FD.end:
                null != i.listener && i.listener.end && i.listener.end(i);
                for (let t = 0; t < e.length; t++)
                    e[t].end && e[t].end(i);
                i.onEnd && this.deprecateStuff() && i.onEnd(i.trackIndex),
                this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(i.trackIndex);
            case FD.dispose:
                null != i.listener && i.listener.dispose && i.listener.dispose(i);
                for (let t = 0; t < e.length; t++)
                    e[t].dispose && e[t].dispose(i);
                this.animState.trackEntryPool.free(i);
                break;
            case FD.complete:
                null != i.listener && i.listener.complete && i.listener.complete(i);
                for (let t = 0; t < e.length; t++)
                    e[t].complete && e[t].complete(i);
                const r = QO.toInt(i.loopsCount());
                i.onComplete && this.deprecateStuff() && i.onComplete(i.trackIndex, r),
                this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(i.trackIndex, r);
                break;
            case FD.event:
                const s = t[2 + n++];
                null != i.listener && i.listener.event && i.listener.event(i, s);
                for (let t = 0; t < e.length; t++)
                    e[t].event && e[t].event(i, s);
                i.onEvent && this.deprecateStuff() && i.onEvent(i.trackIndex, s),
                this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(i.trackIndex, s)
            }
        }
        this.clear(),
        this.drainDisabled = !1
    }
    clear() {
        this.objects.length = 0
    }
}
;
let LD = BD;
LD.deprecatedWarning1 = !1;
var FD = (t=>(t[t.start = 0] = "start",
t[t.interrupt = 1] = "interrupt",
t[t.end = 2] = "end",
t[t.dispose = 3] = "dispose",
t[t.complete = 4] = "complete",
t[t.event = 5] = "event",
t))(FD || {});
class jD {
    start(t) {}
    interrupt(t) {}
    end(t) {}
    dispose(t) {}
    complete(t) {}
    event(t, e) {}
}
const UD = class {
    constructor(t) {
        if (this.animationToMixTime = {},
        this.defaultMix = 0,
        null == t)
            throw new Error("skeletonData cannot be null.");
        this.skeletonData = t
    }
    setMix(t, e, n) {
        const r = this.skeletonData.findAnimation(t);
        if (null == r)
            throw new Error(`Animation not found: ${t}`);
        const i = this.skeletonData.findAnimation(e);
        if (null == i)
            throw new Error(`Animation not found: ${e}`);
        this.setMixWith(r, i, n)
    }
    setMixByName(t, e, n) {
        UD.deprecatedWarning1 || (UD.deprecatedWarning1 = !0,
        console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),
        this.setMix(t, e, n)
    }
    setMixWith(t, e, n) {
        if (null == t)
            throw new Error("from cannot be null.");
        if (null == e)
            throw new Error("to cannot be null.");
        const r = `${t.name}.${e.name}`;
        this.animationToMixTime[r] = n
    }
    getMix(t, e) {
        const n = `${t.name}.${e.name}`
          , r = this.animationToMixTime[n];
        return void 0 === r ? this.defaultMix : r
    }
}
;
let zD = UD;
zD.deprecatedWarning1 = !1;
class VD {
    constructor(t) {
        this.atlas = t
    }
    newRegionAttachment(t, e, n) {
        const r = this.atlas.findRegion(n);
        if (null == r)
            throw new Error(`Region not found in atlas: ${n} (region attachment: ${e})`);
        const i = new tD(e);
        return i.region = r,
        i
    }
    newMeshAttachment(t, e, n) {
        const r = this.atlas.findRegion(n);
        if (null == r)
            throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${e})`);
        const i = new qR(e);
        return i.region = r,
        i
    }
    newBoundingBoxAttachment(t, e) {
        return new GR(e)
    }
    newPathAttachment(t, e) {
        return new KR(e)
    }
    newPointAttachment(t, e) {
        return new QR(e)
    }
    newClippingAttachment(t, e) {
        return new XR(e)
    }
}
class WD {
    constructor(t, e, n) {
        if (this.matrix = new Sv,
        this.children = new Array,
        this.x = 0,
        this.y = 0,
        this.rotation = 0,
        this.scaleX = 0,
        this.scaleY = 0,
        this.shearX = 0,
        this.shearY = 0,
        this.ax = 0,
        this.ay = 0,
        this.arotation = 0,
        this.ascaleX = 0,
        this.ascaleY = 0,
        this.ashearX = 0,
        this.ashearY = 0,
        this.appliedValid = !1,
        this.sorted = !1,
        this.active = !0,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.skeleton = e,
        this.parent = n,
        this.setToSetupPose()
    }
    get worldX() {
        return this.matrix.tx
    }
    get worldY() {
        return this.matrix.ty
    }
    update() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
    }
    updateWorldTransform() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
    }
    updateWorldTransformWith(t, e, n, r, i, s, o) {
        this.ax = t,
        this.ay = e,
        this.arotation = n,
        this.ascaleX = r,
        this.ascaleY = i,
        this.ashearX = s,
        this.ashearY = o,
        this.appliedValid = !0;
        const a = this.parent
          , l = this.matrix
          , c = this.skeleton.scaleX
          , u = oN.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
        if (null == a) {
            const a = this.skeleton
              , h = n + 90 + o;
            return l.a = QO.cosDeg(n + s) * r * c,
            l.c = QO.cosDeg(h) * i * c,
            l.b = QO.sinDeg(n + s) * r * u,
            l.d = QO.sinDeg(h) * i * u,
            l.tx = t * c + a.x,
            void (l.ty = e * u + a.y)
        }
        let h = a.matrix.a
          , d = a.matrix.c
          , f = a.matrix.b
          , p = a.matrix.d;
        switch (l.tx = h * t + d * e + a.matrix.tx,
        l.ty = f * t + p * e + a.matrix.ty,
        this.data.transformMode) {
        case BO.Normal:
            {
                const t = n + 90 + o
                  , e = QO.cosDeg(n + s) * r
                  , a = QO.cosDeg(t) * i
                  , c = QO.sinDeg(n + s) * r
                  , u = QO.sinDeg(t) * i;
                return l.a = h * e + d * c,
                l.c = h * a + d * u,
                l.b = f * e + p * c,
                void (l.d = f * a + p * u)
            }
        case BO.OnlyTranslation:
            {
                const t = n + 90 + o;
                l.a = QO.cosDeg(n + s) * r,
                l.c = QO.cosDeg(t) * i,
                l.b = QO.sinDeg(n + s) * r,
                l.d = QO.sinDeg(t) * i;
                break
            }
        case BO.NoRotationOrReflection:
            {
                let t = h * h + f * f
                  , e = 0;
                t > 1e-4 ? (t = Math.abs(h * p - d * f) / t,
                d = f * t,
                p = h * t,
                e = Math.atan2(f, h) * QO.radDeg) : (h = 0,
                f = 0,
                e = 90 - Math.atan2(p, d) * QO.radDeg);
                const a = n + s - e
                  , c = n + o - e + 90
                  , u = QO.cosDeg(a) * r
                  , m = QO.cosDeg(c) * i
                  , g = QO.sinDeg(a) * r
                  , y = QO.sinDeg(c) * i;
                l.a = h * u - d * g,
                l.c = h * m - d * y,
                l.b = f * u + p * g,
                l.d = f * m + p * y;
                break
            }
        case BO.NoScale:
        case BO.NoScaleOrReflection:
            {
                const t = QO.cosDeg(n)
                  , e = QO.sinDeg(n);
                let a = (h * t + d * e) / c
                  , m = (f * t + p * e) / u
                  , g = Math.sqrt(a * a + m * m);
                g > 1e-5 && (g = 1 / g),
                a *= g,
                m *= g,
                g = Math.sqrt(a * a + m * m),
                this.data.transformMode == BO.NoScale && h * p - d * f < 0 != (oN.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (g = -g);
                const y = Math.PI / 2 + Math.atan2(m, a)
                  , b = Math.cos(y) * g
                  , v = Math.sin(y) * g
                  , w = QO.cosDeg(s) * r
                  , x = QO.cosDeg(90 + o) * i
                  , E = QO.sinDeg(s) * r
                  , _ = QO.sinDeg(90 + o) * i;
                l.a = a * w + b * E,
                l.c = a * x + b * _,
                l.b = m * w + v * E,
                l.d = m * x + v * _;
                break
            }
        }
        l.a *= c,
        l.c *= c,
        l.b *= u,
        l.d *= u
    }
    setToSetupPose() {
        const t = this.data;
        this.x = t.x,
        this.y = t.y,
        this.rotation = t.rotation,
        this.scaleX = t.scaleX,
        this.scaleY = t.scaleY,
        this.shearX = t.shearX,
        this.shearY = t.shearY
    }
    getWorldRotationX() {
        return Math.atan2(this.matrix.b, this.matrix.a) * QO.radDeg
    }
    getWorldRotationY() {
        return Math.atan2(this.matrix.d, this.matrix.c) * QO.radDeg
    }
    getWorldScaleX() {
        const t = this.matrix;
        return Math.sqrt(t.a * t.a + t.c * t.c)
    }
    getWorldScaleY() {
        const t = this.matrix;
        return Math.sqrt(t.b * t.b + t.d * t.d)
    }
    updateAppliedTransform() {
        this.appliedValid = !0;
        const t = this.parent
          , e = this.matrix;
        if (null == t)
            return this.ax = e.tx,
            this.ay = e.ty,
            this.arotation = Math.atan2(e.b, e.a) * QO.radDeg,
            this.ascaleX = Math.sqrt(e.a * e.a + e.b * e.b),
            this.ascaleY = Math.sqrt(e.c * e.c + e.d * e.d),
            this.ashearX = 0,
            void (this.ashearY = Math.atan2(e.a * e.c + e.b * e.d, e.a * e.d - e.b * e.c) * QO.radDeg);
        const n = t.matrix
          , r = 1 / (n.a * n.d - n.b * n.c)
          , i = e.tx - n.tx
          , s = e.ty - n.ty;
        this.ax = i * n.d * r - s * n.c * r,
        this.ay = s * n.a * r - i * n.b * r;
        const o = r * n.d
          , a = r * n.a
          , l = r * n.c
          , c = r * n.b
          , u = o * e.a - l * e.b
          , h = o * e.c - l * e.d
          , d = a * e.b - c * e.a
          , f = a * e.d - c * e.c;
        if (this.ashearX = 0,
        this.ascaleX = Math.sqrt(u * u + d * d),
        this.ascaleX > 1e-4) {
            const t = u * f - h * d;
            this.ascaleY = t / this.ascaleX,
            this.ashearY = Math.atan2(u * h + d * f, t) * QO.radDeg,
            this.arotation = Math.atan2(d, u) * QO.radDeg
        } else
            this.ascaleX = 0,
            this.ascaleY = Math.sqrt(h * h + f * f),
            this.ashearY = 0,
            this.arotation = 90 - Math.atan2(f, h) * QO.radDeg
    }
    worldToLocal(t) {
        const e = this.matrix
          , n = e.a
          , r = e.c
          , i = e.b
          , s = e.d
          , o = 1 / (n * s - r * i)
          , a = t.x - e.tx
          , l = t.y - e.ty;
        return t.x = a * s * o - l * r * o,
        t.y = l * n * o - a * i * o,
        t
    }
    localToWorld(t) {
        const e = this.matrix
          , n = t.x
          , r = t.y;
        return t.x = n * e.a + r * e.c + e.tx,
        t.y = n * e.b + r * e.d + e.ty,
        t
    }
    worldToLocalRotation(t) {
        const e = QO.sinDeg(t)
          , n = QO.cosDeg(t)
          , r = this.matrix;
        return Math.atan2(r.a * e - r.b * n, r.d * n - r.c * e) * QO.radDeg
    }
    localToWorldRotation(t) {
        const e = QO.sinDeg(t)
          , n = QO.cosDeg(t)
          , r = this.matrix;
        return Math.atan2(n * r.b + e * r.d, n * r.a + e * r.c) * QO.radDeg
    }
    rotateWorld(t) {
        const e = this.matrix
          , n = e.a
          , r = e.c
          , i = e.b
          , s = e.d
          , o = QO.cosDeg(t)
          , a = QO.sinDeg(t);
        e.a = o * n - a * i,
        e.c = o * r - a * s,
        e.b = a * n + o * i,
        e.d = a * r + o * s,
        this.appliedValid = !1
    }
}
class YD {
    constructor(t, e, n) {
        if (this.x = 0,
        this.y = 0,
        this.rotation = 0,
        this.scaleX = 1,
        this.scaleY = 1,
        this.shearX = 0,
        this.shearY = 0,
        this.transformMode = BO.Normal,
        t < 0)
            throw new Error("index must be >= 0.");
        if (null == e)
            throw new Error("name cannot be null.");
        this.index = t,
        this.name = e,
        this.parent = n
    }
}
class HD {
    constructor(t, e) {
        if (null == e)
            throw new Error("data cannot be null.");
        this.time = t,
        this.data = e
    }
}
class $D {
    constructor(t) {
        this.name = t
    }
}
class GD {
    constructor(t, e) {
        if (this.bendDirection = 0,
        this.compress = !1,
        this.stretch = !1,
        this.mix = 1,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.mix = t.mix,
        this.bendDirection = t.bendDirection,
        this.compress = t.compress,
        this.stretch = t.stretch,
        this.bones = new Array;
        for (let n = 0; n < t.bones.length; n++)
            this.bones.push(e.findBone(t.bones[n].name));
        this.target = e.findBone(t.target.name)
    }
    getOrder() {
        return this.data.order
    }
    apply() {
        this.update()
    }
    update() {
        const t = this.target
          , e = this.bones;
        switch (e.length) {
        case 1:
            this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
            break;
        case 2:
            this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.mix)
        }
    }
    apply1(t, e, n, r, i, s, o) {
        t.appliedValid || t.updateAppliedTransform();
        const a = t.parent.matrix
          , l = 1 / (a.a * a.d - a.b * a.c)
          , c = e - a.tx
          , u = n - a.ty
          , h = (c * a.d - u * a.c) * l - t.ax
          , d = (u * a.a - c * a.b) * l - t.ay;
        let f = Math.atan2(d, h) * QO.radDeg - t.ashearX - t.arotation;
        t.ascaleX < 0 && (f += 180),
        f > 180 ? f -= 360 : f < -180 && (f += 360);
        let p = t.ascaleX
          , m = t.ascaleY;
        if (r || i) {
            const e = t.data.length * p
              , n = Math.sqrt(h * h + d * d);
            if (r && n < e || i && n > e && e > 1e-4) {
                const t = (n / e - 1) * o + 1;
                p *= t,
                s && (m *= t)
            }
        }
        t.updateWorldTransformWith(t.ax, t.ay, t.arotation + f * o, p, m, t.ashearX, t.ashearY)
    }
    apply2(t, e, n, r, i, s, o) {
        if (0 == o)
            return void e.updateWorldTransform();
        t.appliedValid || t.updateAppliedTransform(),
        e.appliedValid || e.updateAppliedTransform();
        const a = t.ax
          , l = t.ay;
        let c = t.ascaleX
          , u = c
          , h = t.ascaleY
          , d = e.ascaleX;
        const f = t.matrix;
        let p = 0
          , m = 0
          , g = 0;
        c < 0 ? (c = -c,
        p = 180,
        g = -1) : (p = 0,
        g = 1),
        h < 0 && (h = -h,
        g = -g),
        d < 0 ? (d = -d,
        m = 180) : m = 0;
        const y = e.ax;
        let b = 0
          , v = 0
          , w = 0
          , x = f.a
          , E = f.c
          , _ = f.b
          , A = f.d;
        const S = Math.abs(c - h) <= 1e-4;
        S ? (b = e.ay,
        v = x * y + E * b + f.tx,
        w = _ * y + A * b + f.ty) : (b = 0,
        v = x * y + f.tx,
        w = _ * y + f.ty);
        const T = t.parent.matrix;
        x = T.a,
        E = T.c,
        _ = T.b,
        A = T.d;
        const k = 1 / (x * A - E * _);
        let I = n - T.tx
          , M = r - T.ty;
        const C = (I * A - M * E) * k - a
          , P = (M * x - I * _) * k - l
          , O = C * C + P * P;
        I = v - T.tx,
        M = w - T.ty;
        const N = (I * A - M * E) * k - a
          , R = (M * x - I * _) * k - l
          , D = Math.sqrt(N * N + R * R);
        let B = e.data.length * d
          , L = 0
          , F = 0;
        t: if (S) {
            B *= c;
            let t = (O - D * D - B * B) / (2 * D * B);
            t < -1 ? t = -1 : t > 1 && (t = 1,
            s && D + B > 1e-4 && (u *= (Math.sqrt(O) / (D + B) - 1) * o + 1)),
            F = Math.acos(t) * i,
            x = D + B * t,
            E = B * Math.sin(F),
            L = Math.atan2(P * x - C * E, C * x + P * E)
        } else {
            x = c * B,
            E = h * B;
            const t = x * x
              , e = E * E
              , n = Math.atan2(P, C);
            _ = e * D * D + t * O - t * e;
            const r = -2 * e * D
              , s = e - t;
            if (A = r * r - 4 * s * _,
            A >= 0) {
                let t = Math.sqrt(A);
                r < 0 && (t = -t),
                t = -(r + t) / 2;
                const e = t / s
                  , o = _ / t
                  , a = Math.abs(e) < Math.abs(o) ? e : o;
                if (a * a <= O) {
                    M = Math.sqrt(O - a * a) * i,
                    L = n - Math.atan2(M, a),
                    F = Math.atan2(M / h, (a - D) / c);
                    break t
                }
            }
            let o = QO.PI
              , a = D - x
              , l = a * a
              , u = 0
              , d = 0
              , f = D + x
              , p = f * f
              , m = 0;
            _ = -x * D / (t - e),
            _ >= -1 && _ <= 1 && (_ = Math.acos(_),
            I = x * Math.cos(_) + D,
            M = E * Math.sin(_),
            A = I * I + M * M,
            A < l && (o = _,
            l = A,
            a = I,
            u = M),
            A > p && (d = _,
            p = A,
            f = I,
            m = M)),
            O <= (l + p) / 2 ? (L = n - Math.atan2(u * i, a),
            F = o * i) : (L = n - Math.atan2(m * i, f),
            F = d * i)
        }
        const j = Math.atan2(b, y) * g;
        let U = t.arotation;
        L = (L - j) * QO.radDeg + p - U,
        L > 180 ? L -= 360 : L < -180 && (L += 360),
        t.updateWorldTransformWith(a, l, U + L * o, u, t.ascaleY, 0, 0),
        U = e.arotation,
        F = ((F + j) * QO.radDeg - e.ashearX) * g + m - U,
        F > 180 ? F -= 360 : F < -180 && (F += 360),
        e.updateWorldTransformWith(y, b, U + F * o, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY)
    }
}
class XD {
    constructor(t) {
        this.order = 0,
        this.bones = new Array,
        this.bendDirection = 1,
        this.compress = !1,
        this.stretch = !1,
        this.uniform = !1,
        this.mix = 1,
        this.name = t
    }
}
class qD {
    constructor(t) {
        this.order = 0,
        this.bones = new Array,
        this.name = t
    }
}
var KD = (t=>(t[t.Length = 0] = "Length",
t[t.Fixed = 1] = "Fixed",
t[t.Percent = 2] = "Percent",
t))(KD || {});
const QD = class {
    constructor(t, e) {
        if (this.position = 0,
        this.spacing = 0,
        this.rotateMix = 0,
        this.translateMix = 0,
        this.spaces = new Array,
        this.positions = new Array,
        this.world = new Array,
        this.curves = new Array,
        this.lengths = new Array,
        this.segments = new Array,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.bones = new Array;
        for (let n = 0, r = t.bones.length; n < r; n++)
            this.bones.push(e.findBone(t.bones[n].name));
        this.target = e.findSlot(t.target.name),
        this.position = t.position,
        this.spacing = t.spacing,
        this.rotateMix = t.rotateMix,
        this.translateMix = t.translateMix
    }
    apply() {
        this.update()
    }
    update() {
        const t = this.target.getAttachment();
        if (!(t instanceof KR))
            return;
        const e = this.rotateMix
          , n = this.translateMix
          , r = e > 0;
        if (!(n > 0) && !r)
            return;
        const i = this.data
          , s = i.spacingMode
          , o = s == KD.Length
          , a = i.rotateMode
          , l = a == DO.Tangent
          , c = a == DO.ChainScale
          , u = this.bones.length
          , h = l ? u : u + 1
          , d = this.bones
          , f = nN.setArraySize(this.spaces, h);
        let p = null;
        const m = this.spacing;
        if (c || o) {
            c && (p = nN.setArraySize(this.lengths, u));
            for (let t = 0, e = h - 1; t < e; ) {
                const e = d[t]
                  , n = e.data.length;
                if (n < QD.epsilon)
                    c && (p[t] = 0),
                    f[++t] = 0;
                else {
                    const r = n * e.matrix.a
                      , i = n * e.matrix.b
                      , s = Math.sqrt(r * r + i * i);
                    c && (p[t] = s),
                    f[++t] = (o ? n + m : m) * s / n
                }
            }
        } else
            for (let t = 1; t < h; t++)
                f[t] = m;
        const g = this.computeWorldPositions(t, h, l, i.positionMode == RO.Percent, s == KD.Percent);
        let y = g[0]
          , b = g[1]
          , v = i.offsetRotation
          , w = !1;
        if (0 == v)
            w = a == DO.Chain;
        else {
            w = !1;
            const t = this.target.bone.matrix;
            v *= t.a * t.d - t.b * t.c > 0 ? QO.degRad : -QO.degRad
        }
        for (let t = 0, i = 3; t < u; t++,
        i += 3) {
            const s = d[t]
              , o = s.matrix;
            o.tx += (y - o.tx) * n,
            o.ty += (b - o.ty) * n;
            const a = g[i]
              , u = g[i + 1]
              , h = a - y
              , m = u - b;
            if (c) {
                const n = p[t];
                if (0 != n) {
                    const t = (Math.sqrt(h * h + m * m) / n - 1) * e + 1;
                    o.a *= t,
                    o.b *= t
                }
            }
            if (y = a,
            b = u,
            r) {
                const n = o.a
                  , r = o.c
                  , a = o.b
                  , c = o.d;
                let u = 0
                  , d = 0
                  , p = 0;
                if (l && (u = l ? g[i - 1] : 0 == f[t + 1] ? g[i + 2] : Math.atan2(m, h)),
                u -= Math.atan2(a, n),
                w) {
                    d = Math.cos(u),
                    p = Math.sin(u);
                    const t = s.data.length;
                    y += (t * (d * n - p * a) - h) * e,
                    b += (t * (p * n + d * a) - m) * e
                } else
                    u += v;
                u > QO.PI ? u -= QO.PI2 : u < -QO.PI && (u += QO.PI2),
                u *= e,
                d = Math.cos(u),
                p = Math.sin(u),
                o.a = d * n - p * a,
                o.c = d * r - p * c,
                o.b = p * n + d * a,
                o.d = p * r + d * c
            }
            s.appliedValid = !1
        }
    }
    computeWorldPositions(t, e, n, r, i) {
        const s = this.target;
        let o = this.position;
        const a = this.spaces
          , l = nN.setArraySize(this.positions, 3 * e + 2);
        let c = null;
        const u = t.closed;
        let h = t.worldVerticesLength
          , d = h / 6
          , f = QD.NONE;
        if (!t.constantSpeed) {
            const p = t.lengths;
            d -= u ? 1 : 2;
            const m = p[d];
            if (r && (o *= m),
            i)
                for (let t = 0; t < e; t++)
                    a[t] *= m;
            c = nN.setArraySize(this.world, 8);
            for (let r = 0, i = 0, g = 0; r < e; r++,
            i += 3) {
                const e = a[r];
                o += e;
                let y = o;
                if (u)
                    y %= m,
                    y < 0 && (y += m),
                    g = 0;
                else {
                    if (y < 0) {
                        f != QD.BEFORE && (f = QD.BEFORE,
                        t.computeWorldVertices(s, 2, 4, c, 0, 2)),
                        this.addBeforePosition(y, c, 0, l, i);
                        continue
                    }
                    if (y > m) {
                        f != QD.AFTER && (f = QD.AFTER,
                        t.computeWorldVertices(s, h - 6, 4, c, 0, 2)),
                        this.addAfterPosition(y - m, c, 0, l, i);
                        continue
                    }
                }
                for (; ; g++) {
                    const t = p[g];
                    if (!(y > t)) {
                        if (0 == g)
                            y /= t;
                        else {
                            const e = p[g - 1];
                            y = (y - e) / (t - e)
                        }
                        break
                    }
                }
                g != f && (f = g,
                u && g == d ? (t.computeWorldVertices(s, h - 4, 4, c, 0, 2),
                t.computeWorldVertices(s, 0, 4, c, 4, 2)) : t.computeWorldVertices(s, 6 * g + 2, 8, c, 0, 2)),
                this.addCurvePosition(y, c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], l, i, n || r > 0 && 0 == e)
            }
            return l
        }
        u ? (h += 2,
        c = nN.setArraySize(this.world, h),
        t.computeWorldVertices(s, 2, h - 4, c, 0, 2),
        t.computeWorldVertices(s, 0, 2, c, h - 4, 2),
        c[h - 2] = c[0],
        c[h - 1] = c[1]) : (d--,
        h -= 4,
        c = nN.setArraySize(this.world, h),
        t.computeWorldVertices(s, 2, h, c, 0, 2));
        const p = nN.setArraySize(this.curves, d);
        let m = 0
          , g = c[0]
          , y = c[1]
          , b = 0
          , v = 0
          , w = 0
          , x = 0
          , E = 0
          , _ = 0
          , A = 0
          , S = 0
          , T = 0
          , k = 0
          , I = 0
          , M = 0
          , C = 0
          , P = 0;
        for (let t = 0, e = 2; t < d; t++,
        e += 6)
            b = c[e],
            v = c[e + 1],
            w = c[e + 2],
            x = c[e + 3],
            E = c[e + 4],
            _ = c[e + 5],
            A = .1875 * (g - 2 * b + w),
            S = .1875 * (y - 2 * v + x),
            T = .09375 * (3 * (b - w) - g + E),
            k = .09375 * (3 * (v - x) - y + _),
            I = 2 * A + T,
            M = 2 * S + k,
            C = .75 * (b - g) + A + .16666667 * T,
            P = .75 * (v - y) + S + .16666667 * k,
            m += Math.sqrt(C * C + P * P),
            C += I,
            P += M,
            I += T,
            M += k,
            m += Math.sqrt(C * C + P * P),
            C += I,
            P += M,
            m += Math.sqrt(C * C + P * P),
            C += I + T,
            P += M + k,
            m += Math.sqrt(C * C + P * P),
            p[t] = m,
            g = E,
            y = _;
        if (r && (o *= m),
        i)
            for (let t = 0; t < e; t++)
                a[t] *= m;
        const O = this.segments;
        let N = 0;
        for (let t = 0, r = 0, i = 0, s = 0; t < e; t++,
        r += 3) {
            const e = a[t];
            o += e;
            let d = o;
            if (u)
                d %= m,
                d < 0 && (d += m),
                i = 0;
            else {
                if (d < 0) {
                    this.addBeforePosition(d, c, 0, l, r);
                    continue
                }
                if (d > m) {
                    this.addAfterPosition(d - m, c, h - 4, l, r);
                    continue
                }
            }
            for (; ; i++) {
                const t = p[i];
                if (!(d > t)) {
                    if (0 == i)
                        d /= t;
                    else {
                        const e = p[i - 1];
                        d = (d - e) / (t - e)
                    }
                    break
                }
            }
            if (i != f) {
                f = i;
                let t = 6 * i;
                for (g = c[t],
                y = c[t + 1],
                b = c[t + 2],
                v = c[t + 3],
                w = c[t + 4],
                x = c[t + 5],
                E = c[t + 6],
                _ = c[t + 7],
                A = .03 * (g - 2 * b + w),
                S = .03 * (y - 2 * v + x),
                T = .006 * (3 * (b - w) - g + E),
                k = .006 * (3 * (v - x) - y + _),
                I = 2 * A + T,
                M = 2 * S + k,
                C = .3 * (b - g) + A + .16666667 * T,
                P = .3 * (v - y) + S + .16666667 * k,
                N = Math.sqrt(C * C + P * P),
                O[0] = N,
                t = 1; t < 8; t++)
                    C += I,
                    P += M,
                    I += T,
                    M += k,
                    N += Math.sqrt(C * C + P * P),
                    O[t] = N;
                C += I,
                P += M,
                N += Math.sqrt(C * C + P * P),
                O[8] = N,
                C += I + T,
                P += M + k,
                N += Math.sqrt(C * C + P * P),
                O[9] = N,
                s = 0
            }
            for (d *= N; ; s++) {
                const t = O[s];
                if (!(d > t)) {
                    if (0 == s)
                        d /= t;
                    else {
                        const e = O[s - 1];
                        d = s + (d - e) / (t - e)
                    }
                    break
                }
            }
            this.addCurvePosition(.1 * d, g, y, b, v, w, x, E, _, l, r, n || t > 0 && 0 == e)
        }
        return l
    }
    addBeforePosition(t, e, n, r, i) {
        const s = e[n]
          , o = e[n + 1]
          , a = e[n + 2] - s
          , l = e[n + 3] - o
          , c = Math.atan2(l, a);
        r[i] = s + t * Math.cos(c),
        r[i + 1] = o + t * Math.sin(c),
        r[i + 2] = c
    }
    addAfterPosition(t, e, n, r, i) {
        const s = e[n + 2]
          , o = e[n + 3]
          , a = s - e[n]
          , l = o - e[n + 1]
          , c = Math.atan2(l, a);
        r[i] = s + t * Math.cos(c),
        r[i + 1] = o + t * Math.sin(c),
        r[i + 2] = c
    }
    addCurvePosition(t, e, n, r, i, s, o, a, l, c, u, h) {
        (0 == t || isNaN(t)) && (t = 1e-4);
        const d = t * t
          , f = d * t
          , p = 1 - t
          , m = p * p
          , g = m * p
          , y = p * t
          , b = 3 * y
          , v = p * b
          , w = b * t
          , x = e * g + r * v + s * w + a * f
          , E = n * g + i * v + o * w + l * f;
        c[u] = x,
        c[u + 1] = E,
        h && (c[u + 2] = Math.atan2(E - (n * m + i * y * 2 + o * d), x - (e * m + r * y * 2 + s * d)))
    }
    getOrder() {
        return this.data.order
    }
}
;
let ZD = QD;
ZD.NONE = -1,
ZD.BEFORE = -2,
ZD.AFTER = -3,
ZD.epsilon = 1e-5;
class JD {
    constructor(t, e) {
        if (this.rotateMix = 0,
        this.translateMix = 0,
        this.scaleMix = 0,
        this.shearMix = 0,
        this.temp = new iN,
        null == t)
            throw new Error("data cannot be null.");
        if (null == e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.rotateMix = t.rotateMix,
        this.translateMix = t.translateMix,
        this.scaleMix = t.scaleMix,
        this.shearMix = t.shearMix,
        this.bones = new Array;
        for (let n = 0; n < t.bones.length; n++)
            this.bones.push(e.findBone(t.bones[n].name));
        this.target = e.findBone(t.target.name)
    }
    apply() {
        this.update()
    }
    update() {
        this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
    }
    applyAbsoluteWorld() {
        const t = this.rotateMix
          , e = this.translateMix
          , n = this.scaleMix
          , r = this.shearMix
          , i = this.target
          , s = i.matrix
          , o = s.a
          , a = s.c
          , l = s.b
          , c = s.d
          , u = o * c - a * l > 0 ? QO.degRad : -QO.degRad
          , h = this.data.offsetRotation * u
          , d = this.data.offsetShearY * u
          , f = this.bones;
        for (let s = 0, u = f.length; s < u; s++) {
            const u = f[s];
            let p = !1;
            const m = u.matrix;
            if (0 != t) {
                const e = m.a
                  , n = m.c
                  , r = m.b
                  , i = m.d;
                let s = Math.atan2(l, o) - Math.atan2(r, e) + h;
                s > QO.PI ? s -= QO.PI2 : s < -QO.PI && (s += QO.PI2),
                s *= t;
                const a = Math.cos(s)
                  , c = Math.sin(s);
                m.a = a * e - c * r,
                m.c = a * n - c * i,
                m.b = c * e + a * r,
                m.d = c * n + a * i,
                p = !0
            }
            if (0 != e) {
                const t = this.temp;
                i.localToWorld(t.set(this.data.offsetX, this.data.offsetY)),
                m.tx += (t.x - m.tx) * e,
                m.ty += (t.y - m.ty) * e,
                p = !0
            }
            if (n > 0) {
                let t = Math.sqrt(m.a * m.a + m.b * m.b)
                  , e = Math.sqrt(o * o + l * l);
                t > 1e-5 && (t = (t + (e - t + this.data.offsetScaleX) * n) / t),
                m.a *= t,
                m.b *= t,
                t = Math.sqrt(m.c * m.c + m.d * m.d),
                e = Math.sqrt(a * a + c * c),
                t > 1e-5 && (t = (t + (e - t + this.data.offsetScaleY) * n) / t),
                m.c *= t,
                m.d *= t,
                p = !0
            }
            if (r > 0) {
                const t = m.c
                  , e = m.d
                  , n = Math.atan2(e, t);
                let i = Math.atan2(c, a) - Math.atan2(l, o) - (n - Math.atan2(m.b, m.a));
                i > QO.PI ? i -= QO.PI2 : i < -QO.PI && (i += QO.PI2),
                i = n + (i + d) * r;
                const s = Math.sqrt(t * t + e * e);
                m.c = Math.cos(i) * s,
                m.d = Math.sin(i) * s,
                p = !0
            }
            p && (u.appliedValid = !1)
        }
    }
    applyRelativeWorld() {
        const t = this.rotateMix
          , e = this.translateMix
          , n = this.scaleMix
          , r = this.shearMix
          , i = this.target
          , s = i.matrix
          , o = s.a
          , a = s.c
          , l = s.b
          , c = s.d
          , u = o * c - a * l > 0 ? QO.degRad : -QO.degRad
          , h = this.data.offsetRotation * u
          , d = this.data.offsetShearY * u
          , f = this.bones;
        for (let s = 0, u = f.length; s < u; s++) {
            const u = f[s];
            let p = !1;
            const m = u.matrix;
            if (0 != t) {
                const e = m.a
                  , n = m.c
                  , r = m.b
                  , i = m.d;
                let s = Math.atan2(l, o) + h;
                s > QO.PI ? s -= QO.PI2 : s < -QO.PI && (s += QO.PI2),
                s *= t;
                const a = Math.cos(s)
                  , c = Math.sin(s);
                m.a = a * e - c * r,
                m.c = a * n - c * i,
                m.b = c * e + a * r,
                m.d = c * n + a * i,
                p = !0
            }
            if (0 != e) {
                const t = this.temp;
                i.localToWorld(t.set(this.data.offsetX, this.data.offsetY)),
                m.tx += t.x * e,
                m.ty += t.y * e,
                p = !0
            }
            if (n > 0) {
                let t = (Math.sqrt(o * o + l * l) - 1 + this.data.offsetScaleX) * n + 1;
                m.a *= t,
                m.b *= t,
                t = (Math.sqrt(a * a + c * c) - 1 + this.data.offsetScaleY) * n + 1,
                m.c *= t,
                m.d *= t,
                p = !0
            }
            if (r > 0) {
                let t = Math.atan2(c, a) - Math.atan2(l, o);
                t > QO.PI ? t -= QO.PI2 : t < -QO.PI && (t += QO.PI2);
                const e = m.c
                  , n = m.d;
                t = Math.atan2(n, e) + (t - QO.PI / 2 + d) * r;
                const i = Math.sqrt(e * e + n * n);
                m.c = Math.cos(t) * i,
                m.d = Math.sin(t) * i,
                p = !0
            }
            p && (u.appliedValid = !1)
        }
    }
    applyAbsoluteLocal() {
        const t = this.rotateMix
          , e = this.translateMix
          , n = this.scaleMix
          , r = this.shearMix
          , i = this.target;
        i.appliedValid || i.updateAppliedTransform();
        const s = this.bones;
        for (let o = 0, a = s.length; o < a; o++) {
            const a = s[o];
            a.appliedValid || a.updateAppliedTransform();
            let l = a.arotation;
            if (0 != t) {
                let e = i.arotation - l + this.data.offsetRotation;
                e -= 360 * (16384 - (16384.499999999996 - e / 360 | 0)),
                l += e * t
            }
            let c = a.ax
              , u = a.ay;
            0 != e && (c += (i.ax - c + this.data.offsetX) * e,
            u += (i.ay - u + this.data.offsetY) * e);
            let h = a.ascaleX
              , d = a.ascaleY;
            n > 0 && (h > 1e-5 && (h = (h + (i.ascaleX - h + this.data.offsetScaleX) * n) / h),
            d > 1e-5 && (d = (d + (i.ascaleY - d + this.data.offsetScaleY) * n) / d));
            const f = a.ashearY;
            if (r > 0) {
                let t = i.ashearY - f + this.data.offsetShearY;
                t -= 360 * (16384 - (16384.499999999996 - t / 360 | 0)),
                a.shearY += t * r
            }
            a.updateWorldTransformWith(c, u, l, h, d, a.ashearX, f)
        }
    }
    applyRelativeLocal() {
        const t = this.rotateMix
          , e = this.translateMix
          , n = this.scaleMix
          , r = this.shearMix
          , i = this.target;
        i.appliedValid || i.updateAppliedTransform();
        const s = this.bones;
        for (let o = 0, a = s.length; o < a; o++) {
            const a = s[o];
            a.appliedValid || a.updateAppliedTransform();
            let l = a.arotation;
            0 != t && (l += (i.arotation + this.data.offsetRotation) * t);
            let c = a.ax
              , u = a.ay;
            0 != e && (c += (i.ax + this.data.offsetX) * e,
            u += (i.ay + this.data.offsetY) * e);
            let h = a.ascaleX
              , d = a.ascaleY;
            n > 0 && (h > 1e-5 && (h *= (i.ascaleX - 1 + this.data.offsetScaleX) * n + 1),
            d > 1e-5 && (d *= (i.ascaleY - 1 + this.data.offsetScaleY) * n + 1));
            let f = a.ashearY;
            r > 0 && (f += (i.ashearY + this.data.offsetShearY) * r),
            a.updateWorldTransformWith(c, u, l, h, d, a.ashearX, f)
        }
    }
    getOrder() {
        return this.data.order
    }
}
const tB = class {
    constructor(t) {
        if (this._updateCache = new Array,
        this.updateCacheReset = new Array,
        this.time = 0,
        this.scaleX = 1,
        this.scaleY = 1,
        this.x = 0,
        this.y = 0,
        null == t)
            throw new Error("data cannot be null.");
        this.data = t,
        this.bones = new Array;
        for (let e = 0; e < t.bones.length; e++) {
            const n = t.bones[e];
            let r;
            if (null == n.parent)
                r = new WD(n,this,null);
            else {
                const t = this.bones[n.parent.index];
                r = new WD(n,this,t),
                t.children.push(r)
            }
            this.bones.push(r)
        }
        this.slots = new Array,
        this.drawOrder = new Array;
        for (let e = 0; e < t.slots.length; e++) {
            const n = t.slots[e]
              , r = this.bones[n.boneData.index]
              , i = new ZR(n,r);
            this.slots.push(i),
            this.drawOrder.push(i)
        }
        this.ikConstraints = new Array;
        for (let e = 0; e < t.ikConstraints.length; e++) {
            const n = t.ikConstraints[e];
            this.ikConstraints.push(new GD(n,this))
        }
        this.transformConstraints = new Array;
        for (let e = 0; e < t.transformConstraints.length; e++) {
            const n = t.transformConstraints[e];
            this.transformConstraints.push(new JD(n,this))
        }
        this.pathConstraints = new Array;
        for (let e = 0; e < t.pathConstraints.length; e++) {
            const n = t.pathConstraints[e];
            this.pathConstraints.push(new ZD(n,this))
        }
        this.color = new qO(1,1,1,1),
        this.updateCache()
    }
    updateCache() {
        this._updateCache.length = 0,
        this.updateCacheReset.length = 0;
        const t = this.bones;
        for (let e = 0, n = t.length; e < n; e++)
            t[e].sorted = !1;
        const e = this.ikConstraints
          , n = this.transformConstraints
          , r = this.pathConstraints
          , i = e.length
          , s = n.length
          , o = r.length
          , a = i + s + o;
        t: for (let t = 0; t < a; t++) {
            for (let n = 0; n < i; n++) {
                const r = e[n];
                if (r.data.order == t) {
                    this.sortIkConstraint(r);
                    continue t
                }
            }
            for (let e = 0; e < s; e++) {
                const r = n[e];
                if (r.data.order == t) {
                    this.sortTransformConstraint(r);
                    continue t
                }
            }
            for (let e = 0; e < o; e++) {
                const n = r[e];
                if (n.data.order == t) {
                    this.sortPathConstraint(n);
                    continue t
                }
            }
        }
        for (let e = 0, n = t.length; e < n; e++)
            this.sortBone(t[e])
    }
    sortIkConstraint(t) {
        const e = t.target;
        this.sortBone(e);
        const n = t.bones
          , r = n[0];
        if (this.sortBone(r),
        n.length > 1) {
            const t = n[n.length - 1];
            this._updateCache.indexOf(t) > -1 || this.updateCacheReset.push(t)
        }
        this._updateCache.push(t),
        this.sortReset(r.children),
        n[n.length - 1].sorted = !0
    }
    sortPathConstraint(t) {
        const e = t.target
          , n = e.data.index
          , r = e.bone;
        null != this.skin && this.sortPathConstraintAttachment(this.skin, n, r),
        null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, r);
        for (let t = 0, e = this.data.skins.length; t < e; t++)
            this.sortPathConstraintAttachment(this.data.skins[t], n, r);
        const i = e.getAttachment();
        i instanceof KR && this.sortPathConstraintAttachmentWith(i, r);
        const s = t.bones
          , o = s.length;
        for (let t = 0; t < o; t++)
            this.sortBone(s[t]);
        this._updateCache.push(t);
        for (let t = 0; t < o; t++)
            this.sortReset(s[t].children);
        for (let t = 0; t < o; t++)
            s[t].sorted = !0
    }
    sortTransformConstraint(t) {
        this.sortBone(t.target);
        const e = t.bones
          , n = e.length;
        if (t.data.local)
            for (let t = 0; t < n; t++) {
                const n = e[t];
                this.sortBone(n.parent),
                this._updateCache.indexOf(n) > -1 || this.updateCacheReset.push(n)
            }
        else
            for (let t = 0; t < n; t++)
                this.sortBone(e[t]);
        this._updateCache.push(t);
        for (let t = 0; t < n; t++)
            this.sortReset(e[t].children);
        for (let t = 0; t < n; t++)
            e[t].sorted = !0
    }
    sortPathConstraintAttachment(t, e, n) {
        const r = t.attachments[e];
        if (r)
            for (const t in r)
                this.sortPathConstraintAttachmentWith(r[t], n)
    }
    sortPathConstraintAttachmentWith(t, e) {
        if (!(t instanceof KR))
            return;
        const n = t.bones;
        if (null == n)
            this.sortBone(e);
        else {
            const t = this.bones;
            let e = 0;
            for (; e < n.length; ) {
                const r = n[e++];
                for (let i = e + r; e < i; e++) {
                    const r = n[e];
                    this.sortBone(t[r])
                }
            }
        }
    }
    sortBone(t) {
        if (t.sorted)
            return;
        const e = t.parent;
        null != e && this.sortBone(e),
        t.sorted = !0,
        this._updateCache.push(t)
    }
    sortReset(t) {
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            n.sorted && this.sortReset(n.children),
            n.sorted = !1
        }
    }
    updateWorldTransform() {
        const t = this.updateCacheReset;
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            n.ax = n.x,
            n.ay = n.y,
            n.arotation = n.rotation,
            n.ascaleX = n.scaleX,
            n.ascaleY = n.scaleY,
            n.ashearX = n.shearX,
            n.ashearY = n.shearY,
            n.appliedValid = !0
        }
        const e = this._updateCache;
        for (let t = 0, n = e.length; t < n; t++)
            e[t].update()
    }
    setToSetupPose() {
        this.setBonesToSetupPose(),
        this.setSlotsToSetupPose()
    }
    setBonesToSetupPose() {
        const t = this.bones;
        for (let e = 0, n = t.length; e < n; e++)
            t[e].setToSetupPose();
        const e = this.ikConstraints;
        for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t];
            n.bendDirection = n.data.bendDirection,
            n.mix = n.data.mix
        }
        const n = this.transformConstraints;
        for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t]
              , r = e.data;
            e.rotateMix = r.rotateMix,
            e.translateMix = r.translateMix,
            e.scaleMix = r.scaleMix,
            e.shearMix = r.shearMix
        }
        const r = this.pathConstraints;
        for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t]
              , n = e.data;
            e.position = n.position,
            e.spacing = n.spacing,
            e.rotateMix = n.rotateMix,
            e.translateMix = n.translateMix
        }
    }
    setSlotsToSetupPose() {
        const t = this.slots;
        nN.arrayCopy(t, 0, this.drawOrder, 0, t.length);
        for (let e = 0, n = t.length; e < n; e++)
            t[e].setToSetupPose()
    }
    getRootBone() {
        return 0 == this.bones.length ? null : this.bones[0]
    }
    findBone(t) {
        if (null == t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findBoneIndex(t) {
        if (null == t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].data.name == t)
                return n;
        return -1
    }
    findSlot(t) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findSlotIndex(t) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].data.name == t)
                return n;
        return -1
    }
    setSkinByName(t) {
        const e = this.data.findSkin(t);
        if (null == e)
            throw new Error(`Skin not found: ${t}`);
        this.setSkin(e)
    }
    setSkin(t) {
        if (null != t)
            if (null != this.skin)
                t.attachAll(this, this.skin);
            else {
                const e = this.slots;
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n]
                      , i = r.data.attachmentName;
                    if (null != i) {
                        const e = t.getAttachment(n, i);
                        null != e && r.setAttachment(e)
                    }
                }
            }
        this.skin = t
    }
    getAttachmentByName(t, e) {
        return this.getAttachment(this.data.findSlotIndex(t), e)
    }
    getAttachment(t, e) {
        if (null == e)
            throw new Error("attachmentName cannot be null.");
        if (null != this.skin) {
            const n = this.skin.getAttachment(t, e);
            if (null != n)
                return n
        }
        return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
    }
    setAttachment(t, e) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let r = 0, i = n.length; r < i; r++) {
            const i = n[r];
            if (i.data.name == t) {
                let n = null;
                if (null != e && (n = this.getAttachment(r, e),
                null == n))
                    throw new Error(`Attachment not found: ${e}, for slot: ${t}`);
                return void i.setAttachment(n)
            }
        }
        throw new Error(`Slot not found: ${t}`)
    }
    findIkConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.ikConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findTransformConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.transformConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findPathConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    getBounds(t, e, n) {
        if (null == t)
            throw new Error("offset cannot be null.");
        if (null == e)
            throw new Error("size cannot be null.");
        const r = this.drawOrder;
        let i = Number.POSITIVE_INFINITY
          , s = Number.POSITIVE_INFINITY
          , o = Number.NEGATIVE_INFINITY
          , a = Number.NEGATIVE_INFINITY;
        for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t];
            let l = 0
              , c = null;
            const u = e.getAttachment();
            if (u instanceof tD)
                l = 8,
                c = nN.setArraySize(n, l, 0),
                u.computeWorldVertices(e.bone, c, 0, 2);
            else if (u instanceof qR) {
                const t = u;
                l = t.worldVerticesLength,
                c = nN.setArraySize(n, l, 0),
                t.computeWorldVertices(e, 0, l, c, 0, 2)
            }
            if (null != c)
                for (let t = 0, e = c.length; t < e; t += 2) {
                    const e = c[t]
                      , n = c[t + 1];
                    i = Math.min(i, e),
                    s = Math.min(s, n),
                    o = Math.max(o, e),
                    a = Math.max(a, n)
                }
        }
        t.set(i, s),
        e.set(o - i, a - s)
    }
    update(t) {
        this.time += t
    }
    get flipX() {
        return -1 == this.scaleX
    }
    set flipX(t) {
        tB.deprecatedWarning1 || (tB.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
        this.scaleX = t ? 1 : -1
    }
    get flipY() {
        return -1 == this.scaleY
    }
    set flipY(t) {
        tB.deprecatedWarning1 || (tB.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
        this.scaleY = t ? 1 : -1
    }
}
;
let eB = tB;
eB.deprecatedWarning1 = !1;
class nB extends sN {
}
class rB {
    constructor() {
        this.bones = new Array,
        this.slots = new Array,
        this.skins = new Array,
        this.events = new Array,
        this.animations = new Array,
        this.ikConstraints = new Array,
        this.transformConstraints = new Array,
        this.pathConstraints = new Array,
        this.fps = 0
    }
    findBone(t) {
        if (null == t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findBoneIndex(t) {
        if (null == t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].name == t)
                return n;
        return -1
    }
    findSlot(t) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findSlotIndex(t) {
        if (null == t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].name == t)
                return n;
        return -1
    }
    findSkin(t) {
        if (null == t)
            throw new Error("skinName cannot be null.");
        const e = this.skins;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findEvent(t) {
        if (null == t)
            throw new Error("eventDataName cannot be null.");
        const e = this.events;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findAnimation(t) {
        if (null == t)
            throw new Error("animationName cannot be null.");
        const e = this.animations;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findIkConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.ikConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findTransformConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.transformConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findPathConstraint(t) {
        if (null == t)
            throw new Error("constraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findPathConstraintIndex(t) {
        if (null == t)
            throw new Error("pathConstraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].name == t)
                return n;
        return -1
    }
}
class iB {
    constructor(t, e, n) {
        if (this.color = new qO(1,1,1,1),
        t < 0)
            throw new Error("index must be >= 0.");
        if (null == e)
            throw new Error("name cannot be null.");
        if (null == n)
            throw new Error("boneData cannot be null.");
        this.index = t,
        this.name = e,
        this.boneData = n
    }
}
class sB {
    constructor(t) {
        if (this.order = 0,
        this.bones = new Array,
        this.rotateMix = 0,
        this.translateMix = 0,
        this.scaleMix = 0,
        this.shearMix = 0,
        this.offsetRotation = 0,
        this.offsetX = 0,
        this.offsetY = 0,
        this.offsetScaleX = 0,
        this.offsetScaleY = 0,
        this.offsetShearY = 0,
        this.relative = !1,
        this.local = !1,
        null == t)
            throw new Error("name cannot be null.");
        this.name = t
    }
}
class oB {
    constructor(t) {
        if (this.attachments = new Array,
        null == t)
            throw new Error("name cannot be null.");
        this.name = t
    }
    addAttachment(t, e, n) {
        if (null == n)
            throw new Error("attachment cannot be null.");
        const r = this.attachments;
        t >= r.length && (r.length = t + 1),
        r[t] || (r[t] = {}),
        r[t][e] = n
    }
    getAttachment(t, e) {
        const n = this.attachments[t];
        return n ? n[e] : null
    }
    attachAll(t, e) {
        let n = 0;
        for (let r = 0; r < t.slots.length; r++) {
            const i = t.slots[r]
              , s = i.getAttachment();
            if (s && n < e.attachments.length) {
                const t = e.attachments[n];
                for (const e in t) {
                    if (s == t[e]) {
                        const t = this.getAttachment(n, e);
                        null != t && i.setAttachment(t);
                        break
                    }
                }
            }
            n++
        }
    }
}
class aB {
    constructor(t) {
        this.scale = 1,
        this.linkedMeshes = new Array,
        this.attachmentLoader = t
    }
    readSkeletonData(t) {
        const e = this.scale
          , n = new rB
          , r = "string" == typeof t ? JSON.parse(t) : t
          , i = r.skeleton;
        if (null != i && (n.hash = i.hash,
        n.version = i.spine,
        n.width = i.width,
        n.height = i.height,
        n.fps = i.fps,
        n.imagesPath = i.images),
        r.bones)
            for (let t = 0; t < r.bones.length; t++) {
                const i = r.bones[t];
                let s = null;
                const o = this.getValue(i, "parent", null);
                if (null != o && (s = n.findBone(o),
                null == s))
                    throw new Error(`Parent bone not found: ${o}`);
                const a = new YD(n.bones.length,i.name,s);
                a.length = this.getValue(i, "length", 0) * e,
                a.x = this.getValue(i, "x", 0) * e,
                a.y = this.getValue(i, "y", 0) * e,
                a.rotation = this.getValue(i, "rotation", 0),
                a.scaleX = this.getValue(i, "scaleX", 1),
                a.scaleY = this.getValue(i, "scaleY", 1),
                a.shearX = this.getValue(i, "shearX", 0),
                a.shearY = this.getValue(i, "shearY", 0),
                a.transformMode = aB.transformModeFromString(this.getValue(i, "transform", "normal")),
                n.bones.push(a)
            }
        if (r.slots)
            for (let t = 0; t < r.slots.length; t++) {
                const e = r.slots[t]
                  , i = e.name
                  , s = e.bone
                  , o = n.findBone(s);
                if (null == o)
                    throw new Error(`Slot bone not found: ${s}`);
                const a = new iB(n.slots.length,i,o)
                  , l = this.getValue(e, "color", null);
                null != l && a.color.setFromString(l);
                const c = this.getValue(e, "dark", null);
                null != c && (a.darkColor = new qO(1,1,1,1),
                a.darkColor.setFromString(c)),
                a.attachmentName = this.getValue(e, "attachment", null),
                a.blendMode = aB.blendModeFromString(this.getValue(e, "blend", "normal")),
                n.slots.push(a)
            }
        if (r.ik)
            for (let t = 0; t < r.ik.length; t++) {
                const e = r.ik[t]
                  , i = new XD(e.name);
                i.order = this.getValue(e, "order", 0);
                for (let t = 0; t < e.bones.length; t++) {
                    const r = e.bones[t]
                      , s = n.findBone(r);
                    if (null == s)
                        throw new Error(`IK bone not found: ${r}`);
                    i.bones.push(s)
                }
                const s = e.target;
                if (i.target = n.findBone(s),
                null == i.target)
                    throw new Error(`IK target bone not found: ${s}`);
                i.bendDirection = this.getValue(e, "bendPositive", !0) ? 1 : -1,
                i.mix = this.getValue(e, "mix", 1),
                n.ikConstraints.push(i)
            }
        if (r.transform)
            for (let t = 0; t < r.transform.length; t++) {
                const i = r.transform[t]
                  , s = new sB(i.name);
                s.order = this.getValue(i, "order", 0);
                for (let t = 0; t < i.bones.length; t++) {
                    const e = i.bones[t]
                      , r = n.findBone(e);
                    if (null == r)
                        throw new Error(`Transform constraint bone not found: ${e}`);
                    s.bones.push(r)
                }
                const o = i.target;
                if (s.target = n.findBone(o),
                null == s.target)
                    throw new Error(`Transform constraint target bone not found: ${o}`);
                s.local = this.getValue(i, "local", !1),
                s.relative = this.getValue(i, "relative", !1),
                s.offsetRotation = this.getValue(i, "rotation", 0),
                s.offsetX = this.getValue(i, "x", 0) * e,
                s.offsetY = this.getValue(i, "y", 0) * e,
                s.offsetScaleX = this.getValue(i, "scaleX", 0),
                s.offsetScaleY = this.getValue(i, "scaleY", 0),
                s.offsetShearY = this.getValue(i, "shearY", 0),
                s.rotateMix = this.getValue(i, "rotateMix", 1),
                s.translateMix = this.getValue(i, "translateMix", 1),
                s.scaleMix = this.getValue(i, "scaleMix", 1),
                s.shearMix = this.getValue(i, "shearMix", 1),
                n.transformConstraints.push(s)
            }
        if (r.path)
            for (let t = 0; t < r.path.length; t++) {
                const i = r.path[t]
                  , s = new qD(i.name);
                s.order = this.getValue(i, "order", 0);
                for (let t = 0; t < i.bones.length; t++) {
                    const e = i.bones[t]
                      , r = n.findBone(e);
                    if (null == r)
                        throw new Error(`Transform constraint bone not found: ${e}`);
                    s.bones.push(r)
                }
                const o = i.target;
                if (s.target = n.findSlot(o),
                null == s.target)
                    throw new Error(`Path target slot not found: ${o}`);
                s.positionMode = aB.positionModeFromString(this.getValue(i, "positionMode", "percent")),
                s.spacingMode = aB.spacingModeFromString(this.getValue(i, "spacingMode", "length")),
                s.rotateMode = aB.rotateModeFromString(this.getValue(i, "rotateMode", "tangent")),
                s.offsetRotation = this.getValue(i, "rotation", 0),
                s.position = this.getValue(i, "position", 0),
                s.positionMode == RO.Fixed && (s.position *= e),
                s.spacing = this.getValue(i, "spacing", 0),
                s.spacingMode != KD.Length && s.spacingMode != KD.Fixed || (s.spacing *= e),
                s.rotateMix = this.getValue(i, "rotateMix", 1),
                s.translateMix = this.getValue(i, "translateMix", 1),
                n.pathConstraints.push(s)
            }
        if (r.skins)
            for (const t in r.skins) {
                const e = r.skins[t]
                  , i = new oB(t);
                for (const t in e) {
                    const r = n.findSlotIndex(t);
                    if (-1 == r)
                        throw new Error(`Slot not found: ${t}`);
                    const s = e[t];
                    for (const t in s) {
                        const e = this.readAttachment(s[t], i, r, t, n);
                        null != e && i.addAttachment(r, t, e)
                    }
                }
                n.skins.push(i),
                "default" == i.name && (n.defaultSkin = i)
            }
        for (let t = 0, e = this.linkedMeshes.length; t < e; t++) {
            const e = this.linkedMeshes[t]
              , r = null == e.skin ? n.defaultSkin : n.findSkin(e.skin);
            if (null == r)
                throw new Error(`Skin not found: ${e.skin}`);
            const i = r.getAttachment(e.slotIndex, e.parent);
            if (null == i)
                throw new Error(`Parent mesh not found: ${e.parent}`);
            e.mesh.setParentMesh(i)
        }
        if (this.linkedMeshes.length = 0,
        r.events)
            for (const t in r.events) {
                const e = r.events[t]
                  , i = new $D(t);
                i.intValue = this.getValue(e, "int", 0),
                i.floatValue = this.getValue(e, "float", 0),
                i.stringValue = this.getValue(e, "string", ""),
                i.audioPath = this.getValue(e, "audio", null),
                null != i.audioPath && (i.volume = this.getValue(e, "volume", 1),
                i.balance = this.getValue(e, "balance", 0)),
                n.events.push(i)
            }
        if (r.animations)
            for (const t in r.animations) {
                const e = r.animations[t];
                this.readAnimation(e, t, n)
            }
        return n
    }
    readAttachment(t, e, n, r, i) {
        const s = this.scale;
        r = this.getValue(t, "name", r);
        switch (this.getValue(t, "type", "region")) {
        case "region":
            {
                const n = this.getValue(t, "path", r)
                  , i = this.attachmentLoader.newRegionAttachment(e, r, n);
                if (null == i)
                    return null;
                i.path = n,
                i.x = this.getValue(t, "x", 0) * s,
                i.y = this.getValue(t, "y", 0) * s,
                i.scaleX = this.getValue(t, "scaleX", 1),
                i.scaleY = this.getValue(t, "scaleY", 1),
                i.rotation = this.getValue(t, "rotation", 0),
                i.width = t.width * s,
                i.height = t.height * s;
                const o = this.getValue(t, "color", null);
                return null != o && i.color.setFromString(o),
                i
            }
        case "boundingbox":
            {
                const n = this.attachmentLoader.newBoundingBoxAttachment(e, r);
                if (null == n)
                    return null;
                this.readVertices(t, n, t.vertexCount << 1);
                const i = this.getValue(t, "color", null);
                return null != i && n.color.setFromString(i),
                n
            }
        case "mesh":
        case "linkedmesh":
            {
                const i = this.getValue(t, "path", r)
                  , s = this.attachmentLoader.newMeshAttachment(e, r, i);
                if (null == s)
                    return null;
                s.path = i;
                const o = this.getValue(t, "color", null);
                null != o && s.color.setFromString(o);
                const a = this.getValue(t, "parent", null);
                if (null != a)
                    return s.inheritDeform = this.getValue(t, "deform", !0),
                    this.linkedMeshes.push(new lB(s,this.getValue(t, "skin", null),n,a)),
                    s;
                const l = t.uvs;
                return this.readVertices(t, s, l.length),
                s.triangles = t.triangles,
                s.regionUVs = new Float32Array(l),
                s.hullLength = 2 * this.getValue(t, "hull", 0),
                s
            }
        case "path":
            {
                const n = this.attachmentLoader.newPathAttachment(e, r);
                if (null == n)
                    return null;
                n.closed = this.getValue(t, "closed", !1),
                n.constantSpeed = this.getValue(t, "constantSpeed", !0);
                const i = t.vertexCount;
                this.readVertices(t, n, i << 1);
                const o = nN.newArray(i / 3, 0);
                for (let e = 0; e < t.lengths.length; e++)
                    o[e] = t.lengths[e] * s;
                n.lengths = o;
                const a = this.getValue(t, "color", null);
                return null != a && n.color.setFromString(a),
                n
            }
        case "point":
            {
                const n = this.attachmentLoader.newPointAttachment(e, r);
                if (null == n)
                    return null;
                n.x = this.getValue(t, "x", 0) * s,
                n.y = this.getValue(t, "y", 0) * s,
                n.rotation = this.getValue(t, "rotation", 0);
                const i = this.getValue(t, "color", null);
                return null != i && n.color.setFromString(i),
                n
            }
        case "clipping":
            {
                const n = this.attachmentLoader.newClippingAttachment(e, r);
                if (null == n)
                    return null;
                const s = this.getValue(t, "end", null);
                if (null != s) {
                    const t = i.findSlot(s);
                    if (null == t)
                        throw new Error(`Clipping end slot not found: ${s}`);
                    n.endSlot = t
                }
                const o = t.vertexCount;
                this.readVertices(t, n, o << 1);
                const a = this.getValue(t, "color", null);
                return null != a && n.color.setFromString(a),
                n
            }
        }
        return null
    }
    readVertices(t, e, n) {
        const r = this.scale;
        e.worldVerticesLength = n;
        const i = t.vertices;
        if (n == i.length) {
            const t = nN.toFloatArray(i);
            if (1 != r)
                for (let e = 0, n = i.length; e < n; e++)
                    t[e] *= r;
            return void (e.vertices = t)
        }
        const s = new Array
          , o = new Array;
        for (let t = 0, e = i.length; t < e; ) {
            const e = i[t++];
            o.push(e);
            for (let n = t + 4 * e; t < n; t += 4)
                o.push(i[t]),
                s.push(i[t + 1] * r),
                s.push(i[t + 2] * r),
                s.push(i[t + 3])
        }
        e.bones = o,
        e.vertices = nN.toFloatArray(s)
    }
    readAnimation(t, e, n) {
        const r = this.scale
          , i = new Array;
        let s = 0;
        if (t.slots)
            for (const e in t.slots) {
                const r = t.slots[e]
                  , o = n.findSlotIndex(e);
                if (-1 == o)
                    throw new Error(`Slot not found: ${e}`);
                for (const t in r) {
                    const n = r[t];
                    if ("attachment" == t) {
                        const t = new bD(n.length);
                        t.slotIndex = o;
                        let e = 0;
                        for (let r = 0; r < n.length; r++) {
                            const i = n[r];
                            t.setFrame(e++, i.time, i.name)
                        }
                        i.push(t),
                        s = Math.max(s, t.frames[t.getFrameCount() - 1])
                    } else if ("color" == t) {
                        const t = new mD(n.length);
                        t.slotIndex = o;
                        let e = 0;
                        for (let r = 0; r < n.length; r++) {
                            const i = n[r]
                              , s = new qO;
                            s.setFromString(i.color || "ffffffff"),
                            t.setFrame(e, i.time, s.r, s.g, s.b, s.a),
                            this.readCurve(i, t, e),
                            e++
                        }
                        i.push(t),
                        s = Math.max(s, t.frames[(t.getFrameCount() - 1) * mD.ENTRIES])
                    } else {
                        if ("twoColor" != t)
                            throw new Error(`Invalid timeline type for a slot: ${t} (${e})`);
                        {
                            const t = new yD(n.length);
                            t.slotIndex = o;
                            let e = 0;
                            for (let r = 0; r < n.length; r++) {
                                const i = n[r]
                                  , s = new qO
                                  , o = new qO;
                                s.setFromString(i.light),
                                o.setFromString(i.dark),
                                t.setFrame(e, i.time, s.r, s.g, s.b, s.a, o.r, o.g, o.b),
                                this.readCurve(i, t, e),
                                e++
                            }
                            i.push(t),
                            s = Math.max(s, t.frames[(t.getFrameCount() - 1) * yD.ENTRIES])
                        }
                    }
                }
            }
        if (t.bones)
            for (const e in t.bones) {
                const o = t.bones[e]
                  , a = n.findBoneIndex(e);
                if (-1 == a)
                    throw new Error(`Bone not found: ${e}`);
                for (const t in o) {
                    const n = o[t];
                    if ("rotate" === t) {
                        const t = new cD(n.length);
                        t.boneIndex = a;
                        let e = 0;
                        for (let r = 0; r < n.length; r++) {
                            const i = n[r];
                            t.setFrame(e, i.time, i.angle),
                            this.readCurve(i, t, e),
                            e++
                        }
                        i.push(t),
                        s = Math.max(s, t.frames[(t.getFrameCount() - 1) * cD.ENTRIES])
                    } else {
                        if ("translate" !== t && "scale" !== t && "shear" !== t)
                            throw new Error(`Invalid timeline type for a bone: ${t} (${e})`);
                        {
                            let e = null
                              , o = 1;
                            "scale" === t ? e = new dD(n.length) : "shear" === t ? e = new fD(n.length) : (e = new hD(n.length),
                            o = r),
                            e.boneIndex = a;
                            let l = 0;
                            for (let t = 0; t < n.length; t++) {
                                const r = n[t]
                                  , i = this.getValue(r, "x", 0)
                                  , s = this.getValue(r, "y", 0);
                                e.setFrame(l, r.time, i * o, s * o),
                                this.readCurve(r, e, l),
                                l++
                            }
                            i.push(e),
                            s = Math.max(s, e.frames[(e.getFrameCount() - 1) * hD.ENTRIES])
                        }
                    }
                }
            }
        if (t.ik)
            for (const e in t.ik) {
                const r = t.ik[e]
                  , o = n.findIkConstraint(e)
                  , a = new AD(r.length);
                a.ikConstraintIndex = n.ikConstraints.indexOf(o);
                let l = 0;
                for (let t = 0; t < r.length; t++) {
                    const e = r[t];
                    a.setFrame(l, e.time, this.getValue(e, "mix", 1), this.getValue(e, "bendPositive", !0) ? 1 : -1, this.getValue(e, "compress", !1), this.getValue(e, "stretch", !1)),
                    this.readCurve(e, a, l),
                    l++
                }
                i.push(a),
                s = Math.max(s, a.frames[(a.getFrameCount() - 1) * AD.ENTRIES])
            }
        if (t.transform)
            for (const e in t.transform) {
                const r = t.transform[e]
                  , o = n.findTransformConstraint(e)
                  , a = new TD(r.length);
                a.transformConstraintIndex = n.transformConstraints.indexOf(o);
                let l = 0;
                for (let t = 0; t < r.length; t++) {
                    const e = r[t];
                    a.setFrame(l, e.time, this.getValue(e, "rotateMix", 1), this.getValue(e, "translateMix", 1), this.getValue(e, "scaleMix", 1), this.getValue(e, "shearMix", 1)),
                    this.readCurve(e, a, l),
                    l++
                }
                i.push(a),
                s = Math.max(s, a.frames[(a.getFrameCount() - 1) * TD.ENTRIES])
            }
        if (t.paths)
            for (const e in t.paths) {
                const o = t.paths[e]
                  , a = n.findPathConstraintIndex(e);
                if (-1 == a)
                    throw new Error(`Path constraint not found: ${e}`);
                const l = n.pathConstraints[a];
                for (const t in o) {
                    const e = o[t];
                    if ("position" === t || "spacing" === t) {
                        let n = null
                          , o = 1;
                        "spacing" === t ? (n = new MD(e.length),
                        l.spacingMode != KD.Length && l.spacingMode != KD.Fixed || (o = r)) : (n = new ID(e.length),
                        l.positionMode == RO.Fixed && (o = r)),
                        n.pathConstraintIndex = a;
                        let c = 0;
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r];
                            n.setFrame(c, i.time, this.getValue(i, t, 0) * o),
                            this.readCurve(i, n, c),
                            c++
                        }
                        i.push(n),
                        s = Math.max(s, n.frames[(n.getFrameCount() - 1) * ID.ENTRIES])
                    } else if ("mix" === t) {
                        const t = new PD(e.length);
                        t.pathConstraintIndex = a;
                        let n = 0;
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r];
                            t.setFrame(n, i.time, this.getValue(i, "rotateMix", 1), this.getValue(i, "translateMix", 1)),
                            this.readCurve(i, t, n),
                            n++
                        }
                        i.push(t),
                        s = Math.max(s, t.frames[(t.getFrameCount() - 1) * PD.ENTRIES])
                    }
                }
            }
        if (t.deform)
            for (const e in t.deform) {
                const o = t.deform[e]
                  , a = n.findSkin(e);
                if (null != a)
                    for (const t in o) {
                        const e = o[t]
                          , l = n.findSlotIndex(t);
                        if (-1 == l)
                            throw new Error(`Slot not found: ${e.name}`);
                        for (const t in e) {
                            const n = e[t]
                              , o = a.getAttachment(l, t);
                            if (null == o)
                                throw new Error(`Deform attachment not found: ${n.name}`);
                            const c = null != o.bones
                              , u = o.vertices
                              , h = c ? u.length / 3 * 2 : u.length
                              , d = new wD(n.length);
                            d.slotIndex = l,
                            d.attachment = o;
                            let f = 0;
                            for (let t = 0; t < n.length; t++) {
                                const e = n[t];
                                let i;
                                const s = this.getValue(e, "vertices", null);
                                if (null == s)
                                    i = c ? nN.newFloatArray(h) : u;
                                else {
                                    i = nN.newFloatArray(h);
                                    const t = this.getValue(e, "offset", 0);
                                    if (nN.arrayCopy(s, 0, i, t, s.length),
                                    1 != r)
                                        for (let e = t, n = e + s.length; e < n; e++)
                                            i[e] *= r;
                                    if (!c)
                                        for (let t = 0; t < h; t++)
                                            i[t] += u[t]
                                }
                                d.setFrame(f, e.time, i),
                                this.readCurve(e, d, f),
                                f++
                            }
                            i.push(d),
                            s = Math.max(s, d.frames[d.getFrameCount() - 1])
                        }
                    }
                else if (oN.FAIL_ON_NON_EXISTING_SKIN)
                    throw new Error(`Skin not found: ${e}`)
            }
        let o = t.drawOrder;
        if (null == o && (o = t.draworder),
        null != o) {
            const t = new ED(o.length)
              , e = n.slots.length;
            let r = 0;
            for (let i = 0; i < o.length; i++) {
                const s = o[i];
                let a = null;
                const l = this.getValue(s, "offsets", null);
                if (null != l) {
                    a = nN.newArray(e, -1);
                    const t = nN.newArray(e - l.length, 0);
                    let r = 0
                      , i = 0;
                    for (let e = 0; e < l.length; e++) {
                        const s = l[e]
                          , o = n.findSlotIndex(s.slot);
                        if (-1 == o)
                            throw new Error(`Slot not found: ${s.slot}`);
                        for (; r != o; )
                            t[i++] = r++;
                        a[r + s.offset] = r++
                    }
                    for (; r < e; )
                        t[i++] = r++;
                    for (let n = e - 1; n >= 0; n--)
                        -1 == a[n] && (a[n] = t[--i])
                }
                t.setFrame(r++, s.time, a)
            }
            i.push(t),
            s = Math.max(s, t.frames[t.getFrameCount() - 1])
        }
        if (t.events) {
            const e = new xD(t.events.length);
            let r = 0;
            for (let i = 0; i < t.events.length; i++) {
                const s = t.events[i]
                  , o = n.findEvent(s.name);
                if (null == o)
                    throw new Error(`Event not found: ${s.name}`);
                const a = new HD(nN.toSinglePrecision(s.time),o);
                a.intValue = this.getValue(s, "int", o.intValue),
                a.floatValue = this.getValue(s, "float", o.floatValue),
                a.stringValue = this.getValue(s, "string", o.stringValue),
                null != a.data.audioPath && (a.volume = this.getValue(s, "volume", 1),
                a.balance = this.getValue(s, "balance", 0)),
                e.setFrame(r++, a)
            }
            i.push(e),
            s = Math.max(s, e.frames[e.getFrameCount() - 1])
        }
        if (isNaN(s))
            throw new Error("Error while parsing animation, duration is NaN");
        n.animations.push(new iD(e,i,s))
    }
    readCurve(t, e, n) {
        if (t.curve)
            if ("stepped" === t.curve)
                e.setStepped(n);
            else if ("[object Array]" === Object.prototype.toString.call(t.curve)) {
                const r = t.curve;
                e.setCurve(n, r[0], r[1], r[2], r[3])
            }
    }
    getValue(t, e, n) {
        return void 0 !== t[e] ? t[e] : n
    }
    static blendModeFromString(t) {
        if ("normal" == (t = t.toLowerCase()))
            return Om.NORMAL;
        if ("additive" == t)
            return Om.ADD;
        if ("multiply" == t)
            return Om.MULTIPLY;
        if ("screen" == t)
            return Om.SCREEN;
        throw new Error(`Unknown blend mode: ${t}`)
    }
    static positionModeFromString(t) {
        if ("fixed" == (t = t.toLowerCase()))
            return RO.Fixed;
        if ("percent" == t)
            return RO.Percent;
        throw new Error(`Unknown position mode: ${t}`)
    }
    static spacingModeFromString(t) {
        if ("length" == (t = t.toLowerCase()))
            return KD.Length;
        if ("fixed" == t)
            return KD.Fixed;
        if ("percent" == t)
            return KD.Percent;
        throw new Error(`Unknown position mode: ${t}`)
    }
    static rotateModeFromString(t) {
        if ("tangent" == (t = t.toLowerCase()))
            return DO.Tangent;
        if ("chain" == t)
            return DO.Chain;
        if ("chainscale" == t)
            return DO.ChainScale;
        throw new Error(`Unknown rotate mode: ${t}`)
    }
    static transformModeFromString(t) {
        if ("normal" == (t = t.toLowerCase()))
            return BO.Normal;
        if ("onlytranslation" == t)
            return BO.OnlyTranslation;
        if ("norotationorreflection" == t)
            return BO.NoRotationOrReflection;
        if ("noscale" == t)
            return BO.NoScale;
        if ("noscaleorreflection" == t)
            return BO.NoScaleOrReflection;
        throw new Error(`Unknown transform mode: ${t}`)
    }
}
class lB {
    constructor(t, e, n, r) {
        this.mesh = t,
        this.skin = e,
        this.slotIndex = n,
        this.parent = r
    }
}
class cB extends hN {
    createSkeleton(t) {
        this.skeleton = new eB(t),
        this.skeleton.updateWorldTransform(),
        this.stateData = new zD(t),
        this.state = new ND(this.stateData)
    }
}
var uB = {};
t(uB, "Attachment", (()=>hB)),
t(uB, "VertexAttachment", (()=>fB)),
t(uB, "BoundingBoxAttachment", (()=>pB)),
t(uB, "ClippingAttachment", (()=>mB)),
t(uB, "MeshAttachment", (()=>gB)),
t(uB, "PathAttachment", (()=>yB)),
t(uB, "PointAttachment", (()=>bB)),
t(uB, "RegionAttachment", (()=>wB)),
t(uB, "Sequence", (()=>EB)),
t(uB, "SequenceMode", (()=>_B)),
t(uB, "SequenceModeValues", (()=>AB)),
t(uB, "AlphaTimeline", (()=>lL)),
t(uB, "Animation", (()=>SB)),
t(uB, "AttachmentTimeline", (()=>hL)),
t(uB, "CurveTimeline", (()=>GB)),
t(uB, "CurveTimeline1", (()=>XB)),
t(uB, "CurveTimeline2", (()=>qB)),
t(uB, "DeformTimeline", (()=>dL)),
t(uB, "DrawOrderTimeline", (()=>gL)),
t(uB, "EventTimeline", (()=>pL)),
t(uB, "IkConstraintTimeline", (()=>yL)),
t(uB, "PathConstraintMixTimeline", (()=>xL)),
t(uB, "PathConstraintPositionTimeline", (()=>vL)),
t(uB, "PathConstraintSpacingTimeline", (()=>wL)),
t(uB, "RGB2Timeline", (()=>uL)),
t(uB, "RGBA2Timeline", (()=>cL)),
t(uB, "RGBATimeline", (()=>oL)),
t(uB, "RGBTimeline", (()=>aL)),
t(uB, "RotateTimeline", (()=>KB)),
t(uB, "ScaleTimeline", (()=>tL)),
t(uB, "ScaleXTimeline", (()=>eL)),
t(uB, "ScaleYTimeline", (()=>nL)),
t(uB, "SequenceTimeline", (()=>_L)),
t(uB, "ShearTimeline", (()=>rL)),
t(uB, "ShearXTimeline", (()=>iL)),
t(uB, "ShearYTimeline", (()=>sL)),
t(uB, "Timeline", (()=>$B)),
t(uB, "TransformConstraintTimeline", (()=>bL)),
t(uB, "TranslateTimeline", (()=>QB)),
t(uB, "TranslateXTimeline", (()=>ZB)),
t(uB, "TranslateYTimeline", (()=>JB)),
t(uB, "AnimationState", (()=>SL)),
t(uB, "AnimationStateAdapter", (()=>CL)),
t(uB, "EventQueue", (()=>IL)),
t(uB, "EventType", (()=>ML)),
t(uB, "TrackEntry", (()=>kL)),
t(uB, "AnimationStateData", (()=>FL)),
t(uB, "AtlasAttachmentLoader", (()=>jL)),
t(uB, "Bone", (()=>UL)),
t(uB, "BoneData", (()=>zL)),
t(uB, "ConstraintData", (()=>VL)),
t(uB, "Event", (()=>WL)),
t(uB, "EventData", (()=>YL)),
t(uB, "IkConstraint", (()=>HL)),
t(uB, "IkConstraintData", (()=>$L)),
t(uB, "PathConstraint", (()=>KL)),
t(uB, "PathConstraintData", (()=>GL)),
t(uB, "SpacingMode", (()=>XL)),
t(uB, "Skeleton", (()=>tF)),
t(uB, "SkeletonBinary", (()=>oF)),
t(uB, "SkeletonBounds", (()=>DF)),
t(uB, "SkeletonData", (()=>eF)),
t(uB, "SkeletonJson", (()=>BF)),
t(uB, "Skin", (()=>sF)),
t(uB, "SkinEntry", (()=>iF)),
t(uB, "Slot", (()=>QL)),
t(uB, "SlotData", (()=>nF)),
t(uB, "TransformConstraint", (()=>ZL)),
t(uB, "TransformConstraintData", (()=>rF)),
t(uB, "Spine", (()=>VF));
class hB {
    constructor(t) {
        if (!t)
            throw new Error("name cannot be null.");
        this.name = t
    }
}
const dB = class extends hB {
    constructor(t) {
        super(t),
        this.id = dB.nextID++,
        this.bones = null,
        this.vertices = [],
        this.worldVerticesLength = 0,
        this.timelineAttachment = this
    }
    computeWorldVerticesOld(t, e) {
        this.computeWorldVertices(t, 0, this.worldVerticesLength, e, 0, 2)
    }
    computeWorldVertices(t, e, n, r, i, s) {
        n = i + (n >> 1) * s;
        const o = t.bone.skeleton
          , a = t.deform;
        let l = this.vertices;
        const c = this.bones;
        if (!c) {
            a.length > 0 && (l = a);
            const o = t.bone.matrix
              , c = o.tx
              , u = o.ty
              , h = o.a
              , d = o.c
              , f = o.b
              , p = o.d;
            for (let t = e, o = i; o < n; t += 2,
            o += s) {
                const e = l[t]
                  , n = l[t + 1];
                r[o] = e * h + n * d + c,
                r[o + 1] = e * f + n * p + u
            }
            return
        }
        let u = 0
          , h = 0;
        for (let t = 0; t < e; t += 2) {
            const t = c[u];
            u += t + 1,
            h += t
        }
        const d = o.bones;
        if (0 == a.length)
            for (let t = i, e = 3 * h; t < n; t += s) {
                let n = 0
                  , i = 0
                  , s = c[u++];
                for (s += u; u < s; u++,
                e += 3) {
                    const t = d[c[u]].matrix
                      , r = l[e]
                      , s = l[e + 1]
                      , o = l[e + 2];
                    n += (r * t.a + s * t.c + t.tx) * o,
                    i += (r * t.b + s * t.d + t.ty) * o
                }
                r[t] = n,
                r[t + 1] = i
            }
        else {
            const t = a;
            for (let e = i, o = 3 * h, a = h << 1; e < n; e += s) {
                let n = 0
                  , i = 0
                  , s = c[u++];
                for (s += u; u < s; u++,
                o += 3,
                a += 2) {
                    const e = d[c[u]].matrix
                      , r = l[o] + t[a]
                      , s = l[o + 1] + t[a + 1]
                      , h = l[o + 2];
                    n += (r * e.a + s * e.c + e.tx) * h,
                    i += (r * e.b + s * e.d + e.ty) * h
                }
                r[e] = n,
                r[e + 1] = i
            }
        }
    }
    copyTo(t) {
        this.bones ? (t.bones = new Array(this.bones.length),
        nN.arrayCopy(this.bones, 0, t.bones, 0, this.bones.length)) : t.bones = null,
        this.vertices && (t.vertices = nN.newFloatArray(this.vertices.length),
        nN.arrayCopy(this.vertices, 0, t.vertices, 0, this.vertices.length)),
        t.worldVerticesLength = this.worldVerticesLength,
        t.timelineAttachment = this.timelineAttachment
    }
}
;
let fB = dB;
fB.nextID = 0;
class pB extends fB {
    constructor(t) {
        super(t),
        this.type = CO.BoundingBox,
        this.color = new qO(1,1,1,1)
    }
    copy() {
        const t = new pB(this.name);
        return this.copyTo(t),
        t.color.setFromColor(this.color),
        t
    }
}
class mB extends fB {
    constructor(t) {
        super(t),
        this.type = CO.Clipping,
        this.endSlot = null,
        this.color = new qO(.2275,.2275,.8078,1)
    }
    copy() {
        const t = new mB(this.name);
        return this.copyTo(t),
        t.endSlot = this.endSlot,
        t.color.setFromColor(this.color),
        t
    }
}
class gB extends fB {
    constructor(t, e) {
        super(t),
        this.type = CO.Mesh,
        this.region = null,
        this.triangles = [],
        this.color = new qO(1,1,1,1),
        this.width = 0,
        this.height = 0,
        this.hullLength = 0,
        this.edges = [],
        this.parentMesh = null,
        this.sequence = null,
        this.tempColor = new qO(0,0,0,0),
        this.path = e
    }
    getParentMesh() {
        return this.parentMesh
    }
    setParentMesh(t) {
        this.parentMesh = t,
        t && (this.bones = t.bones,
        this.vertices = t.vertices,
        this.worldVerticesLength = t.worldVerticesLength,
        this.regionUVs = t.regionUVs,
        this.triangles = t.triangles,
        this.hullLength = t.hullLength,
        this.worldVerticesLength = t.worldVerticesLength)
    }
    copy() {
        if (this.parentMesh)
            return this.newLinkedMesh();
        const t = new gB(this.name,this.path);
        return t.region = this.region,
        t.color.setFromColor(this.color),
        this.copyTo(t),
        t.regionUVs = new Float32Array(this.regionUVs.length),
        nN.arrayCopy(this.regionUVs, 0, t.regionUVs, 0, this.regionUVs.length),
        t.triangles = new Array(this.triangles.length),
        nN.arrayCopy(this.triangles, 0, t.triangles, 0, this.triangles.length),
        t.hullLength = this.hullLength,
        t.sequence = null != this.sequence ? this.sequence.copy() : null,
        this.edges && (t.edges = new Array(this.edges.length),
        nN.arrayCopy(this.edges, 0, t.edges, 0, this.edges.length)),
        t.width = this.width,
        t.height = this.height,
        t
    }
    computeWorldVertices(t, e, n, r, i, s) {
        null != this.sequence && this.sequence.apply(t, this),
        super.computeWorldVertices(t, e, n, r, i, s)
    }
    newLinkedMesh() {
        const t = new gB(this.name,this.path);
        return t.region = this.region,
        t.color.setFromColor(this.color),
        t.timelineAttachment = this.timelineAttachment,
        t.setParentMesh(this.parentMesh ? this.parentMesh : this),
        t
    }
}
class yB extends fB {
    constructor(t) {
        super(t),
        this.type = CO.Path,
        this.lengths = [],
        this.closed = !1,
        this.constantSpeed = !1,
        this.color = new qO(1,1,1,1)
    }
    copy() {
        const t = new yB(this.name);
        return this.copyTo(t),
        t.lengths = new Array(this.lengths.length),
        nN.arrayCopy(this.lengths, 0, t.lengths, 0, this.lengths.length),
        t.closed = closed,
        t.constantSpeed = this.constantSpeed,
        t.color.setFromColor(this.color),
        t
    }
}
class bB extends fB {
    constructor(t) {
        super(t),
        this.type = CO.Point,
        this.x = 0,
        this.y = 0,
        this.rotation = 0,
        this.color = new qO(.38,.94,0,1)
    }
    computeWorldPosition(t, e) {
        const n = t.matrix;
        return e.x = this.x * n.a + this.y * n.c + t.worldX,
        e.y = this.x * n.b + this.y * n.d + t.worldY,
        e
    }
    computeWorldRotation(t) {
        const e = t.matrix
          , n = QO.cosDeg(this.rotation)
          , r = QO.sinDeg(this.rotation)
          , i = n * e.a + r * e.c
          , s = n * e.b + r * e.d;
        return Math.atan2(s, i) * QO.radDeg
    }
    copy() {
        const t = new bB(this.name);
        return t.x = this.x,
        t.y = this.y,
        t.rotation = this.rotation,
        t.color.setFromColor(this.color),
        t
    }
}
const vB = class extends hB {
    constructor(t, e) {
        super(t),
        this.type = CO.Region,
        this.x = 0,
        this.y = 0,
        this.scaleX = 1,
        this.scaleY = 1,
        this.rotation = 0,
        this.width = 0,
        this.height = 0,
        this.color = new qO(1,1,1,1),
        this.rendererObject = null,
        this.region = null,
        this.sequence = null,
        this.offset = nN.newFloatArray(8),
        this.uvs = nN.newFloatArray(8),
        this.tempColor = new qO(1,1,1,1),
        this.path = e
    }
    updateRegion() {
        if (!this.region)
            throw new Error("Region not set.");
        const t = this.region
          , e = this.width / this.region.originalWidth * this.scaleX
          , n = this.height / this.region.originalHeight * this.scaleY
          , r = -this.width / 2 * this.scaleX + this.region.offsetX * e
          , i = -this.height / 2 * this.scaleY + this.region.offsetY * n
          , s = r + this.region.width * e
          , o = i + this.region.height * n
          , a = this.rotation * Math.PI / 180
          , l = Math.cos(a)
          , c = Math.sin(a)
          , u = this.x
          , h = this.y
          , d = r * l + u
          , f = r * c
          , p = i * l + h
          , m = i * c
          , g = s * l + u
          , y = s * c
          , b = o * l + h
          , v = o * c
          , w = this.offset;
        w[0] = d - m,
        w[1] = p + f,
        w[2] = d - v,
        w[3] = b + f,
        w[4] = g - v,
        w[5] = b + y,
        w[6] = g - m,
        w[7] = p + y;
        const x = this.uvs;
        90 == t.degrees ? (x[2] = t.u,
        x[3] = t.v2,
        x[4] = t.u,
        x[5] = t.v,
        x[6] = t.u2,
        x[7] = t.v,
        x[0] = t.u2,
        x[1] = t.v2) : (x[0] = t.u,
        x[1] = t.v2,
        x[2] = t.u,
        x[3] = t.v,
        x[4] = t.u2,
        x[5] = t.v,
        x[6] = t.u2,
        x[7] = t.v2)
    }
    computeWorldVertices(t, e, n, r) {
        null != this.sequence && this.sequence.apply(t, this);
        const i = t.bone
          , s = this.offset
          , o = i.matrix
          , a = o.tx
          , l = o.ty
          , c = o.a
          , u = o.c
          , h = o.b
          , d = o.d;
        let f = 0
          , p = 0;
        f = s[0],
        p = s[1],
        e[n] = f * c + p * u + a,
        e[n + 1] = f * h + p * d + l,
        n += r,
        f = s[2],
        p = s[3],
        e[n] = f * c + p * u + a,
        e[n + 1] = f * h + p * d + l,
        n += r,
        f = s[4],
        p = s[5],
        e[n] = f * c + p * u + a,
        e[n + 1] = f * h + p * d + l,
        n += r,
        f = s[6],
        p = s[7],
        e[n] = f * c + p * u + a,
        e[n + 1] = f * h + p * d + l
    }
    copy() {
        const t = new vB(this.name,this.path);
        return t.region = this.region,
        t.rendererObject = this.rendererObject,
        t.x = this.x,
        t.y = this.y,
        t.scaleX = this.scaleX,
        t.scaleY = this.scaleY,
        t.rotation = this.rotation,
        t.width = this.width,
        t.height = this.height,
        nN.arrayCopy(this.uvs, 0, t.uvs, 0, 8),
        nN.arrayCopy(this.offset, 0, t.offset, 0, 8),
        t.color.setFromColor(this.color),
        t.sequence = null != this.sequence ? this.sequence.copy() : null,
        t
    }
}
;
let wB = vB;
wB.X1 = 0,
wB.Y1 = 1,
wB.C1R = 2,
wB.C1G = 3,
wB.C1B = 4,
wB.C1A = 5,
wB.U1 = 6,
wB.V1 = 7,
wB.X2 = 8,
wB.Y2 = 9,
wB.C2R = 10,
wB.C2G = 11,
wB.C2B = 12,
wB.C2A = 13,
wB.U2 = 14,
wB.V2 = 15,
wB.X3 = 16,
wB.Y3 = 17,
wB.C3R = 18,
wB.C3G = 19,
wB.C3B = 20,
wB.C3A = 21,
wB.U3 = 22,
wB.V3 = 23,
wB.X4 = 24,
wB.Y4 = 25,
wB.C4R = 26,
wB.C4G = 27,
wB.C4B = 28,
wB.C4A = 29,
wB.U4 = 30,
wB.V4 = 31;
const xB = class {
    constructor(t) {
        this.id = xB.nextID(),
        this.start = 0,
        this.digits = 0,
        this.setupIndex = 0,
        this.regions = new Array(t)
    }
    copy() {
        const t = new xB(this.regions.length);
        return nN.arrayCopy(this.regions, 0, t.regions, 0, this.regions.length),
        t.start = this.start,
        t.digits = this.digits,
        t.setupIndex = this.setupIndex,
        t
    }
    apply(t, e) {
        let n = t.sequenceIndex;
        -1 == n && (n = this.setupIndex),
        n >= this.regions.length && (n = this.regions.length - 1);
        const r = this.regions[n];
        e.region != r && (e.region = r)
    }
    getPath(t, e) {
        let n = t;
        const r = (this.start + e).toString();
        for (let t = this.digits - r.length; t > 0; t--)
            n += "0";
        return n += r,
        n
    }
    static nextID() {
        return xB._nextID++
    }
}
;
let EB = xB;
EB._nextID = 0;
var _B = (t=>(t[t.hold = 0] = "hold",
t[t.once = 1] = "once",
t[t.loop = 2] = "loop",
t[t.pingpong = 3] = "pingpong",
t[t.onceReverse = 4] = "onceReverse",
t[t.loopReverse = 5] = "loopReverse",
t[t.pingpongReverse = 6] = "pingpongReverse",
t))(_B || {});
const AB = [0, 1, 2, 3, 4, 5, 6];
class SB {
    constructor(t, e, n) {
        if (this.timelines = [],
        this.timelineIds = new GO,
        !t)
            throw new Error("name cannot be null.");
        this.name = t,
        this.setTimelines(e),
        this.duration = n
    }
    setTimelines(t) {
        if (!t)
            throw new Error("timelines cannot be null.");
        this.timelines = t,
        this.timelineIds.clear();
        for (let e = 0; e < t.length; e++)
            this.timelineIds.addAll(t[e].getPropertyIds())
    }
    hasTimeline(t) {
        for (let e = 0; e < t.length; e++)
            if (this.timelineIds.contains(t[e]))
                return !0;
        return !1
    }
    apply(t, e, n, r, i, s, o, a) {
        if (!t)
            throw new Error("skeleton cannot be null.");
        r && 0 != this.duration && (n %= this.duration,
        e > 0 && (e %= this.duration));
        const l = this.timelines;
        for (let r = 0, c = l.length; r < c; r++)
            l[r].apply(t, e, n, i, s, o, a)
    }
}
const TB = 0
  , kB = 1
  , IB = 2
  , MB = 3
  , CB = 4
  , PB = 5
  , OB = 6
  , NB = 7
  , RB = 8
  , DB = 9
  , BB = 10
  , LB = 11
  , FB = 12
  , jB = 13
  , UB = 14
  , zB = 15
  , VB = 16
  , WB = 17
  , YB = 18
  , HB = 19;
class $B {
    constructor(t, e) {
        this.propertyIds = e,
        this.frames = nN.newFloatArray(t * this.getFrameEntries())
    }
    getPropertyIds() {
        return this.propertyIds
    }
    getFrameEntries() {
        return 1
    }
    getFrameCount() {
        return this.frames.length / this.getFrameEntries()
    }
    getDuration() {
        return this.frames[this.frames.length - this.getFrameEntries()]
    }
    static search1(t, e) {
        const n = t.length;
        for (let r = 1; r < n; r++)
            if (t[r] > e)
                return r - 1;
        return n - 1
    }
    static search(t, e, n) {
        const r = t.length;
        for (let i = n; i < r; i += n)
            if (t[i] > e)
                return i - n;
        return r - n
    }
}
class GB extends $B {
    constructor(t, e, n) {
        super(t, n),
        this.curves = nN.newFloatArray(t + 18 * e),
        this.curves[t - 1] = 1
    }
    setLinear(t) {
        this.curves[t] = 0
    }
    setStepped(t) {
        this.curves[t] = 1
    }
    shrink(t) {
        const e = this.getFrameCount() + 18 * t;
        if (this.curves.length > e) {
            const t = nN.newFloatArray(e);
            nN.arrayCopy(this.curves, 0, t, 0, e),
            this.curves = t
        }
    }
    setBezier(t, e, n, r, i, s, o, a, l, c, u) {
        const h = this.curves;
        let d = this.getFrameCount() + 18 * t;
        0 == n && (h[e] = 2 + d);
        const f = .03 * (r - 2 * s + a)
          , p = .03 * (i - 2 * o + l)
          , m = .006 * (3 * (s - a) - r + c)
          , g = .006 * (3 * (o - l) - i + u);
        let y = 2 * f + m
          , b = 2 * p + g
          , v = .3 * (s - r) + f + .16666667 * m
          , w = .3 * (o - i) + p + .16666667 * g
          , x = r + v
          , E = i + w;
        for (let t = d + 18; d < t; d += 2)
            h[d] = x,
            h[d + 1] = E,
            v += y,
            w += b,
            y += m,
            b += g,
            x += v,
            E += w
    }
    getBezierValue(t, e, n, r) {
        const i = this.curves;
        if (i[r] > t) {
            const s = this.frames[e]
              , o = this.frames[e + n];
            return o + (t - s) / (i[r] - s) * (i[r + 1] - o)
        }
        const s = r + 18;
        for (r += 2; r < s; r += 2)
            if (i[r] >= t) {
                const e = i[r - 2]
                  , n = i[r - 1];
                return n + (t - e) / (i[r] - e) * (i[r + 1] - n)
            }
        e += this.getFrameEntries();
        const o = i[s - 2]
          , a = i[s - 1];
        return a + (t - o) / (this.frames[e] - o) * (this.frames[e + n] - a)
    }
}
class XB extends GB {
    constructor(t, e, n) {
        super(t, e, [n])
    }
    getFrameEntries() {
        return 2
    }
    setFrame(t, e, n) {
        t <<= 1,
        this.frames[t] = e,
        this.frames[t + 1] = n
    }
    getCurveValue(t) {
        const e = this.frames;
        let n = e.length - 2;
        for (let r = 2; r <= n; r += 2)
            if (e[r] > t) {
                n = r - 2;
                break
            }
        const r = this.curves[n >> 1];
        switch (r) {
        case 0:
            const r = e[n]
              , i = e[n + 1];
            return i + (t - r) / (e[n + 2] - r) * (e[n + 2 + 1] - i);
        case 1:
            return e[n + 1]
        }
        return this.getBezierValue(t, n, 1, r - 2)
    }
}
class qB extends GB {
    constructor(t, e, n, r) {
        super(t, e, [n, r])
    }
    getFrameEntries() {
        return 3
    }
    setFrame(t, e, n, r) {
        t *= 3,
        this.frames[t] = e,
        this.frames[t + 1] = n,
        this.frames[t + 2] = r
    }
}
class KB extends XB {
    constructor(t, e, n) {
        super(t, e, `${TB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        if (n < this.frames[0]) {
            switch (s) {
            case OO.setup:
                return void (a.rotation = a.data.rotation);
            case OO.first:
                a.rotation += (a.data.rotation - a.rotation) * i
            }
            return
        }
        let l = this.getCurveValue(n);
        switch (s) {
        case OO.setup:
            a.rotation = a.data.rotation + l * i;
            break;
        case OO.first:
        case OO.replace:
            l += a.data.rotation - a.rotation;
        case OO.add:
            a.rotation += l * i
        }
    }
}
class QB extends qB {
    constructor(t, e, n) {
        super(t, e, `${kB}|${n}`, `${IB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        const l = this.frames;
        if (n < l[0]) {
            switch (s) {
            case OO.setup:
                return a.x = a.data.x,
                void (a.y = a.data.y);
            case OO.first:
                a.x += (a.data.x - a.x) * i,
                a.y += (a.data.y - a.y) * i
            }
            return
        }
        let c = 0
          , u = 0;
        const h = $B.search(l, n, 3)
          , d = this.curves[h / 3];
        switch (d) {
        case 0:
            const t = l[h];
            c = l[h + 1],
            u = l[h + 2];
            const e = (n - t) / (l[h + 3] - t);
            c += (l[h + 3 + 1] - c) * e,
            u += (l[h + 3 + 2] - u) * e;
            break;
        case 1:
            c = l[h + 1],
            u = l[h + 2];
            break;
        default:
            c = this.getBezierValue(n, h, 1, d - 2),
            u = this.getBezierValue(n, h, 2, d + 18 - 2)
        }
        switch (s) {
        case OO.setup:
            a.x = a.data.x + c * i,
            a.y = a.data.y + u * i;
            break;
        case OO.first:
        case OO.replace:
            a.x += (a.data.x + c - a.x) * i,
            a.y += (a.data.y + u - a.y) * i;
            break;
        case OO.add:
            a.x += c * i,
            a.y += u * i
        }
    }
}
class ZB extends XB {
    constructor(t, e, n) {
        super(t, e, `${kB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        if (n < this.frames[0]) {
            switch (s) {
            case OO.setup:
                return void (a.x = a.data.x);
            case OO.first:
                a.x += (a.data.x - a.x) * i
            }
            return
        }
        const l = this.getCurveValue(n);
        switch (s) {
        case OO.setup:
            a.x = a.data.x + l * i;
            break;
        case OO.first:
        case OO.replace:
            a.x += (a.data.x + l - a.x) * i;
            break;
        case OO.add:
            a.x += l * i
        }
    }
}
class JB extends XB {
    constructor(t, e, n) {
        super(t, e, `${IB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        if (n < this.frames[0]) {
            switch (s) {
            case OO.setup:
                return void (a.y = a.data.y);
            case OO.first:
                a.y += (a.data.y - a.y) * i
            }
            return
        }
        const l = this.getCurveValue(n);
        switch (s) {
        case OO.setup:
            a.y = a.data.y + l * i;
            break;
        case OO.first:
        case OO.replace:
            a.y += (a.data.y + l - a.y) * i;
            break;
        case OO.add:
            a.y += l * i
        }
    }
}
class tL extends qB {
    constructor(t, e, n) {
        super(t, e, `${MB}|${n}`, `${CB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        const l = this.frames;
        if (n < l[0]) {
            switch (s) {
            case OO.setup:
                return a.scaleX = a.data.scaleX,
                void (a.scaleY = a.data.scaleY);
            case OO.first:
                a.scaleX += (a.data.scaleX - a.scaleX) * i,
                a.scaleY += (a.data.scaleY - a.scaleY) * i
            }
            return
        }
        let c, u;
        const h = $B.search(l, n, 3)
          , d = this.curves[h / 3];
        switch (d) {
        case 0:
            const t = l[h];
            c = l[h + 1],
            u = l[h + 2];
            const e = (n - t) / (l[h + 3] - t);
            c += (l[h + 3 + 1] - c) * e,
            u += (l[h + 3 + 2] - u) * e;
            break;
        case 1:
            c = l[h + 1],
            u = l[h + 2];
            break;
        default:
            c = this.getBezierValue(n, h, 1, d - 2),
            u = this.getBezierValue(n, h, 2, d + 18 - 2)
        }
        if (c *= a.data.scaleX,
        u *= a.data.scaleY,
        1 == i)
            s == OO.add ? (a.scaleX += c - a.data.scaleX,
            a.scaleY += u - a.data.scaleY) : (a.scaleX = c,
            a.scaleY = u);
        else {
            let t = 0
              , e = 0;
            if (o == NO.mixOut)
                switch (s) {
                case OO.setup:
                    t = a.data.scaleX,
                    e = a.data.scaleY,
                    a.scaleX = t + (Math.abs(c) * QO.signum(t) - t) * i,
                    a.scaleY = e + (Math.abs(u) * QO.signum(e) - e) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = a.scaleX,
                    e = a.scaleY,
                    a.scaleX = t + (Math.abs(c) * QO.signum(t) - t) * i,
                    a.scaleY = e + (Math.abs(u) * QO.signum(e) - e) * i;
                    break;
                case OO.add:
                    a.scaleX += (c - a.data.scaleX) * i,
                    a.scaleY += (u - a.data.scaleY) * i
                }
            else
                switch (s) {
                case OO.setup:
                    t = Math.abs(a.data.scaleX) * QO.signum(c),
                    e = Math.abs(a.data.scaleY) * QO.signum(u),
                    a.scaleX = t + (c - t) * i,
                    a.scaleY = e + (u - e) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = Math.abs(a.scaleX) * QO.signum(c),
                    e = Math.abs(a.scaleY) * QO.signum(u),
                    a.scaleX = t + (c - t) * i,
                    a.scaleY = e + (u - e) * i;
                    break;
                case OO.add:
                    a.scaleX += (c - a.data.scaleX) * i,
                    a.scaleY += (u - a.data.scaleY) * i
                }
        }
    }
}
class eL extends XB {
    constructor(t, e, n) {
        super(t, e, `${MB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        if (n < this.frames[0]) {
            switch (s) {
            case OO.setup:
                return void (a.scaleX = a.data.scaleX);
            case OO.first:
                a.scaleX += (a.data.scaleX - a.scaleX) * i
            }
            return
        }
        const l = this.getCurveValue(n) * a.data.scaleX;
        if (1 == i)
            s == OO.add ? a.scaleX += l - a.data.scaleX : a.scaleX = l;
        else {
            let t = 0;
            if (o == NO.mixOut)
                switch (s) {
                case OO.setup:
                    t = a.data.scaleX,
                    a.scaleX = t + (Math.abs(l) * QO.signum(t) - t) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = a.scaleX,
                    a.scaleX = t + (Math.abs(l) * QO.signum(t) - t) * i;
                    break;
                case OO.add:
                    a.scaleX += (l - a.data.scaleX) * i
                }
            else
                switch (s) {
                case OO.setup:
                    t = Math.abs(a.data.scaleX) * QO.signum(l),
                    a.scaleX = t + (l - t) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = Math.abs(a.scaleX) * QO.signum(l),
                    a.scaleX = t + (l - t) * i;
                    break;
                case OO.add:
                    a.scaleX += (l - a.data.scaleX) * i
                }
        }
    }
}
class nL extends XB {
    constructor(t, e, n) {
        super(t, e, `${CB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        if (n < this.frames[0]) {
            switch (s) {
            case OO.setup:
                return void (a.scaleY = a.data.scaleY);
            case OO.first:
                a.scaleY += (a.data.scaleY - a.scaleY) * i
            }
            return
        }
        const l = this.getCurveValue(n) * a.data.scaleY;
        if (1 == i)
            s == OO.add ? a.scaleY += l - a.data.scaleY : a.scaleY = l;
        else {
            let t = 0;
            if (o == NO.mixOut)
                switch (s) {
                case OO.setup:
                    t = a.data.scaleY,
                    a.scaleY = t + (Math.abs(l) * QO.signum(t) - t) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = a.scaleY,
                    a.scaleY = t + (Math.abs(l) * QO.signum(t) - t) * i;
                    break;
                case OO.add:
                    a.scaleY += (l - a.data.scaleY) * i
                }
            else
                switch (s) {
                case OO.setup:
                    t = Math.abs(a.data.scaleY) * QO.signum(l),
                    a.scaleY = t + (l - t) * i;
                    break;
                case OO.first:
                case OO.replace:
                    t = Math.abs(a.scaleY) * QO.signum(l),
                    a.scaleY = t + (l - t) * i;
                    break;
                case OO.add:
                    a.scaleY += (l - a.data.scaleY) * i
                }
        }
    }
}
class rL extends qB {
    constructor(t, e, n) {
        super(t, e, `${PB}|${n}`, `${OB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        const l = this.frames;
        if (n < l[0]) {
            switch (s) {
            case OO.setup:
                return a.shearX = a.data.shearX,
                void (a.shearY = a.data.shearY);
            case OO.first:
                a.shearX += (a.data.shearX - a.shearX) * i,
                a.shearY += (a.data.shearY - a.shearY) * i
            }
            return
        }
        let c = 0
          , u = 0;
        const h = $B.search(l, n, 3)
          , d = this.curves[h / 3];
        switch (d) {
        case 0:
            const t = l[h];
            c = l[h + 1],
            u = l[h + 2];
            const e = (n - t) / (l[h + 3] - t);
            c += (l[h + 3 + 1] - c) * e,
            u += (l[h + 3 + 2] - u) * e;
            break;
        case 1:
            c = l[h + 1],
            u = l[h + 2];
            break;
        default:
            c = this.getBezierValue(n, h, 1, d - 2),
            u = this.getBezierValue(n, h, 2, d + 18 - 2)
        }
        switch (s) {
        case OO.setup:
            a.shearX = a.data.shearX + c * i,
            a.shearY = a.data.shearY + u * i;
            break;
        case OO.first:
        case OO.replace:
            a.shearX += (a.data.shearX + c - a.shearX) * i,
            a.shearY += (a.data.shearY + u - a.shearY) * i;
            break;
        case OO.add:
            a.shearX += c * i,
            a.shearY += u * i
        }
    }
}
class iL extends XB {
    constructor(t, e, n) {
        super(t, e, `${PB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        if (n < this.frames[0]) {
            switch (s) {
            case OO.setup:
                return void (a.shearX = a.data.shearX);
            case OO.first:
                a.shearX += (a.data.shearX - a.shearX) * i
            }
            return
        }
        const l = this.getCurveValue(n);
        switch (s) {
        case OO.setup:
            a.shearX = a.data.shearX + l * i;
            break;
        case OO.first:
        case OO.replace:
            a.shearX += (a.data.shearX + l - a.shearX) * i;
            break;
        case OO.add:
            a.shearX += l * i
        }
    }
}
class sL extends XB {
    constructor(t, e, n) {
        super(t, e, `${OB}|${n}`),
        this.boneIndex = 0,
        this.boneIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.bones[this.boneIndex];
        if (!a.active)
            return;
        if (n < this.frames[0]) {
            switch (s) {
            case OO.setup:
                return void (a.shearY = a.data.shearY);
            case OO.first:
                a.shearY += (a.data.shearY - a.shearY) * i
            }
            return
        }
        const l = this.getCurveValue(n);
        switch (s) {
        case OO.setup:
            a.shearY = a.data.shearY + l * i;
            break;
        case OO.first:
        case OO.replace:
            a.shearY += (a.data.shearY + l - a.shearY) * i;
            break;
        case OO.add:
            a.shearY += l * i
        }
    }
}
class oL extends GB {
    constructor(t, e, n) {
        super(t, e, [`${NB}|${n}`, `${RB}|${n}`]),
        this.slotIndex = 0,
        this.slotIndex = n
    }
    getFrameEntries() {
        return 5
    }
    setFrame(t, e, n, r, i, s) {
        t *= 5,
        this.frames[t] = e,
        this.frames[t + 1] = n,
        this.frames[t + 2] = r,
        this.frames[t + 3] = i,
        this.frames[t + 4] = s
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = this.frames
          , c = a.color;
        if (n < l[0]) {
            const t = a.data.color;
            switch (s) {
            case OO.setup:
                return void c.setFromColor(t);
            case OO.first:
                c.add((t.r - c.r) * i, (t.g - c.g) * i, (t.b - c.b) * i, (t.a - c.a) * i)
            }
            return
        }
        let u = 0
          , h = 0
          , d = 0
          , f = 0;
        const p = $B.search(l, n, 5)
          , m = this.curves[p / 5];
        switch (m) {
        case 0:
            const t = l[p];
            u = l[p + 1],
            h = l[p + 2],
            d = l[p + 3],
            f = l[p + 4];
            const e = (n - t) / (l[p + 5] - t);
            u += (l[p + 5 + 1] - u) * e,
            h += (l[p + 5 + 2] - h) * e,
            d += (l[p + 5 + 3] - d) * e,
            f += (l[p + 5 + 4] - f) * e;
            break;
        case 1:
            u = l[p + 1],
            h = l[p + 2],
            d = l[p + 3],
            f = l[p + 4];
            break;
        default:
            u = this.getBezierValue(n, p, 1, m - 2),
            h = this.getBezierValue(n, p, 2, m + 18 - 2),
            d = this.getBezierValue(n, p, 3, m + 36 - 2),
            f = this.getBezierValue(n, p, 4, m + 54 - 2)
        }
        1 == i ? c.set(u, h, d, f) : (s == OO.setup && c.setFromColor(a.data.color),
        c.add((u - c.r) * i, (h - c.g) * i, (d - c.b) * i, (f - c.a) * i))
    }
}
class aL extends GB {
    constructor(t, e, n) {
        super(t, e, [`${NB}|${n}`]),
        this.slotIndex = 0,
        this.slotIndex = n
    }
    getFrameEntries() {
        return 4
    }
    setFrame(t, e, n, r, i) {
        t <<= 2,
        this.frames[t] = e,
        this.frames[t + 1] = n,
        this.frames[t + 2] = r,
        this.frames[t + 3] = i
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = this.frames
          , c = a.color;
        if (n < l[0]) {
            const t = a.data.color;
            switch (s) {
            case OO.setup:
                return c.r = t.r,
                c.g = t.g,
                void (c.b = t.b);
            case OO.first:
                c.r += (t.r - c.r) * i,
                c.g += (t.g - c.g) * i,
                c.b += (t.b - c.b) * i
            }
            return
        }
        let u = 0
          , h = 0
          , d = 0;
        const f = $B.search(l, n, 4)
          , p = this.curves[f >> 2];
        switch (p) {
        case 0:
            const t = l[f];
            u = l[f + 1],
            h = l[f + 2],
            d = l[f + 3];
            const e = (n - t) / (l[f + 4] - t);
            u += (l[f + 4 + 1] - u) * e,
            h += (l[f + 4 + 2] - h) * e,
            d += (l[f + 4 + 3] - d) * e;
            break;
        case 1:
            u = l[f + 1],
            h = l[f + 2],
            d = l[f + 3];
            break;
        default:
            u = this.getBezierValue(n, f, 1, p - 2),
            h = this.getBezierValue(n, f, 2, p + 18 - 2),
            d = this.getBezierValue(n, f, 3, p + 36 - 2)
        }
        if (1 == i)
            c.r = u,
            c.g = h,
            c.b = d;
        else {
            if (s == OO.setup) {
                const t = a.data.color;
                c.r = t.r,
                c.g = t.g,
                c.b = t.b
            }
            c.r += (u - c.r) * i,
            c.g += (h - c.g) * i,
            c.b += (d - c.b) * i
        }
    }
}
class lL extends XB {
    constructor(t, e, n) {
        super(t, e, `${RB}|${n}`),
        this.slotIndex = 0,
        this.slotIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = a.color;
        if (n < this.frames[0]) {
            const t = a.data.color;
            switch (s) {
            case OO.setup:
                return void (l.a = t.a);
            case OO.first:
                l.a += (t.a - l.a) * i
            }
            return
        }
        const c = this.getCurveValue(n);
        1 == i ? l.a = c : (s == OO.setup && (l.a = a.data.color.a),
        l.a += (c - l.a) * i)
    }
}
class cL extends GB {
    constructor(t, e, n) {
        super(t, e, [`${NB}|${n}`, `${RB}|${n}`, `${DB}|${n}`]),
        this.slotIndex = 0,
        this.slotIndex = n
    }
    getFrameEntries() {
        return 8
    }
    setFrame(t, e, n, r, i, s, o, a, l) {
        t <<= 3,
        this.frames[t] = e,
        this.frames[t + 1] = n,
        this.frames[t + 2] = r,
        this.frames[t + 3] = i,
        this.frames[t + 4] = s,
        this.frames[t + 5] = o,
        this.frames[t + 6] = a,
        this.frames[t + 7] = l
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = this.frames
          , c = a.color
          , u = a.darkColor;
        if (n < l[0]) {
            const t = a.data.color
              , e = a.data.darkColor;
            switch (s) {
            case OO.setup:
                return c.setFromColor(t),
                u.r = e.r,
                u.g = e.g,
                void (u.b = e.b);
            case OO.first:
                c.add((t.r - c.r) * i, (t.g - c.g) * i, (t.b - c.b) * i, (t.a - c.a) * i),
                u.r += (e.r - u.r) * i,
                u.g += (e.g - u.g) * i,
                u.b += (e.b - u.b) * i
            }
            return
        }
        let h = 0
          , d = 0
          , f = 0
          , p = 0
          , m = 0
          , g = 0
          , y = 0;
        const b = $B.search(l, n, 8)
          , v = this.curves[b >> 3];
        switch (v) {
        case 0:
            const t = l[b];
            h = l[b + 1],
            d = l[b + 2],
            f = l[b + 3],
            p = l[b + 4],
            m = l[b + 5],
            g = l[b + 6],
            y = l[b + 7];
            const e = (n - t) / (l[b + 8] - t);
            h += (l[b + 8 + 1] - h) * e,
            d += (l[b + 8 + 2] - d) * e,
            f += (l[b + 8 + 3] - f) * e,
            p += (l[b + 8 + 4] - p) * e,
            m += (l[b + 8 + 5] - m) * e,
            g += (l[b + 8 + 6] - g) * e,
            y += (l[b + 8 + 7] - y) * e;
            break;
        case 1:
            h = l[b + 1],
            d = l[b + 2],
            f = l[b + 3],
            p = l[b + 4],
            m = l[b + 5],
            g = l[b + 6],
            y = l[b + 7];
            break;
        default:
            h = this.getBezierValue(n, b, 1, v - 2),
            d = this.getBezierValue(n, b, 2, v + 18 - 2),
            f = this.getBezierValue(n, b, 3, v + 36 - 2),
            p = this.getBezierValue(n, b, 4, v + 54 - 2),
            m = this.getBezierValue(n, b, 5, v + 72 - 2),
            g = this.getBezierValue(n, b, 6, v + 90 - 2),
            y = this.getBezierValue(n, b, 7, v + 108 - 2)
        }
        if (1 == i)
            c.set(h, d, f, p),
            u.r = m,
            u.g = g,
            u.b = y;
        else {
            if (s == OO.setup) {
                c.setFromColor(a.data.color);
                const t = a.data.darkColor;
                u.r = t.r,
                u.g = t.g,
                u.b = t.b
            }
            c.add((h - c.r) * i, (d - c.g) * i, (f - c.b) * i, (p - c.a) * i),
            u.r += (m - u.r) * i,
            u.g += (g - u.g) * i,
            u.b += (y - u.b) * i
        }
    }
}
class uL extends GB {
    constructor(t, e, n) {
        super(t, e, [`${NB}|${n}`, `${DB}|${n}`]),
        this.slotIndex = 0,
        this.slotIndex = n
    }
    getFrameEntries() {
        return 7
    }
    setFrame(t, e, n, r, i, s, o, a) {
        t *= 7,
        this.frames[t] = e,
        this.frames[t + 1] = n,
        this.frames[t + 2] = r,
        this.frames[t + 3] = i,
        this.frames[t + 4] = s,
        this.frames[t + 5] = o,
        this.frames[t + 6] = a
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = this.frames
          , c = a.color
          , u = a.darkColor;
        if (n < l[0]) {
            const t = a.data.color
              , e = a.data.darkColor;
            switch (s) {
            case OO.setup:
                return c.r = t.r,
                c.g = t.g,
                c.b = t.b,
                u.r = e.r,
                u.g = e.g,
                void (u.b = e.b);
            case OO.first:
                c.r += (t.r - c.r) * i,
                c.g += (t.g - c.g) * i,
                c.b += (t.b - c.b) * i,
                u.r += (e.r - u.r) * i,
                u.g += (e.g - u.g) * i,
                u.b += (e.b - u.b) * i
            }
            return
        }
        let h = 0
          , d = 0
          , f = 0
          , p = 0
          , m = 0
          , g = 0;
        const y = $B.search(l, n, 7)
          , b = this.curves[y / 7];
        switch (b) {
        case 0:
            const t = l[y];
            h = l[y + 1],
            d = l[y + 2],
            f = l[y + 3],
            p = l[y + 4],
            m = l[y + 5],
            g = l[y + 6];
            const e = (n - t) / (l[y + 7] - t);
            h += (l[y + 7 + 1] - h) * e,
            d += (l[y + 7 + 2] - d) * e,
            f += (l[y + 7 + 3] - f) * e,
            p += (l[y + 7 + 4] - p) * e,
            m += (l[y + 7 + 5] - m) * e,
            g += (l[y + 7 + 6] - g) * e;
            break;
        case 1:
            h = l[y + 1],
            d = l[y + 2],
            f = l[y + 3],
            p = l[y + 4],
            m = l[y + 5],
            g = l[y + 6];
            break;
        default:
            h = this.getBezierValue(n, y, 1, b - 2),
            d = this.getBezierValue(n, y, 2, b + 18 - 2),
            f = this.getBezierValue(n, y, 3, b + 36 - 2),
            p = this.getBezierValue(n, y, 4, b + 54 - 2),
            m = this.getBezierValue(n, y, 5, b + 72 - 2),
            g = this.getBezierValue(n, y, 6, b + 90 - 2)
        }
        if (1 == i)
            c.r = h,
            c.g = d,
            c.b = f,
            u.r = p,
            u.g = m,
            u.b = g;
        else {
            if (s == OO.setup) {
                const t = a.data.color
                  , e = a.data.darkColor;
                c.r = t.r,
                c.g = t.g,
                c.b = t.b,
                u.r = e.r,
                u.g = e.g,
                u.b = e.b
            }
            c.r += (h - c.r) * i,
            c.g += (d - c.g) * i,
            c.b += (f - c.b) * i,
            u.r += (p - u.r) * i,
            u.g += (m - u.g) * i,
            u.b += (g - u.b) * i
        }
    }
}
class hL extends $B {
    constructor(t, e) {
        super(t, [`${BB}|${e}`]),
        this.slotIndex = 0,
        this.slotIndex = e,
        this.attachmentNames = new Array(t)
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
        this.attachmentNames[t] = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        a.bone.active && (o != NO.mixOut ? n < this.frames[0] ? s != OO.setup && s != OO.first || this.setAttachment(t, a, a.data.attachmentName) : this.setAttachment(t, a, this.attachmentNames[$B.search1(this.frames, n)]) : s == OO.setup && this.setAttachment(t, a, a.data.attachmentName))
    }
    setAttachment(t, e, n) {
        e.setAttachment(n ? t.getAttachment(this.slotIndex, n) : null)
    }
}
class dL extends GB {
    constructor(t, e, n, r) {
        super(t, e, [`${LB}|${n}|${r.id}`]),
        this.slotIndex = 0,
        this.slotIndex = n,
        this.attachment = r,
        this.vertices = new Array(t)
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
        this.vertices[t] = n
    }
    setBezier(t, e, n, r, i, s, o, a, l, c, u) {
        const h = this.curves;
        let d = this.getFrameCount() + 18 * t;
        0 == n && (h[e] = 2 + d);
        const f = .03 * (r - 2 * s + a)
          , p = .03 * l - .06 * o
          , m = .006 * (3 * (s - a) - r + c)
          , g = .018 * (o - l + .33333333);
        let y = 2 * f + m
          , b = 2 * p + g
          , v = .3 * (s - r) + f + .16666667 * m
          , w = .3 * o + p + .16666667 * g
          , x = r + v
          , E = w;
        for (let t = d + 18; d < t; d += 2)
            h[d] = x,
            h[d + 1] = E,
            v += y,
            w += b,
            y += m,
            b += g,
            x += v,
            E += w
    }
    getCurvePercent(t, e) {
        const n = this.curves;
        let r = n[e];
        switch (r) {
        case 0:
            const n = this.frames[e];
            return (t - n) / (this.frames[e + this.getFrameEntries()] - n);
        case 1:
            return 0
        }
        if (r -= 2,
        n[r] > t) {
            const i = this.frames[e];
            return n[r + 1] * (t - i) / (n[r] - i)
        }
        const i = r + 18;
        for (r += 2; r < i; r += 2)
            if (n[r] >= t) {
                const e = n[r - 2]
                  , i = n[r - 1];
                return i + (t - e) / (n[r] - e) * (n[r + 1] - i)
            }
        const s = n[i - 2]
          , o = n[i - 1];
        return o + (1 - o) * (t - s) / (this.frames[e + this.getFrameEntries()] - s)
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = a.getAttachment();
        if (!l)
            return;
        if (!(l instanceof fB) || l.timelineAttachment != this.attachment)
            return;
        const c = a.deform;
        0 == c.length && (s = OO.setup);
        const u = this.vertices
          , h = u[0].length
          , d = this.frames;
        if (n < d[0]) {
            switch (s) {
            case OO.setup:
                return void (c.length = 0);
            case OO.first:
                if (1 == i)
                    return void (c.length = 0);
                c.length = h;
                const t = l;
                if (t.bones) {
                    i = 1 - i;
                    for (let t = 0; t < h; t++)
                        c[t] *= i
                } else {
                    const e = t.vertices;
                    for (let t = 0; t < h; t++)
                        c[t] += (e[t] - c[t]) * i
                }
            }
            return
        }
        if (c.length = h,
        n >= d[d.length - 1]) {
            const t = u[d.length - 1];
            if (1 == i)
                if (s == OO.add) {
                    const e = l;
                    if (e.bones)
                        for (let e = 0; e < h; e++)
                            c[e] += t[e];
                    else {
                        const n = e.vertices;
                        for (let e = 0; e < h; e++)
                            c[e] += t[e] - n[e]
                    }
                } else
                    nN.arrayCopy(t, 0, c, 0, h);
            else
                switch (s) {
                case OO.setup:
                    {
                        const e = l;
                        if (e.bones)
                            for (let e = 0; e < h; e++)
                                c[e] = t[e] * i;
                        else {
                            const n = e.vertices;
                            for (let e = 0; e < h; e++) {
                                const r = n[e];
                                c[e] = r + (t[e] - r) * i
                            }
                        }
                        break
                    }
                case OO.first:
                case OO.replace:
                    for (let e = 0; e < h; e++)
                        c[e] += (t[e] - c[e]) * i;
                    break;
                case OO.add:
                    const e = l;
                    if (e.bones)
                        for (let e = 0; e < h; e++)
                            c[e] += t[e] * i;
                    else {
                        const n = e.vertices;
                        for (let e = 0; e < h; e++)
                            c[e] += (t[e] - n[e]) * i
                    }
                }
            return
        }
        const f = $B.search1(d, n)
          , p = this.getCurvePercent(n, f)
          , m = u[f]
          , g = u[f + 1];
        if (1 == i)
            if (s == OO.add) {
                const t = l;
                if (t.bones)
                    for (let t = 0; t < h; t++) {
                        const e = m[t];
                        c[t] += e + (g[t] - e) * p
                    }
                else {
                    const e = t.vertices;
                    for (let t = 0; t < h; t++) {
                        const n = m[t];
                        c[t] += n + (g[t] - n) * p - e[t]
                    }
                }
            } else
                for (let t = 0; t < h; t++) {
                    const e = m[t];
                    c[t] = e + (g[t] - e) * p
                }
        else
            switch (s) {
            case OO.setup:
                {
                    const t = l;
                    if (t.bones)
                        for (let t = 0; t < h; t++) {
                            const e = m[t];
                            c[t] = (e + (g[t] - e) * p) * i
                        }
                    else {
                        const e = t.vertices;
                        for (let t = 0; t < h; t++) {
                            const n = m[t]
                              , r = e[t];
                            c[t] = r + (n + (g[t] - n) * p - r) * i
                        }
                    }
                    break
                }
            case OO.first:
            case OO.replace:
                for (let t = 0; t < h; t++) {
                    const e = m[t];
                    c[t] += (e + (g[t] - e) * p - c[t]) * i
                }
                break;
            case OO.add:
                const t = l;
                if (t.bones)
                    for (let t = 0; t < h; t++) {
                        const e = m[t];
                        c[t] += (e + (g[t] - e) * p) * i
                    }
                else {
                    const e = t.vertices;
                    for (let t = 0; t < h; t++) {
                        const n = m[t];
                        c[t] += (n + (g[t] - n) * p - e[t]) * i
                    }
                }
            }
    }
}
const fL = class extends $B {
    constructor(t) {
        super(t, fL.propertyIds),
        this.events = new Array(t)
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e) {
        this.frames[t] = e.time,
        this.events[t] = e
    }
    apply(t, e, n, r, i, s, o) {
        if (!r)
            return;
        const a = this.frames
          , l = this.frames.length;
        if (e > n)
            this.apply(t, e, Number.MAX_VALUE, r, i, s, o),
            e = -1;
        else if (e >= a[l - 1])
            return;
        if (n < a[0])
            return;
        let c = 0;
        if (e < a[0])
            c = 0;
        else {
            c = $B.search1(a, e) + 1;
            const t = a[c];
            for (; c > 0 && a[c - 1] == t; )
                c--
        }
        for (; c < l && n >= a[c]; c++)
            r.push(this.events[c])
    }
}
;
let pL = fL;
pL.propertyIds = [`${FB}`];
const mL = class extends $B {
    constructor(t) {
        super(t, mL.propertyIds),
        this.drawOrders = new Array(t)
    }
    getFrameCount() {
        return this.frames.length
    }
    setFrame(t, e, n) {
        this.frames[t] = e,
        this.drawOrders[t] = n
    }
    apply(t, e, n, r, i, s, o) {
        if (o == NO.mixOut)
            return void (s == OO.setup && nN.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length));
        if (n < this.frames[0])
            return void (s != OO.setup && s != OO.first || nN.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length));
        const a = $B.search1(this.frames, n)
          , l = this.drawOrders[a];
        if (l) {
            const e = t.drawOrder
              , n = t.slots;
            for (let t = 0, r = l.length; t < r; t++)
                e[t] = n[l[t]]
        } else
            nN.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length)
    }
}
;
let gL = mL;
gL.propertyIds = [`${jB}`];
class yL extends GB {
    constructor(t, e, n) {
        super(t, e, [`${UB}|${n}`]),
        this.ikConstraintIndex = 0,
        this.ikConstraintIndex = n
    }
    getFrameEntries() {
        return 6
    }
    setFrame(t, e, n, r, i, s, o) {
        t *= 6,
        this.frames[t] = e,
        this.frames[t + 1] = n,
        this.frames[t + 2] = r,
        this.frames[t + 3] = i,
        this.frames[t + 4] = s ? 1 : 0,
        this.frames[t + 5] = o ? 1 : 0
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.ikConstraints[this.ikConstraintIndex];
        if (!a.active)
            return;
        const l = this.frames;
        if (n < l[0]) {
            switch (s) {
            case OO.setup:
                return a.mix = a.data.mix,
                a.softness = a.data.softness,
                a.bendDirection = a.data.bendDirection,
                a.compress = a.data.compress,
                void (a.stretch = a.data.stretch);
            case OO.first:
                a.mix += (a.data.mix - a.mix) * i,
                a.softness += (a.data.softness - a.softness) * i,
                a.bendDirection = a.data.bendDirection,
                a.compress = a.data.compress,
                a.stretch = a.data.stretch
            }
            return
        }
        let c = 0
          , u = 0;
        const h = $B.search(l, n, 6)
          , d = this.curves[h / 6];
        switch (d) {
        case 0:
            const t = l[h];
            c = l[h + 1],
            u = l[h + 2];
            const e = (n - t) / (l[h + 6] - t);
            c += (l[h + 6 + 1] - c) * e,
            u += (l[h + 6 + 2] - u) * e;
            break;
        case 1:
            c = l[h + 1],
            u = l[h + 2];
            break;
        default:
            c = this.getBezierValue(n, h, 1, d - 2),
            u = this.getBezierValue(n, h, 2, d + 18 - 2)
        }
        s == OO.setup ? (a.mix = a.data.mix + (c - a.data.mix) * i,
        a.softness = a.data.softness + (u - a.data.softness) * i,
        o == NO.mixOut ? (a.bendDirection = a.data.bendDirection,
        a.compress = a.data.compress,
        a.stretch = a.data.stretch) : (a.bendDirection = l[h + 3],
        a.compress = 0 != l[h + 4],
        a.stretch = 0 != l[h + 5])) : (a.mix += (c - a.mix) * i,
        a.softness += (u - a.softness) * i,
        o == NO.mixIn && (a.bendDirection = l[h + 3],
        a.compress = 0 != l[h + 4],
        a.stretch = 0 != l[h + 5]))
    }
}
class bL extends GB {
    constructor(t, e, n) {
        super(t, e, [`${zB}|${n}`]),
        this.transformConstraintIndex = 0,
        this.transformConstraintIndex = n
    }
    getFrameEntries() {
        return 7
    }
    setFrame(t, e, n, r, i, s, o, a) {
        const l = this.frames;
        l[t *= 7] = e,
        l[t + 1] = n,
        l[t + 2] = r,
        l[t + 3] = i,
        l[t + 4] = s,
        l[t + 5] = o,
        l[t + 6] = a
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.transformConstraints[this.transformConstraintIndex];
        if (!a.active)
            return;
        const l = this.frames;
        if (n < l[0]) {
            const t = a.data;
            switch (s) {
            case OO.setup:
                return a.mixRotate = t.mixRotate,
                a.mixX = t.mixX,
                a.mixY = t.mixY,
                a.mixScaleX = t.mixScaleX,
                a.mixScaleY = t.mixScaleY,
                void (a.mixShearY = t.mixShearY);
            case OO.first:
                a.mixRotate += (t.mixRotate - a.mixRotate) * i,
                a.mixX += (t.mixX - a.mixX) * i,
                a.mixY += (t.mixY - a.mixY) * i,
                a.mixScaleX += (t.mixScaleX - a.mixScaleX) * i,
                a.mixScaleY += (t.mixScaleY - a.mixScaleY) * i,
                a.mixShearY += (t.mixShearY - a.mixShearY) * i
            }
            return
        }
        let c, u, h, d, f, p;
        const m = $B.search(l, n, 7)
          , g = this.curves[m / 7];
        switch (g) {
        case 0:
            const t = l[m];
            c = l[m + 1],
            u = l[m + 2],
            h = l[m + 3],
            d = l[m + 4],
            f = l[m + 5],
            p = l[m + 6];
            const e = (n - t) / (l[m + 7] - t);
            c += (l[m + 7 + 1] - c) * e,
            u += (l[m + 7 + 2] - u) * e,
            h += (l[m + 7 + 3] - h) * e,
            d += (l[m + 7 + 4] - d) * e,
            f += (l[m + 7 + 5] - f) * e,
            p += (l[m + 7 + 6] - p) * e;
            break;
        case 1:
            c = l[m + 1],
            u = l[m + 2],
            h = l[m + 3],
            d = l[m + 4],
            f = l[m + 5],
            p = l[m + 6];
            break;
        default:
            c = this.getBezierValue(n, m, 1, g - 2),
            u = this.getBezierValue(n, m, 2, g + 18 - 2),
            h = this.getBezierValue(n, m, 3, g + 36 - 2),
            d = this.getBezierValue(n, m, 4, g + 54 - 2),
            f = this.getBezierValue(n, m, 5, g + 72 - 2),
            p = this.getBezierValue(n, m, 6, g + 90 - 2)
        }
        if (s == OO.setup) {
            const t = a.data;
            a.mixRotate = t.mixRotate + (c - t.mixRotate) * i,
            a.mixX = t.mixX + (u - t.mixX) * i,
            a.mixY = t.mixY + (h - t.mixY) * i,
            a.mixScaleX = t.mixScaleX + (d - t.mixScaleX) * i,
            a.mixScaleY = t.mixScaleY + (f - t.mixScaleY) * i,
            a.mixShearY = t.mixShearY + (p - t.mixShearY) * i
        } else
            a.mixRotate += (c - a.mixRotate) * i,
            a.mixX += (u - a.mixX) * i,
            a.mixY += (h - a.mixY) * i,
            a.mixScaleX += (d - a.mixScaleX) * i,
            a.mixScaleY += (f - a.mixScaleY) * i,
            a.mixShearY += (p - a.mixShearY) * i
    }
}
class vL extends XB {
    constructor(t, e, n) {
        super(t, e, `${VB}|${n}`),
        this.pathConstraintIndex = 0,
        this.pathConstraintIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.pathConstraints[this.pathConstraintIndex];
        if (!a.active)
            return;
        if (n < this.frames[0]) {
            switch (s) {
            case OO.setup:
                return void (a.position = a.data.position);
            case OO.first:
                a.position += (a.data.position - a.position) * i
            }
            return
        }
        const l = this.getCurveValue(n);
        s == OO.setup ? a.position = a.data.position + (l - a.data.position) * i : a.position += (l - a.position) * i
    }
}
class wL extends XB {
    constructor(t, e, n) {
        super(t, e, `${WB}|${n}`),
        this.pathConstraintIndex = 0,
        this.pathConstraintIndex = n
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.pathConstraints[this.pathConstraintIndex];
        if (!a.active)
            return;
        if (n < this.frames[0]) {
            switch (s) {
            case OO.setup:
                return void (a.spacing = a.data.spacing);
            case OO.first:
                a.spacing += (a.data.spacing - a.spacing) * i
            }
            return
        }
        const l = this.getCurveValue(n);
        s == OO.setup ? a.spacing = a.data.spacing + (l - a.data.spacing) * i : a.spacing += (l - a.spacing) * i
    }
}
class xL extends GB {
    constructor(t, e, n) {
        super(t, e, [`${YB}|${n}`]),
        this.pathConstraintIndex = 0,
        this.pathConstraintIndex = n
    }
    getFrameEntries() {
        return 4
    }
    setFrame(t, e, n, r, i) {
        const s = this.frames;
        s[t <<= 2] = e,
        s[t + 1] = n,
        s[t + 2] = r,
        s[t + 3] = i
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.pathConstraints[this.pathConstraintIndex];
        if (!a.active)
            return;
        const l = this.frames;
        if (n < l[0]) {
            switch (s) {
            case OO.setup:
                return a.mixRotate = a.data.mixRotate,
                a.mixX = a.data.mixX,
                void (a.mixY = a.data.mixY);
            case OO.first:
                a.mixRotate += (a.data.mixRotate - a.mixRotate) * i,
                a.mixX += (a.data.mixX - a.mixX) * i,
                a.mixY += (a.data.mixY - a.mixY) * i
            }
            return
        }
        let c, u, h;
        const d = $B.search(l, n, 4)
          , f = this.curves[d >> 2];
        switch (f) {
        case 0:
            const t = l[d];
            c = l[d + 1],
            u = l[d + 2],
            h = l[d + 3];
            const e = (n - t) / (l[d + 4] - t);
            c += (l[d + 4 + 1] - c) * e,
            u += (l[d + 4 + 2] - u) * e,
            h += (l[d + 4 + 3] - h) * e;
            break;
        case 1:
            c = l[d + 1],
            u = l[d + 2],
            h = l[d + 3];
            break;
        default:
            c = this.getBezierValue(n, d, 1, f - 2),
            u = this.getBezierValue(n, d, 2, f + 18 - 2),
            h = this.getBezierValue(n, d, 3, f + 36 - 2)
        }
        if (s == OO.setup) {
            const t = a.data;
            a.mixRotate = t.mixRotate + (c - t.mixRotate) * i,
            a.mixX = t.mixX + (u - t.mixX) * i,
            a.mixY = t.mixY + (h - t.mixY) * i
        } else
            a.mixRotate += (c - a.mixRotate) * i,
            a.mixX += (u - a.mixX) * i,
            a.mixY += (h - a.mixY) * i
    }
}
const EL = class extends $B {
    constructor(t, e, n) {
        super(t, [`${HB}|${e}|${n.sequence.id}`]),
        this.slotIndex = e,
        this.attachment = n
    }
    getFrameEntries() {
        return EL.ENTRIES
    }
    getSlotIndex() {
        return this.slotIndex
    }
    getAttachment() {
        return this.attachment
    }
    setFrame(t, e, n, r, i) {
        const s = this.frames;
        s[t *= EL.ENTRIES] = e,
        s[t + EL.MODE] = n | r << 4,
        s[t + EL.DELAY] = i
    }
    apply(t, e, n, r, i, s, o) {
        const a = t.slots[this.slotIndex];
        if (!a.bone.active)
            return;
        const l = a.attachment
          , c = this.attachment;
        if (!(l == c || l instanceof fB && l.timelineAttachment == c))
            return;
        const u = this.frames;
        if (n < u[0])
            return void (s != OO.setup && s != OO.first || (a.sequenceIndex = -1));
        const h = $B.search(u, n, EL.ENTRIES)
          , d = u[h]
          , f = u[h + EL.MODE]
          , p = u[h + EL.DELAY];
        if (!this.attachment.sequence)
            return;
        let m = f >> 4;
        const g = this.attachment.sequence.regions.length
          , y = AB[15 & f];
        if (y != _B.hold)
            switch (m += (n - d) / p + 1e-5 | 0,
            y) {
            case _B.once:
                m = Math.min(g - 1, m);
                break;
            case _B.loop:
                m %= g;
                break;
            case _B.pingpong:
                {
                    const t = (g << 1) - 2;
                    m = 0 == t ? 0 : m % t,
                    m >= g && (m = t - m);
                    break
                }
            case _B.onceReverse:
                m = Math.max(g - 1 - m, 0);
                break;
            case _B.loopReverse:
                m = g - 1 - m % g;
                break;
            case _B.pingpongReverse:
                {
                    const t = (g << 1) - 2;
                    m = 0 == t ? 0 : (m + g - 1) % t,
                    m >= g && (m = t - m)
                }
            }
        a.sequenceIndex = m
    }
}
;
let _L = EL;
_L.ENTRIES = 3,
_L.MODE = 1,
_L.DELAY = 2;
const AL = class {
    constructor(t) {
        this.tracks = new Array,
        this.timeScale = 1,
        this.unkeyedState = 0,
        this.events = new Array,
        this.listeners = new Array,
        this.queue = new IL(this),
        this.propertyIDs = new GO,
        this.animationsChanged = !1,
        this.trackEntryPool = new rN((()=>new kL)),
        this.data = t
    }
    static emptyAnimation() {
        return AL._emptyAnimation
    }
    update(t) {
        t *= this.timeScale;
        const e = this.tracks;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (!r)
                continue;
            r.animationLast = r.nextAnimationLast,
            r.trackLast = r.nextTrackLast;
            let i = t * r.timeScale;
            if (r.delay > 0) {
                if (r.delay -= i,
                r.delay > 0)
                    continue;
                i = -r.delay,
                r.delay = 0
            }
            let s = r.next;
            if (s) {
                const e = r.trackLast - s.delay;
                if (e >= 0) {
                    for (s.delay = 0,
                    s.trackTime += 0 == r.timeScale ? 0 : (e / r.timeScale + t) * s.timeScale,
                    r.trackTime += i,
                    this.setCurrent(n, s, !0); s.mixingFrom; )
                        s.mixTime += t,
                        s = s.mixingFrom;
                    continue
                }
            } else if (r.trackLast >= r.trackEnd && !r.mixingFrom) {
                e[n] = null,
                this.queue.end(r),
                this.clearNext(r);
                continue
            }
            if (r.mixingFrom && this.updateMixingFrom(r, t)) {
                let t = r.mixingFrom;
                for (r.mixingFrom = null,
                t && (t.mixingTo = null); t; )
                    this.queue.end(t),
                    t = t.mixingFrom
            }
            r.trackTime += i
        }
        this.queue.drain()
    }
    updateMixingFrom(t, e) {
        const n = t.mixingFrom;
        if (!n)
            return !0;
        const r = this.updateMixingFrom(n, e);
        return n.animationLast = n.nextAnimationLast,
        n.trackLast = n.nextTrackLast,
        t.mixTime > 0 && t.mixTime >= t.mixDuration ? (0 != n.totalAlpha && 0 != t.mixDuration || (t.mixingFrom = n.mixingFrom,
        n.mixingFrom && (n.mixingFrom.mixingTo = t),
        t.interruptAlpha = n.interruptAlpha,
        this.queue.end(n)),
        r) : (n.trackTime += e * n.timeScale,
        t.mixTime += e,
        !1)
    }
    apply(t) {
        if (!t)
            throw new Error("skeleton cannot be null.");
        this.animationsChanged && this._animationsChanged();
        const e = this.events
          , n = this.tracks;
        let r = !1;
        for (let i = 0, s = n.length; i < s; i++) {
            const s = n[i];
            if (!s || s.delay > 0)
                continue;
            r = !0;
            const o = 0 == i ? OO.first : s.mixBlend;
            let a = s.alpha;
            s.mixingFrom ? a *= this.applyMixingFrom(s, t, o) : s.trackTime >= s.trackEnd && !s.next && (a = 0);
            const l = s.animationLast
              , c = s.getAnimationTime();
            let u = c
              , h = e;
            s.reverse && (u = s.animation.duration - u,
            h = null);
            const d = s.animation.timelines
              , f = d.length;
            if (0 == i && 1 == a || o == OO.add)
                for (let e = 0; e < f; e++) {
                    nN.webkit602BugfixHelper(a, o);
                    const n = d[e];
                    n instanceof hL ? this.applyAttachmentTimeline(n, t, u, o, !0) : n.apply(t, l, u, h, a, o, NO.mixIn)
                }
            else {
                const e = s.timelineMode
                  , n = s.shortestRotation
                  , r = !n && s.timelinesRotation.length != f << 1;
                r && (s.timelinesRotation.length = f << 1);
                for (let i = 0; i < f; i++) {
                    const c = d[i]
                      , f = e[i] == PL ? o : OO.setup;
                    !n && c instanceof KB ? this.applyRotateTimeline(c, t, u, a, f, s.timelinesRotation, i << 1, r) : c instanceof hL ? this.applyAttachmentTimeline(c, t, u, o, !0) : (nN.webkit602BugfixHelper(a, o),
                    c.apply(t, l, u, h, a, f, NO.mixIn))
                }
            }
            this.queueEvents(s, c),
            e.length = 0,
            s.nextAnimationLast = c,
            s.nextTrackLast = s.trackTime
        }
        const i = this.unkeyedState + BL
          , s = t.slots;
        for (let e = 0, n = t.slots.length; e < n; e++) {
            const n = s[e];
            if (n.attachmentState == i) {
                const e = n.data.attachmentName;
                n.setAttachment(e ? t.getAttachment(n.data.index, e) : null)
            }
        }
        return this.unkeyedState += 2,
        this.queue.drain(),
        r
    }
    applyMixingFrom(t, e, n) {
        const r = t.mixingFrom;
        r.mixingFrom && this.applyMixingFrom(r, e, n);
        let i = 0;
        0 == t.mixDuration ? (i = 1,
        n == OO.first && (n = OO.setup)) : (i = t.mixTime / t.mixDuration,
        i > 1 && (i = 1),
        n != OO.first && (n = r.mixBlend));
        const s = i < r.attachmentThreshold
          , o = i < r.drawOrderThreshold
          , a = r.animation.timelines
          , l = a.length
          , c = r.alpha * t.interruptAlpha
          , u = c * (1 - i)
          , h = r.animationLast
          , d = r.getAnimationTime();
        let f = d
          , p = null;
        if (r.reverse ? f = r.animation.duration - f : i < r.eventThreshold && (p = this.events),
        n == OO.add)
            for (let t = 0; t < l; t++)
                a[t].apply(e, h, f, p, u, n, NO.mixOut);
        else {
            const t = r.timelineMode
              , i = r.timelineHoldMix
              , d = r.shortestRotation
              , m = !d && r.timelinesRotation.length != l << 1;
            m && (r.timelinesRotation.length = l << 1),
            r.totalAlpha = 0;
            for (let g = 0; g < l; g++) {
                const l = a[g];
                let y, b = NO.mixOut, v = 0;
                switch (t[g]) {
                case PL:
                    if (!o && l instanceof gL)
                        continue;
                    y = n,
                    v = u;
                    break;
                case OL:
                    y = OO.setup,
                    v = u;
                    break;
                case NL:
                    y = n,
                    v = c;
                    break;
                case RL:
                    y = OO.setup,
                    v = c;
                    break;
                default:
                    y = OO.setup;
                    const t = i[g];
                    v = c * Math.max(0, 1 - t.mixTime / t.mixDuration)
                }
                r.totalAlpha += v,
                !d && l instanceof KB ? this.applyRotateTimeline(l, e, f, v, y, r.timelinesRotation, g << 1, m) : l instanceof hL ? this.applyAttachmentTimeline(l, e, f, y, s) : (nN.webkit602BugfixHelper(v, n),
                o && l instanceof gL && y == OO.setup && (b = NO.mixIn),
                l.apply(e, h, f, p, v, y, b))
            }
        }
        return t.mixDuration > 0 && this.queueEvents(r, d),
        this.events.length = 0,
        r.nextAnimationLast = d,
        r.nextTrackLast = r.trackTime,
        i
    }
    applyAttachmentTimeline(t, e, n, r, i) {
        const s = e.slots[t.slotIndex];
        s.bone.active && (n < t.frames[0] ? r != OO.setup && r != OO.first || this.setAttachment(e, s, s.data.attachmentName, i) : this.setAttachment(e, s, t.attachmentNames[$B.search1(t.frames, n)], i),
        s.attachmentState <= this.unkeyedState && (s.attachmentState = this.unkeyedState + BL))
    }
    setAttachment(t, e, n, r) {
        e.setAttachment(n ? t.getAttachment(e.data.index, n) : null),
        r && (e.attachmentState = this.unkeyedState + LL)
    }
    applyRotateTimeline(t, e, n, r, i, s, o, a) {
        if (a && (s[o] = 0),
        1 == r)
            return void t.apply(e, 0, n, null, 1, i, NO.mixIn);
        const l = e.bones[t.boneIndex];
        if (!l.active)
            return;
        let c = 0
          , u = 0;
        if (n < t.frames[0])
            switch (i) {
            case OO.setup:
                l.rotation = l.data.rotation;
            default:
                return;
            case OO.first:
                c = l.rotation,
                u = l.data.rotation
            }
        else
            c = i == OO.setup ? l.data.rotation : l.rotation,
            u = l.data.rotation + t.getCurveValue(n);
        let h = 0
          , d = u - c;
        if (d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0)),
        0 == d)
            h = s[o];
        else {
            let t = 0
              , e = 0;
            a ? (t = 0,
            e = d) : (t = s[o],
            e = s[o + 1]);
            const n = d > 0;
            let r = t >= 0;
            QO.signum(e) != QO.signum(d) && Math.abs(e) <= 90 && (Math.abs(t) > 180 && (t += 360 * QO.signum(t)),
            r = n),
            h = d + t - t % 360,
            r != n && (h += 360 * QO.signum(t)),
            s[o] = h
        }
        s[o + 1] = d,
        l.rotation = c + h * r
    }
    queueEvents(t, e) {
        const n = t.animationStart
          , r = t.animationEnd
          , i = r - n
          , s = t.trackLast % i
          , o = this.events;
        let a = 0;
        const l = o.length;
        for (; a < l; a++) {
            const e = o[a];
            if (e.time < s)
                break;
            e.time > r || this.queue.event(t, e)
        }
        let c = !1;
        for (c = t.loop ? 0 == i || s > t.trackTime % i : e >= r && t.animationLast < r,
        c && this.queue.complete(t); a < l; a++) {
            const e = o[a];
            e.time < n || this.queue.event(t, e)
        }
    }
    clearTracks() {
        const t = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let t = 0, e = this.tracks.length; t < e; t++)
            this.clearTrack(t);
        this.tracks.length = 0,
        this.queue.drainDisabled = t,
        this.queue.drain()
    }
    clearTrack(t) {
        if (t >= this.tracks.length)
            return;
        const e = this.tracks[t];
        if (!e)
            return;
        this.queue.end(e),
        this.clearNext(e);
        let n = e;
        for (; ; ) {
            const t = n.mixingFrom;
            if (!t)
                break;
            this.queue.end(t),
            n.mixingFrom = null,
            n.mixingTo = null,
            n = t
        }
        this.tracks[e.trackIndex] = null,
        this.queue.drain()
    }
    setCurrent(t, e, n) {
        const r = this.expandToIndex(t);
        this.tracks[t] = e,
        e.previous = null,
        r && (n && this.queue.interrupt(r),
        e.mixingFrom = r,
        r.mixingTo = e,
        e.mixTime = 0,
        r.mixingFrom && r.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, r.mixTime / r.mixDuration)),
        r.timelinesRotation.length = 0),
        this.queue.start(e)
    }
    setAnimation(t, e, n=!1) {
        const r = this.data.skeletonData.findAnimation(e);
        if (!r)
            throw new Error(`Animation not found: ${e}`);
        return this.setAnimationWith(t, r, n)
    }
    setAnimationWith(t, e, n=!1) {
        if (!e)
            throw new Error("animation cannot be null.");
        let r = !0
          , i = this.expandToIndex(t);
        i && (-1 == i.nextTrackLast ? (this.tracks[t] = i.mixingFrom,
        this.queue.interrupt(i),
        this.queue.end(i),
        this.clearNext(i),
        i = i.mixingFrom,
        r = !1) : this.clearNext(i));
        const s = this.trackEntry(t, e, n, i);
        return this.setCurrent(t, s, r),
        this.queue.drain(),
        s
    }
    addAnimation(t, e, n=!1, r=0) {
        const i = this.data.skeletonData.findAnimation(e);
        if (!i)
            throw new Error(`Animation not found: ${e}`);
        return this.addAnimationWith(t, i, n, r)
    }
    addAnimationWith(t, e, n=!1, r=0) {
        if (!e)
            throw new Error("animation cannot be null.");
        let i = this.expandToIndex(t);
        if (i)
            for (; i.next; )
                i = i.next;
        const s = this.trackEntry(t, e, n, i);
        return i ? (i.next = s,
        s.previous = i,
        r <= 0 && (r += i.getTrackComplete() - s.mixDuration)) : (this.setCurrent(t, s, !0),
        this.queue.drain()),
        s.delay = r,
        s
    }
    setEmptyAnimation(t, e=0) {
        const n = this.setAnimationWith(t, AL.emptyAnimation(), !1);
        return n.mixDuration = e,
        n.trackEnd = e,
        n
    }
    addEmptyAnimation(t, e=0, n=0) {
        const r = this.addAnimationWith(t, AL.emptyAnimation(), !1, n);
        return n <= 0 && (r.delay += r.mixDuration - e),
        r.mixDuration = e,
        r.trackEnd = e,
        r
    }
    setEmptyAnimations(t=0) {
        const e = this.queue.drainDisabled;
        this.queue.drainDisabled = !0;
        for (let e = 0, n = this.tracks.length; e < n; e++) {
            const n = this.tracks[e];
            n && this.setEmptyAnimation(n.trackIndex, t)
        }
        this.queue.drainDisabled = e,
        this.queue.drain()
    }
    expandToIndex(t) {
        return t < this.tracks.length ? this.tracks[t] : (nN.ensureArrayCapacity(this.tracks, t + 1, null),
        this.tracks.length = t + 1,
        null)
    }
    trackEntry(t, e, n, r) {
        const i = this.trackEntryPool.obtain();
        return i.reset(),
        i.trackIndex = t,
        i.animation = e,
        i.loop = n,
        i.holdPrevious = !1,
        i.reverse = !1,
        i.shortestRotation = !1,
        i.eventThreshold = 0,
        i.attachmentThreshold = 0,
        i.drawOrderThreshold = 0,
        i.animationStart = 0,
        i.animationEnd = e.duration,
        i.animationLast = -1,
        i.nextAnimationLast = -1,
        i.delay = 0,
        i.trackTime = 0,
        i.trackLast = -1,
        i.nextTrackLast = -1,
        i.trackEnd = Number.MAX_VALUE,
        i.timeScale = 1,
        i.alpha = 1,
        i.mixTime = 0,
        i.mixDuration = r ? this.data.getMix(r.animation, e) : 0,
        i.interruptAlpha = 1,
        i.totalAlpha = 0,
        i.mixBlend = OO.replace,
        i
    }
    clearNext(t) {
        let e = t.next;
        for (; e; )
            this.queue.dispose(e),
            e = e.next;
        t.next = null
    }
    _animationsChanged() {
        this.animationsChanged = !1,
        this.propertyIDs.clear();
        const t = this.tracks;
        for (let e = 0, n = t.length; e < n; e++) {
            let n = t[e];
            if (n) {
                for (; n.mixingFrom; )
                    n = n.mixingFrom;
                do {
                    n.mixingTo && n.mixBlend == OO.add || this.computeHold(n),
                    n = n.mixingTo
                } while (n)
            }
        }
    }
    computeHold(t) {
        const e = t.mixingTo
          , n = t.animation.timelines
          , r = t.animation.timelines.length
          , i = t.timelineMode;
        i.length = r;
        const s = t.timelineHoldMix;
        s.length = 0;
        const o = this.propertyIDs;
        if (e && e.holdPrevious)
            for (let t = 0; t < r; t++)
                i[t] = o.addAll(n[t].getPropertyIds()) ? RL : NL;
        else
            t: for (let a = 0; a < r; a++) {
                const r = n[a]
                  , l = r.getPropertyIds();
                if (o.addAll(l))
                    if (!e || r instanceof hL || r instanceof gL || r instanceof pL || !e.animation.hasTimeline(l))
                        i[a] = OL;
                    else {
                        for (let n = e.mixingTo; n; n = n.mixingTo)
                            if (!n.animation.hasTimeline(l)) {
                                if (t.mixDuration > 0) {
                                    i[a] = DL,
                                    s[a] = n;
                                    continue t
                                }
                                break
                            }
                        i[a] = RL
                    }
                else
                    i[a] = PL
            }
    }
    getCurrent(t) {
        return t >= this.tracks.length ? null : this.tracks[t]
    }
    addListener(t) {
        if (!t)
            throw new Error("listener cannot be null.");
        this.listeners.push(t)
    }
    removeListener(t) {
        const e = this.listeners.indexOf(t);
        e >= 0 && this.listeners.splice(e, 1)
    }
    clearListeners() {
        this.listeners.length = 0
    }
    clearListenerNotifications() {
        this.queue.clear()
    }
    setAnimationByName(t, e, n) {
        AL.deprecatedWarning1 || (AL.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),
        this.setAnimation(t, e, n)
    }
    addAnimationByName(t, e, n, r) {
        AL.deprecatedWarning2 || (AL.deprecatedWarning2 = !0,
        console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),
        this.addAnimation(t, e, n, r)
    }
    hasAnimation(t) {
        return null !== this.data.skeletonData.findAnimation(t)
    }
    hasAnimationByName(t) {
        return AL.deprecatedWarning3 || (AL.deprecatedWarning3 = !0,
        console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),
        this.hasAnimation(t)
    }
}
;
let SL = AL;
SL._emptyAnimation = new SB("<empty>",[],0),
SL.deprecatedWarning1 = !1,
SL.deprecatedWarning2 = !1,
SL.deprecatedWarning3 = !1;
const TL = class {
    constructor() {
        this.animation = null,
        this.previous = null,
        this.next = null,
        this.mixingFrom = null,
        this.mixingTo = null,
        this.listener = null,
        this.trackIndex = 0,
        this.loop = !1,
        this.holdPrevious = !1,
        this.reverse = !1,
        this.shortestRotation = !1,
        this.eventThreshold = 0,
        this.attachmentThreshold = 0,
        this.drawOrderThreshold = 0,
        this.animationStart = 0,
        this.animationEnd = 0,
        this.animationLast = 0,
        this.nextAnimationLast = 0,
        this.delay = 0,
        this.trackTime = 0,
        this.trackLast = 0,
        this.nextTrackLast = 0,
        this.trackEnd = 0,
        this.timeScale = 0,
        this.alpha = 0,
        this.mixTime = 0,
        this.mixDuration = 0,
        this.interruptAlpha = 0,
        this.totalAlpha = 0,
        this.mixBlend = OO.replace,
        this.timelineMode = new Array,
        this.timelineHoldMix = new Array,
        this.timelinesRotation = new Array
    }
    reset() {
        this.next = null,
        this.previous = null,
        this.mixingFrom = null,
        this.mixingTo = null,
        this.animation = null,
        this.listener = null,
        this.timelineMode.length = 0,
        this.timelineHoldMix.length = 0,
        this.timelinesRotation.length = 0
    }
    getAnimationTime() {
        if (this.loop) {
            const t = this.animationEnd - this.animationStart;
            return 0 == t ? this.animationStart : this.trackTime % t + this.animationStart
        }
        return Math.min(this.trackTime + this.animationStart, this.animationEnd)
    }
    setAnimationLast(t) {
        this.animationLast = t,
        this.nextAnimationLast = t
    }
    isComplete() {
        return this.trackTime >= this.animationEnd - this.animationStart
    }
    resetRotationDirections() {
        this.timelinesRotation.length = 0
    }
    getTrackComplete() {
        const t = this.animationEnd - this.animationStart;
        if (0 != t) {
            if (this.loop)
                return t * (1 + (this.trackTime / t | 0));
            if (this.trackTime < t)
                return t
        }
        return this.trackTime
    }
    get time() {
        return TL.deprecatedWarning1 || (TL.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
        this.trackTime
    }
    set time(t) {
        TL.deprecatedWarning1 || (TL.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),
        this.trackTime = t
    }
    get endTime() {
        return TL.deprecatedWarning2 || (TL.deprecatedWarning2 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
        this.trackTime
    }
    set endTime(t) {
        TL.deprecatedWarning2 || (TL.deprecatedWarning2 = !0,
        console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),
        this.trackTime = t
    }
    loopsCount() {
        return Math.floor(this.trackTime / this.trackEnd)
    }
}
;
let kL = TL;
kL.deprecatedWarning1 = !1,
kL.deprecatedWarning2 = !1;
class IL {
    constructor(t) {
        this.objects = [],
        this.drainDisabled = !1,
        this.animState = t
    }
    start(t) {
        this.objects.push(ML.start),
        this.objects.push(t),
        this.animState.animationsChanged = !0
    }
    interrupt(t) {
        this.objects.push(ML.interrupt),
        this.objects.push(t)
    }
    end(t) {
        this.objects.push(ML.end),
        this.objects.push(t),
        this.animState.animationsChanged = !0
    }
    dispose(t) {
        this.objects.push(ML.dispose),
        this.objects.push(t)
    }
    complete(t) {
        this.objects.push(ML.complete),
        this.objects.push(t)
    }
    event(t, e) {
        this.objects.push(ML.event),
        this.objects.push(t),
        this.objects.push(e)
    }
    drain() {
        if (this.drainDisabled)
            return;
        this.drainDisabled = !0;
        const t = this.objects
          , e = this.animState.listeners;
        for (let n = 0; n < t.length; n += 2) {
            const r = t[n]
              , i = t[n + 1];
            switch (r) {
            case ML.start:
                i.listener && i.listener.start && i.listener.start(i);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.start && n.start(i)
                }
                break;
            case ML.interrupt:
                i.listener && i.listener.interrupt && i.listener.interrupt(i);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.interrupt && n.interrupt(i)
                }
                break;
            case ML.end:
                i.listener && i.listener.end && i.listener.end(i);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.end && n.end(i)
                }
            case ML.dispose:
                i.listener && i.listener.dispose && i.listener.dispose(i);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.dispose && n.dispose(i)
                }
                this.animState.trackEntryPool.free(i);
                break;
            case ML.complete:
                i.listener && i.listener.complete && i.listener.complete(i);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.complete && n.complete(i)
                }
                break;
            case ML.event:
                const r = t[2 + n++];
                i.listener && i.listener.event && i.listener.event(i, r);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.event && n.event(i, r)
                }
            }
        }
        this.clear(),
        this.drainDisabled = !1
    }
    clear() {
        this.objects.length = 0
    }
}
var ML = (t=>(t[t.start = 0] = "start",
t[t.interrupt = 1] = "interrupt",
t[t.end = 2] = "end",
t[t.dispose = 3] = "dispose",
t[t.complete = 4] = "complete",
t[t.event = 5] = "event",
t))(ML || {});
class CL {
    start(t) {}
    interrupt(t) {}
    end(t) {}
    dispose(t) {}
    complete(t) {}
    event(t, e) {}
}
const PL = 0
  , OL = 1
  , NL = 2
  , RL = 3
  , DL = 4
  , BL = 1
  , LL = 2;
class FL {
    constructor(t) {
        if (this.animationToMixTime = {},
        this.defaultMix = 0,
        !t)
            throw new Error("skeletonData cannot be null.");
        this.skeletonData = t
    }
    setMix(t, e, n) {
        const r = this.skeletonData.findAnimation(t);
        if (!r)
            throw new Error(`Animation not found: ${t}`);
        const i = this.skeletonData.findAnimation(e);
        if (!i)
            throw new Error(`Animation not found: ${e}`);
        this.setMixWith(r, i, n)
    }
    setMixWith(t, e, n) {
        if (!t)
            throw new Error("from cannot be null.");
        if (!e)
            throw new Error("to cannot be null.");
        const r = `${t.name}.${e.name}`;
        this.animationToMixTime[r] = n
    }
    getMix(t, e) {
        const n = `${t.name}.${e.name}`
          , r = this.animationToMixTime[n];
        return void 0 === r ? this.defaultMix : r
    }
}
class jL {
    constructor(t) {
        this.atlas = t
    }
    loadSequence(t, e, n) {
        const r = n.regions;
        for (let i = 0, s = r.length; i < s; i++) {
            const s = n.getPath(e, i)
              , o = this.atlas.findRegion(s);
            if (null == o)
                throw new Error(`Region not found in atlas: ${s} (sequence: ${t})`);
            r[i] = o,
            r[i].renderObject = r[i]
        }
    }
    newRegionAttachment(t, e, n, r) {
        const i = new wB(e,n);
        if (null != r)
            this.loadSequence(e, n, r);
        else {
            const t = this.atlas.findRegion(n);
            if (!t)
                throw new Error(`Region not found in atlas: ${n} (region attachment: ${e})`);
            t.renderObject = t,
            i.region = t
        }
        return i
    }
    newMeshAttachment(t, e, n, r) {
        const i = new gB(e,n);
        if (null != r)
            this.loadSequence(e, n, r);
        else {
            const t = this.atlas.findRegion(n);
            if (!t)
                throw new Error(`Region not found in atlas: ${n} (mesh attachment: ${e})`);
            t.renderObject = t,
            i.region = t
        }
        return i
    }
    newBoundingBoxAttachment(t, e) {
        return new pB(e)
    }
    newPathAttachment(t, e) {
        return new yB(e)
    }
    newPointAttachment(t, e) {
        return new bB(e)
    }
    newClippingAttachment(t, e) {
        return new mB(e)
    }
}
class UL {
    constructor(t, e, n) {
        if (this.matrix = new Sv,
        this.parent = null,
        this.children = new Array,
        this.x = 0,
        this.y = 0,
        this.rotation = 0,
        this.scaleX = 0,
        this.scaleY = 0,
        this.shearX = 0,
        this.shearY = 0,
        this.ax = 0,
        this.ay = 0,
        this.arotation = 0,
        this.ascaleX = 0,
        this.ascaleY = 0,
        this.ashearX = 0,
        this.ashearY = 0,
        this.sorted = !1,
        this.active = !1,
        !t)
            throw new Error("data cannot be null.");
        if (!e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.skeleton = e,
        this.parent = n,
        this.setToSetupPose()
    }
    get worldX() {
        return this.matrix.tx
    }
    get worldY() {
        return this.matrix.ty
    }
    isActive() {
        return this.active
    }
    update() {
        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY)
    }
    updateWorldTransform() {
        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
    }
    updateWorldTransformWith(t, e, n, r, i, s, o) {
        this.ax = t,
        this.ay = e,
        this.arotation = n,
        this.ascaleX = r,
        this.ascaleY = i,
        this.ashearX = s,
        this.ashearY = o;
        const a = this.parent
          , l = this.matrix
          , c = this.skeleton.scaleX
          , u = oN.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
        if (!a) {
            const a = this.skeleton
              , h = n + 90 + o;
            return l.a = QO.cosDeg(n + s) * r * c,
            l.c = QO.cosDeg(h) * i * c,
            l.b = QO.sinDeg(n + s) * r * u,
            l.d = QO.sinDeg(h) * i * u,
            l.tx = t * c + a.x,
            void (l.ty = e * u + a.y)
        }
        let h = a.matrix.a
          , d = a.matrix.c
          , f = a.matrix.b
          , p = a.matrix.d;
        switch (l.tx = h * t + d * e + a.matrix.tx,
        l.ty = f * t + p * e + a.matrix.ty,
        this.data.transformMode) {
        case BO.Normal:
            {
                const t = n + 90 + o
                  , e = QO.cosDeg(n + s) * r
                  , a = QO.cosDeg(t) * i
                  , c = QO.sinDeg(n + s) * r
                  , u = QO.sinDeg(t) * i;
                return l.a = h * e + d * c,
                l.c = h * a + d * u,
                l.b = f * e + p * c,
                void (l.d = f * a + p * u)
            }
        case BO.OnlyTranslation:
            {
                const t = n + 90 + o;
                l.a = QO.cosDeg(n + s) * r,
                l.c = QO.cosDeg(t) * i,
                l.b = QO.sinDeg(n + s) * r,
                l.d = QO.sinDeg(t) * i;
                break
            }
        case BO.NoRotationOrReflection:
            {
                let t = h * h + f * f
                  , e = 0;
                t > 1e-4 ? (t = Math.abs(h * p - d * f) / t,
                h /= c,
                f /= u,
                d = f * t,
                p = h * t,
                e = Math.atan2(f, h) * QO.radDeg) : (h = 0,
                f = 0,
                e = 90 - Math.atan2(p, d) * QO.radDeg);
                const a = n + s - e
                  , m = n + o - e + 90
                  , g = QO.cosDeg(a) * r
                  , y = QO.cosDeg(m) * i
                  , b = QO.sinDeg(a) * r
                  , v = QO.sinDeg(m) * i;
                l.a = h * g - d * b,
                l.c = h * y - d * v,
                l.b = f * g + p * b,
                l.d = f * y + p * v;
                break
            }
        case BO.NoScale:
        case BO.NoScaleOrReflection:
            {
                const t = QO.cosDeg(n)
                  , e = QO.sinDeg(n);
                let a = (h * t + d * e) / c
                  , m = (f * t + p * e) / u
                  , g = Math.sqrt(a * a + m * m);
                g > 1e-5 && (g = 1 / g),
                a *= g,
                m *= g,
                g = Math.sqrt(a * a + m * m),
                this.data.transformMode == BO.NoScale && h * p - d * f < 0 != (c < 0 != u < 0) && (g = -g);
                const y = Math.PI / 2 + Math.atan2(m, a)
                  , b = Math.cos(y) * g
                  , v = Math.sin(y) * g
                  , w = QO.cosDeg(s) * r
                  , x = QO.cosDeg(90 + o) * i
                  , E = QO.sinDeg(s) * r
                  , _ = QO.sinDeg(90 + o) * i;
                l.a = a * w + b * E,
                l.c = a * x + b * _,
                l.b = m * w + v * E,
                l.d = m * x + v * _;
                break
            }
        }
        l.a *= c,
        l.c *= c,
        l.b *= u,
        l.d *= u
    }
    setToSetupPose() {
        const t = this.data;
        this.x = t.x,
        this.y = t.y,
        this.rotation = t.rotation,
        this.scaleX = t.scaleX,
        this.scaleY = t.scaleY,
        this.shearX = t.shearX,
        this.shearY = t.shearY
    }
    getWorldRotationX() {
        return Math.atan2(this.matrix.b, this.matrix.a) * QO.radDeg
    }
    getWorldRotationY() {
        return Math.atan2(this.matrix.d, this.matrix.c) * QO.radDeg
    }
    getWorldScaleX() {
        const t = this.matrix;
        return Math.sqrt(t.a * t.a + t.b * t.b)
    }
    getWorldScaleY() {
        const t = this.matrix;
        return Math.sqrt(t.c * t.c + t.d * t.d)
    }
    updateAppliedTransform() {
        const t = this.parent
          , e = this.matrix;
        if (!t)
            return this.ax = e.tx - this.skeleton.x,
            this.ay = e.ty - this.skeleton.y,
            this.arotation = Math.atan2(e.b, e.a) * QO.radDeg,
            this.ascaleX = Math.sqrt(e.a * e.a + e.b * e.b),
            this.ascaleY = Math.sqrt(e.c * e.c + e.d * e.d),
            this.ashearX = 0,
            void (this.ashearY = Math.atan2(e.a * e.c + e.b * e.d, e.a * e.d - e.b * e.c) * QO.radDeg);
        const n = t.matrix
          , r = 1 / (n.a * n.d - n.b * n.c)
          , i = e.tx - n.tx
          , s = e.ty - n.ty;
        this.ax = i * n.d * r - s * n.c * r,
        this.ay = s * n.a * r - i * n.b * r;
        const o = r * n.d
          , a = r * n.a
          , l = r * n.c
          , c = r * n.b
          , u = o * e.a - l * e.b
          , h = o * e.c - l * e.d
          , d = a * e.b - c * e.a
          , f = a * e.d - c * e.c;
        if (this.ashearX = 0,
        this.ascaleX = Math.sqrt(u * u + d * d),
        this.ascaleX > 1e-4) {
            const t = u * f - h * d;
            this.ascaleY = t / this.ascaleX,
            this.ashearY = Math.atan2(u * h + d * f, t) * QO.radDeg,
            this.arotation = Math.atan2(d, u) * QO.radDeg
        } else
            this.ascaleX = 0,
            this.ascaleY = Math.sqrt(h * h + f * f),
            this.ashearY = 0,
            this.arotation = 90 - Math.atan2(f, h) * QO.radDeg
    }
    worldToLocal(t) {
        const e = this.matrix
          , n = e.a
          , r = e.c
          , i = e.b
          , s = e.d
          , o = 1 / (n * s - r * i)
          , a = t.x - e.tx
          , l = t.y - e.ty;
        return t.x = a * s * o - l * r * o,
        t.y = l * n * o - a * i * o,
        t
    }
    localToWorld(t) {
        const e = this.matrix
          , n = t.x
          , r = t.y;
        return t.x = n * e.a + r * e.c + e.tx,
        t.y = n * e.b + r * e.d + e.ty,
        t
    }
    worldToLocalRotation(t) {
        const e = QO.sinDeg(t)
          , n = QO.cosDeg(t)
          , r = this.matrix;
        return Math.atan2(r.a * e - r.b * n, r.d * n - r.c * e) * QO.radDeg
    }
    localToWorldRotation(t) {
        t -= this.rotation - this.shearX;
        const e = QO.sinDeg(t)
          , n = QO.cosDeg(t)
          , r = this.matrix;
        return Math.atan2(n * r.b + e * r.d, n * r.a + e * r.c) * QO.radDeg
    }
    rotateWorld(t) {
        const e = this.matrix
          , n = e.a
          , r = e.c
          , i = e.b
          , s = e.d
          , o = QO.cosDeg(t)
          , a = QO.sinDeg(t);
        e.a = o * n - a * i,
        e.c = o * r - a * s,
        e.b = a * n + o * i,
        e.d = a * r + o * s
    }
}
class zL {
    constructor(t, e, n) {
        if (this.index = 0,
        this.parent = null,
        this.length = 0,
        this.x = 0,
        this.y = 0,
        this.rotation = 0,
        this.scaleX = 1,
        this.scaleY = 1,
        this.shearX = 0,
        this.shearY = 0,
        this.transformMode = BO.Normal,
        this.skinRequired = !1,
        this.color = new qO,
        t < 0)
            throw new Error("index must be >= 0.");
        if (!e)
            throw new Error("name cannot be null.");
        this.index = t,
        this.name = e,
        this.parent = n
    }
}
class VL {
    constructor(t, e, n) {
        this.name = t,
        this.order = e,
        this.skinRequired = n
    }
}
class WL {
    constructor(t, e) {
        if (this.intValue = 0,
        this.floatValue = 0,
        this.stringValue = null,
        this.time = 0,
        this.volume = 0,
        this.balance = 0,
        !e)
            throw new Error("data cannot be null.");
        this.time = t,
        this.data = e
    }
}
class YL {
    constructor(t) {
        this.intValue = 0,
        this.floatValue = 0,
        this.stringValue = null,
        this.audioPath = null,
        this.volume = 0,
        this.balance = 0,
        this.name = t
    }
}
class HL {
    constructor(t, e) {
        if (this.bendDirection = 0,
        this.compress = !1,
        this.stretch = !1,
        this.mix = 1,
        this.softness = 0,
        this.active = !1,
        !t)
            throw new Error("data cannot be null.");
        if (!e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.mix = t.mix,
        this.softness = t.softness,
        this.bendDirection = t.bendDirection,
        this.compress = t.compress,
        this.stretch = t.stretch,
        this.bones = new Array;
        for (let n = 0; n < t.bones.length; n++) {
            const r = e.findBone(t.bones[n].name);
            if (!r)
                throw new Error(`Couldn't find bone ${t.bones[n].name}`);
            this.bones.push(r)
        }
        const n = e.findBone(t.target.name);
        if (!n)
            throw new Error(`Couldn't find bone ${t.target.name}`);
        this.target = n
    }
    isActive() {
        return this.active
    }
    update() {
        if (0 == this.mix)
            return;
        const t = this.target
          , e = this.bones;
        switch (e.length) {
        case 1:
            this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
            break;
        case 2:
            this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix)
        }
    }
    apply1(t, e, n, r, i, s, o) {
        const a = t.parent.matrix;
        if (!a)
            throw new Error("IK bone must have parent.");
        const l = a.a;
        let c = a.c;
        const u = a.b;
        let h = a.d
          , d = -t.ashearX - t.arotation
          , f = 0
          , p = 0;
        const m = t.skeleton.scaleX
          , g = oN.yDown ? -t.skeleton.scaleY : t.skeleton.scaleY;
        switch (t.data.transformMode) {
        case BO.OnlyTranslation:
            f = e - t.worldX,
            p = n - t.worldY,
            oN.yDown && (p = -p);
            break;
        case BO.NoRotationOrReflection:
            const r = Math.abs(l * h - c * u) / (l * l + u * u)
              , i = l / m
              , s = u / g;
            c = -s * r * m,
            h = i * r * g,
            d += Math.atan2(s, i) * QO.radDeg;
        default:
            const o = e - a.tx
              , y = n - a.ty
              , b = l * h - c * u;
            f = (o * h - y * c) / b - t.ax,
            p = (y * l - o * u) / b - t.ay
        }
        d += Math.atan2(p, f) * QO.radDeg,
        t.ascaleX < 0 && (d += 180),
        d > 180 ? d -= 360 : d < -180 && (d += 360);
        let y = t.ascaleX
          , b = t.ascaleY;
        if (r || i) {
            switch (t.data.transformMode) {
            case BO.NoScale:
            case BO.NoScaleOrReflection:
                f = e - t.worldX,
                p = n - t.worldY
            }
            const a = t.data.length * y
              , l = Math.sqrt(f * f + p * p);
            if (r && l < a || i && l > a && a > 1e-4) {
                const t = (l / a - 1) * o + 1;
                y *= t,
                s && (b *= t)
            }
        }
        t.updateWorldTransformWith(t.ax, t.ay, t.arotation + d * o, y, b, t.ashearX, t.ashearY)
    }
    apply2(t, e, n, r, i, s, o, a, l) {
        const c = t.ax
          , u = t.ay;
        let h = t.ascaleX
          , d = t.ascaleY
          , f = h
          , p = d
          , m = e.ascaleX;
        const g = t.matrix;
        let y = 0
          , b = 0
          , v = 0;
        h < 0 ? (h = -h,
        y = 180,
        v = -1) : (y = 0,
        v = 1),
        d < 0 && (d = -d,
        v = -v),
        m < 0 ? (m = -m,
        b = 180) : b = 0;
        const w = e.ax;
        let x = 0
          , E = 0
          , _ = 0
          , A = g.a
          , S = g.c
          , T = g.b
          , k = g.d;
        const I = Math.abs(h - d) <= 1e-4;
        !I || s ? (x = 0,
        E = A * w + g.tx,
        _ = T * w + g.ty) : (x = e.ay,
        E = A * w + S * x + g.tx,
        _ = T * w + k * x + g.ty);
        const M = t.parent.matrix;
        if (!M)
            throw new Error("IK parent must itself have a parent.");
        A = M.a,
        S = M.c,
        T = M.b,
        k = M.d;
        const C = 1 / (A * k - S * T);
        let P = E - M.tx
          , O = _ - M.ty;
        const N = (P * k - O * S) * C - c
          , R = (O * A - P * T) * C - u
          , D = Math.sqrt(N * N + R * R);
        let B, L, F = e.data.length * m;
        if (D < 1e-4)
            return this.apply1(t, n, r, !1, s, !1, l),
            void e.updateWorldTransformWith(w, x, 0, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY);
        P = n - M.tx,
        O = r - M.ty;
        let j = (P * k - O * S) * C - c
          , U = (O * A - P * T) * C - u
          , z = j * j + U * U;
        if (0 != a) {
            a *= h * (m + 1) * .5;
            const t = Math.sqrt(z)
              , e = t - D - F * h + a;
            if (e > 0) {
                let n = Math.min(1, e / (2 * a)) - 1;
                n = (e - a * (1 - n * n)) / t,
                j -= n * j,
                U -= n * U,
                z = j * j + U * U
            }
        }
        t: if (I) {
            F *= h;
            let t = (z - D * D - F * F) / (2 * D * F);
            t < -1 ? (t = -1,
            L = Math.PI * i) : t > 1 ? (t = 1,
            L = 0,
            s && (A = (Math.sqrt(z) / (D + F) - 1) * l + 1,
            f *= A,
            o && (p *= A))) : L = Math.acos(t) * i,
            A = D + F * t,
            S = F * Math.sin(L),
            B = Math.atan2(U * A - j * S, j * A + U * S)
        } else {
            A = h * F,
            S = d * F;
            const t = A * A
              , e = S * S
              , n = Math.atan2(U, j);
            T = e * D * D + t * z - t * e;
            const r = -2 * e * D
              , s = e - t;
            if (k = r * r - 4 * s * T,
            k >= 0) {
                let t = Math.sqrt(k);
                r < 0 && (t = -t),
                t = .5 * -(r + t);
                const e = t / s
                  , o = T / t
                  , a = Math.abs(e) < Math.abs(o) ? e : o;
                if (a * a <= z) {
                    O = Math.sqrt(z - a * a) * i,
                    B = n - Math.atan2(O, a),
                    L = Math.atan2(O / d, (a - D) / h);
                    break t
                }
            }
            let o = QO.PI
              , a = D - A
              , l = a * a
              , c = 0
              , u = 0
              , f = D + A
              , p = f * f
              , m = 0;
            T = -A * D / (t - e),
            T >= -1 && T <= 1 && (T = Math.acos(T),
            P = A * Math.cos(T) + D,
            O = S * Math.sin(T),
            k = P * P + O * O,
            k < l && (o = T,
            l = k,
            a = P,
            c = O),
            k > p && (u = T,
            p = k,
            f = P,
            m = O)),
            z <= .5 * (l + p) ? (B = n - Math.atan2(c * i, a),
            L = o * i) : (B = n - Math.atan2(m * i, f),
            L = u * i)
        }
        const V = Math.atan2(x, w) * v;
        let W = t.arotation;
        B = (B - V) * QO.radDeg + y - W,
        B > 180 ? B -= 360 : B < -180 && (B += 360),
        t.updateWorldTransformWith(c, u, W + B * l, f, p, 0, 0),
        W = e.arotation,
        L = ((L + V) * QO.radDeg - e.ashearX) * v + b - W,
        L > 180 ? L -= 360 : L < -180 && (L += 360),
        e.updateWorldTransformWith(w, x, W + L * l, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY)
    }
}
class $L extends VL {
    constructor(t) {
        super(t, 0, !1),
        this.bones = new Array,
        this._target = null,
        this.bendDirection = 1,
        this.compress = !1,
        this.stretch = !1,
        this.uniform = !1,
        this.mix = 1,
        this.softness = 0
    }
    set target(t) {
        this._target = t
    }
    get target() {
        if (this._target)
            return this._target;
        throw new Error("BoneData not set.")
    }
}
class GL extends VL {
    constructor(t) {
        super(t, 0, !1),
        this.bones = new Array,
        this._target = null,
        this.positionMode = RO.Fixed,
        this.spacingMode = XL.Fixed,
        this.rotateMode = DO.Chain,
        this.offsetRotation = 0,
        this.position = 0,
        this.spacing = 0,
        this.mixRotate = 0,
        this.mixX = 0,
        this.mixY = 0
    }
    set target(t) {
        this._target = t
    }
    get target() {
        if (this._target)
            return this._target;
        throw new Error("SlotData not set.")
    }
}
var XL = (t=>(t[t.Length = 0] = "Length",
t[t.Fixed = 1] = "Fixed",
t[t.Percent = 2] = "Percent",
t[t.Proportional = 3] = "Proportional",
t))(XL || {});
const qL = class {
    constructor(t, e) {
        if (this.position = 0,
        this.spacing = 0,
        this.mixRotate = 0,
        this.mixX = 0,
        this.mixY = 0,
        this.spaces = new Array,
        this.positions = new Array,
        this.world = new Array,
        this.curves = new Array,
        this.lengths = new Array,
        this.segments = new Array,
        this.active = !1,
        !t)
            throw new Error("data cannot be null.");
        if (!e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.bones = new Array;
        for (let n = 0, r = t.bones.length; n < r; n++) {
            const r = e.findBone(t.bones[n].name);
            if (!r)
                throw new Error(`Couldn't find bone ${t.bones[n].name}.`);
            this.bones.push(r)
        }
        const n = e.findSlot(t.target.name);
        if (!n)
            throw new Error(`Couldn't find target bone ${t.target.name}`);
        this.target = n,
        this.position = t.position,
        this.spacing = t.spacing,
        this.mixRotate = t.mixRotate,
        this.mixX = t.mixX,
        this.mixY = t.mixY
    }
    isActive() {
        return this.active
    }
    update() {
        const t = this.target.getAttachment();
        if (!(t instanceof yB))
            return;
        const e = this.mixRotate
          , n = this.mixX
          , r = this.mixY;
        if (0 == e && 0 == n && 0 == r)
            return;
        const i = this.data
          , s = i.rotateMode == DO.Tangent
          , o = i.rotateMode == DO.ChainScale
          , a = this.bones
          , l = a.length
          , c = s ? l : l + 1
          , u = nN.setArraySize(this.spaces, c)
          , h = o ? this.lengths = nN.setArraySize(this.lengths, l) : []
          , d = this.spacing;
        switch (i.spacingMode) {
        case XL.Percent:
            if (o)
                for (let t = 0, e = c - 1; t < e; t++) {
                    const e = a[t]
                      , n = e.data.length;
                    if (n < qL.epsilon)
                        h[t] = 0;
                    else {
                        const r = n * e.matrix.a
                          , i = n * e.matrix.b;
                        h[t] = Math.sqrt(r * r + i * i)
                    }
                }
            nN.arrayFill(u, 1, c, d);
            break;
        case XL.Proportional:
            let t = 0;
            for (let e = 0, n = c - 1; e < n; ) {
                const n = a[e]
                  , r = n.data.length;
                if (r < qL.epsilon)
                    o && (h[e] = 0),
                    u[++e] = d;
                else {
                    const i = r * n.matrix.a
                      , s = r * n.matrix.b
                      , a = Math.sqrt(i * i + s * s);
                    o && (h[e] = a),
                    u[++e] = a,
                    t += a
                }
            }
            if (t > 0) {
                t = c / t * d;
                for (let e = 1; e < c; e++)
                    u[e] *= t
            }
            break;
        default:
            const e = i.spacingMode == XL.Length;
            for (let t = 0, n = c - 1; t < n; ) {
                const n = a[t]
                  , r = n.data.length;
                if (r < qL.epsilon)
                    o && (h[t] = 0),
                    u[++t] = d;
                else {
                    const i = r * n.matrix.a
                      , s = r * n.matrix.b
                      , a = Math.sqrt(i * i + s * s);
                    o && (h[t] = a),
                    u[++t] = (e ? r + d : d) * a / r
                }
            }
        }
        const f = this.computeWorldPositions(t, c, s);
        let p = f[0]
          , m = f[1]
          , g = i.offsetRotation
          , y = !1;
        if (0 == g)
            y = i.rotateMode == DO.Chain;
        else {
            y = !1;
            const t = this.target.bone.matrix;
            g *= t.a * t.d - t.b * t.c > 0 ? QO.degRad : -QO.degRad
        }
        for (let t = 0, i = 3; t < l; t++,
        i += 3) {
            const l = a[t]
              , c = l.matrix;
            c.tx += (p - c.tx) * n,
            c.ty += (m - c.ty) * r;
            const d = f[i]
              , b = f[i + 1]
              , v = d - p
              , w = b - m;
            if (o) {
                const n = h[t];
                if (0 != n) {
                    const t = (Math.sqrt(v * v + w * w) / n - 1) * e + 1;
                    c.a *= t,
                    c.b *= t
                }
            }
            if (p = d,
            m = b,
            e > 0) {
                const n = c.a
                  , r = c.c
                  , o = c.b
                  , a = c.d;
                let h = 0
                  , d = 0
                  , b = 0;
                if (h = s ? f[i - 1] : 0 == u[t + 1] ? f[i + 2] : Math.atan2(w, v),
                h -= Math.atan2(o, n),
                y) {
                    d = Math.cos(h),
                    b = Math.sin(h);
                    const t = l.data.length;
                    p += (t * (d * n - b * o) - v) * e,
                    m += (t * (b * n + d * o) - w) * e
                } else
                    h += g;
                h > QO.PI ? h -= QO.PI2 : h < -QO.PI && (h += QO.PI2),
                h *= e,
                d = Math.cos(h),
                b = Math.sin(h),
                c.a = d * n - b * o,
                c.c = d * r - b * a,
                c.b = b * n + d * o,
                c.d = b * r + d * a
            }
            l.updateAppliedTransform()
        }
    }
    computeWorldPositions(t, e, n) {
        const r = this.target;
        let i = this.position;
        const s = this.spaces
          , o = nN.setArraySize(this.positions, 3 * e + 2);
        let a = this.world;
        const l = t.closed;
        let c = t.worldVerticesLength
          , u = c / 6
          , h = qL.NONE;
        if (!t.constantSpeed) {
            const d = t.lengths;
            u -= l ? 1 : 2;
            const f = d[u];
            let p;
            switch (this.data.positionMode == RO.Percent && (i *= f),
            this.data.spacingMode) {
            case XL.Percent:
                p = f;
                break;
            case XL.Proportional:
                p = f / e;
                break;
            default:
                p = 1
            }
            a = nN.setArraySize(this.world, 8);
            for (let m = 0, g = 0, y = 0; m < e; m++,
            g += 3) {
                const e = s[m] * p;
                i += e;
                let b = i;
                if (l)
                    b %= f,
                    b < 0 && (b += f),
                    y = 0;
                else {
                    if (b < 0) {
                        h != qL.BEFORE && (h = qL.BEFORE,
                        t.computeWorldVertices(r, 2, 4, a, 0, 2)),
                        this.addBeforePosition(b, a, 0, o, g);
                        continue
                    }
                    if (b > f) {
                        h != qL.AFTER && (h = qL.AFTER,
                        t.computeWorldVertices(r, c - 6, 4, a, 0, 2)),
                        this.addAfterPosition(b - f, a, 0, o, g);
                        continue
                    }
                }
                for (; ; y++) {
                    const t = d[y];
                    if (!(b > t)) {
                        if (0 == y)
                            b /= t;
                        else {
                            const e = d[y - 1];
                            b = (b - e) / (t - e)
                        }
                        break
                    }
                }
                y != h && (h = y,
                l && y == u ? (t.computeWorldVertices(r, c - 4, 4, a, 0, 2),
                t.computeWorldVertices(r, 0, 4, a, 4, 2)) : t.computeWorldVertices(r, 6 * y + 2, 8, a, 0, 2)),
                this.addCurvePosition(b, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], o, g, n || m > 0 && 0 == e)
            }
            return o
        }
        l ? (c += 2,
        a = nN.setArraySize(this.world, c),
        t.computeWorldVertices(r, 2, c - 4, a, 0, 2),
        t.computeWorldVertices(r, 0, 2, a, c - 4, 2),
        a[c - 2] = a[0],
        a[c - 1] = a[1]) : (u--,
        c -= 4,
        a = nN.setArraySize(this.world, c),
        t.computeWorldVertices(r, 2, c, a, 0, 2));
        const d = nN.setArraySize(this.curves, u);
        let f, p = 0, m = a[0], g = a[1], y = 0, b = 0, v = 0, w = 0, x = 0, E = 0, _ = 0, A = 0, S = 0, T = 0, k = 0, I = 0, M = 0, C = 0;
        for (let t = 0, e = 2; t < u; t++,
        e += 6)
            y = a[e],
            b = a[e + 1],
            v = a[e + 2],
            w = a[e + 3],
            x = a[e + 4],
            E = a[e + 5],
            _ = .1875 * (m - 2 * y + v),
            A = .1875 * (g - 2 * b + w),
            S = .09375 * (3 * (y - v) - m + x),
            T = .09375 * (3 * (b - w) - g + E),
            k = 2 * _ + S,
            I = 2 * A + T,
            M = .75 * (y - m) + _ + .16666667 * S,
            C = .75 * (b - g) + A + .16666667 * T,
            p += Math.sqrt(M * M + C * C),
            M += k,
            C += I,
            k += S,
            I += T,
            p += Math.sqrt(M * M + C * C),
            M += k,
            C += I,
            p += Math.sqrt(M * M + C * C),
            M += k + S,
            C += I + T,
            p += Math.sqrt(M * M + C * C),
            d[t] = p,
            m = x,
            g = E;
        switch (this.data.positionMode == RO.Percent && (i *= p),
        this.data.spacingMode) {
        case XL.Percent:
            f = p;
            break;
        case XL.Proportional:
            f = p / e;
            break;
        default:
            f = 1
        }
        const P = this.segments;
        let O = 0;
        for (let t = 0, r = 0, u = 0, N = 0; t < e; t++,
        r += 3) {
            const e = s[t] * f;
            i += e;
            let R = i;
            if (l)
                R %= p,
                R < 0 && (R += p),
                u = 0;
            else {
                if (R < 0) {
                    this.addBeforePosition(R, a, 0, o, r);
                    continue
                }
                if (R > p) {
                    this.addAfterPosition(R - p, a, c - 4, o, r);
                    continue
                }
            }
            for (; ; u++) {
                const t = d[u];
                if (!(R > t)) {
                    if (0 == u)
                        R /= t;
                    else {
                        const e = d[u - 1];
                        R = (R - e) / (t - e)
                    }
                    break
                }
            }
            if (u != h) {
                h = u;
                let t = 6 * u;
                for (m = a[t],
                g = a[t + 1],
                y = a[t + 2],
                b = a[t + 3],
                v = a[t + 4],
                w = a[t + 5],
                x = a[t + 6],
                E = a[t + 7],
                _ = .03 * (m - 2 * y + v),
                A = .03 * (g - 2 * b + w),
                S = .006 * (3 * (y - v) - m + x),
                T = .006 * (3 * (b - w) - g + E),
                k = 2 * _ + S,
                I = 2 * A + T,
                M = .3 * (y - m) + _ + .16666667 * S,
                C = .3 * (b - g) + A + .16666667 * T,
                O = Math.sqrt(M * M + C * C),
                P[0] = O,
                t = 1; t < 8; t++)
                    M += k,
                    C += I,
                    k += S,
                    I += T,
                    O += Math.sqrt(M * M + C * C),
                    P[t] = O;
                M += k,
                C += I,
                O += Math.sqrt(M * M + C * C),
                P[8] = O,
                M += k + S,
                C += I + T,
                O += Math.sqrt(M * M + C * C),
                P[9] = O,
                N = 0
            }
            for (R *= O; ; N++) {
                const t = P[N];
                if (!(R > t)) {
                    if (0 == N)
                        R /= t;
                    else {
                        const e = P[N - 1];
                        R = N + (R - e) / (t - e)
                    }
                    break
                }
            }
            this.addCurvePosition(.1 * R, m, g, y, b, v, w, x, E, o, r, n || t > 0 && 0 == e)
        }
        return o
    }
    addBeforePosition(t, e, n, r, i) {
        const s = e[n]
          , o = e[n + 1]
          , a = e[n + 2] - s
          , l = e[n + 3] - o
          , c = Math.atan2(l, a);
        r[i] = s + t * Math.cos(c),
        r[i + 1] = o + t * Math.sin(c),
        r[i + 2] = c
    }
    addAfterPosition(t, e, n, r, i) {
        const s = e[n + 2]
          , o = e[n + 3]
          , a = s - e[n]
          , l = o - e[n + 1]
          , c = Math.atan2(l, a);
        r[i] = s + t * Math.cos(c),
        r[i + 1] = o + t * Math.sin(c),
        r[i + 2] = c
    }
    addCurvePosition(t, e, n, r, i, s, o, a, l, c, u, h) {
        if (0 == t || isNaN(t))
            return c[u] = e,
            c[u + 1] = n,
            void (c[u + 2] = Math.atan2(i - n, r - e));
        const d = t * t
          , f = d * t
          , p = 1 - t
          , m = p * p
          , g = m * p
          , y = p * t
          , b = 3 * y
          , v = p * b
          , w = b * t
          , x = e * g + r * v + s * w + a * f
          , E = n * g + i * v + o * w + l * f;
        c[u] = x,
        c[u + 1] = E,
        h && (c[u + 2] = t < .001 ? Math.atan2(i - n, r - e) : Math.atan2(E - (n * m + i * y * 2 + o * d), x - (e * m + r * y * 2 + s * d)))
    }
}
;
let KL = qL;
KL.NONE = -1,
KL.BEFORE = -2,
KL.AFTER = -3,
KL.epsilon = 1e-5;
class QL {
    constructor(t, e) {
        if (this.darkColor = null,
        this.attachment = null,
        this.attachmentState = 0,
        this.sequenceIndex = -1,
        this.deform = new Array,
        !t)
            throw new Error("data cannot be null.");
        if (!e)
            throw new Error("bone cannot be null.");
        this.data = t,
        this.bone = e,
        this.color = new qO,
        this.darkColor = t.darkColor ? new qO : null,
        this.setToSetupPose(),
        this.blendMode = this.data.blendMode
    }
    getSkeleton() {
        return this.bone.skeleton
    }
    getAttachment() {
        return this.attachment
    }
    setAttachment(t) {
        this.attachment != t && (t instanceof fB && this.attachment instanceof fB && t.timelineAttachment == this.attachment.timelineAttachment || (this.deform.length = 0),
        this.attachment = t,
        this.sequenceIndex = -1)
    }
    setToSetupPose() {
        this.color.setFromColor(this.data.color),
        this.darkColor && this.darkColor.setFromColor(this.data.darkColor),
        this.data.attachmentName ? (this.attachment = null,
        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName))) : this.attachment = null
    }
}
class ZL {
    constructor(t, e) {
        if (this.mixRotate = 0,
        this.mixX = 0,
        this.mixY = 0,
        this.mixScaleX = 0,
        this.mixScaleY = 0,
        this.mixShearY = 0,
        this.temp = new iN,
        this.active = !1,
        !t)
            throw new Error("data cannot be null.");
        if (!e)
            throw new Error("skeleton cannot be null.");
        this.data = t,
        this.mixRotate = t.mixRotate,
        this.mixX = t.mixX,
        this.mixY = t.mixY,
        this.mixScaleX = t.mixScaleX,
        this.mixScaleY = t.mixScaleY,
        this.mixShearY = t.mixShearY,
        this.bones = new Array;
        for (let n = 0; n < t.bones.length; n++) {
            const r = e.findBone(t.bones[n].name);
            if (!r)
                throw new Error(`Couldn't find bone ${t.bones[n].name}.`);
            this.bones.push(r)
        }
        const n = e.findBone(t.target.name);
        if (!n)
            throw new Error(`Couldn't find target bone ${t.target.name}.`);
        this.target = n
    }
    isActive() {
        return this.active
    }
    update() {
        0 == this.mixRotate && 0 == this.mixX && 0 == this.mixY && 0 == this.mixScaleX && 0 == this.mixScaleX && 0 == this.mixShearY || (this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld())
    }
    applyAbsoluteWorld() {
        const t = this.mixRotate
          , e = this.mixX
          , n = this.mixY
          , r = this.mixScaleX
          , i = this.mixScaleY
          , s = this.mixShearY
          , o = 0 != e || 0 != n
          , a = this.target
          , l = a.matrix
          , c = l.a
          , u = l.c
          , h = l.b
          , d = l.d
          , f = c * d - u * h > 0 ? QO.degRad : -QO.degRad
          , p = this.data.offsetRotation * f
          , m = this.data.offsetShearY * f
          , g = this.bones;
        for (let l = 0, f = g.length; l < f; l++) {
            const f = g[l]
              , y = f.matrix;
            if (0 != t) {
                const e = y.a
                  , n = y.c
                  , r = y.b
                  , i = y.d;
                let s = Math.atan2(h, c) - Math.atan2(r, e) + p;
                s > QO.PI ? s -= QO.PI2 : s < -QO.PI && (s += QO.PI2),
                s *= t;
                const o = Math.cos(s)
                  , a = Math.sin(s);
                y.a = o * e - a * r,
                y.c = o * n - a * i,
                y.b = a * e + o * r,
                y.d = a * n + o * i
            }
            if (o) {
                const t = this.temp;
                a.localToWorld(t.set(this.data.offsetX, this.data.offsetY)),
                y.tx += (t.x - y.tx) * e,
                y.ty += (t.y - y.ty) * n
            }
            if (0 != r) {
                let t = Math.sqrt(y.a * y.a + y.b * y.b);
                0 != t && (t = (t + (Math.sqrt(c * c + h * h) - t + this.data.offsetScaleX) * r) / t),
                y.a *= t,
                y.b *= t
            }
            if (0 != i) {
                let t = Math.sqrt(y.c * y.c + y.d * y.d);
                0 != t && (t = (t + (Math.sqrt(u * u + d * d) - t + this.data.offsetScaleY) * i) / t),
                y.c *= t,
                y.d *= t
            }
            if (s > 0) {
                const t = y.c
                  , e = y.d
                  , n = Math.atan2(e, t);
                let r = Math.atan2(d, u) - Math.atan2(h, c) - (n - Math.atan2(y.b, y.a));
                r > QO.PI ? r -= QO.PI2 : r < -QO.PI && (r += QO.PI2),
                r = n + (r + m) * s;
                const i = Math.sqrt(t * t + e * e);
                y.c = Math.cos(r) * i,
                y.d = Math.sin(r) * i
            }
            f.updateAppliedTransform()
        }
    }
    applyRelativeWorld() {
        const t = this.mixRotate
          , e = this.mixX
          , n = this.mixY
          , r = this.mixScaleX
          , i = this.mixScaleY
          , s = this.mixShearY
          , o = 0 != e || 0 != n
          , a = this.target
          , l = a.matrix
          , c = l.a
          , u = l.c
          , h = l.b
          , d = l.d
          , f = c * d - u * h > 0 ? QO.degRad : -QO.degRad
          , p = this.data.offsetRotation * f
          , m = this.data.offsetShearY * f
          , g = this.bones;
        for (let l = 0, f = g.length; l < f; l++) {
            const f = g[l]
              , y = f.matrix;
            if (0 != t) {
                const e = y.a
                  , n = y.c
                  , r = y.b
                  , i = y.d;
                let s = Math.atan2(h, c) + p;
                s > QO.PI ? s -= QO.PI2 : s < -QO.PI && (s += QO.PI2),
                s *= t;
                const o = Math.cos(s)
                  , a = Math.sin(s);
                y.a = o * e - a * r,
                y.c = o * n - a * i,
                y.b = a * e + o * r,
                y.d = a * n + o * i
            }
            if (o) {
                const t = this.temp;
                a.localToWorld(t.set(this.data.offsetX, this.data.offsetY)),
                y.tx += t.x * e,
                y.ty += t.y * n
            }
            if (0 != r) {
                const t = (Math.sqrt(c * c + h * h) - 1 + this.data.offsetScaleX) * r + 1;
                y.a *= t,
                y.b *= t
            }
            if (0 != i) {
                const t = (Math.sqrt(u * u + d * d) - 1 + this.data.offsetScaleY) * i + 1;
                y.c *= t,
                y.d *= t
            }
            if (s > 0) {
                let t = Math.atan2(d, u) - Math.atan2(h, c);
                t > QO.PI ? t -= QO.PI2 : t < -QO.PI && (t += QO.PI2);
                const e = y.c
                  , n = y.d;
                t = Math.atan2(n, e) + (t - QO.PI / 2 + m) * s;
                const r = Math.sqrt(e * e + n * n);
                y.c = Math.cos(t) * r,
                y.d = Math.sin(t) * r
            }
            f.updateAppliedTransform()
        }
    }
    applyAbsoluteLocal() {
        const t = this.mixRotate
          , e = this.mixX
          , n = this.mixY
          , r = this.mixScaleX
          , i = this.mixScaleY
          , s = this.mixShearY
          , o = this.target
          , a = this.bones;
        for (let l = 0, c = a.length; l < c; l++) {
            const c = a[l];
            let u = c.arotation;
            if (0 != t) {
                let e = o.arotation - u + this.data.offsetRotation;
                e -= 360 * (16384 - (16384.499999999996 - e / 360 | 0)),
                u += e * t
            }
            let h = c.ax
              , d = c.ay;
            h += (o.ax - h + this.data.offsetX) * e,
            d += (o.ay - d + this.data.offsetY) * n;
            let f = c.ascaleX
              , p = c.ascaleY;
            0 != r && 0 != f && (f = (f + (o.ascaleX - f + this.data.offsetScaleX) * r) / f),
            0 != i && 0 != p && (p = (p + (o.ascaleY - p + this.data.offsetScaleY) * i) / p);
            let m = c.ashearY;
            if (0 != s) {
                let t = o.ashearY - m + this.data.offsetShearY;
                t -= 360 * (16384 - (16384.499999999996 - t / 360 | 0)),
                m += t * s
            }
            c.updateWorldTransformWith(h, d, u, f, p, c.ashearX, m)
        }
    }
    applyRelativeLocal() {
        const t = this.mixRotate
          , e = this.mixX
          , n = this.mixY
          , r = this.mixScaleX
          , i = this.mixScaleY
          , s = this.mixShearY
          , o = this.target
          , a = this.bones;
        for (let l = 0, c = a.length; l < c; l++) {
            const c = a[l]
              , u = c.arotation + (o.arotation + this.data.offsetRotation) * t
              , h = c.ax + (o.ax + this.data.offsetX) * e
              , d = c.ay + (o.ay + this.data.offsetY) * n
              , f = c.ascaleX * ((o.ascaleX - 1 + this.data.offsetScaleX) * r + 1)
              , p = c.ascaleY * ((o.ascaleY - 1 + this.data.offsetScaleY) * i + 1)
              , m = c.ashearY + (o.ashearY + this.data.offsetShearY) * s;
            c.updateWorldTransformWith(h, d, u, f, p, c.ashearX, m)
        }
    }
}
const JL = class {
    constructor(t) {
        if (this._updateCache = new Array,
        this.skin = null,
        this.scaleX = 1,
        this.scaleY = 1,
        this.x = 0,
        this.y = 0,
        !t)
            throw new Error("data cannot be null.");
        this.data = t,
        this.bones = new Array;
        for (let e = 0; e < t.bones.length; e++) {
            const n = t.bones[e];
            let r;
            if (n.parent) {
                const t = this.bones[n.parent.index];
                r = new UL(n,this,t),
                t.children.push(r)
            } else
                r = new UL(n,this,null);
            this.bones.push(r)
        }
        this.slots = new Array,
        this.drawOrder = new Array;
        for (let e = 0; e < t.slots.length; e++) {
            const n = t.slots[e]
              , r = this.bones[n.boneData.index]
              , i = new QL(n,r);
            this.slots.push(i),
            this.drawOrder.push(i)
        }
        this.ikConstraints = new Array;
        for (let e = 0; e < t.ikConstraints.length; e++) {
            const n = t.ikConstraints[e];
            this.ikConstraints.push(new HL(n,this))
        }
        this.transformConstraints = new Array;
        for (let e = 0; e < t.transformConstraints.length; e++) {
            const n = t.transformConstraints[e];
            this.transformConstraints.push(new ZL(n,this))
        }
        this.pathConstraints = new Array;
        for (let e = 0; e < t.pathConstraints.length; e++) {
            const n = t.pathConstraints[e];
            this.pathConstraints.push(new KL(n,this))
        }
        this.color = new qO(1,1,1,1),
        this.updateCache()
    }
    updateCache() {
        this._updateCache.length = 0;
        const t = this.bones;
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            n.sorted = n.data.skinRequired,
            n.active = !n.sorted
        }
        if (this.skin) {
            const t = this.skin.bones;
            for (let e = 0, n = this.skin.bones.length; e < n; e++) {
                let n = this.bones[t[e].index];
                do {
                    n.sorted = !1,
                    n.active = !0,
                    n = n.parent
                } while (n)
            }
        }
        const e = this.ikConstraints
          , n = this.transformConstraints
          , r = this.pathConstraints
          , i = e.length
          , s = n.length
          , o = r.length
          , a = i + s + o;
        t: for (let t = 0; t < a; t++) {
            for (let n = 0; n < i; n++) {
                const r = e[n];
                if (r.data.order == t) {
                    this.sortIkConstraint(r);
                    continue t
                }
            }
            for (let e = 0; e < s; e++) {
                const r = n[e];
                if (r.data.order == t) {
                    this.sortTransformConstraint(r);
                    continue t
                }
            }
            for (let e = 0; e < o; e++) {
                const n = r[e];
                if (n.data.order == t) {
                    this.sortPathConstraint(n);
                    continue t
                }
            }
        }
        for (let e = 0, n = t.length; e < n; e++)
            this.sortBone(t[e])
    }
    sortIkConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && nN.contains(this.skin.constraints, t.data, !0)),
        !t.active)
            return;
        const e = t.target;
        this.sortBone(e);
        const n = t.bones
          , r = n[0];
        if (this.sortBone(r),
        1 == n.length)
            this._updateCache.push(t),
            this.sortReset(r.children);
        else {
            const e = n[n.length - 1];
            this.sortBone(e),
            this._updateCache.push(t),
            this.sortReset(r.children),
            e.sorted = !0
        }
    }
    sortPathConstraint(t) {
        if (t.active = t.target.bone.isActive() && (!t.data.skinRequired || this.skin && nN.contains(this.skin.constraints, t.data, !0)),
        !t.active)
            return;
        const e = t.target
          , n = e.data.index
          , r = e.bone;
        this.skin && this.sortPathConstraintAttachment(this.skin, n, r),
        this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, r);
        for (let t = 0, e = this.data.skins.length; t < e; t++)
            this.sortPathConstraintAttachment(this.data.skins[t], n, r);
        const i = e.getAttachment();
        i instanceof yB && this.sortPathConstraintAttachmentWith(i, r);
        const s = t.bones
          , o = s.length;
        for (let t = 0; t < o; t++)
            this.sortBone(s[t]);
        this._updateCache.push(t);
        for (let t = 0; t < o; t++)
            this.sortReset(s[t].children);
        for (let t = 0; t < o; t++)
            s[t].sorted = !0
    }
    sortTransformConstraint(t) {
        if (t.active = t.target.isActive() && (!t.data.skinRequired || this.skin && nN.contains(this.skin.constraints, t.data, !0)),
        !t.active)
            return;
        this.sortBone(t.target);
        const e = t.bones
          , n = e.length;
        if (t.data.local)
            for (let t = 0; t < n; t++) {
                const n = e[t];
                this.sortBone(n.parent),
                this.sortBone(n)
            }
        else
            for (let t = 0; t < n; t++)
                this.sortBone(e[t]);
        this._updateCache.push(t);
        for (let t = 0; t < n; t++)
            this.sortReset(e[t].children);
        for (let t = 0; t < n; t++)
            e[t].sorted = !0
    }
    sortPathConstraintAttachment(t, e, n) {
        const r = t.attachments[e];
        if (r)
            for (const t in r)
                this.sortPathConstraintAttachmentWith(r[t], n)
    }
    sortPathConstraintAttachmentWith(t, e) {
        if (!(t instanceof yB))
            return;
        const n = t.bones;
        if (n) {
            const t = this.bones;
            for (let e = 0, r = n.length; e < r; ) {
                let r = n[e++];
                for (r += e; e < r; )
                    this.sortBone(t[n[e++]])
            }
        } else
            this.sortBone(e)
    }
    sortBone(t) {
        if (!t)
            return;
        if (t.sorted)
            return;
        const e = t.parent;
        e && this.sortBone(e),
        t.sorted = !0,
        this._updateCache.push(t)
    }
    sortReset(t) {
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            n.active && (n.sorted && this.sortReset(n.children),
            n.sorted = !1)
        }
    }
    updateWorldTransform() {
        const t = this.bones;
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            n.ax = n.x,
            n.ay = n.y,
            n.arotation = n.rotation,
            n.ascaleX = n.scaleX,
            n.ascaleY = n.scaleY,
            n.ashearX = n.shearX,
            n.ashearY = n.shearY
        }
        const e = this._updateCache;
        for (let t = 0, n = e.length; t < n; t++)
            e[t].update()
    }
    updateWorldTransformWith(t) {
        const e = this.getRootBone()
          , n = t.matrix.a
          , r = t.matrix.c
          , i = t.matrix.b
          , s = t.matrix.d;
        e.matrix.tx = n * this.x + r * this.y + t.worldX,
        e.matrix.ty = i * this.x + s * this.y + t.worldY;
        const o = e.rotation + 90 + e.shearY
          , a = QO.cosDeg(e.rotation + e.shearX) * e.scaleX
          , l = QO.cosDeg(o) * e.scaleY
          , c = QO.sinDeg(e.rotation + e.shearX) * e.scaleX
          , u = QO.sinDeg(o) * e.scaleY
          , h = this.scaleX
          , d = oN.yDown ? -this.scaleY : this.scaleY;
        e.matrix.a = (n * a + r * c) * h,
        e.matrix.c = (n * l + r * u) * h,
        e.matrix.b = (i * a + s * c) * d,
        e.matrix.d = (i * l + s * u) * d;
        const f = this._updateCache;
        for (let t = 0, n = f.length; t < n; t++) {
            const n = f[t];
            n != e && n.update()
        }
    }
    setToSetupPose() {
        this.setBonesToSetupPose(),
        this.setSlotsToSetupPose()
    }
    setBonesToSetupPose() {
        const t = this.bones;
        for (let e = 0, n = t.length; e < n; e++)
            t[e].setToSetupPose();
        const e = this.ikConstraints;
        for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t];
            n.mix = n.data.mix,
            n.softness = n.data.softness,
            n.bendDirection = n.data.bendDirection,
            n.compress = n.data.compress,
            n.stretch = n.data.stretch
        }
        const n = this.transformConstraints;
        for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t]
              , r = e.data;
            e.mixRotate = r.mixRotate,
            e.mixX = r.mixX,
            e.mixY = r.mixY,
            e.mixScaleX = r.mixScaleX,
            e.mixScaleY = r.mixScaleY,
            e.mixShearY = r.mixShearY
        }
        const r = this.pathConstraints;
        for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t]
              , n = e.data;
            e.position = n.position,
            e.spacing = n.spacing,
            e.mixRotate = n.mixRotate,
            e.mixX = n.mixX,
            e.mixY = n.mixY
        }
    }
    setSlotsToSetupPose() {
        const t = this.slots;
        nN.arrayCopy(t, 0, this.drawOrder, 0, t.length);
        for (let e = 0, n = t.length; e < n; e++)
            t[e].setToSetupPose()
    }
    getRootBone() {
        return 0 == this.bones.length ? null : this.bones[0]
    }
    findBone(t) {
        if (!t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findBoneIndex(t) {
        if (!t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].data.name == t)
                return n;
        return -1
    }
    findSlot(t) {
        if (!t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findSlotIndex(t) {
        if (!t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].data.name == t)
                return n;
        return -1
    }
    setSkinByName(t) {
        const e = this.data.findSkin(t);
        if (!e)
            throw new Error(`Skin not found: ${t}`);
        this.setSkin(e)
    }
    setSkin(t) {
        if (t != this.skin) {
            if (t)
                if (this.skin)
                    t.attachAll(this, this.skin);
                else {
                    const e = this.slots;
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = e[n]
                          , i = r.data.attachmentName;
                        if (i) {
                            const e = t.getAttachment(n, i);
                            e && r.setAttachment(e)
                        }
                    }
                }
            this.skin = t,
            this.updateCache()
        }
    }
    getAttachmentByName(t, e) {
        const n = this.data.findSlot(t);
        if (!n)
            throw new Error(`Can't find slot with name ${t}`);
        return this.getAttachment(n.index, e)
    }
    getAttachment(t, e) {
        if (!e)
            throw new Error("attachmentName cannot be null.");
        if (this.skin) {
            const n = this.skin.getAttachment(t, e);
            if (n)
                return n
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
    }
    setAttachment(t, e) {
        if (!t)
            throw new Error("slotName cannot be null.");
        const n = this.slots;
        for (let r = 0, i = n.length; r < i; r++) {
            const i = n[r];
            if (i.data.name == t) {
                let n = null;
                if (e && (n = this.getAttachment(r, e),
                !n))
                    throw new Error(`Attachment not found: ${e}, for slot: ${t}`);
                return void i.setAttachment(n)
            }
        }
        throw new Error(`Slot not found: ${t}`)
    }
    findIkConstraint(t) {
        if (!t)
            throw new Error("constraintName cannot be null.");
        const e = this.ikConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findTransformConstraint(t) {
        if (!t)
            throw new Error("constraintName cannot be null.");
        const e = this.transformConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    findPathConstraint(t) {
        if (!t)
            throw new Error("constraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.data.name == t)
                return r
        }
        return null
    }
    getBoundsRect() {
        const t = new iN
          , e = new iN;
        return this.getBounds(t, e),
        {
            x: t.x,
            y: t.y,
            width: e.x,
            height: e.y
        }
    }
    getBounds(t, e, n=new Array(2)) {
        if (!t)
            throw new Error("offset cannot be null.");
        if (!e)
            throw new Error("size cannot be null.");
        const r = this.drawOrder;
        let i = Number.POSITIVE_INFINITY
          , s = Number.POSITIVE_INFINITY
          , o = Number.NEGATIVE_INFINITY
          , a = Number.NEGATIVE_INFINITY;
        for (let t = 0, e = r.length; t < e; t++) {
            const e = r[t];
            if (!e.bone.active)
                continue;
            let l = 0
              , c = null;
            const u = e.getAttachment();
            if (u instanceof wB)
                l = 8,
                c = nN.setArraySize(n, l, 0),
                u.computeWorldVertices(e, c, 0, 2);
            else if (u instanceof gB) {
                const t = u;
                l = t.worldVerticesLength,
                c = nN.setArraySize(n, l, 0),
                t.computeWorldVertices(e, 0, l, c, 0, 2)
            }
            if (c)
                for (let t = 0, e = c.length; t < e; t += 2) {
                    const e = c[t]
                      , n = c[t + 1];
                    i = Math.min(i, e),
                    s = Math.min(s, n),
                    o = Math.max(o, e),
                    a = Math.max(a, n)
                }
        }
        t.set(i, s),
        e.set(o - i, a - s)
    }
    get flipX() {
        return -1 == this.scaleX
    }
    set flipX(t) {
        JL.deprecatedWarning1 || (JL.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
        this.scaleX = t ? 1 : -1
    }
    get flipY() {
        return -1 == this.scaleY
    }
    set flipY(t) {
        JL.deprecatedWarning1 || (JL.deprecatedWarning1 = !0,
        console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),
        this.scaleY = t ? 1 : -1
    }
}
;
let tF = JL;
tF.deprecatedWarning1 = !1;
class eF {
    constructor() {
        this.name = null,
        this.bones = new Array,
        this.slots = new Array,
        this.skins = new Array,
        this.defaultSkin = null,
        this.events = new Array,
        this.animations = new Array,
        this.ikConstraints = new Array,
        this.transformConstraints = new Array,
        this.pathConstraints = new Array,
        this.x = 0,
        this.y = 0,
        this.width = 0,
        this.height = 0,
        this.version = null,
        this.hash = null,
        this.fps = 0,
        this.imagesPath = null,
        this.audioPath = null
    }
    findBone(t) {
        if (!t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findBoneIndex(t) {
        if (!t)
            throw new Error("boneName cannot be null.");
        const e = this.bones;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].name == t)
                return n;
        return -1
    }
    findSlot(t) {
        if (!t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findSlotIndex(t) {
        if (!t)
            throw new Error("slotName cannot be null.");
        const e = this.slots;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].name == t)
                return n;
        return -1
    }
    findSkin(t) {
        if (!t)
            throw new Error("skinName cannot be null.");
        const e = this.skins;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findEvent(t) {
        if (!t)
            throw new Error("eventDataName cannot be null.");
        const e = this.events;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findAnimation(t) {
        if (!t)
            throw new Error("animationName cannot be null.");
        const e = this.animations;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findIkConstraint(t) {
        if (!t)
            throw new Error("constraintName cannot be null.");
        const e = this.ikConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findTransformConstraint(t) {
        if (!t)
            throw new Error("constraintName cannot be null.");
        const e = this.transformConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findPathConstraint(t) {
        if (!t)
            throw new Error("constraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, r = e.length; n < r; n++) {
            const r = e[n];
            if (r.name == t)
                return r
        }
        return null
    }
    findPathConstraintIndex(t) {
        if (null == t)
            throw new Error("pathConstraintName cannot be null.");
        const e = this.pathConstraints;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n].name == t)
                return n;
        return -1
    }
}
class nF {
    constructor(t, e, n) {
        if (this.index = 0,
        this.color = new qO(1,1,1,1),
        this.darkColor = null,
        this.attachmentName = null,
        this.blendMode = Om.NORMAL,
        t < 0)
            throw new Error("index must be >= 0.");
        if (!e)
            throw new Error("name cannot be null.");
        if (!n)
            throw new Error("boneData cannot be null.");
        this.index = t,
        this.name = e,
        this.boneData = n
    }
}
class rF extends VL {
    constructor(t) {
        super(t, 0, !1),
        this.bones = new Array,
        this._target = null,
        this.mixRotate = 0,
        this.mixX = 0,
        this.mixY = 0,
        this.mixScaleX = 0,
        this.mixScaleY = 0,
        this.mixShearY = 0,
        this.offsetRotation = 0,
        this.offsetX = 0,
        this.offsetY = 0,
        this.offsetScaleX = 0,
        this.offsetScaleY = 0,
        this.offsetShearY = 0,
        this.relative = !1,
        this.local = !1
    }
    set target(t) {
        this._target = t
    }
    get target() {
        if (this._target)
            return this._target;
        throw new Error("BoneData not set.")
    }
}
class iF {
    constructor(t, e, n) {
        this.slotIndex = t,
        this.name = e,
        this.attachment = n
    }
}
class sF {
    constructor(t) {
        if (this.attachments = new Array,
        this.bones = Array(),
        this.constraints = new Array,
        !t)
            throw new Error("name cannot be null.");
        this.name = t
    }
    setAttachment(t, e, n) {
        if (!n)
            throw new Error("attachment cannot be null.");
        const r = this.attachments;
        t >= r.length && (r.length = t + 1),
        r[t] || (r[t] = {}),
        r[t][e] = n
    }
    addSkin(t) {
        for (let e = 0; e < t.bones.length; e++) {
            const n = t.bones[e];
            let r = !1;
            for (let t = 0; t < this.bones.length; t++)
                if (this.bones[t] == n) {
                    r = !0;
                    break
                }
            r || this.bones.push(n)
        }
        for (let e = 0; e < t.constraints.length; e++) {
            const n = t.constraints[e];
            let r = !1;
            for (let t = 0; t < this.constraints.length; t++)
                if (this.constraints[t] == n) {
                    r = !0;
                    break
                }
            r || this.constraints.push(n)
        }
        const e = t.getAttachments();
        for (let t = 0; t < e.length; t++) {
            const n = e[t];
            this.setAttachment(n.slotIndex, n.name, n.attachment)
        }
    }
    copySkin(t) {
        for (let e = 0; e < t.bones.length; e++) {
            const n = t.bones[e];
            let r = !1;
            for (let t = 0; t < this.bones.length; t++)
                if (this.bones[t] == n) {
                    r = !0;
                    break
                }
            r || this.bones.push(n)
        }
        for (let e = 0; e < t.constraints.length; e++) {
            const n = t.constraints[e];
            let r = !1;
            for (let t = 0; t < this.constraints.length; t++)
                if (this.constraints[t] == n) {
                    r = !0;
                    break
                }
            r || this.constraints.push(n)
        }
        const e = t.getAttachments();
        for (let t = 0; t < e.length; t++) {
            const n = e[t];
            n.attachment && (n.attachment instanceof gB ? (n.attachment = n.attachment.newLinkedMesh(),
            this.setAttachment(n.slotIndex, n.name, n.attachment)) : (n.attachment = n.attachment.copy(),
            this.setAttachment(n.slotIndex, n.name, n.attachment)))
        }
    }
    getAttachment(t, e) {
        const n = this.attachments[t];
        return n ? n[e] : null
    }
    removeAttachment(t, e) {
        const n = this.attachments[t];
        n && delete n[e]
    }
    getAttachments() {
        const t = new Array;
        for (let e = 0; e < this.attachments.length; e++) {
            const n = this.attachments[e];
            if (n)
                for (const r in n) {
                    const i = n[r];
                    i && t.push(new iF(e,r,i))
                }
        }
        return t
    }
    getAttachmentsForSlot(t, e) {
        const n = this.attachments[t];
        if (n)
            for (const r in n) {
                const i = n[r];
                i && e.push(new iF(t,r,i))
            }
    }
    clear() {
        this.attachments.length = 0,
        this.bones.length = 0,
        this.constraints.length = 0
    }
    attachAll(t, e) {
        let n = 0;
        for (let r = 0; r < t.slots.length; r++) {
            const i = t.slots[r]
              , s = i.getAttachment();
            if (s && n < e.attachments.length) {
                const t = e.attachments[n];
                for (const e in t) {
                    if (s == t[e]) {
                        const t = this.getAttachment(n, e);
                        t && i.setAttachment(t);
                        break
                    }
                }
            }
            n++
        }
    }
}
class oF {
    constructor(t) {
        this.ver40 = !1,
        this.scale = 1,
        this.linkedMeshes = new Array,
        this.attachmentLoader = t
    }
    readSkeletonData(t) {
        const e = this.scale
          , n = new eF;
        n.name = "";
        const r = new PO(t)
          , i = r.readInt32()
          , s = r.readInt32();
        n.hash = 0 == s && 0 == i ? null : s.toString(16) + i.toString(16),
        n.version = r.readString();
        const o = n.version.substr(0, 3);
        if ("4.0" !== o && "4.1" !== o) {
            const t = `Spine 4.1 loader cant load version ${n.version}. Please configure your pixi-spine bundle`;
            console.error(t)
        }
        this.ver40 = "4.0" === o,
        n.x = r.readFloat(),
        n.y = r.readFloat(),
        n.width = r.readFloat(),
        n.height = r.readFloat();
        const a = r.readBoolean();
        a && (n.fps = r.readFloat(),
        n.imagesPath = r.readString(),
        n.audioPath = r.readString());
        let l = 0;
        l = r.readInt(!0);
        for (let t = 0; t < l; t++) {
            const t = r.readString();
            if (!t)
                throw new Error("String in string table must not be null.");
            r.strings.push(t)
        }
        l = r.readInt(!0);
        for (let t = 0; t < l; t++) {
            const i = r.readString();
            if (!i)
                throw new Error("Bone name must not be null.");
            const s = 0 == t ? null : n.bones[r.readInt(!0)]
              , o = new zL(t,i,s);
            o.rotation = r.readFloat(),
            o.x = r.readFloat() * e,
            o.y = r.readFloat() * e,
            o.scaleX = r.readFloat(),
            o.scaleY = r.readFloat(),
            o.shearX = r.readFloat(),
            o.shearY = r.readFloat(),
            o.length = r.readFloat() * e,
            o.transformMode = r.readInt(!0),
            o.skinRequired = r.readBoolean(),
            a && qO.rgba8888ToColor(o.color, r.readInt32()),
            n.bones.push(o)
        }
        l = r.readInt(!0);
        for (let t = 0; t < l; t++) {
            const e = r.readString();
            if (!e)
                throw new Error("Slot name must not be null.");
            const i = n.bones[r.readInt(!0)]
              , s = new nF(t,e,i);
            qO.rgba8888ToColor(s.color, r.readInt32());
            const o = r.readInt32();
            -1 != o && qO.rgb888ToColor(s.darkColor = new qO, o),
            s.attachmentName = r.readStringRef(),
            s.blendMode = r.readInt(!0),
            n.slots.push(s)
        }
        l = r.readInt(!0);
        for (let t, i = 0; i < l; i++) {
            const i = r.readString();
            if (!i)
                throw new Error("IK constraint data name must not be null.");
            const s = new $L(i);
            s.order = r.readInt(!0),
            s.skinRequired = r.readBoolean(),
            t = r.readInt(!0);
            for (let e = 0; e < t; e++)
                s.bones.push(n.bones[r.readInt(!0)]);
            s.target = n.bones[r.readInt(!0)],
            s.mix = r.readFloat(),
            s.softness = r.readFloat() * e,
            s.bendDirection = r.readByte(),
            s.compress = r.readBoolean(),
            s.stretch = r.readBoolean(),
            s.uniform = r.readBoolean(),
            n.ikConstraints.push(s)
        }
        l = r.readInt(!0);
        for (let t, i = 0; i < l; i++) {
            const i = r.readString();
            if (!i)
                throw new Error("Transform constraint data name must not be null.");
            const s = new rF(i);
            s.order = r.readInt(!0),
            s.skinRequired = r.readBoolean(),
            t = r.readInt(!0);
            for (let e = 0; e < t; e++)
                s.bones.push(n.bones[r.readInt(!0)]);
            s.target = n.bones[r.readInt(!0)],
            s.local = r.readBoolean(),
            s.relative = r.readBoolean(),
            s.offsetRotation = r.readFloat(),
            s.offsetX = r.readFloat() * e,
            s.offsetY = r.readFloat() * e,
            s.offsetScaleX = r.readFloat(),
            s.offsetScaleY = r.readFloat(),
            s.offsetShearY = r.readFloat(),
            s.mixRotate = r.readFloat(),
            s.mixX = r.readFloat(),
            s.mixY = r.readFloat(),
            s.mixScaleX = r.readFloat(),
            s.mixScaleY = r.readFloat(),
            s.mixShearY = r.readFloat(),
            n.transformConstraints.push(s)
        }
        l = r.readInt(!0);
        for (let t, i = 0; i < l; i++) {
            const i = r.readString();
            if (!i)
                throw new Error("Path constraint data name must not be null.");
            const s = new GL(i);
            s.order = r.readInt(!0),
            s.skinRequired = r.readBoolean(),
            t = r.readInt(!0);
            for (let e = 0; e < t; e++)
                s.bones.push(n.bones[r.readInt(!0)]);
            s.target = n.slots[r.readInt(!0)],
            s.positionMode = r.readInt(!0),
            s.spacingMode = r.readInt(!0),
            s.rotateMode = r.readInt(!0),
            s.offsetRotation = r.readFloat(),
            s.position = r.readFloat(),
            s.positionMode == RO.Fixed && (s.position *= e),
            s.spacing = r.readFloat(),
            s.spacingMode != XL.Length && s.spacingMode != XL.Fixed || (s.spacing *= e),
            s.mixRotate = r.readFloat(),
            s.mixX = r.readFloat(),
            s.mixY = r.readFloat(),
            n.pathConstraints.push(s)
        }
        const c = this.readSkin(r, n, !0, a);
        c && (n.defaultSkin = c,
        n.skins.push(c));
        {
            let t = n.skins.length;
            for (nN.setArraySize(n.skins, l = t + r.readInt(!0)); t < l; t++) {
                const e = this.readSkin(r, n, !1, a);
                if (!e)
                    throw new Error("readSkin() should not have returned null.");
                n.skins[t] = e
            }
        }
        l = this.linkedMeshes.length;
        for (let t = 0; t < l; t++) {
            const e = this.linkedMeshes[t]
              , r = e.skin ? n.findSkin(e.skin) : n.defaultSkin;
            if (!r)
                throw new Error("Not skin found for linked mesh.");
            if (!e.parent)
                throw new Error("Linked mesh parent must not be null");
            const i = r.getAttachment(e.slotIndex, e.parent);
            if (!i)
                throw new Error(`Parent mesh not found: ${e.parent}`);
            e.mesh.timelineAttachment = e.inheritTimeline ? i : e.mesh,
            e.mesh.setParentMesh(i)
        }
        this.linkedMeshes.length = 0,
        l = r.readInt(!0);
        for (let t = 0; t < l; t++) {
            const t = r.readStringRef();
            if (!t)
                throw new Error;
            const e = new YL(t);
            e.intValue = r.readInt(!1),
            e.floatValue = r.readFloat(),
            e.stringValue = r.readString(),
            e.audioPath = r.readString(),
            e.audioPath && (e.volume = r.readFloat(),
            e.balance = r.readFloat()),
            n.events.push(e)
        }
        l = r.readInt(!0);
        for (let t = 0; t < l; t++) {
            const t = r.readString();
            if (!t)
                throw new Error("Animatio name must not be null.");
            n.animations.push(this.readAnimation(r, t, n))
        }
        return n
    }
    readSkin(t, e, n, r) {
        let i = null
          , s = 0;
        if (n) {
            if (s = t.readInt(!0),
            0 == s)
                return null;
            i = new sF("default")
        } else {
            const n = t.readStringRef();
            if (!n)
                throw new Error("Skin name must not be null.");
            i = new sF(n),
            i.bones.length = t.readInt(!0);
            for (let n = 0, r = i.bones.length; n < r; n++)
                i.bones[n] = e.bones[t.readInt(!0)];
            for (let n = 0, r = t.readInt(!0); n < r; n++)
                i.constraints.push(e.ikConstraints[t.readInt(!0)]);
            for (let n = 0, r = t.readInt(!0); n < r; n++)
                i.constraints.push(e.transformConstraints[t.readInt(!0)]);
            for (let n = 0, r = t.readInt(!0); n < r; n++)
                i.constraints.push(e.pathConstraints[t.readInt(!0)]);
            s = t.readInt(!0)
        }
        for (let n = 0; n < s; n++) {
            const n = t.readInt(!0);
            for (let s = 0, o = t.readInt(!0); s < o; s++) {
                const s = t.readStringRef();
                if (!s)
                    throw new Error("Attachment name must not be null");
                const o = this.readAttachment(t, e, i, n, s, r);
                o && i.setAttachment(n, s, o)
            }
        }
        return i
    }
    readAttachment(t, e, n, r, i, s) {
        const o = this.scale;
        let a = t.readStringRef();
        switch (a || (a = i),
        t.readByte()) {
        case CO.Region:
            {
                let e = t.readStringRef();
                const r = t.readFloat()
                  , i = t.readFloat()
                  , s = t.readFloat()
                  , l = t.readFloat()
                  , c = t.readFloat()
                  , u = t.readFloat()
                  , h = t.readFloat()
                  , d = t.readInt32()
                  , f = this.readSequence(t);
                e || (e = a);
                const p = this.attachmentLoader.newRegionAttachment(n, a, e, f);
                return p ? (p.path = e,
                p.x = i * o,
                p.y = s * o,
                p.scaleX = l,
                p.scaleY = c,
                p.rotation = r,
                p.width = u * o,
                p.height = h * o,
                qO.rgba8888ToColor(p.color, d),
                p.sequence = f,
                null == f && p.updateRegion(),
                p) : null
            }
        case CO.BoundingBox:
            {
                const e = t.readInt(!0)
                  , r = this.readVertices(t, e)
                  , i = s ? t.readInt32() : 0
                  , o = this.attachmentLoader.newBoundingBoxAttachment(n, a);
                return o ? (o.worldVerticesLength = e << 1,
                o.vertices = r.vertices,
                o.bones = r.bones,
                s && qO.rgba8888ToColor(o.color, i),
                o) : null
            }
        case CO.Mesh:
            {
                let e = t.readStringRef();
                const r = t.readInt32()
                  , i = t.readInt(!0)
                  , l = this.readFloatArray(t, i << 1, 1)
                  , c = this.readShortArray(t)
                  , u = this.readVertices(t, i)
                  , h = t.readInt(!0)
                  , d = this.readSequence(t);
                let f = []
                  , p = 0
                  , m = 0;
                s && (f = this.readShortArray(t),
                p = t.readFloat(),
                m = t.readFloat()),
                e || (e = a);
                const g = this.attachmentLoader.newMeshAttachment(n, a, e, d);
                return g ? (g.path = e,
                qO.rgba8888ToColor(g.color, r),
                g.bones = u.bones,
                g.vertices = u.vertices,
                g.worldVerticesLength = i << 1,
                g.triangles = c,
                g.regionUVs = new Float32Array(l),
                g.hullLength = h << 1,
                g.sequence = d,
                s && (g.edges = f,
                g.width = p * o,
                g.height = m * o),
                g) : null
            }
        case CO.LinkedMesh:
            {
                let e = t.readStringRef();
                const i = t.readInt32()
                  , l = t.readStringRef()
                  , c = t.readStringRef()
                  , u = t.readBoolean()
                  , h = this.readSequence(t);
                let d = 0
                  , f = 0;
                s && (d = t.readFloat(),
                f = t.readFloat()),
                e || (e = a);
                const p = this.attachmentLoader.newMeshAttachment(n, a, e, h);
                return p ? (p.path = e,
                qO.rgba8888ToColor(p.color, i),
                p.sequence = h,
                s && (p.width = d * o,
                p.height = f * o),
                this.linkedMeshes.push(new aF(p,l,r,c,u)),
                p) : null
            }
        case CO.Path:
            {
                const e = t.readBoolean()
                  , r = t.readBoolean()
                  , i = t.readInt(!0)
                  , l = this.readVertices(t, i)
                  , c = nN.newArray(i / 3, 0);
                for (let e = 0, n = c.length; e < n; e++)
                    c[e] = t.readFloat() * o;
                const u = s ? t.readInt32() : 0
                  , h = this.attachmentLoader.newPathAttachment(n, a);
                return h ? (h.closed = e,
                h.constantSpeed = r,
                h.worldVerticesLength = i << 1,
                h.vertices = l.vertices,
                h.bones = l.bones,
                h.lengths = c,
                s && qO.rgba8888ToColor(h.color, u),
                h) : null
            }
        case CO.Point:
            {
                const e = t.readFloat()
                  , r = t.readFloat()
                  , i = t.readFloat()
                  , l = s ? t.readInt32() : 0
                  , c = this.attachmentLoader.newPointAttachment(n, a);
                return c ? (c.x = r * o,
                c.y = i * o,
                c.rotation = e,
                s && qO.rgba8888ToColor(c.color, l),
                c) : null
            }
        case CO.Clipping:
            {
                const r = t.readInt(!0)
                  , i = t.readInt(!0)
                  , o = this.readVertices(t, i)
                  , l = s ? t.readInt32() : 0
                  , c = this.attachmentLoader.newClippingAttachment(n, a);
                return c ? (c.endSlot = e.slots[r],
                c.worldVerticesLength = i << 1,
                c.vertices = o.vertices,
                c.bones = o.bones,
                s && qO.rgba8888ToColor(c.color, l),
                c) : null
            }
        }
        return null
    }
    readSequence(t) {
        if (this.ver40 || !t.readBoolean())
            return null;
        const e = new EB(t.readInt(!0));
        return e.start = t.readInt(!0),
        e.digits = t.readInt(!0),
        e.setupIndex = t.readInt(!0),
        e
    }
    readDeformTimelineType(t) {
        return this.ver40 ? IF : t.readByte()
    }
    readVertices(t, e) {
        const n = this.scale
          , r = e << 1
          , i = new lF;
        if (!t.readBoolean())
            return i.vertices = this.readFloatArray(t, r, n),
            i;
        const s = new Array
          , o = new Array;
        for (let r = 0; r < e; r++) {
            const e = t.readInt(!0);
            o.push(e);
            for (let r = 0; r < e; r++)
                o.push(t.readInt(!0)),
                s.push(t.readFloat() * n),
                s.push(t.readFloat() * n),
                s.push(t.readFloat())
        }
        return i.vertices = nN.toFloatArray(s),
        i.bones = o,
        i
    }
    readFloatArray(t, e, n) {
        const r = new Array(e);
        if (1 == n)
            for (let n = 0; n < e; n++)
                r[n] = t.readFloat();
        else
            for (let i = 0; i < e; i++)
                r[i] = t.readFloat() * n;
        return r
    }
    readShortArray(t) {
        const e = t.readInt(!0)
          , n = new Array(e);
        for (let r = 0; r < e; r++)
            n[r] = t.readShort();
        return n
    }
    readAnimation(t, e, n) {
        t.readInt(!0);
        const r = new Array
          , i = this.scale;
        for (let e = 0, n = t.readInt(!0); e < n; e++) {
            const e = t.readInt(!0);
            for (let n = 0, i = t.readInt(!0); n < i; n++) {
                const n = t.readByte()
                  , i = t.readInt(!0)
                  , s = i - 1;
                switch (n) {
                case EF:
                    {
                        const n = new hL(i,e);
                        for (let e = 0; e < i; e++)
                            n.setFrame(e, t.readFloat(), t.readStringRef());
                        r.push(n);
                        break
                    }
                case _F:
                    {
                        const n = t.readInt(!0)
                          , o = new oL(i,n,e);
                        let a = t.readFloat()
                          , l = t.readUnsignedByte() / 255
                          , c = t.readUnsignedByte() / 255
                          , u = t.readUnsignedByte() / 255
                          , h = t.readUnsignedByte() / 255;
                        for (let e = 0, n = 0; o.setFrame(e, a, l, c, u, h),
                        e != s; e++) {
                            const r = t.readFloat()
                              , i = t.readUnsignedByte() / 255
                              , s = t.readUnsignedByte() / 255
                              , d = t.readUnsignedByte() / 255
                              , f = t.readUnsignedByte() / 255;
                            switch (t.readByte()) {
                            case NF:
                                o.setStepped(e);
                                break;
                            case RF:
                                hF(t, o, n++, e, 0, a, r, l, i, 1),
                                hF(t, o, n++, e, 1, a, r, c, s, 1),
                                hF(t, o, n++, e, 2, a, r, u, d, 1),
                                hF(t, o, n++, e, 3, a, r, h, f, 1)
                            }
                            a = r,
                            l = i,
                            c = s,
                            u = d,
                            h = f
                        }
                        r.push(o);
                        break
                    }
                case AF:
                    {
                        const n = t.readInt(!0)
                          , o = new aL(i,n,e);
                        let a = t.readFloat()
                          , l = t.readUnsignedByte() / 255
                          , c = t.readUnsignedByte() / 255
                          , u = t.readUnsignedByte() / 255;
                        for (let e = 0, n = 0; o.setFrame(e, a, l, c, u),
                        e != s; e++) {
                            const r = t.readFloat()
                              , i = t.readUnsignedByte() / 255
                              , s = t.readUnsignedByte() / 255
                              , h = t.readUnsignedByte() / 255;
                            switch (t.readByte()) {
                            case NF:
                                o.setStepped(e);
                                break;
                            case RF:
                                hF(t, o, n++, e, 0, a, r, l, i, 1),
                                hF(t, o, n++, e, 1, a, r, c, s, 1),
                                hF(t, o, n++, e, 2, a, r, u, h, 1)
                            }
                            a = r,
                            l = i,
                            c = s,
                            u = h
                        }
                        r.push(o);
                        break
                    }
                case SF:
                    {
                        const n = t.readInt(!0)
                          , o = new cL(i,n,e);
                        let a = t.readFloat()
                          , l = t.readUnsignedByte() / 255
                          , c = t.readUnsignedByte() / 255
                          , u = t.readUnsignedByte() / 255
                          , h = t.readUnsignedByte() / 255
                          , d = t.readUnsignedByte() / 255
                          , f = t.readUnsignedByte() / 255
                          , p = t.readUnsignedByte() / 255;
                        for (let e = 0, n = 0; o.setFrame(e, a, l, c, u, h, d, f, p),
                        e != s; e++) {
                            const r = t.readFloat()
                              , i = t.readUnsignedByte() / 255
                              , s = t.readUnsignedByte() / 255
                              , m = t.readUnsignedByte() / 255
                              , g = t.readUnsignedByte() / 255
                              , y = t.readUnsignedByte() / 255
                              , b = t.readUnsignedByte() / 255
                              , v = t.readUnsignedByte() / 255;
                            switch (t.readByte()) {
                            case NF:
                                o.setStepped(e);
                                break;
                            case RF:
                                hF(t, o, n++, e, 0, a, r, l, i, 1),
                                hF(t, o, n++, e, 1, a, r, c, s, 1),
                                hF(t, o, n++, e, 2, a, r, u, m, 1),
                                hF(t, o, n++, e, 3, a, r, h, g, 1),
                                hF(t, o, n++, e, 4, a, r, d, y, 1),
                                hF(t, o, n++, e, 5, a, r, f, b, 1),
                                hF(t, o, n++, e, 6, a, r, p, v, 1)
                            }
                            a = r,
                            l = i,
                            c = s,
                            u = m,
                            h = g,
                            d = y,
                            f = b,
                            p = v
                        }
                        r.push(o);
                        break
                    }
                case TF:
                    {
                        const n = t.readInt(!0)
                          , o = new uL(i,n,e);
                        let a = t.readFloat()
                          , l = t.readUnsignedByte() / 255
                          , c = t.readUnsignedByte() / 255
                          , u = t.readUnsignedByte() / 255
                          , h = t.readUnsignedByte() / 255
                          , d = t.readUnsignedByte() / 255
                          , f = t.readUnsignedByte() / 255;
                        for (let e = 0, n = 0; o.setFrame(e, a, l, c, u, h, d, f),
                        e != s; e++) {
                            const r = t.readFloat()
                              , i = t.readUnsignedByte() / 255
                              , s = t.readUnsignedByte() / 255
                              , p = t.readUnsignedByte() / 255
                              , m = t.readUnsignedByte() / 255
                              , g = t.readUnsignedByte() / 255
                              , y = t.readUnsignedByte() / 255;
                            switch (t.readByte()) {
                            case NF:
                                o.setStepped(e);
                                break;
                            case RF:
                                hF(t, o, n++, e, 0, a, r, l, i, 1),
                                hF(t, o, n++, e, 1, a, r, c, s, 1),
                                hF(t, o, n++, e, 2, a, r, u, p, 1),
                                hF(t, o, n++, e, 3, a, r, h, m, 1),
                                hF(t, o, n++, e, 4, a, r, d, g, 1),
                                hF(t, o, n++, e, 5, a, r, f, y, 1)
                            }
                            a = r,
                            l = i,
                            c = s,
                            u = p,
                            h = m,
                            d = g,
                            f = y
                        }
                        r.push(o);
                        break
                    }
                case kF:
                    {
                        const n = new lL(i,t.readInt(!0),e);
                        let o = t.readFloat()
                          , a = t.readUnsignedByte() / 255;
                        for (let e = 0, r = 0; n.setFrame(e, o, a),
                        e != s; e++) {
                            const i = t.readFloat()
                              , s = t.readUnsignedByte() / 255;
                            switch (t.readByte()) {
                            case NF:
                                n.setStepped(e);
                                break;
                            case RF:
                                hF(t, n, r++, e, 0, o, i, a, s, 1)
                            }
                            o = i,
                            a = s
                        }
                        r.push(n)
                    }
                }
            }
        }
        for (let e = 0, n = t.readInt(!0); e < n; e++) {
            const e = t.readInt(!0);
            for (let n = 0, s = t.readInt(!0); n < s; n++) {
                const n = t.readByte()
                  , s = t.readInt(!0)
                  , o = t.readInt(!0);
                switch (n) {
                case dF:
                    r.push(cF(t, new KB(s,o,e), 1));
                    break;
                case fF:
                    r.push(uF(t, new QB(s,o,e), i));
                    break;
                case pF:
                    r.push(cF(t, new ZB(s,o,e), i));
                    break;
                case mF:
                    r.push(cF(t, new JB(s,o,e), i));
                    break;
                case gF:
                    r.push(uF(t, new tL(s,o,e), 1));
                    break;
                case yF:
                    r.push(cF(t, new eL(s,o,e), 1));
                    break;
                case bF:
                    r.push(cF(t, new nL(s,o,e), 1));
                    break;
                case vF:
                    r.push(uF(t, new rL(s,o,e), 1));
                    break;
                case wF:
                    r.push(cF(t, new iL(s,o,e), 1));
                    break;
                case xF:
                    r.push(cF(t, new sL(s,o,e), 1))
                }
            }
        }
        for (let e = 0, n = t.readInt(!0); e < n; e++) {
            const e = t.readInt(!0)
              , n = t.readInt(!0)
              , s = n - 1
              , o = new yL(n,t.readInt(!0),e);
            let a = t.readFloat()
              , l = t.readFloat()
              , c = t.readFloat() * i;
            for (let e = 0, n = 0; o.setFrame(e, a, l, c, t.readByte(), t.readBoolean(), t.readBoolean()),
            e != s; e++) {
                const r = t.readFloat()
                  , s = t.readFloat()
                  , u = t.readFloat() * i;
                switch (t.readByte()) {
                case NF:
                    o.setStepped(e);
                    break;
                case RF:
                    hF(t, o, n++, e, 0, a, r, l, s, 1),
                    hF(t, o, n++, e, 1, a, r, c, u, i)
                }
                a = r,
                l = s,
                c = u
            }
            r.push(o)
        }
        for (let e = 0, n = t.readInt(!0); e < n; e++) {
            const e = t.readInt(!0)
              , n = t.readInt(!0)
              , i = n - 1
              , s = new bL(n,t.readInt(!0),e);
            let o = t.readFloat()
              , a = t.readFloat()
              , l = t.readFloat()
              , c = t.readFloat()
              , u = t.readFloat()
              , h = t.readFloat()
              , d = t.readFloat();
            for (let e = 0, n = 0; s.setFrame(e, o, a, l, c, u, h, d),
            e != i; e++) {
                const r = t.readFloat()
                  , i = t.readFloat()
                  , f = t.readFloat()
                  , p = t.readFloat()
                  , m = t.readFloat()
                  , g = t.readFloat()
                  , y = t.readFloat();
                switch (t.readByte()) {
                case NF:
                    s.setStepped(e);
                    break;
                case RF:
                    hF(t, s, n++, e, 0, o, r, a, i, 1),
                    hF(t, s, n++, e, 1, o, r, l, f, 1),
                    hF(t, s, n++, e, 2, o, r, c, p, 1),
                    hF(t, s, n++, e, 3, o, r, u, m, 1),
                    hF(t, s, n++, e, 4, o, r, h, g, 1),
                    hF(t, s, n++, e, 5, o, r, d, y, 1)
                }
                o = r,
                a = i,
                l = f,
                c = p,
                u = m,
                h = g,
                d = y
            }
            r.push(s)
        }
        for (let e = 0, s = t.readInt(!0); e < s; e++) {
            const e = t.readInt(!0)
              , s = n.pathConstraints[e];
            for (let n = 0, o = t.readInt(!0); n < o; n++)
                switch (t.readByte()) {
                case CF:
                    r.push(cF(t, new vL(t.readInt(!0),t.readInt(!0),e), s.positionMode == RO.Fixed ? i : 1));
                    break;
                case PF:
                    r.push(cF(t, new wL(t.readInt(!0),t.readInt(!0),e), s.spacingMode == XL.Length || s.spacingMode == XL.Fixed ? i : 1));
                    break;
                case OF:
                    const n = new xL(t.readInt(!0),t.readInt(!0),e);
                    let o = t.readFloat()
                      , a = t.readFloat()
                      , l = t.readFloat()
                      , c = t.readFloat();
                    for (let e = 0, r = 0, i = n.getFrameCount() - 1; n.setFrame(e, o, a, l, c),
                    e != i; e++) {
                        const i = t.readFloat()
                          , s = t.readFloat()
                          , u = t.readFloat()
                          , h = t.readFloat();
                        switch (t.readByte()) {
                        case NF:
                            n.setStepped(e);
                            break;
                        case RF:
                            hF(t, n, r++, e, 0, o, i, a, s, 1),
                            hF(t, n, r++, e, 1, o, i, l, u, 1),
                            hF(t, n, r++, e, 2, o, i, c, h, 1)
                        }
                        o = i,
                        a = s,
                        l = u,
                        c = h
                    }
                    r.push(n)
                }
        }
        for (let e = 0, s = t.readInt(!0); e < s; e++) {
            const e = n.skins[t.readInt(!0)];
            for (let n = 0, s = t.readInt(!0); n < s; n++) {
                const n = t.readInt(!0);
                for (let s = 0, o = t.readInt(!0); s < o; s++) {
                    const s = t.readStringRef();
                    if (!s)
                        throw new Error("attachmentName must not be null.");
                    const o = e.getAttachment(n, s)
                      , a = this.readDeformTimelineType(t)
                      , l = t.readInt(!0)
                      , c = l - 1;
                    switch (a) {
                    case IF:
                        {
                            const e = o
                              , s = e.bones
                              , a = e.vertices
                              , u = s ? a.length / 3 * 2 : a.length
                              , h = t.readInt(!0)
                              , d = new dL(l,h,n,e);
                            let f = t.readFloat();
                            for (let e = 0, n = 0; ; e++) {
                                let r, o = t.readInt(!0);
                                if (0 == o)
                                    r = s ? nN.newFloatArray(u) : a;
                                else {
                                    r = nN.newFloatArray(u);
                                    const e = t.readInt(!0);
                                    if (o += e,
                                    1 == i)
                                        for (let n = e; n < o; n++)
                                            r[n] = t.readFloat();
                                    else
                                        for (let n = e; n < o; n++)
                                            r[n] = t.readFloat() * i;
                                    if (!s)
                                        for (let t = 0, e = r.length; t < e; t++)
                                            r[t] += a[t]
                                }
                                if (d.setFrame(e, f, r),
                                e == c)
                                    break;
                                const l = t.readFloat();
                                switch (t.readByte()) {
                                case NF:
                                    d.setStepped(e);
                                    break;
                                case RF:
                                    hF(t, d, n++, e, 0, f, l, 0, 1, 1)
                                }
                                f = l
                            }
                            r.push(d);
                            break
                        }
                    case MF:
                        {
                            const e = new _L(l,n,o);
                            for (let n = 0; n < l; n++) {
                                const r = t.readFloat()
                                  , i = t.readInt32();
                                e.setFrame(n, r, AB[15 & i], i >> 4, t.readFloat())
                            }
                            r.push(e);
                            break
                        }
                    }
                }
            }
        }
        const s = t.readInt(!0);
        if (s > 0) {
            const e = new gL(s)
              , i = n.slots.length;
            for (let n = 0; n < s; n++) {
                const r = t.readFloat()
                  , s = t.readInt(!0)
                  , o = nN.newArray(i, 0);
                for (let t = i - 1; t >= 0; t--)
                    o[t] = -1;
                const a = nN.newArray(i - s, 0);
                let l = 0
                  , c = 0;
                for (let e = 0; e < s; e++) {
                    const e = t.readInt(!0);
                    for (; l != e; )
                        a[c++] = l++;
                    o[l + t.readInt(!0)] = l++
                }
                for (; l < i; )
                    a[c++] = l++;
                for (let t = i - 1; t >= 0; t--)
                    -1 == o[t] && (o[t] = a[--c]);
                e.setFrame(n, r, o)
            }
            r.push(e)
        }
        const o = t.readInt(!0);
        if (o > 0) {
            const e = new pL(o);
            for (let r = 0; r < o; r++) {
                const i = t.readFloat()
                  , s = n.events[t.readInt(!0)]
                  , o = new WL(i,s);
                o.intValue = t.readInt(!1),
                o.floatValue = t.readFloat(),
                o.stringValue = t.readBoolean() ? t.readString() : s.stringValue,
                o.data.audioPath && (o.volume = t.readFloat(),
                o.balance = t.readFloat()),
                e.setFrame(r, o)
            }
            r.push(e)
        }
        let a = 0;
        for (let t = 0, e = r.length; t < e; t++)
            a = Math.max(a, r[t].getDuration());
        return new SB(e,r,a)
    }
}
oF.BlendModeValues = [Om.NORMAL, Om.ADD, Om.MULTIPLY, Om.SCREEN];
class aF {
    constructor(t, e, n, r, i) {
        this.mesh = t,
        this.skin = e,
        this.slotIndex = n,
        this.parent = r,
        this.inheritTimeline = i
    }
}
class lF {
    constructor(t=null, e=null) {
        this.bones = t,
        this.vertices = e
    }
}
function cF(t, e, n) {
    let r = t.readFloat()
      , i = t.readFloat() * n;
    for (let s = 0, o = 0, a = e.getFrameCount() - 1; e.setFrame(s, r, i),
    s != a; s++) {
        const a = t.readFloat()
          , l = t.readFloat() * n;
        switch (t.readByte()) {
        case NF:
            e.setStepped(s);
            break;
        case RF:
            hF(t, e, o++, s, 0, r, a, i, l, n)
        }
        r = a,
        i = l
    }
    return e
}
function uF(t, e, n) {
    let r = t.readFloat()
      , i = t.readFloat() * n
      , s = t.readFloat() * n;
    for (let o = 0, a = 0, l = e.getFrameCount() - 1; e.setFrame(o, r, i, s),
    o != l; o++) {
        const l = t.readFloat()
          , c = t.readFloat() * n
          , u = t.readFloat() * n;
        switch (t.readByte()) {
        case NF:
            e.setStepped(o);
            break;
        case RF:
            hF(t, e, a++, o, 0, r, l, i, c, n),
            hF(t, e, a++, o, 1, r, l, s, u, n)
        }
        r = l,
        i = c,
        s = u
    }
    return e
}
function hF(t, e, n, r, i, s, o, a, l, c) {
    e.setBezier(n, r, i, s, a, t.readFloat(), t.readFloat() * c, t.readFloat(), t.readFloat() * c, o, l)
}
const dF = 0
  , fF = 1
  , pF = 2
  , mF = 3
  , gF = 4
  , yF = 5
  , bF = 6
  , vF = 7
  , wF = 8
  , xF = 9
  , EF = 0
  , _F = 1
  , AF = 2
  , SF = 3
  , TF = 4
  , kF = 5
  , IF = 0
  , MF = 1
  , CF = 0
  , PF = 1
  , OF = 2
  , NF = 1
  , RF = 2;
class DF extends sN {
}
class BF {
    constructor(t) {
        this.scale = 1,
        this.linkedMeshes = new Array,
        this.attachmentLoader = t
    }
    readSkeletonData(t) {
        const e = this.scale
          , n = new eF
          , r = "string" == typeof t ? JSON.parse(t) : t
          , i = r.skeleton;
        if (i) {
            n.hash = i.hash,
            n.version = i.spine;
            const t = n.version.substr(0, 3);
            if ("4.0" !== t && "4.1" !== t) {
                const t = `Spine 4.1 loader cant load version ${i.spine}. Please configure your pixi-spine bundle`;
                console.error(t)
            }
            n.x = i.x,
            n.y = i.y,
            n.width = i.width,
            n.height = i.height,
            n.fps = i.fps,
            n.imagesPath = i.images
        }
        if (r.bones)
            for (let t = 0; t < r.bones.length; t++) {
                const i = r.bones[t];
                let s = null;
                const o = zF(i, "parent", null);
                if (null != o && (s = n.findBone(o),
                null == s))
                    throw new Error(`Parent bone not found: ${o}`);
                const a = new zL(n.bones.length,i.name,s);
                a.length = zF(i, "length", 0) * e,
                a.x = zF(i, "x", 0) * e,
                a.y = zF(i, "y", 0) * e,
                a.rotation = zF(i, "rotation", 0),
                a.scaleX = zF(i, "scaleX", 1),
                a.scaleY = zF(i, "scaleY", 1),
                a.shearX = zF(i, "shearX", 0),
                a.shearY = zF(i, "shearY", 0),
                a.transformMode = nN.enumValue(BO, zF(i, "transform", "Normal")),
                a.skinRequired = zF(i, "skin", !1);
                const l = zF(i, "color", null);
                l && a.color.setFromString(l),
                n.bones.push(a)
            }
        if (r.slots)
            for (let t = 0; t < r.slots.length; t++) {
                const e = r.slots[t]
                  , i = n.findBone(e.bone);
                if (!i)
                    throw new Error(`Couldn't find bone ${e.bone} for slot ${e.name}`);
                const s = new nF(n.slots.length,e.name,i)
                  , o = zF(e, "color", null);
                o && s.color.setFromString(o);
                const a = zF(e, "dark", null);
                a && (s.darkColor = qO.fromString(a)),
                s.attachmentName = zF(e, "attachment", null),
                s.blendMode = BF.blendModeFromString(zF(e, "blend", "normal")),
                n.slots.push(s)
            }
        if (r.ik)
            for (let t = 0; t < r.ik.length; t++) {
                const i = r.ik[t]
                  , s = new $L(i.name);
                s.order = zF(i, "order", 0),
                s.skinRequired = zF(i, "skin", !1);
                for (let t = 0; t < i.bones.length; t++) {
                    const e = i.bones[t]
                      , r = n.findBone(e);
                    if (null == r)
                        throw new Error(`IK bone not found: ${e}`);
                    s.bones.push(r)
                }
                s.target = n.findBone(i.target),
                s.mix = zF(i, "mix", 1),
                s.softness = zF(i, "softness", 0) * e,
                s.bendDirection = zF(i, "bendPositive", !0) ? 1 : -1,
                s.compress = zF(i, "compress", !1),
                s.stretch = zF(i, "stretch", !1),
                s.uniform = zF(i, "uniform", !1),
                n.ikConstraints.push(s)
            }
        if (r.transform)
            for (let t = 0; t < r.transform.length; t++) {
                const i = r.transform[t]
                  , s = new rF(i.name);
                s.order = zF(i, "order", 0),
                s.skinRequired = zF(i, "skin", !1);
                for (let t = 0; t < i.bones.length; t++) {
                    const e = i.bones[t]
                      , r = n.findBone(e);
                    if (!r)
                        throw new Error(`Couldn't find bone ${e} for transform constraint ${i.name}.`);
                    s.bones.push(r)
                }
                const o = i.target
                  , a = n.findBone(o);
                if (!a)
                    throw new Error(`Couldn't find target bone ${o} for transform constraint ${i.name}.`);
                s.target = a,
                s.local = zF(i, "local", !1),
                s.relative = zF(i, "relative", !1),
                s.offsetRotation = zF(i, "rotation", 0),
                s.offsetX = zF(i, "x", 0) * e,
                s.offsetY = zF(i, "y", 0) * e,
                s.offsetScaleX = zF(i, "scaleX", 0),
                s.offsetScaleY = zF(i, "scaleY", 0),
                s.offsetShearY = zF(i, "shearY", 0),
                s.mixRotate = zF(i, "mixRotate", 1),
                s.mixX = zF(i, "mixX", 1),
                s.mixY = zF(i, "mixY", s.mixX),
                s.mixScaleX = zF(i, "mixScaleX", 1),
                s.mixScaleY = zF(i, "mixScaleY", s.mixScaleX),
                s.mixShearY = zF(i, "mixShearY", 1),
                n.transformConstraints.push(s)
            }
        if (r.path)
            for (let t = 0; t < r.path.length; t++) {
                const i = r.path[t]
                  , s = new GL(i.name);
                s.order = zF(i, "order", 0),
                s.skinRequired = zF(i, "skin", !1);
                for (let t = 0; t < i.bones.length; t++) {
                    const e = i.bones[t]
                      , r = n.findBone(e);
                    if (!r)
                        throw new Error(`Couldn't find bone ${e} for path constraint ${i.name}.`);
                    s.bones.push(r)
                }
                const o = i.target
                  , a = n.findSlot(o);
                if (!a)
                    throw new Error(`Couldn't find target slot ${o} for path constraint ${i.name}.`);
                s.target = a,
                s.positionMode = nN.enumValue(RO, zF(i, "positionMode", "Percent")),
                s.spacingMode = nN.enumValue(XL, zF(i, "spacingMode", "Length")),
                s.rotateMode = nN.enumValue(DO, zF(i, "rotateMode", "Tangent")),
                s.offsetRotation = zF(i, "rotation", 0),
                s.position = zF(i, "position", 0),
                s.positionMode == RO.Fixed && (s.position *= e),
                s.spacing = zF(i, "spacing", 0),
                s.spacingMode != XL.Length && s.spacingMode != XL.Fixed || (s.spacing *= e),
                s.mixRotate = zF(i, "mixRotate", 1),
                s.mixX = zF(i, "mixX", 1),
                s.mixY = zF(i, "mixY", s.mixX),
                n.pathConstraints.push(s)
            }
        if (r.skins)
            for (let t = 0; t < r.skins.length; t++) {
                const e = r.skins[t]
                  , i = new sF(e.name);
                if (e.bones)
                    for (let t = 0; t < e.bones.length; t++) {
                        const r = e.bones[t]
                          , s = n.findBone(r);
                        if (!s)
                            throw new Error(`Couldn't find bone ${r} for skin ${e.name}.`);
                        i.bones.push(s)
                    }
                if (e.ik)
                    for (let t = 0; t < e.ik.length; t++) {
                        const r = e.ik[t]
                          , s = n.findIkConstraint(r);
                        if (!s)
                            throw new Error(`Couldn't find IK constraint ${r} for skin ${e.name}.`);
                        i.constraints.push(s)
                    }
                if (e.transform)
                    for (let t = 0; t < e.transform.length; t++) {
                        const r = e.transform[t]
                          , s = n.findTransformConstraint(r);
                        if (!s)
                            throw new Error(`Couldn't find transform constraint ${r} for skin ${e.name}.`);
                        i.constraints.push(s)
                    }
                if (e.path)
                    for (let t = 0; t < e.path.length; t++) {
                        const r = e.path[t]
                          , s = n.findPathConstraint(r);
                        if (!s)
                            throw new Error(`Couldn't find path constraint ${r} for skin ${e.name}.`);
                        i.constraints.push(s)
                    }
                for (const t in e.attachments) {
                    const r = n.findSlot(t);
                    if (!r)
                        throw new Error(`Couldn't find slot ${t} for skin ${e.name}.`);
                    const s = e.attachments[t];
                    for (const t in s) {
                        const e = this.readAttachment(s[t], i, r.index, t, n);
                        e && i.setAttachment(r.index, t, e)
                    }
                }
                n.skins.push(i),
                "default" == i.name && (n.defaultSkin = i)
            }
        for (let t = 0, e = this.linkedMeshes.length; t < e; t++) {
            const e = this.linkedMeshes[t]
              , r = e.skin ? n.findSkin(e.skin) : n.defaultSkin;
            if (!r)
                throw new Error(`Skin not found: ${e.skin}`);
            const i = r.getAttachment(e.slotIndex, e.parent);
            if (!i)
                throw new Error(`Parent mesh not found: ${e.parent}`);
            e.mesh.timelineAttachment = e.inheritTimeline ? i : e.mesh,
            e.mesh.setParentMesh(i)
        }
        if (this.linkedMeshes.length = 0,
        r.events)
            for (const t in r.events) {
                const e = r.events[t]
                  , i = new YL(t);
                i.intValue = zF(e, "int", 0),
                i.floatValue = zF(e, "float", 0),
                i.stringValue = zF(e, "string", ""),
                i.audioPath = zF(e, "audio", null),
                i.audioPath && (i.volume = zF(e, "volume", 1),
                i.balance = zF(e, "balance", 0)),
                n.events.push(i)
            }
        if (r.animations)
            for (const t in r.animations) {
                const e = r.animations[t];
                this.readAnimation(e, t, n)
            }
        return n
    }
    readAttachment(t, e, n, r, i) {
        const s = this.scale;
        switch (r = zF(t, "name", r),
        zF(t, "type", "region")) {
        case "region":
            {
                const n = zF(t, "path", r)
                  , i = this.readSequence(zF(t, "sequence", null))
                  , o = this.attachmentLoader.newRegionAttachment(e, r, n, i);
                if (!o)
                    return null;
                o.path = n,
                o.x = zF(t, "x", 0) * s,
                o.y = zF(t, "y", 0) * s,
                o.scaleX = zF(t, "scaleX", 1),
                o.scaleY = zF(t, "scaleY", 1),
                o.rotation = zF(t, "rotation", 0),
                o.width = t.width * s,
                o.height = t.height * s,
                o.sequence = i;
                const a = zF(t, "color", null);
                return a && o.color.setFromString(a),
                o
            }
        case "boundingbox":
            {
                const n = this.attachmentLoader.newBoundingBoxAttachment(e, r);
                if (!n)
                    return null;
                this.readVertices(t, n, t.vertexCount << 1);
                const i = zF(t, "color", null);
                return i && n.color.setFromString(i),
                n
            }
        case "mesh":
        case "linkedmesh":
            {
                const i = zF(t, "path", r)
                  , o = this.readSequence(zF(t, "sequence", null))
                  , a = this.attachmentLoader.newMeshAttachment(e, r, i, o);
                if (!a)
                    return null;
                a.path = i;
                const l = zF(t, "color", null);
                l && a.color.setFromString(l),
                a.width = zF(t, "width", 0) * s,
                a.height = zF(t, "height", 0) * s,
                a.sequence = o;
                const c = zF(t, "parent", null);
                if (c)
                    return this.linkedMeshes.push(new LF(a,zF(t, "skin", null),n,c,zF(t, "timelines", !0))),
                    a;
                const u = t.uvs;
                return this.readVertices(t, a, u.length),
                a.triangles = t.triangles,
                a.regionUVs = new Float32Array(u),
                a.edges = zF(t, "edges", null),
                a.hullLength = 2 * zF(t, "hull", 0),
                a
            }
        case "path":
            {
                const n = this.attachmentLoader.newPathAttachment(e, r);
                if (!n)
                    return null;
                n.closed = zF(t, "closed", !1),
                n.constantSpeed = zF(t, "constantSpeed", !0);
                const i = t.vertexCount;
                this.readVertices(t, n, i << 1);
                const o = nN.newArray(i / 3, 0);
                for (let e = 0; e < t.lengths.length; e++)
                    o[e] = t.lengths[e] * s;
                n.lengths = o;
                const a = zF(t, "color", null);
                return a && n.color.setFromString(a),
                n
            }
        case "point":
            {
                const n = this.attachmentLoader.newPointAttachment(e, r);
                if (!n)
                    return null;
                n.x = zF(t, "x", 0) * s,
                n.y = zF(t, "y", 0) * s,
                n.rotation = zF(t, "rotation", 0);
                const i = zF(t, "color", null);
                return i && n.color.setFromString(i),
                n
            }
        case "clipping":
            {
                const n = this.attachmentLoader.newClippingAttachment(e, r);
                if (!n)
                    return null;
                const s = zF(t, "end", null);
                if (null != s) {
                    const t = i.findSlot(s);
                    if (null == t)
                        throw new Error(`Clipping end slot not found: ${s}`);
                    n.endSlot = t
                }
                const o = t.vertexCount;
                this.readVertices(t, n, o << 1);
                const a = zF(t, "color", null);
                return a && n.color.setFromString(a),
                n
            }
        }
        return null
    }
    readSequence(t) {
        if (null == t)
            return null;
        const e = new EB(zF(t, "count", 0));
        return e.start = zF(t, "start", 1),
        e.digits = zF(t, "digits", 0),
        e.setupIndex = zF(t, "setup", 0),
        e
    }
    readVertices(t, e, n) {
        const r = this.scale;
        e.worldVerticesLength = n;
        const i = t.vertices;
        if (n == i.length) {
            const t = nN.toFloatArray(i);
            if (1 != r)
                for (let e = 0, n = i.length; e < n; e++)
                    t[e] *= r;
            return void (e.vertices = t)
        }
        const s = new Array
          , o = new Array;
        for (let t = 0, e = i.length; t < e; ) {
            const e = i[t++];
            o.push(e);
            for (let n = t + 4 * e; t < n; t += 4)
                o.push(i[t]),
                s.push(i[t + 1] * r),
                s.push(i[t + 2] * r),
                s.push(i[t + 3])
        }
        e.bones = o,
        e.vertices = nN.toFloatArray(s)
    }
    readAnimation(t, e, n) {
        const r = this.scale
          , i = new Array;
        if (t.slots)
            for (const e in t.slots) {
                const r = t.slots[e]
                  , s = n.findSlot(e);
                if (!s)
                    throw new Error(`Slot not found: ${e}`);
                const o = s.index;
                for (const t in r) {
                    const e = r[t];
                    if (!e)
                        continue;
                    const n = e.length;
                    if ("attachment" == t) {
                        const t = new hL(n,o);
                        for (let r = 0; r < n; r++) {
                            const n = e[r];
                            t.setFrame(r, zF(n, "time", 0), zF(n, "name", null))
                        }
                        i.push(t)
                    } else if ("rgba" == t) {
                        const t = new oL(n,n << 2,o);
                        let r = e[0]
                          , s = zF(r, "time", 0)
                          , a = qO.fromString(r.color);
                        for (let n = 0, i = 0; ; n++) {
                            t.setFrame(n, s, a.r, a.g, a.b, a.a);
                            const o = e[n + 1];
                            if (!o) {
                                t.shrink(i);
                                break
                            }
                            const l = zF(o, "time", 0)
                              , c = qO.fromString(o.color)
                              , u = r.curve;
                            u && (i = UF(u, t, i, n, 0, s, l, a.r, c.r, 1),
                            i = UF(u, t, i, n, 1, s, l, a.g, c.g, 1),
                            i = UF(u, t, i, n, 2, s, l, a.b, c.b, 1),
                            i = UF(u, t, i, n, 3, s, l, a.a, c.a, 1)),
                            s = l,
                            a = c,
                            r = o
                        }
                        i.push(t)
                    } else if ("rgb" == t) {
                        const t = new aL(n,3 * n,o);
                        let r = e[0]
                          , s = zF(r, "time", 0)
                          , a = qO.fromString(r.color);
                        for (let n = 0, i = 0; ; n++) {
                            t.setFrame(n, s, a.r, a.g, a.b);
                            const o = e[n + 1];
                            if (!o) {
                                t.shrink(i);
                                break
                            }
                            const l = zF(o, "time", 0)
                              , c = qO.fromString(o.color)
                              , u = r.curve;
                            u && (i = UF(u, t, i, n, 0, s, l, a.r, c.r, 1),
                            i = UF(u, t, i, n, 1, s, l, a.g, c.g, 1),
                            i = UF(u, t, i, n, 2, s, l, a.b, c.b, 1)),
                            s = l,
                            a = c,
                            r = o
                        }
                        i.push(t)
                    } else if ("alpha" == t)
                        i.push(FF(e, new lL(n,n,o), 0, 1));
                    else if ("rgba2" == t) {
                        const t = new cL(n,7 * n,o);
                        let r = e[0]
                          , s = zF(r, "time", 0)
                          , a = qO.fromString(r.light)
                          , l = qO.fromString(r.dark);
                        for (let n = 0, i = 0; ; n++) {
                            t.setFrame(n, s, a.r, a.g, a.b, a.a, l.r, l.g, l.b);
                            const o = e[n + 1];
                            if (!o) {
                                t.shrink(i);
                                break
                            }
                            const c = zF(o, "time", 0)
                              , u = qO.fromString(o.light)
                              , h = qO.fromString(o.dark)
                              , d = r.curve;
                            d && (i = UF(d, t, i, n, 0, s, c, a.r, u.r, 1),
                            i = UF(d, t, i, n, 1, s, c, a.g, u.g, 1),
                            i = UF(d, t, i, n, 2, s, c, a.b, u.b, 1),
                            i = UF(d, t, i, n, 3, s, c, a.a, u.a, 1),
                            i = UF(d, t, i, n, 4, s, c, l.r, h.r, 1),
                            i = UF(d, t, i, n, 5, s, c, l.g, h.g, 1),
                            i = UF(d, t, i, n, 6, s, c, l.b, h.b, 1)),
                            s = c,
                            a = u,
                            l = h,
                            r = o
                        }
                        i.push(t)
                    } else if ("rgb2" == t) {
                        const t = new uL(n,6 * n,o);
                        let r = e[0]
                          , s = zF(r, "time", 0)
                          , a = qO.fromString(r.light)
                          , l = qO.fromString(r.dark);
                        for (let n = 0, i = 0; ; n++) {
                            t.setFrame(n, s, a.r, a.g, a.b, l.r, l.g, l.b);
                            const o = e[n + 1];
                            if (!o) {
                                t.shrink(i);
                                break
                            }
                            const c = zF(o, "time", 0)
                              , u = qO.fromString(o.light)
                              , h = qO.fromString(o.dark)
                              , d = r.curve;
                            d && (i = UF(d, t, i, n, 0, s, c, a.r, u.r, 1),
                            i = UF(d, t, i, n, 1, s, c, a.g, u.g, 1),
                            i = UF(d, t, i, n, 2, s, c, a.b, u.b, 1),
                            i = UF(d, t, i, n, 3, s, c, l.r, h.r, 1),
                            i = UF(d, t, i, n, 4, s, c, l.g, h.g, 1),
                            i = UF(d, t, i, n, 5, s, c, l.b, h.b, 1)),
                            s = c,
                            a = u,
                            l = h,
                            r = o
                        }
                        i.push(t)
                    }
                }
            }
        if (t.bones)
            for (const e in t.bones) {
                const s = t.bones[e]
                  , o = n.findBone(e);
                if (!o)
                    throw new Error(`Bone not found: ${e}`);
                const a = o.index;
                for (const t in s) {
                    const e = s[t]
                      , n = e.length;
                    if (0 != n)
                        if ("rotate" === t)
                            i.push(FF(e, new KB(n,n,a), 0, 1));
                        else if ("translate" === t) {
                            const t = new QB(n,n << 1,a);
                            i.push(jF(e, t, "x", "y", 0, r))
                        } else if ("translatex" === t) {
                            const t = new ZB(n,n,a);
                            i.push(FF(e, t, 0, r))
                        } else if ("translatey" === t) {
                            const t = new JB(n,n,a);
                            i.push(FF(e, t, 0, r))
                        } else if ("scale" === t) {
                            const t = new tL(n,n << 1,a);
                            i.push(jF(e, t, "x", "y", 1, 1))
                        } else if ("scalex" === t) {
                            const t = new eL(n,n,a);
                            i.push(FF(e, t, 1, 1))
                        } else if ("scaley" === t) {
                            const t = new nL(n,n,a);
                            i.push(FF(e, t, 1, 1))
                        } else if ("shear" === t) {
                            const t = new rL(n,n << 1,a);
                            i.push(jF(e, t, "x", "y", 0, 1))
                        } else if ("shearx" === t) {
                            const t = new iL(n,n,a);
                            i.push(FF(e, t, 0, 1))
                        } else if ("sheary" === t) {
                            const t = new sL(n,n,a);
                            i.push(FF(e, t, 0, 1))
                        }
                }
            }
        if (t.ik)
            for (const e in t.ik) {
                const s = t.ik[e];
                let o = s[0];
                if (!o)
                    continue;
                const a = n.findIkConstraint(e);
                if (!a)
                    throw new Error(`IK Constraint not found: ${e}`);
                const l = n.ikConstraints.indexOf(a)
                  , c = new yL(s.length,s.length << 1,l);
                let u = zF(o, "time", 0)
                  , h = zF(o, "mix", 1)
                  , d = zF(o, "softness", 0) * r;
                for (let t = 0, e = 0; ; t++) {
                    c.setFrame(t, u, h, d, zF(o, "bendPositive", !0) ? 1 : -1, zF(o, "compress", !1), zF(o, "stretch", !1));
                    const n = s[t + 1];
                    if (!n) {
                        c.shrink(e);
                        break
                    }
                    const i = zF(n, "time", 0)
                      , a = zF(n, "mix", 1)
                      , l = zF(n, "softness", 0) * r
                      , f = o.curve;
                    f && (e = UF(f, c, e, t, 0, u, i, h, a, 1),
                    e = UF(f, c, e, t, 1, u, i, d, l, r)),
                    u = i,
                    h = a,
                    d = l,
                    o = n
                }
                i.push(c)
            }
        if (t.transform)
            for (const e in t.transform) {
                const r = t.transform[e];
                let s = r[0];
                if (!s)
                    continue;
                const o = n.findTransformConstraint(e);
                if (!o)
                    throw new Error(`Transform constraint not found: ${e}`);
                const a = n.transformConstraints.indexOf(o)
                  , l = new bL(r.length,6 * r.length,a);
                let c = zF(s, "time", 0)
                  , u = zF(s, "mixRotate", 1)
                  , h = zF(s, "mixX", 1)
                  , d = zF(s, "mixY", h)
                  , f = zF(s, "mixScaleX", 1)
                  , p = zF(s, "mixScaleY", f);
                const m = zF(s, "mixShearY", 1);
                for (let t = 0, e = 0; ; t++) {
                    l.setFrame(t, c, u, h, d, f, p, m);
                    const n = r[t + 1];
                    if (!n) {
                        l.shrink(e);
                        break
                    }
                    const i = zF(n, "time", 0)
                      , o = zF(n, "mixRotate", 1)
                      , a = zF(n, "mixX", 1)
                      , g = zF(n, "mixY", a)
                      , y = zF(n, "mixScaleX", 1)
                      , b = zF(n, "mixScaleY", y)
                      , v = zF(n, "mixShearY", 1)
                      , w = s.curve;
                    w && (e = UF(w, l, e, t, 0, c, i, u, o, 1),
                    e = UF(w, l, e, t, 1, c, i, h, a, 1),
                    e = UF(w, l, e, t, 2, c, i, d, g, 1),
                    e = UF(w, l, e, t, 3, c, i, f, y, 1),
                    e = UF(w, l, e, t, 4, c, i, p, b, 1),
                    e = UF(w, l, e, t, 5, c, i, m, v, 1)),
                    c = i,
                    u = o,
                    h = a,
                    d = g,
                    f = y,
                    p = b,
                    f = y,
                    s = n
                }
                i.push(l)
            }
        if (t.path)
            for (const e in t.path) {
                const s = t.path[e]
                  , o = n.findPathConstraint(e);
                if (!o)
                    throw new Error(`Path constraint not found: ${e}`);
                const a = n.pathConstraints.indexOf(o);
                for (const t in s) {
                    const e = s[t];
                    let n = e[0];
                    if (!n)
                        continue;
                    const l = e.length;
                    if ("position" === t) {
                        const t = new vL(l,l,a);
                        i.push(FF(e, t, 0, o.positionMode == RO.Fixed ? r : 1))
                    } else if ("spacing" === t) {
                        const t = new wL(l,l,a);
                        i.push(FF(e, t, 0, o.spacingMode == XL.Length || o.spacingMode == XL.Fixed ? r : 1))
                    } else if ("mix" === t) {
                        const t = new xL(l,3 * l,a);
                        let r = zF(n, "time", 0)
                          , s = zF(n, "mixRotate", 1)
                          , o = zF(n, "mixX", 1)
                          , c = zF(n, "mixY", o);
                        for (let i = 0, a = 0; ; i++) {
                            t.setFrame(i, r, s, o, c);
                            const l = e[i + 1];
                            if (!l) {
                                t.shrink(a);
                                break
                            }
                            const u = zF(l, "time", 0)
                              , h = zF(l, "mixRotate", 1)
                              , d = zF(l, "mixX", 1)
                              , f = zF(l, "mixY", d)
                              , p = n.curve;
                            p && (a = UF(p, t, a, i, 0, r, u, s, h, 1),
                            a = UF(p, t, a, i, 1, r, u, o, d, 1),
                            a = UF(p, t, a, i, 2, r, u, c, f, 1)),
                            r = u,
                            s = h,
                            o = d,
                            c = f,
                            n = l
                        }
                        i.push(t)
                    }
                }
            }
        if (t.deform) {
            t.attachments = {};
            for (const e in t.deform) {
                const n = t.deform[e]
                  , r = t.attachments[e] = {};
                for (const t in n) {
                    const e = n[t]
                      , i = r[t] = {};
                    for (const t in e)
                        i[t] = {
                            deform: e[t]
                        }
                }
            }
        }
        if (t.attachments)
            for (const e in t.attachments) {
                const s = t.attachments[e]
                  , o = n.findSkin(e);
                if (null != o)
                    for (const t in s) {
                        const e = s[t]
                          , a = n.findSlot(t);
                        if (!a)
                            throw new Error(`Slot not found: ${t}`);
                        const l = a.index;
                        for (const t in e) {
                            const n = e[t]
                              , s = o.getAttachment(l, t);
                            for (const t in n) {
                                const e = n[t];
                                let o = e[0];
                                if (o)
                                    if ("deform" == t) {
                                        const t = s.bones
                                          , n = s.vertices
                                          , a = t ? n.length / 3 * 2 : n.length
                                          , c = new dL(e.length,e.length,l,s);
                                        let u = zF(o, "time", 0);
                                        for (let i = 0, s = 0; ; i++) {
                                            let l;
                                            const h = zF(o, "vertices", null);
                                            if (h) {
                                                l = nN.newFloatArray(a);
                                                const e = zF(o, "offset", 0);
                                                if (nN.arrayCopy(h, 0, l, e, h.length),
                                                1 != r)
                                                    for (let t = e, n = t + h.length; t < n; t++)
                                                        l[t] *= r;
                                                if (!t)
                                                    for (let t = 0; t < a; t++)
                                                        l[t] += n[t]
                                            } else
                                                l = t ? nN.newFloatArray(a) : n;
                                            c.setFrame(i, u, l);
                                            const d = e[i + 1];
                                            if (!d) {
                                                c.shrink(s);
                                                break
                                            }
                                            const f = zF(d, "time", 0)
                                              , p = o.curve;
                                            p && (s = UF(p, c, s, i, 0, u, f, 0, 1, 1)),
                                            u = f,
                                            o = d
                                        }
                                        i.push(c)
                                    } else if ("sequence" == t) {
                                        const t = new _L(e.length,l,s);
                                        let n = 0;
                                        for (let r = 0; r < e.length; r++) {
                                            const i = zF(o, "delay", n)
                                              , s = zF(o, "time", 0)
                                              , a = _B[zF(o, "mode", "hold")]
                                              , l = zF(o, "index", 0);
                                            t.setFrame(r, s, a, l, i),
                                            n = i,
                                            o = e[r + 1]
                                        }
                                        i.push(t)
                                    }
                            }
                        }
                    }
                else if (oN.FAIL_ON_NON_EXISTING_SKIN)
                    throw new Error(`Skin not found: ${e}`)
            }
        if (t.drawOrder) {
            const e = new gL(t.drawOrder.length)
              , r = n.slots.length;
            let s = 0;
            for (let i = 0; i < t.drawOrder.length; i++,
            s++) {
                const o = t.drawOrder[i];
                let a = null;
                const l = zF(o, "offsets", null);
                if (l) {
                    a = nN.newArray(r, -1);
                    const t = nN.newArray(r - l.length, 0);
                    let e = 0
                      , i = 0;
                    for (let r = 0; r < l.length; r++) {
                        const s = l[r]
                          , o = n.findSlot(s.slot);
                        if (!o)
                            throw new Error(`Slot not found: ${o}`);
                        const c = o.index;
                        for (; e != c; )
                            t[i++] = e++;
                        a[e + s.offset] = e++
                    }
                    for (; e < r; )
                        t[i++] = e++;
                    for (let e = r - 1; e >= 0; e--)
                        -1 == a[e] && (a[e] = t[--i])
                }
                e.setFrame(s, zF(o, "time", 0), a)
            }
            i.push(e)
        }
        if (t.events) {
            const e = new pL(t.events.length);
            let r = 0;
            for (let i = 0; i < t.events.length; i++,
            r++) {
                const s = t.events[i]
                  , o = n.findEvent(s.name);
                if (!o)
                    throw new Error(`Event not found: ${s.name}`);
                const a = new WL(nN.toSinglePrecision(zF(s, "time", 0)),o);
                a.intValue = zF(s, "int", o.intValue),
                a.floatValue = zF(s, "float", o.floatValue),
                a.stringValue = zF(s, "string", o.stringValue),
                a.data.audioPath && (a.volume = zF(s, "volume", 1),
                a.balance = zF(s, "balance", 0)),
                e.setFrame(r, a)
            }
            i.push(e)
        }
        let s = 0;
        for (let t = 0, e = i.length; t < e; t++)
            s = Math.max(s, i[t].getDuration());
        if (isNaN(s))
            throw new Error("Error while parsing animation, duration is NaN");
        n.animations.push(new SB(e,i,s))
    }
    static blendModeFromString(t) {
        if ("normal" == (t = t.toLowerCase()))
            return Om.NORMAL;
        if ("additive" == t)
            return Om.ADD;
        if ("multiply" == t)
            return Om.MULTIPLY;
        if ("screen" == t)
            return Om.SCREEN;
        throw new Error(`Unknown blend mode: ${t}`)
    }
}
class LF {
    constructor(t, e, n, r, i) {
        this.mesh = t,
        this.skin = e,
        this.slotIndex = n,
        this.parent = r,
        this.inheritTimeline = i
    }
}
function FF(t, e, n, r) {
    let i = t[0]
      , s = zF(i, "time", 0)
      , o = zF(i, "value", n) * r
      , a = 0;
    for (let l = 0; ; l++) {
        e.setFrame(l, s, o);
        const c = t[l + 1];
        if (!c)
            return e.shrink(a),
            e;
        const u = zF(c, "time", 0)
          , h = zF(c, "value", n) * r;
        i.curve && (a = UF(i.curve, e, a, l, 0, s, u, o, h, r)),
        s = u,
        o = h,
        i = c
    }
}
function jF(t, e, n, r, i, s) {
    let o = t[0]
      , a = zF(o, "time", 0)
      , l = zF(o, n, i) * s
      , c = zF(o, r, i) * s
      , u = 0;
    for (let h = 0; ; h++) {
        e.setFrame(h, a, l, c);
        const d = t[h + 1];
        if (!d)
            return e.shrink(u),
            e;
        const f = zF(d, "time", 0)
          , p = zF(d, n, i) * s
          , m = zF(d, r, i) * s
          , g = o.curve;
        g && (u = UF(g, e, u, h, 0, a, f, l, p, s),
        u = UF(g, e, u, h, 1, a, f, c, m, s)),
        a = f,
        l = p,
        c = m,
        o = d
    }
}
function UF(t, e, n, r, i, s, o, a, l, c) {
    if ("stepped" == t)
        return e.setStepped(r),
        n;
    const u = i << 2
      , h = t[u]
      , d = t[u + 1] * c
      , f = t[u + 2]
      , p = t[u + 3] * c;
    return e.setBezier(n, r, i, s, a, h, d, f, p, o, l),
    n + 1
}
function zF(t, e, n) {
    return void 0 !== t[e] ? t[e] : n
}
class VF extends hN {
    createSkeleton(t) {
        this.skeleton = new tF(t),
        this.skeleton.updateWorldTransform(),
        this.stateData = new FL(t),
        this.state = new SL(this.stateData)
    }
}
var WF = (t=>(t[t.UNKNOWN = 0] = "UNKNOWN",
t[t.VER37 = 37] = "VER37",
t[t.VER38 = 38] = "VER38",
t[t.VER40 = 40] = "VER40",
t[t.VER41 = 41] = "VER41",
t))(WF || {});
function YF(t) {
    const e = t.substr(0, 3)
      , n = Math.floor(10 * Number(e) + .001);
    return "3.7" === e ? 37 : "3.8" === e ? 38 : "4.0" === e ? 40 : "4.1" === e ? 41 : n < 37 ? 37 : 0
}
class HF {
    constructor() {
        this.scale = 1
    }
    readSkeletonData(t, e) {
        let n = null
          , r = this.readVersionOldFormat(e)
          , i = YF(r);
        if (i === WF.VER38 && (n = new BR(new mR(t))),
        r = this.readVersionNewFormat(e),
        i = YF(r),
        i !== WF.VER40 && i !== WF.VER41 || (n = new oF(new jL(t))),
        !n) {
            const t = `Unsupported version of spine model ${r}, please update pixi-spine`;
            console.error(t)
        }
        return n.scale = this.scale,
        n.readSkeletonData(e)
    }
    readVersionOldFormat(t) {
        const e = new PO(t);
        let n;
        try {
            e.readString(),
            n = e.readString()
        } catch (t) {
            n = ""
        }
        return n || ""
    }
    readVersionNewFormat(t) {
        const e = new PO(t);
        let n;
        e.readInt32(),
        e.readInt32();
        try {
            n = e.readString()
        } catch (t) {
            n = ""
        }
        return n || ""
    }
}
class $F {
    constructor() {
        this.scale = 1
    }
    readSkeletonData(t, e) {
        const n = e.skeleton.spine
          , r = YF(n);
        let i = null;
        if (r === WF.VER37 && (i = new aB(new VD(t))),
        r === WF.VER38 && (i = new UR(new mR(t))),
        r !== WF.VER40 && r !== WF.VER41 || (i = new BF(new jL(t))),
        !i) {
            const t = `Unsupported version of spine model ${n}, please update pixi-spine`;
            console.error(t)
        }
        return i.scale = this.scale,
        i.readSkeletonData(e)
    }
}
class GF extends hN {
    createSkeleton(t) {
        const e = YF(t.version);
        let n = null;
        if (e === WF.VER37 && (n = WR),
        e === WF.VER38 && (n = gN),
        e !== WF.VER40 && e !== WF.VER41 || (n = uB),
        !n) {
            const e = `Cant detect version of spine model ${t.version}`;
            console.error(e)
        }
        this.skeleton = new n.Skeleton(t),
        this.skeleton.updateWorldTransform(),
        this.stateData = new n.AnimationStateData(t),
        this.state = new n.AnimationState(this.stateData)
    }
}
(new class extends mN {
    createBinaryParser() {
        return new HF
    }
    createJsonParser() {
        return new $F
    }
    parseData(t, e, n) {
        return {
            spineData: t.readSkeletonData(e, n),
            spineAtlas: e
        }
    }
}
).installLoader();
const XF = {
    loading: !1,
    exited: !1,
    particles: {},
    orientation: {},
    references: {
        ui: {
            level: {}
        }
    },
    latency: {
        pingTime: 0,
        history: []
    },
    external: {
        getSessionToken: ()=>{}
    }
}
  , qF = ()=>QF() / 480
  , KF = ()=>ZF() / 969
  , QF = ()=>XF.app ? XF.app.view.parentNode.offsetWidth : 0
  , ZF = ()=>XF.app ? XF.app.view.parentNode.offsetHeight : 0
  , JF = ()=>{
    if (!XF.viewport || !XF.resources || !XF.level)
        return;
    const t = (new KC).beginFill(wO.Blue).drawRect(0, -bO.Blue * KF(), QF(), bO.Blue * KF()).endFill()
      , e = (new KC).beginFill(wO.Green).drawRect(0, -bO.Green * KF(), QF(), (bO.Green - bO.Blue) * KF()).endFill()
      , n = (new KC).beginFill(wO.Pink).drawRect(0, -bO.Pink * KF(), QF(), (bO.Pink - bO.Green) * KF()).endFill()
      , r = (new KC).beginFill(wO.Teal).drawRect(0, -bO.Teal * KF(), QF(), (bO.Teal - bO.Pink) * KF()).endFill()
      , i = (new KC).beginFill(wO.Yellow).drawRect(0, -bO.Yellow * KF(), QF(), (bO.Yellow - bO.Teal) * KF()).endFill();
    XF.viewport.addChild(t, e, n, r, i),
    tj = 0,
    ij()
}
;
let tj = 0
  , ej = 0
  , nj = 0
  , rj = !0;
const ij = ()=>{
    if (!XF.viewport || !XF.level)
        return;
    const t = 80 * qF()
      , e = XF.level.state.score * KF() + 2 * ZF();
    for (let n = tj; n < Math.floor(e / t); n++)
        if (tj = n + 1,
        Math.random() > 0) {
            const e = n * t / KF()
              , r = e < bO.Blue ? XF.resources["bg-cloud"] : e < bO.Green && e > bO.Blue + 160 ? XF.resources["bg-water-drop"] : e < bO.Pink && e > bO.Green + 160 ? XF.resources["bg-heart"] : e < bO.Teal && e > bO.Pink + 160 ? XF.resources["bg-polygon"] : e > bO.Teal + 160 ? XF.resources["bg-polygon-yellow"] : void 0;
            if (!r) {
                rj = !0;
                continue
            }
            const i = new lM(r)
              , s = QF() / i.width / 3.1
              , o = Math.min(Math.max(.5, Math.random()) * qF(), s);
            i.scale.set(o, o),
            i.x = (QF() - i.width) * Math.random(),
            i.y = -n * t,
            i.zIndex = 1;
            let a = 0;
            for (; !rj && a < 10 && (i.x >= ej && i.x <= ej + nj || i.x + i.width >= ej && i.x + i.width <= ej + nj || i.x <= ej && i.x + i.width >= ej + nj); )
                i.x = (QF() - i.width) * Math.random(),
                ++a;
            XF.viewport.addChild(i),
            ej = i.x,
            nj = i.width,
            rj = !1
        } else
            rj = !0
}
  , sj = t=>{
    const e = new KC;
    return e.beginFill(0),
    e.drawCircle(0, 0, t.height),
    e.endFill(),
    e
}
  , oj = ()=>{
    const t = XF.level?.state.character;
    if (!XF.viewport || !XF.resources || !t)
        return;
    const e = new GF(XF.resources.character.spineData)
      , n = 2.8 * t.width / e.width;
    e.scale.set(n, n),
    e.skeleton.setSkinByName("Blue/Blue_Normal"),
    e.state.setAnimation(0, "JUMP", !0),
    e.position.set(t.x + e.width / 2, t.y + e.height),
    XF.references.character = e,
    e.zIndex = 12,
    XF.viewport.addChild(e)
}
  , aj = ()=>{
    if (!XF.references.character || !XF.level)
        return;
    const t = XF.references.character;
    XF.level.state.invincibilityActive && XF.level.state.rocketActive ? t.state.setAnimation(0, "JUMP_WITH_ROCKET_INVINCIBILITY", !0) : XF.level.state.invincibilityActive && !XF.level.state.rocketActive ? t.state.setAnimation(0, "IDLE_INVINCIBILITY", !0) : !XF.level.state.invincibilityActive && XF.level.state.rocketActive ? t.state.setAnimation(0, "JUMP_WITH_ROCKET", !0) : t.state.setAnimation(0, "JUMP", !0)
}
  , lj = t=>{
    if (!XF.viewport || !XF.resources)
        return;
    let e;
    t.type === pO.Blackhole ? e = new GF(XF.resources.blackhole.spineData) : (e = new GF(XF.resources.items.spineData),
    e.skeleton.setSkinByName(t.type.charAt(0).toUpperCase().concat(t.type.slice(1))));
    const n = 1.6 * t.width / e.width;
    return e.scale.set(n, n),
    e.state.setAnimation(0, "IDLE", !0),
    e.position.set(t.x + e.width / 3, t.y + e.height / 2.5),
    e
}
  , cj = (t,e)=>{
    if (!XF.references.items)
        return;
    const n = XF.references.items.findIndex((e=>e?.uid === t.uid))
      , r = XF.references.items[n];
    if (r) {
        XF.references.items = [...XF.references.items.slice(0, n), ...XF.references.items.slice(n + 1)];
        const i = r.spine;
        t.type === pO.Blackhole ? i.destroy() : (i.state.setAnimation(0, "EXPLODE", !1),
        e && e.play(),
        i.state.addListener({
            complete(t) {
                "EXPLODE" === t.animation?.name && setTimeout((()=>{
                    try {
                        i.destroy()
                    } catch {}
                }
                ))
            }
        }))
    }
}
  , uj = (t,e)=>{
    t.send("move", e)
}
  , hj = (t,e)=>{
    t.send("move-orientation", e)
}
  , dj = (t,e)=>{
    t.send("pause", e)
}
  , fj = t=>{
    t.send("new-life")
}
  , pj = (t,e,n)=>{
    t.send("fire-at", {
        from: e,
        to: n
    })
}
  , mj = t=>{
    XF.latency.pingTime = (new Date).getTime(),
    t.send("ping")
}
  , gj = t=>{
    if (!XF.viewport || !XF.resources)
        return;
    const e = new GF(XF.resources[t.type].spineData)
      , n = t.width / e.width * (t.type === dO.Ghost ? 1.1 : 2.6);
    return e.scale.set(n, n),
    e.state.setAnimation(0, "IDLE", !0),
    e.position.set(t.x + t.width / 2, t.y + t.height),
    e
}
  , yj = (t,e)=>{
    if (!XF.references.monsters)
        return;
    const n = XF.references.monsters.findIndex((e=>e?.uid === t.uid))
      , r = XF.references.monsters[n];
    if (r) {
        XF.references.monsters = [...XF.references.monsters.slice(0, n), ...XF.references.monsters.slice(n + 1)];
        const t = r.spine;
        t.state.setAnimation(0, "DEAD", !1),
        e && e.play(),
        t.state.addListener({
            complete(e) {
                "DEAD" === e.animation?.name && setTimeout((()=>{
                    try {
                        t.destroy()
                    } catch {}
                }
                ))
            }
        })
    }
}
  , bj = t=>{
    if (!XF.resources)
        return;
    let e;
    switch (t.type) {
    case cO.Jumper:
    case cO.Jumper2:
        e = new GF(XF.resources["platform-jumper"].spineData),
        e.state.setAnimation(0, "IDLE", !0),
        t.type === cO.Jumper ? e.skeleton.setSkinByName("Jumper") : e.skeleton.setSkinByName("Jumper2"),
        e.scale.set(t.width / e.width, t.width / e.width),
        e.position.set(t.x + .46 * e.width, t.y + 20);
        break;
    case cO.Rock:
    case cO.Rock2:
        e = new GF(XF.resources["platform-rock"].spineData),
        t.type === cO.Rock ? e.skeleton.setSkinByName("Rock") : e.skeleton.setSkinByName("Rock2"),
        e.scale.set(t.width / e.width, t.width / e.width),
        e.position.set(t.x + .42 * e.width, t.y + e.height / 2);
        break;
    default:
        e = new lM(XF.resources[`platform-${t.type}`]),
        e.scale.set(t.width / e.width, t.width / e.width),
        e.position.set(t.x, t.y)
    }
    return e
}
  , vj = t=>{
    if (!XF.references.platforms)
        return;
    const e = XF.references.platforms.findIndex((e=>e?.uid === t.uid))
      , n = XF.references.platforms[e];
    if (n)
        if (XF.references.platforms = [...XF.references.platforms.slice(0, e), ...XF.references.platforms.slice(e + 1)],
        t.type === cO.Rock || t.type === cO.Rock2) {
            const t = n.sprite;
            t.state.setAnimation(0, "animation", !1),
            t.state.addListener({
                complete(e) {
                    "animation" === e.animation?.name && setTimeout((()=>{
                        try {
                            t.destroy()
                        } catch {}
                    }
                    ))
                }
            })
        } else
            n.sprite.destroy()
}
  , wj = "https://cdn.piratesquadnft.com/clients/meegos/game/sounds"
  , xj = "https://cdn.piratesquadnft.com/clients/meegos/game/visual"
  , Ej = "https://cdn.piratesquadnft.com/clients/meegos/game/visual/animations"
  , _j = t=>{
    Object.entries(gO).filter((e=>e[0].toLowerCase().includes("music") && e[0].toLowerCase() !== t.toLowerCase())).forEach((t=>{
        l_.find(t[1])?.isPlaying && l_.find(t[1]).stop()
    }
    ));
    const e = l_.find(t);
    !e.isPlaying && e.isLoaded && e.play()
}
  , Aj = ()=>{
    const t = [gO.Neutral1, gO.Neutral2, gO.Neutral3, gO.Neutral4, gO.Neutral5, gO.Neutral6, gO.Neutral7];
    return l_.find(t[Math.floor(Math.random() * t.length)])
}
  , Sj = ()=>"true" === window.localStorage.getItem("music-muted")
  , Tj = ()=>"true" === window.localStorage.getItem("sfx-muted")
  , kj = t=>{
    const e = Sj();
    console.log(e, window.localStorage.getItem("music-muted"), String(void 0 !== t ? t : !e)),
    Object.entries(gO).filter((t=>t[0].toLowerCase().includes("music"))).forEach((n=>{
        l_.find(n[1]).muted = void 0 !== t ? t : !e
    }
    )),
    window.localStorage.setItem("music-muted", String(void 0 !== t ? t : !e))
}
  , Ij = t=>{
    const e = Tj();
    Object.entries(gO).filter((t=>!t[0].toLowerCase().includes("music"))).forEach((n=>{
        l_.find(n[1]).muted = void 0 !== t ? t : !e
    }
    )),
    window.localStorage.setItem("sfx-muted", String(void 0 !== t ? t : !e))
}
  , Mj = (t,e)=>{
    const n = Object.keys(gO).length;
    let r = 0;
    const i = i=>{
        XF.exited || (i && !XF.exited && XF.external.clearGame && (XF.exited = !0,
        XF.external.clearGame(),
        XF.external.showLoading && XF.external.showLoading(!1),
        XF.external.showModal && XF.external.showModal({
            title: "Error",
            text: "Impossible to load the sound resources, please check your internet connection and refresh the page"
        })),
        ++r,
        r === n && e ? e() : t && t(r / n * 100))
    }
    ;
    Cj(i),
    Dj(i),
    Pj(i),
    Oj(i),
    Bj(i),
    Nj(i),
    Rj(i),
    Sj() && kj(!0),
    Tj() && Ij(!0)
}
  , Cj = t=>{
    l_.add(gO.Music1, {
        preload: !0,
        url: wj + "/music/music-1.mp3",
        volume: .2,
        loop: !0,
        loaded: t
    }),
    l_.add(gO.Music2, {
        preload: !0,
        url: wj + "/music/music-2.mp3",
        volume: .2,
        loop: !0,
        loaded: t
    }),
    l_.add(gO.Music3, {
        preload: !0,
        url: wj + "/music/music-3.mp3",
        volume: .2,
        loop: !0,
        loaded: t
    }),
    l_.add(gO.Music4, {
        preload: !0,
        url: wj + "/music/music-4.mp3",
        volume: .2,
        loop: !0,
        loaded: t
    }),
    l_.add(gO.Music5, {
        preload: !0,
        url: wj + "/music/music-5.mp3",
        volume: .2,
        loop: !0,
        loaded: t
    })
}
  , Pj = t=>{
    l_.add(gO.ItemRocket, {
        preload: !0,
        url: wj + "/items/rocket.mp3",
        volume: .4,
        loaded: t
    }),
    l_.add(gO.ItemInvincibility, {
        preload: !0,
        url: wj + "/items/invincibility.mp3",
        volume: .4,
        loaded: t
    })
}
  , Oj = t=>{
    l_.add(gO.PlatformRock, {
        preload: !0,
        url: wj + "/platforms/rock.mp3",
        volume: .15,
        loaded: t
    }),
    l_.add(gO.PlatformSpike, {
        preload: !0,
        url: wj + "/platforms/spike.mp3",
        volume: .3,
        loaded: t
    }),
    l_.add(gO.PlatformJumper, {
        preload: !0,
        url: wj + "/platforms/jumper.mp3",
        volume: .3,
        loaded: t
    }),
    l_.add(gO.PlatformLava, {
        preload: !0,
        url: wj + "/platforms/fire.mp3",
        volume: .3,
        loaded: t
    })
}
  , Nj = t=>{
    l_.add(gO.Shoot, {
        preload: !0,
        url: wj + "/character/shoot.mp3",
        volume: .1,
        loaded: t
    }),
    l_.add(gO.Jump, {
        preload: !0,
        url: wj + "/character/jump.mp3",
        volume: .08,
        loaded: t
    })
}
  , Rj = t=>{
    l_.add(gO.BatDeath, {
        preload: !0,
        url: wj + "/monsters/bat-death.mp3",
        volume: .25,
        loaded: t
    }),
    l_.add(gO.BatIdle, {
        preload: !0,
        url: wj + "/monsters/bat-idle.mp3",
        volume: .65,
        loaded: t
    }),
    l_.add(gO.GhostDeath, {
        preload: !0,
        url: wj + "/monsters/ghost-death.mp3",
        volume: .2,
        loaded: t
    }),
    l_.add(gO.GhostIdle, {
        preload: !0,
        url: wj + "/monsters/ghost-idle.mp3",
        volume: .35,
        loaded: t
    }),
    l_.add(gO.OctopusDeath, {
        preload: !0,
        url: wj + "/monsters/octopus-death.mp3",
        volume: .2,
        loaded: t
    }),
    l_.add(gO.OctopusIdle, {
        preload: !0,
        url: wj + "/monsters/octopus-idle.mp3",
        volume: .35,
        loaded: t
    }),
    l_.add(gO.MonsterDeath, {
        preload: !0,
        url: wj + "/monsters/monster-death.mp3",
        volume: .2,
        loaded: t
    }),
    l_.add(gO.MonsterIdle, {
        preload: !0,
        url: wj + "/monsters/monster-idle.mp3",
        volume: .35,
        loaded: t
    })
}
  , Dj = t=>{
    l_.add(gO.Neutral1, {
        preload: !0,
        url: wj + "/bullet/neutral-1.mp3",
        volume: .1,
        loaded: t
    }),
    l_.add(gO.Neutral2, {
        preload: !0,
        url: wj + "/bullet/neutral-2.mp3",
        volume: .1,
        loaded: t
    }),
    l_.add(gO.Neutral3, {
        preload: !0,
        url: wj + "/bullet/neutral-3.mp3",
        volume: .1,
        loaded: t
    }),
    l_.add(gO.Neutral4, {
        preload: !0,
        url: wj + "/bullet/neutral-4.mp3",
        volume: .1,
        loaded: t
    }),
    l_.add(gO.Neutral5, {
        preload: !0,
        url: wj + "/bullet/neutral-5.mp3",
        volume: .1,
        loaded: t
    }),
    l_.add(gO.Neutral6, {
        preload: !0,
        url: wj + "/bullet/neutral-6.mp3",
        volume: .1,
        loaded: t
    }),
    l_.add(gO.Neutral7, {
        preload: !0,
        url: wj + "/bullet/neutral-7.mp3",
        volume: .1,
        loaded: t
    })
}
  , Bj = t=>{
    l_.add(gO.GameOk, {
        preload: !0,
        url: wj + "/game/ok.mp3",
        volume: .2,
        loaded: t
    }),
    l_.add(gO.GamePlay, {
        preload: !0,
        url: wj + "/game/play.mp3",
        volume: .1,
        loaded: t
    }),
    l_.add(gO.GameWin, {
        preload: !0,
        url: wj + "/game/win.mp3",
        volume: .25,
        loaded: t
    }),
    l_.add(gO.GamePause, {
        preload: !0,
        url: wj + "/game/pause.mp3",
        volume: .25,
        loaded: t
    }),
    l_.add(gO.GameMusicToggle, {
        preload: !0,
        url: wj + "/game/music-toggle.mp3",
        volume: .25,
        loaded: t
    })
}
;
/*!
 * @pixi/particle-emitter - v5.0.8
 * Compiled Mon, 28 Nov 2022 04:01:38 UTC
 *
 * @pixi/particle-emitter is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
class Lj {
    constructor(t, e, n) {
        this.value = t,
        this.time = e,
        this.next = null,
        this.isStepped = !1,
        this.ease = n ? "function" == typeof n ? n : $j(n) : null
    }
    static createList(t) {
        if ("list"in t) {
            const e = t.list;
            let n;
            const {value: r, time: i} = e[0]
              , s = n = new Lj("string" == typeof r ? Hj(r) : r,i,t.ease);
            if (e.length > 2 || 2 === e.length && e[1].value !== r)
                for (let t = 1; t < e.length; ++t) {
                    const {value: r, time: i} = e[t];
                    n.next = new Lj("string" == typeof r ? Hj(r) : r,i),
                    n = n.next
                }
            return s.isStepped = !!t.isStepped,
            s
        }
        const e = new Lj("string" == typeof t.start ? Hj(t.start) : t.start,0);
        return t.end !== t.start && (e.next = new Lj("string" == typeof t.end ? Hj(t.end) : t.end,1)),
        e
    }
}
let Fj = Ow.from;
const jj = Math.PI / 180;
function Uj(t, e) {
    if (!t)
        return;
    const n = Math.sin(t)
      , r = Math.cos(t)
      , i = e.x * r - e.y * n
      , s = e.x * n + e.y * r;
    e.x = i,
    e.y = s
}
function zj(t, e, n) {
    return t << 16 | e << 8 | n
}
function Vj(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y)
}
function Wj(t) {
    const e = 1 / Vj(t);
    t.x *= e,
    t.y *= e
}
function Yj(t, e) {
    t.x *= e,
    t.y *= e
}
function Hj(t, e) {
    let n;
    return e || (e = {}),
    "#" === t.charAt(0) ? t = t.substr(1) : 0 === t.indexOf("0x") && (t = t.substr(2)),
    8 === t.length && (n = t.substr(0, 2),
    t = t.substr(2)),
    e.r = parseInt(t.substr(0, 2), 16),
    e.g = parseInt(t.substr(2, 2), 16),
    e.b = parseInt(t.substr(4, 2), 16),
    n && (e.a = parseInt(n, 16)),
    e
}
function $j(t) {
    const e = t.length
      , n = 1 / e;
    return function(r) {
        const i = e * r | 0
          , s = (r - i * n) * e
          , o = t[i] || t[e - 1];
        return o.s + s * (2 * (1 - s) * (o.cp - o.s) + s * (o.e - o.s))
    }
}
function Gj(t) {
    return t ? (t = t.toUpperCase().replace(/ /g, "_"),
    Om[t] || Om.NORMAL) : Om.NORMAL
}
var Xj, qj;
class Kj extends lM {
    constructor(t) {
        super(),
        this.prevChild = this.nextChild = null,
        this.emitter = t,
        this.config = {},
        this.anchor.x = this.anchor.y = .5,
        this.maxLife = 0,
        this.age = 0,
        this.agePercent = 0,
        this.oneOverLife = 0,
        this.next = null,
        this.prev = null,
        this.init = this.init,
        this.kill = this.kill
    }
    init(t) {
        this.maxLife = t,
        this.age = this.agePercent = 0,
        this.rotation = 0,
        this.position.x = this.position.y = 0,
        this.scale.x = this.scale.y = 1,
        this.tint = 16777215,
        this.alpha = 1,
        this.oneOverLife = 1 / this.maxLife,
        this.visible = !0
    }
    kill() {
        this.emitter.recycle(this)
    }
    destroy() {
        this.parent && this.parent.removeChild(this),
        this.emitter = this.next = this.prev = null,
        super.destroy()
    }
}
(qj = Xj || (Xj = {}))[qj.Spawn = 0] = "Spawn",
qj[qj.Normal = 2] = "Normal",
qj[qj.Late = 5] = "Late";
const Qj = Bx.shared
  , Zj = Symbol("Position particle per emitter position");
class Jj {
    constructor(t, e) {
        this.initBehaviors = [],
        this.updateBehaviors = [],
        this.recycleBehaviors = [],
        this.minLifetime = 0,
        this.maxLifetime = 0,
        this.customEase = null,
        this._frequency = 1,
        this.spawnChance = 1,
        this.maxParticles = 1e3,
        this.emitterLifetime = -1,
        this.spawnPos = new bv,
        this.particlesPerWave = 1,
        this.rotation = 0,
        this.ownerPos = new bv,
        this._prevEmitterPos = new bv,
        this._prevPosIsValid = !1,
        this._posChanged = !1,
        this._parent = null,
        this.addAtBack = !1,
        this.particleCount = 0,
        this._emit = !1,
        this._spawnTimer = 0,
        this._emitterLife = -1,
        this._activeParticlesFirst = null,
        this._activeParticlesLast = null,
        this._poolFirst = null,
        this._origConfig = null,
        this._autoUpdate = !1,
        this._destroyWhenComplete = !1,
        this._completeCallback = null,
        this.parent = t,
        e && this.init(e),
        this.recycle = this.recycle,
        this.update = this.update,
        this.rotate = this.rotate,
        this.updateSpawnPos = this.updateSpawnPos,
        this.updateOwnerPos = this.updateOwnerPos
    }
    static registerBehavior(t) {
        Jj.knownBehaviors[t.type] = t
    }
    get frequency() {
        return this._frequency
    }
    set frequency(t) {
        this._frequency = "number" == typeof t && t > 0 ? t : 1
    }
    get parent() {
        return this._parent
    }
    set parent(t) {
        this.cleanup(),
        this._parent = t
    }
    init(t) {
        if (!t)
            return;
        this.cleanup(),
        this._origConfig = t,
        this.minLifetime = t.lifetime.min,
        this.maxLifetime = t.lifetime.max,
        t.ease ? this.customEase = "function" == typeof t.ease ? t.ease : $j(t.ease) : this.customEase = null,
        this.particlesPerWave = 1,
        t.particlesPerWave && t.particlesPerWave > 1 && (this.particlesPerWave = t.particlesPerWave),
        this.frequency = t.frequency,
        this.spawnChance = "number" == typeof t.spawnChance && t.spawnChance > 0 ? t.spawnChance : 1,
        this.emitterLifetime = t.emitterLifetime || -1,
        this.maxParticles = t.maxParticles > 0 ? t.maxParticles : 1e3,
        this.addAtBack = !!t.addAtBack,
        this.rotation = 0,
        this.ownerPos.set(0),
        t.pos ? this.spawnPos.copyFrom(t.pos) : this.spawnPos.set(0),
        this._prevEmitterPos.copyFrom(this.spawnPos),
        this._prevPosIsValid = !1,
        this._spawnTimer = 0,
        this.emit = void 0 === t.emit || !!t.emit,
        this.autoUpdate = !!t.autoUpdate;
        const e = t.behaviors.map((t=>{
            const e = Jj.knownBehaviors[t.type];
            return e ? new e(t.config) : (console.error(`Unknown behavior: ${t.type}`),
            null)
        }
        )).filter((t=>!!t));
        e.push(Zj),
        e.sort(((t,e)=>t === Zj ? e.order === Xj.Spawn ? 1 : -1 : e === Zj ? t.order === Xj.Spawn ? -1 : 1 : t.order - e.order)),
        this.initBehaviors = e.slice(),
        this.updateBehaviors = e.filter((t=>t !== Zj && t.updateParticle)),
        this.recycleBehaviors = e.filter((t=>t !== Zj && t.recycleParticle))
    }
    getBehavior(t) {
        return Jj.knownBehaviors[t] && this.initBehaviors.find((e=>e instanceof Jj.knownBehaviors[t])) || null
    }
    fillPool(t) {
        for (; t > 0; --t) {
            const t = new Kj(this);
            t.next = this._poolFirst,
            this._poolFirst = t
        }
    }
    recycle(t, e=!1) {
        for (let n = 0; n < this.recycleBehaviors.length; ++n)
            this.recycleBehaviors[n].recycleParticle(t, !e);
        t.next && (t.next.prev = t.prev),
        t.prev && (t.prev.next = t.next),
        t === this._activeParticlesLast && (this._activeParticlesLast = t.prev),
        t === this._activeParticlesFirst && (this._activeParticlesFirst = t.next),
        t.prev = null,
        t.next = this._poolFirst,
        this._poolFirst = t,
        t.parent && t.parent.removeChild(t),
        --this.particleCount
    }
    rotate(t) {
        if (this.rotation === t)
            return;
        const e = t - this.rotation;
        this.rotation = t,
        Uj(e, this.spawnPos),
        this._posChanged = !0
    }
    updateSpawnPos(t, e) {
        this._posChanged = !0,
        this.spawnPos.x = t,
        this.spawnPos.y = e
    }
    updateOwnerPos(t, e) {
        this._posChanged = !0,
        this.ownerPos.x = t,
        this.ownerPos.y = e
    }
    resetPositionTracking() {
        this._prevPosIsValid = !1
    }
    get emit() {
        return this._emit
    }
    set emit(t) {
        this._emit = !!t,
        this._emitterLife = this.emitterLifetime
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        this._autoUpdate && !t ? Qj.remove(this.update, this) : !this._autoUpdate && t && Qj.add(this.update, this),
        this._autoUpdate = !!t
    }
    playOnceAndDestroy(t) {
        this.autoUpdate = !0,
        this.emit = !0,
        this._destroyWhenComplete = !0,
        this._completeCallback = t
    }
    playOnce(t) {
        this.emit = !0,
        this._completeCallback = t
    }
    update(t) {
        if (this._autoUpdate && (t = .001 * Qj.elapsedMS),
        !this._parent)
            return;
        for (let e, n = this._activeParticlesFirst; n; n = e)
            if (e = n.next,
            n.age += t,
            n.age > n.maxLife || n.age < 0)
                this.recycle(n);
            else {
                let e = n.age * n.oneOverLife;
                this.customEase && (e = 4 === this.customEase.length ? this.customEase(e, 0, 1, 1) : this.customEase(e)),
                n.agePercent = e;
                for (let e = 0; e < this.updateBehaviors.length; ++e)
                    if (this.updateBehaviors[e].updateParticle(n, t)) {
                        this.recycle(n);
                        break
                    }
            }
        let e, n;
        this._prevPosIsValid && (e = this._prevEmitterPos.x,
        n = this._prevEmitterPos.y);
        const r = this.ownerPos.x + this.spawnPos.x
          , i = this.ownerPos.y + this.spawnPos.y;
        if (this._emit)
            for (this._spawnTimer -= t < 0 ? 0 : t; this._spawnTimer <= 0; ) {
                if (this._emitterLife >= 0 && (this._emitterLife -= this._frequency,
                this._emitterLife <= 0)) {
                    this._spawnTimer = 0,
                    this._emitterLife = 0,
                    this.emit = !1;
                    break
                }
                if (this.particleCount >= this.maxParticles) {
                    this._spawnTimer += this._frequency;
                    continue
                }
                let s, o;
                if (this._prevPosIsValid && this._posChanged) {
                    const a = 1 + this._spawnTimer / t;
                    s = (r - e) * a + e,
                    o = (i - n) * a + n
                } else
                    s = r,
                    o = i;
                let a = null
                  , l = null;
                for (let t = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), e = 0; e < t; ++e) {
                    if (this.spawnChance < 1 && Math.random() >= this.spawnChance)
                        continue;
                    let t, e;
                    (t = this.minLifetime === this.maxLifetime ? this.minLifetime : Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime,
                    -this._spawnTimer >= t) || (this._poolFirst ? (e = this._poolFirst,
                    this._poolFirst = this._poolFirst.next,
                    e.next = null) : e = new Kj(this),
                    e.init(t),
                    this.addAtBack ? this._parent.addChildAt(e, 0) : this._parent.addChild(e),
                    a ? (l.next = e,
                    e.prev = l,
                    l = e) : l = a = e,
                    ++this.particleCount)
                }
                if (a) {
                    this._activeParticlesLast ? (this._activeParticlesLast.next = a,
                    a.prev = this._activeParticlesLast,
                    this._activeParticlesLast = l) : (this._activeParticlesFirst = a,
                    this._activeParticlesLast = l);
                    for (let t = 0; t < this.initBehaviors.length; ++t) {
                        const e = this.initBehaviors[t];
                        if (e === Zj)
                            for (let t, e = a; e; e = t) {
                                t = e.next,
                                0 !== this.rotation && (Uj(this.rotation, e.position),
                                e.rotation += this.rotation),
                                e.position.x += s,
                                e.position.y += o,
                                e.age += -this._spawnTimer;
                                let n = e.age * e.oneOverLife;
                                this.customEase && (n = 4 === this.customEase.length ? this.customEase(n, 0, 1, 1) : this.customEase(n)),
                                e.agePercent = n
                            }
                        else
                            e.initParticles(a)
                    }
                    for (let t, e = a; e; e = t) {
                        t = e.next;
                        for (let t = 0; t < this.updateBehaviors.length; ++t)
                            if (this.updateBehaviors[t].updateParticle(e, -this._spawnTimer)) {
                                this.recycle(e);
                                break
                            }
                    }
                }
                this._spawnTimer += this._frequency
            }
        if (this._posChanged && (this._prevEmitterPos.x = r,
        this._prevEmitterPos.y = i,
        this._prevPosIsValid = !0,
        this._posChanged = !1),
        !this._emit && !this._activeParticlesFirst) {
            if (this._completeCallback) {
                const t = this._completeCallback;
                this._completeCallback = null,
                t()
            }
            this._destroyWhenComplete && this.destroy()
        }
    }
    emitNow() {
        const t = this.ownerPos.x + this.spawnPos.x
          , e = this.ownerPos.y + this.spawnPos.y;
        let n = null
          , r = null;
        for (let t = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), e = 0; e < t; ++e) {
            if (this.spawnChance < 1 && Math.random() >= this.spawnChance)
                continue;
            let t, e;
            this._poolFirst ? (t = this._poolFirst,
            this._poolFirst = this._poolFirst.next,
            t.next = null) : t = new Kj(this),
            e = this.minLifetime === this.maxLifetime ? this.minLifetime : Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime,
            t.init(e),
            this.addAtBack ? this._parent.addChildAt(t, 0) : this._parent.addChild(t),
            n ? (r.next = t,
            t.prev = r,
            r = t) : r = n = t,
            ++this.particleCount
        }
        if (n) {
            this._activeParticlesLast ? (this._activeParticlesLast.next = n,
            n.prev = this._activeParticlesLast,
            this._activeParticlesLast = r) : (this._activeParticlesFirst = n,
            this._activeParticlesLast = r);
            for (let r = 0; r < this.initBehaviors.length; ++r) {
                const i = this.initBehaviors[r];
                if (i === Zj)
                    for (let r, i = n; i; i = r)
                        r = i.next,
                        0 !== this.rotation && (Uj(this.rotation, i.position),
                        i.rotation += this.rotation),
                        i.position.x += t,
                        i.position.y += e;
                else
                    i.initParticles(n)
            }
        }
    }
    cleanup() {
        let t, e;
        for (t = this._activeParticlesFirst; t; t = e)
            e = t.next,
            this.recycle(t, !0);
        this._activeParticlesFirst = this._activeParticlesLast = null,
        this.particleCount = 0
    }
    get destroyed() {
        return !(this._parent && this.initBehaviors.length)
    }
    destroy() {
        let t;
        this.autoUpdate = !1,
        this.cleanup();
        for (let e = this._poolFirst; e; e = t)
            t = e.next,
            e.destroy();
        this._poolFirst = this._parent = this.spawnPos = this.ownerPos = this.customEase = this._completeCallback = null,
        this.initBehaviors.length = this.updateBehaviors.length = this.recycleBehaviors.length = 0
    }
}
Jj.knownBehaviors = {};
class tU {
    constructor(t) {
        this.x = t.x,
        this.y = t.y,
        this.w = t.w,
        this.h = t.h
    }
    getRandPos(t) {
        t.x = Math.random() * this.w + this.x,
        t.y = Math.random() * this.h + this.y
    }
}
tU.type = "rect",
tU.editorConfig = null;
class eU {
    constructor(t) {
        this.x = t.x || 0,
        this.y = t.y || 0,
        this.radius = t.radius,
        this.innerRadius = t.innerRadius || 0,
        this.rotation = !!t.affectRotation
    }
    getRandPos(t) {
        this.innerRadius !== this.radius ? t.x = Math.random() * (this.radius - this.innerRadius) + this.innerRadius : t.x = this.radius,
        t.y = 0;
        const e = Math.random() * Math.PI * 2;
        this.rotation && (t.rotation += e),
        Uj(e, t.position),
        t.position.x += this.x,
        t.position.y += this.y
    }
}
eU.type = "torus",
eU.editorConfig = null;
class nU {
    constructor(t) {
        this.segments = [],
        this.countingLengths = [],
        this.totalLength = 0,
        this.init(t)
    }
    init(t) {
        if (t && t.length)
            if (Array.isArray(t[0]))
                for (let e = 0; e < t.length; ++e) {
                    const n = t[e];
                    let r = n[0];
                    for (let t = 1; t < n.length; ++t) {
                        const e = n[t];
                        this.segments.push({
                            p1: r,
                            p2: e,
                            l: 0
                        }),
                        r = e
                    }
                }
            else {
                let e = t[0];
                for (let n = 1; n < t.length; ++n) {
                    const r = t[n];
                    this.segments.push({
                        p1: e,
                        p2: r,
                        l: 0
                    }),
                    e = r
                }
            }
        else
            this.segments.push({
                p1: {
                    x: 0,
                    y: 0
                },
                p2: {
                    x: 0,
                    y: 0
                },
                l: 0
            });
        for (let t = 0; t < this.segments.length; ++t) {
            const {p1: e, p2: n} = this.segments[t]
              , r = Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y));
            this.segments[t].l = r,
            this.totalLength += r,
            this.countingLengths.push(this.totalLength)
        }
    }
    getRandPos(t) {
        const e = Math.random() * this.totalLength;
        let n, r;
        if (1 === this.segments.length)
            n = this.segments[0],
            r = e;
        else
            for (let t = 0; t < this.countingLengths.length; ++t)
                if (e < this.countingLengths[t]) {
                    n = this.segments[t],
                    r = 0 === t ? e : e - this.countingLengths[t - 1];
                    break
                }
        r /= n.l || 1;
        const {p1: i, p2: s} = n;
        t.x = i.x + r * (s.x - i.x),
        t.y = i.y + r * (s.y - i.y)
    }
}
nU.type = "polygonalChain",
nU.editorConfig = null;
class rU {
    constructor(t) {
        var e;
        this.order = Xj.Late,
        this.minStart = t.minStart,
        this.maxStart = t.maxStart,
        this.accel = t.accel,
        this.rotate = !!t.rotate,
        this.maxSpeed = null !== (e = t.maxSpeed) && void 0 !== e ? e : 0
    }
    initParticles(t) {
        let e = t;
        for (; e; ) {
            const t = Math.random() * (this.maxStart - this.minStart) + this.minStart;
            e.config.velocity ? e.config.velocity.set(t, 0) : e.config.velocity = new bv(t,0),
            Uj(e.rotation, e.config.velocity),
            e = e.next
        }
    }
    updateParticle(t, e) {
        const n = t.config.velocity
          , r = n.x
          , i = n.y;
        if (n.x += this.accel.x * e,
        n.y += this.accel.y * e,
        this.maxSpeed) {
            const t = Vj(n);
            t > this.maxSpeed && Yj(n, this.maxSpeed / t)
        }
        t.x += (r + n.x) / 2 * e,
        t.y += (i + n.y) / 2 * e,
        this.rotate && (t.rotation = Math.atan2(n.y, n.x))
    }
}
function iU(t) {
    return this.ease && (t = this.ease(t)),
    (this.first.next.value - this.first.value) * t + this.first.value
}
function sU(t) {
    this.ease && (t = this.ease(t));
    const e = this.first.value
      , n = this.first.next.value;
    return zj((n.r - e.r) * t + e.r, (n.g - e.g) * t + e.g, (n.b - e.b) * t + e.b)
}
function oU(t) {
    this.ease && (t = this.ease(t));
    let e = this.first
      , n = e.next;
    for (; t > n.time; )
        e = n,
        n = n.next;
    return t = (t - e.time) / (n.time - e.time),
    (n.value - e.value) * t + e.value
}
function aU(t) {
    this.ease && (t = this.ease(t));
    let e = this.first
      , n = e.next;
    for (; t > n.time; )
        e = n,
        n = n.next;
    t = (t - e.time) / (n.time - e.time);
    const r = e.value
      , i = n.value;
    return zj((i.r - r.r) * t + r.r, (i.g - r.g) * t + r.g, (i.b - r.b) * t + r.b)
}
function lU(t) {
    this.ease && (t = this.ease(t));
    let e = this.first;
    for (; e.next && t > e.next.time; )
        e = e.next;
    return e.value
}
function cU(t) {
    this.ease && (t = this.ease(t));
    let e = this.first;
    for (; e.next && t > e.next.time; )
        e = e.next;
    const n = e.value;
    return zj(n.r, n.g, n.b)
}
rU.type = "moveAcceleration",
rU.editorConfig = null;
class uU {
    constructor(t=!1) {
        this.first = null,
        this.isColor = !!t,
        this.interpolate = null,
        this.ease = null
    }
    reset(t) {
        this.first = t;
        t.next && t.next.time >= 1 ? this.interpolate = this.isColor ? sU : iU : t.isStepped ? this.interpolate = this.isColor ? cU : lU : this.interpolate = this.isColor ? aU : oU,
        this.ease = this.first.ease
    }
}
class hU {
    constructor(t) {
        this.order = Xj.Normal,
        this.list = new uU(!1),
        this.list.reset(Lj.createList(t.alpha))
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            e.alpha = this.list.first.value,
            e = e.next
    }
    updateParticle(t) {
        t.alpha = this.list.interpolate(t.agePercent)
    }
}
hU.type = "alpha",
hU.editorConfig = null;
class dU {
    constructor(t) {
        this.order = Xj.Normal,
        this.value = t.alpha
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            e.alpha = this.value,
            e = e.next
    }
}
function fU(t) {
    const e = [];
    for (let n = 0; n < t.length; ++n) {
        let r = t[n];
        if ("string" == typeof r)
            e.push(Fj(r));
        else if (r instanceof Ow)
            e.push(r);
        else {
            let t = r.count || 1;
            for (r = "string" == typeof r.texture ? Fj(r.texture) : r.texture; t > 0; --t)
                e.push(r)
        }
    }
    return e
}
dU.type = "alphaStatic",
dU.editorConfig = null;
class pU {
    constructor(t) {
        this.order = Xj.Normal,
        this.anims = [];
        for (let e = 0; e < t.anims.length; ++e) {
            const n = t.anims[e]
              , r = fU(n.textures)
              , i = n.framerate < 0 ? -1 : n.framerate > 0 ? n.framerate : 60
              , s = {
                textures: r,
                duration: i > 0 ? r.length / i : 0,
                framerate: i,
                loop: i > 0 && !!n.loop
            };
            this.anims.push(s)
        }
    }
    initParticles(t) {
        let e = t;
        for (; e; ) {
            const t = Math.floor(Math.random() * this.anims.length)
              , n = e.config.anim = this.anims[t];
            e.texture = n.textures[0],
            e.config.animElapsed = 0,
            -1 === n.framerate ? (e.config.animDuration = e.maxLife,
            e.config.animFramerate = n.textures.length / e.maxLife) : (e.config.animDuration = n.duration,
            e.config.animFramerate = n.framerate),
            e = e.next
        }
    }
    updateParticle(t, e) {
        const n = t.config
          , r = n.anim;
        n.animElapsed += e,
        n.animElapsed >= n.animDuration && (n.anim.loop ? n.animElapsed = n.animElapsed % n.animDuration : n.animElapsed = n.animDuration - 1e-6);
        const i = n.animElapsed * n.animFramerate + 1e-7 | 0;
        t.texture = r.textures[i] || r.textures[r.textures.length - 1] || Ow.EMPTY
    }
}
pU.type = "animatedRandom",
pU.editorConfig = null;
class mU {
    constructor(t) {
        this.order = Xj.Normal;
        const e = t.anim
          , n = fU(e.textures)
          , r = e.framerate < 0 ? -1 : e.framerate > 0 ? e.framerate : 60;
        this.anim = {
            textures: n,
            duration: r > 0 ? n.length / r : 0,
            framerate: r,
            loop: r > 0 && !!e.loop
        }
    }
    initParticles(t) {
        let e = t;
        const n = this.anim;
        for (; e; )
            e.texture = n.textures[0],
            e.config.animElapsed = 0,
            -1 === n.framerate ? (e.config.animDuration = e.maxLife,
            e.config.animFramerate = n.textures.length / e.maxLife) : (e.config.animDuration = n.duration,
            e.config.animFramerate = n.framerate),
            e = e.next
    }
    updateParticle(t, e) {
        const n = this.anim
          , r = t.config;
        r.animElapsed += e,
        r.animElapsed >= r.animDuration && (n.loop ? r.animElapsed = r.animElapsed % r.animDuration : r.animElapsed = r.animDuration - 1e-6);
        const i = r.animElapsed * r.animFramerate + 1e-7 | 0;
        t.texture = n.textures[i] || n.textures[n.textures.length - 1] || Ow.EMPTY
    }
}
mU.type = "animatedSingle",
mU.editorConfig = null;
class gU {
    constructor(t) {
        this.order = Xj.Normal,
        this.value = t.blendMode
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            e.blendMode = Gj(this.value),
            e = e.next
    }
}
gU.type = "blendMode",
gU.editorConfig = null;
class yU {
    constructor(t) {
        this.order = Xj.Spawn,
        this.spacing = t.spacing * jj,
        this.start = t.start * jj,
        this.distance = t.distance
    }
    initParticles(t) {
        let e = 0
          , n = t;
        for (; n; ) {
            let t;
            t = this.spacing ? this.start + this.spacing * e : Math.random() * Math.PI * 2,
            n.rotation = t,
            this.distance && (n.position.x = this.distance,
            Uj(t, n.position)),
            n = n.next,
            ++e
        }
    }
}
yU.type = "spawnBurst",
yU.editorConfig = null;
class bU {
    constructor(t) {
        this.order = Xj.Normal,
        this.list = new uU(!0),
        this.list.reset(Lj.createList(t.color))
    }
    initParticles(t) {
        let e = t;
        const n = this.list.first.value
          , r = zj(n.r, n.g, n.b);
        for (; e; )
            e.tint = r,
            e = e.next
    }
    updateParticle(t) {
        t.tint = this.list.interpolate(t.agePercent)
    }
}
bU.type = "color",
bU.editorConfig = null;
class vU {
    constructor(t) {
        this.order = Xj.Normal;
        let e = t.color;
        "#" === e.charAt(0) ? e = e.substr(1) : 0 === e.indexOf("0x") && (e = e.substr(2)),
        this.value = parseInt(e, 16)
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            e.tint = this.value,
            e = e.next
    }
}
vU.type = "colorStatic",
vU.editorConfig = null;
class wU {
    constructor(t) {
        this.order = Xj.Normal,
        this.index = 0,
        this.textures = t.textures.map((t=>"string" == typeof t ? Fj(t) : t))
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            e.texture = this.textures[this.index],
            ++this.index >= this.textures.length && (this.index = 0),
            e = e.next
    }
}
wU.type = "textureOrdered",
wU.editorConfig = null;
const xU = new bv
  , EU = ["E", "LN2", "LN10", "LOG2E", "LOG10E", "PI", "SQRT1_2", "SQRT2", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "cbrt", "ceil", "cos", "cosh", "exp", "expm1", "floor", "fround", "hypot", "log", "log1p", "log10", "log2", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh"]
  , _U = new RegExp(["[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]"].concat(EU).join("|"),"g");
class AU {
    constructor(t) {
        var e;
        if (this.order = Xj.Late,
        t.path)
            if ("function" == typeof t.path)
                this.path = t.path;
            else
                try {
                    this.path = function(t) {
                        const e = t.match(_U);
                        for (let t = e.length - 1; t >= 0; --t)
                            EU.indexOf(e[t]) >= 0 && (e[t] = `Math.${e[t]}`);
                        return t = e.join(""),
                        new Function("x",`return ${t};`)
                    }(t.path)
                } catch (t) {
                    this.path = null
                }
        else
            this.path = t=>t;
        this.list = new uU(!1),
        this.list.reset(Lj.createList(t.speed)),
        this.minMult = null !== (e = t.minMult) && void 0 !== e ? e : 1
    }
    initParticles(t) {
        let e = t;
        for (; e; ) {
            e.config.initRotation = e.rotation,
            e.config.initPosition ? e.config.initPosition.copyFrom(e.position) : e.config.initPosition = new bv(e.x,e.y),
            e.config.movement = 0;
            const t = Math.random() * (1 - this.minMult) + this.minMult;
            e.config.speedMult = t,
            e = e.next
        }
    }
    updateParticle(t, e) {
        const n = this.list.interpolate(t.agePercent) * t.config.speedMult;
        t.config.movement += n * e,
        xU.x = t.config.movement,
        xU.y = this.path(xU.x),
        Uj(t.config.initRotation, xU),
        t.position.x = t.config.initPosition.x + xU.x,
        t.position.y = t.config.initPosition.y + xU.y
    }
}
AU.type = "movePath",
AU.editorConfig = null;
class SU {
    constructor() {
        this.order = Xj.Spawn
    }
    initParticles(t) {}
}
SU.type = "spawnPoint",
SU.editorConfig = null;
class TU {
    constructor(t) {
        this.order = Xj.Normal,
        this.textures = t.textures.map((t=>"string" == typeof t ? Fj(t) : t))
    }
    initParticles(t) {
        let e = t;
        for (; e; ) {
            const t = Math.floor(Math.random() * this.textures.length);
            e.texture = this.textures[t],
            e = e.next
        }
    }
}
TU.type = "textureRandom",
TU.editorConfig = null;
class kU {
    constructor(t) {
        this.order = Xj.Normal,
        this.minStart = t.minStart * jj,
        this.maxStart = t.maxStart * jj,
        this.minSpeed = t.minSpeed * jj,
        this.maxSpeed = t.maxSpeed * jj,
        this.accel = t.accel * jj
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            this.minStart === this.maxStart ? e.rotation += this.maxStart : e.rotation += Math.random() * (this.maxStart - this.minStart) + this.minStart,
            e.config.rotSpeed = Math.random() * (this.maxSpeed - this.minSpeed) + this.minSpeed,
            e = e.next
    }
    updateParticle(t, e) {
        if (this.accel) {
            const n = t.config.rotSpeed;
            t.config.rotSpeed += this.accel * e,
            t.rotation += (t.config.rotSpeed + n) / 2 * e
        } else
            t.rotation += t.config.rotSpeed * e
    }
}
kU.type = "rotation",
kU.editorConfig = null;
class IU {
    constructor(t) {
        this.order = Xj.Normal,
        this.min = t.min * jj,
        this.max = t.max * jj
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            this.min === this.max ? e.rotation += this.max : e.rotation += Math.random() * (this.max - this.min) + this.min,
            e = e.next
    }
}
IU.type = "rotationStatic",
IU.editorConfig = null;
class MU {
    constructor(t) {
        this.order = Xj.Late + 1,
        this.rotation = (t.rotation || 0) * jj
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            e.rotation = this.rotation,
            e = e.next
    }
}
MU.type = "noRotation",
MU.editorConfig = null;
class CU {
    constructor(t) {
        var e;
        this.order = Xj.Normal,
        this.list = new uU(!1),
        this.list.reset(Lj.createList(t.scale)),
        this.minMult = null !== (e = t.minMult) && void 0 !== e ? e : 1
    }
    initParticles(t) {
        let e = t;
        for (; e; ) {
            const t = Math.random() * (1 - this.minMult) + this.minMult;
            e.config.scaleMult = t,
            e.scale.x = e.scale.y = this.list.first.value * t,
            e = e.next
        }
    }
    updateParticle(t) {
        t.scale.x = t.scale.y = this.list.interpolate(t.agePercent) * t.config.scaleMult
    }
}
CU.type = "scale",
CU.editorConfig = null;
class PU {
    constructor(t) {
        this.order = Xj.Normal,
        this.min = t.min,
        this.max = t.max
    }
    initParticles(t) {
        let e = t;
        for (; e; ) {
            const t = Math.random() * (this.max - this.min) + this.min;
            e.scale.x = e.scale.y = t,
            e = e.next
        }
    }
}
PU.type = "scaleStatic",
PU.editorConfig = null;
class OU {
    constructor(t) {
        this.order = Xj.Spawn;
        const e = OU.shapes[t.type];
        if (!e)
            throw new Error(`No shape found with type '${t.type}'`);
        this.shape = new e(t.data)
    }
    static registerShape(t, e) {
        OU.shapes[e || t.type] = t
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            this.shape.getRandPos(e),
            e = e.next
    }
}
OU.type = "spawnShape",
OU.editorConfig = null,
OU.shapes = {},
OU.registerShape(nU),
OU.registerShape(tU),
OU.registerShape(eU),
OU.registerShape(eU, "circle");
class NU {
    constructor(t) {
        this.order = Xj.Normal,
        this.texture = "string" == typeof t.texture ? Fj(t.texture) : t.texture
    }
    initParticles(t) {
        let e = t;
        for (; e; )
            e.texture = this.texture,
            e = e.next
    }
}
NU.type = "textureSingle",
NU.editorConfig = null;
class RU {
    constructor(t) {
        var e;
        this.order = Xj.Late,
        this.list = new uU(!1),
        this.list.reset(Lj.createList(t.speed)),
        this.minMult = null !== (e = t.minMult) && void 0 !== e ? e : 1
    }
    initParticles(t) {
        let e = t;
        for (; e; ) {
            const t = Math.random() * (1 - this.minMult) + this.minMult;
            e.config.speedMult = t,
            e.config.velocity ? e.config.velocity.set(this.list.first.value * t, 0) : e.config.velocity = new bv(this.list.first.value * t,0),
            Uj(e.rotation, e.config.velocity),
            e = e.next
        }
    }
    updateParticle(t, e) {
        const n = this.list.interpolate(t.agePercent) * t.config.speedMult
          , r = t.config.velocity;
        Wj(r),
        Yj(r, n),
        t.x += r.x * e,
        t.y += r.y * e
    }
}
RU.type = "moveSpeed",
RU.editorConfig = null;
class DU {
    constructor(t) {
        this.order = Xj.Late,
        this.min = t.min,
        this.max = t.max
    }
    initParticles(t) {
        let e = t;
        for (; e; ) {
            const t = Math.random() * (this.max - this.min) + this.min;
            e.config.velocity ? e.config.velocity.set(t, 0) : e.config.velocity = new bv(t,0),
            Uj(e.rotation, e.config.velocity),
            e = e.next
        }
    }
    updateParticle(t, e) {
        const n = t.config.velocity;
        t.x += n.x * e,
        t.y += n.y * e
    }
}
DU.type = "moveSpeedStatic",
DU.editorConfig = null;
Jj.registerBehavior(rU),
Jj.registerBehavior(hU),
Jj.registerBehavior(dU),
Jj.registerBehavior(pU),
Jj.registerBehavior(mU),
Jj.registerBehavior(gU),
Jj.registerBehavior(yU),
Jj.registerBehavior(bU),
Jj.registerBehavior(vU),
Jj.registerBehavior(wU),
Jj.registerBehavior(AU),
Jj.registerBehavior(SU),
Jj.registerBehavior(TU),
Jj.registerBehavior(kU),
Jj.registerBehavior(IU),
Jj.registerBehavior(MU),
Jj.registerBehavior(CU),
Jj.registerBehavior(PU),
Jj.registerBehavior(OU),
Jj.registerBehavior(NU),
Jj.registerBehavior(RU),
Jj.registerBehavior(DU);
const BU = (t,e)=>{
    LU(e),
    FU(t),
    wz(t)
}
  , LU = t=>{
    XF.level = {
        state: {
            lastPauseTimestamp: 0,
            totalTime: 0,
            canMove: t.canMove,
            ended: t.ended,
            lives: t.lives,
            livesUsed: t.livesUsed,
            paused: t.paused,
            score: t.score,
            bonusScore: t.bonusScore,
            character: {
                x: t.character.x,
                y: t.character.y,
                dx: t.character.dx,
                dy: t.character.dy,
                width: t.character.width,
                height: t.character.height
            },
            rocketActive: !1,
            invincibilityActive: !1
        }
    },
    t.items.onAdd((t=>{
        const e = Tz(t);
        e && (t.listen("x", (t=>e.x = t)),
        t.listen("y", (t=>e.y = t)))
    }
    )),
    t.items.onRemove((t=>{
        cj(t)
    }
    )),
    t.monsters.onAdd((t=>{
        const e = kz(t);
        switch (t.type) {
        case dO.Bat:
            l_.play(gO.BatIdle);
            break;
        case dO.Ghost:
            l_.play(gO.GhostIdle);
            break;
        case dO.Octopus:
            l_.play(gO.OctopusIdle);
            break;
        case dO.Monster:
            l_.play(gO.MonsterIdle)
        }
        e && (t.listen("x", (t=>e.x = t)),
        t.listen("y", (t=>e.y = t)),
        t.listen("dx", (t=>e.dx = t)),
        t.listen("dy", (t=>e.dy = t)),
        t.listen("life", (t=>e.life = t)))
    }
    )),
    t.monsters.onRemove((t=>{
        yj(t)
    }
    )),
    t.platforms.onAdd((t=>{
        const e = Iz(t);
        e && (t.listen("x", (t=>e.x = t)),
        t.listen("y", (t=>e.y = t)),
        t.listen("type", (()=>{
            if (!XF.references.platforms)
                return;
            const e = Iz(t, !1)
              , n = XF.references.platforms.findIndex((e=>e?.uid === t.uid))
              , r = XF.references.platforms[n];
            r && e && (r.sprite.destroy(),
            r.sprite = e.sprite,
            r.type = e.type)
        }
        )))
    }
    )),
    t.platforms.onRemove((t=>{
        vj(t)
    }
    )),
    t.bullets.onAdd((t=>{
        const e = Mz(t);
        e && (t.listen("x", (t=>e.x = t)),
        t.listen("y", (t=>e.y = t)))
    }
    )),
    t.bullets.onRemove((t=>{
        if (XF.references.bullets) {
            const e = XF.references.bullets.findIndex((e=>e?.uid === t.uid))
              , n = XF.references.bullets[e];
            n && (XF.references.bullets = [...XF.references.bullets.slice(0, e), ...XF.references.bullets.slice(e + 1)],
            n.graphics.destroy())
        }
    }
    )),
    t.listen("canMove", (t=>{
        XF.level && (XF.level.state.canMove = t,
        console.log("canMove", t))
    }
    )),
    t.listen("ended", (t=>{
        XF.level && (XF.level.state.ended = t,
        console.log("ended", t))
    }
    )),
    t.listen("score", (t=>{
        XF.level && (XF.level.state.score = t,
        ij(),
        qU(XF.level.state.score + XF.level.state.bonusScore))
    }
    )),
    t.listen("bonusScore", (t=>{
        XF.level && (XF.level.state.bonusScore = t,
        qU(XF.level.state.score + XF.level.state.bonusScore))
    }
    )),
    t.listen("lives", (t=>{
        XF.level && (XF.level.state.lives = t,
        console.log("lives", t))
    }
    )),
    t.listen("livesUsed", (t=>{
        XF.level && (XF.level.state.livesUsed = t,
        console.log("livesUsed", t))
    }
    )),
    t.character.listen("x", (t=>{
        XF.level?.state.character && (XF.level.state.character.x = t)
    }
    )),
    t.character.listen("y", (t=>{
        XF.level?.state.character && (XF.level.state.character.y = t)
    }
    )),
    t.character.listen("dx", (t=>{
        XF.level?.state.character && (XF.level.state.character.dx = t)
    }
    )),
    t.character.listen("dy", (t=>{
        XF.level?.state.character && (XF.level.state.character.dy = t)
    }
    ))
}
  , FU = t=>{
    t.onMessage("item-touched", (({item: t})=>{
        const e = XF.references.items?.findIndex((e=>e?.uid === t.uid));
        if (!XF.references.items || void 0 === e || -1 === e)
            return;
        XF.references.items[e]
    }
    )),
    t.onMessage("platform-touched", (({platform: t})=>{
        if (XF.references.platforms)
            if (t.type !== cO.Jumper && t.type !== cO.Jumper2 || !XF.references.character)
                t.type === cO.Rock || t.type === cO.Rock2 ? l_.play(gO.PlatformRock) : t.type === cO.Spike ? l_.play(gO.PlatformSpike) : t.type === cO.Lava ? l_.play(gO.PlatformLava) : l_.play(gO.Jump);
            else {
                const t = XF.references.character;
                setTimeout((()=>{
                    t.skeleton.setSkinByName((t.skeleton.skin?.name ?? "").split("_")[0] + "_Surprise")
                }
                ), 100),
                l_.play(gO.PlatformJumper)
            }
    }
    )),
    t.onMessage("rocket", (({active: t, time: e})=>{
        if (!XF.level || !XF.references.character)
            return;
        XF.level.state.rocketActive = t;
        const n = XF.references.character;
        if (t ? n.skeleton.setSkinByName((n.skeleton.skin?.name ?? "").split("_")[0] + "_Smile") : n.skeleton.setSkinByName((n.skeleton.skin?.name ?? "").split("_")[0] + "_Normal"),
        aj(),
        t && void 0 !== e) {
            (r = n,
            i = 0,
            s = 30,
            o = qF(),
            a = [XF.resources.fireParticle, XF.resources.circleParticle],
            new Jj(r,{
                lifetime: {
                    min: .5 * o,
                    max: 1 * o
                },
                frequency: 5e-4,
                emitterLifetime: 2,
                maxParticles: 3e3,
                addAtBack: !1,
                pos: {
                    x: i,
                    y: s
                },
                behaviors: [{
                    type: "alpha",
                    config: {
                        alpha: {
                            list: [{
                                time: 0,
                                value: .62
                            }, {
                                time: 1,
                                value: 0
                            }]
                        }
                    }
                }, {
                    type: "moveSpeedStatic",
                    config: {
                        min: 500,
                        max: 4e3
                    }
                }, {
                    type: "scale",
                    config: {
                        scale: {
                            list: [{
                                time: 0,
                                value: .5
                            }, {
                                time: 1,
                                value: 1.25
                            }]
                        },
                        minMult: 1
                    }
                }, {
                    type: "color",
                    config: {
                        color: {
                            list: [{
                                time: 0,
                                value: "fff191"
                            }, {
                                time: .25,
                                value: "ff622c"
                            }, {
                                time: 1,
                                value: "666666"
                            }]
                        }
                    }
                }, {
                    type: "rotation",
                    config: {
                        accel: 0,
                        minSpeed: 50,
                        maxSpeed: 200,
                        minStart: 74,
                        maxStart: 105
                    }
                }, {
                    type: "textureRandom",
                    config: {
                        textures: a
                    }
                }, {
                    type: "spawnShape",
                    config: {
                        type: "torus",
                        data: {
                            x: 0,
                            y: 0,
                            radius: 10,
                            innerRadius: 0,
                            affectRotation: !1
                        }
                    }
                }]
            })).playOnceAndDestroy();
            const t = new lM(XF.resources.rocket)
              , l = QF() / t.width * .04;
            t.scale.set(l, l),
            ZU("rocket", t, e)
        }
        var r, i, s, o, a;
        t && l_.play("rocket")
    }
    )),
    t.onMessage("invincibility", (({active: t, time: e})=>{
        if (!XF.level || !XF.references.character)
            return;
        XF.level.state.invincibilityActive = t;
        const n = XF.references.character;
        if (t && void 0 !== e) {
            n.skeleton.setSkinByName((n.skeleton.skin?.name ?? "").split("_")[0] + "_Smile");
            const t = new lM(XF.resources.shield)
              , r = QF() / t.width * .04;
            t.scale.set(r, r),
            ZU("invincibility", t, e),
            l_.play("invincibility")
        } else
            n.skeleton.setSkinByName((n.skeleton.skin?.name ?? "").split("_")[0] + "_Normal");
        aj()
    }
    )),
    t.onMessage("bullet-collided", (({bullet: t, monster: e})=>{
        Aj().play()
    }
    )),
    t.onMessage("monster-killed", (({monster: t})=>{
        switch (t.type) {
        case dO.Bat:
            l_.play(gO.BatDeath);
            break;
        case dO.Ghost:
            l_.play(gO.GhostDeath);
            break;
        case dO.Octopus:
            l_.play(gO.OctopusDeath);
            break;
        case dO.Monster:
            l_.play(gO.MonsterDeath)
        }
    }
    )),
    t.onMessage("new-life", (({x: t, y: e})=>{
        if (!XF.level || !XF.references.character || !XF.level.state.character)
            return;
        const n = XF.references.character
          , r = XF.level.state.character
          , i = t + r.width / 2
          , s = e + r.height;
        n.position.set(i, s),
        tz()
    }
    )),
    t.onMessage("dead", (({score: t})=>{
        if (!XF.level || !XF.references.character)
            return;
        const e = XF.references.character;
        e.skeleton.setSkinByName((e.skeleton.skin?.name ?? "").split("_")[0] + "_Scare"),
        l_.stopAll().play(gO.GameWin),
        KU(t)
    }
    )),
    t.onMessage("pong", (()=>{
        if (!XF.level)
            return;
        const e = (new Date).getTime();
        XF.latency.history = [...XF.latency.history.slice(0, 9), e - XF.latency.pingTime],
        XF.level.state.paused && setTimeout((()=>{
            mj(t)
        }
        ), 100),
        GU()
    }
    ))
}
  , jU = t=>{
    XF.external.showLoading && XF.external.showLoading(!1),
    XF.external.showModal && XF.external.showModal({
        title: "Impossible to connect to the game",
        text: t.message ? `(code ${t.code}) ${t.message}. You request has been refused, please try to refresh the page or unlock your wallet again` : ""
    }),
    console.error(t)
}
  , UU = t=>{
    1e3 !== t && XF.external.showModal && (XF.room = void 0)
}
  , zU = async()=>{
    if (XF.room) {
        try {
            await XF.room.leave(!0)
        } catch (t) {
            console.error(t)
        }
        XF.room = void 0
    }
}
  , VU = ()=>{
    if (!XF.app || !XF.viewport || !XF.resources)
        return;
    const t = WU();
    t && (YU(t),
    HU(t),
    t.zIndex = 20,
    XF.app.stage.addChild(t),
    XF.references.topContainer = t)
}
  , WU = ()=>{
    if (!XF.viewport)
        return;
    const t = new EI;
    return t.x = 0,
    t.y = 0,
    XF.references.ui.level.container = t,
    t
}
  , YU = t=>{
    if (!XF.viewport || !XF.resources)
        return;
    const e = qF()
      , n = new lM(XF.resources.pause);
    n.interactive = !0,
    n.cursor = "pointer",
    n.on("pointertap", (t=>{
        l_.find(gO.GamePause).play(),
        $U(),
        t.stopPropagation()
    }
    )),
    n.scale.set(.6 * e, .6 * e),
    n.x = QF() - 1.25 * n.width,
    n.y = 20 * KF(),
    t.addChild(n)
}
  , HU = t=>{
    if (!XF.viewport || !XF.resources)
        return;
    const e = new lM(XF.resources.trophy)
      , n = .75 * qF();
    e.scale.set(n, n),
    e.x = 15 * qF(),
    e.y = 15 * KF();
    const r = new lM(XF.resources["yellow-reverted-button"])
      , i = e.height / r.height * .8;
    r.scale.set(i, i),
    r.x = 28 * qF(),
    r.y = e.y + (e.height - r.height);
    const s = new fP({
        fontFamily: "Inter",
        fontWeight: "700",
        fill: 16777215,
        fontSize: 20 * qF(),
        stroke: 0,
        strokeThickness: 2 * qF(),
        dropShadow: !0,
        dropShadowColor: 0,
        dropShadowDistance: 2 * qF(),
        dropShadowAngle: 90,
        align: "center"
    })
      , o = new bP("0",s)
      , a = uP.measureText(o.text, o.style);
    o.style = s,
    o.x = r.x + (r.width - e.width) / 2 + e.width / 2,
    o.y = r.y + .3 * (r.height / 2 - a.height / 2),
    XF.references.ui.level.scoreCount = o,
    t.addChild(r, e, o)
}
  , $U = ()=>{
    if (!XF.level || !XF.room || !XF.app)
        return;
    dj(XF.room, !0),
    XF.latency.history = [],
    mj(XF.room),
    XF.level.state.paused = !0;
    const t = new EI;
    t.x = 0,
    t.y = 0,
    t.width = QF(),
    t.height = ZF(),
    t.interactive = !0,
    t.on("pointertap", (t=>t.stopPropagation()));
    const e = (new KC).beginFill("#314148").drawRect(0, 0, QF(), ZF()).endFill();
    e.interactive = !0,
    e.cursor = "pointer",
    e.on("pointertap", (t=>{
        l_.find(gO.GameOk).play(),
        XU(),
        t.stopPropagation()
    }
    )),
    e.alpha = .5,
    t.addChild(e);
    const n = new lM(XF.resources["normal-popup"])
      , r = QF() / n.width * .95;
    n.scale.set(r, r),
    n.x = .025 * QF(),
    n.y = ZF() / 2 - n.height / 2,
    t.addChild(n);
    const i = new lM(XF.resources["pause-title"])
      , s = n.width / i.width * .6;
    i.scale.set(s, s),
    i.x = n.x + n.width / 2 - i.width / 2,
    i.y = n.y - .6 * i.height,
    t.addChild(i);
    const o = new lM(XF.resources["pause-text"])
      , a = n.width / o.width * .75;
    o.scale.set(a, a),
    o.x = n.x + n.width / 2 - o.width / 2,
    o.y = n.y + n.height / 2 - o.height / 2,
    o.interactive = !0,
    o.cursor = "pointer",
    o.on("pointertap", (t=>{
        l_.find(gO.GameOk).play(),
        XU(),
        t.stopPropagation()
    }
    )),
    t.addChild(o);
    const l = new fP({
        fontFamily: "Inter",
        fontWeight: "700",
        fill: 16777215,
        fontSize: 16 * qF(),
        stroke: 0,
        strokeThickness: 1.5 * qF(),
        dropShadow: !0,
        dropShadowColor: 0,
        dropShadowDistance: 1.5 * qF(),
        dropShadowAngle: 90,
        align: "center"
    })
      , c = new bP("Music",l)
      , u = uP.measureText(c.text, c.style);
    c.x = o.x,
    c.y = n.y + 2 * u.height;
    const h = new lM(Sj() ? XF.resources["volume-off"] : XF.resources["volume-on"])
      , d = u.height / h.height;
    h.scale.set(d, d),
    h.x = c.x + u.width + h.width / 2,
    h.y = c.y,
    h.tint = Sj() ? 11184810 : 7190758;
    const f = ()=>{
        kj();
        const t = new lM(Sj() ? XF.resources["volume-off"] : XF.resources["volume-on"]);
        h.texture = t.texture,
        h.tint = Sj() ? 11184810 : 7190758
    }
    ;
    h.interactive = !0,
    h.cursor = "pointer",
    h.on("pointertap", (()=>{
        l_.find(gO.GameOk).play(),
        f()
    }
    )),
    c.interactive = !0,
    c.cursor = "pointer",
    c.on("pointertap", (()=>{
        l_.find(gO.GameOk).play(),
        f()
    }
    )),
    t.addChild(h, c);
    const p = new fP({
        fontFamily: "Inter",
        fontWeight: "700",
        fill: 16777215,
        fontSize: 16 * qF(),
        stroke: 0,
        strokeThickness: 1.5 * qF(),
        dropShadow: !0,
        dropShadowColor: 0,
        dropShadowDistance: 1.5 * qF(),
        dropShadowAngle: 90,
        align: "center"
    })
      , m = new bP("SFX",p)
      , g = uP.measureText(m.text, m.style)
      , y = new lM(Tj() ? XF.resources["volume-off"] : XF.resources["volume-on"])
      , b = g.height / y.height;
    y.scale.set(b, b),
    y.x = o.x + o.width - y.width,
    y.y = h.y,
    y.tint = Tj() ? 11184810 : 7190758,
    m.x = y.x - y.width / 2 - g.width,
    m.y = y.y;
    const v = ()=>{
        Ij();
        const t = new lM(Tj() ? XF.resources["volume-off"] : XF.resources["volume-on"]);
        y.texture = t.texture,
        y.tint = Tj() ? 11184810 : 7190758
    }
    ;
    y.interactive = !0,
    y.cursor = "pointer",
    y.on("pointertap", (()=>{
        l_.find(gO.GameOk).play(),
        v()
    }
    )),
    m.interactive = !0,
    m.cursor = "pointer",
    m.on("pointertap", (()=>{
        l_.find(gO.GameOk).play(),
        v()
    }
    )),
    t.addChild(y, m);
    const w = new GF(XF.resources.character.spineData)
      , x = n.width / w.width * .9;
    w.scale.set(x, x),
    w.x = n.x + n.width / 2,
    w.y = n.y + n.height + w.height / 7,
    w.skeleton.setSkinByName("Blue/Blue_Surprise"),
    w.state.setAnimation(0, "IDLE", !0),
    t.addChild(w);
    const E = new fP({
        fontFamily: "Inter",
        fontWeight: "700",
        fill: 16777215,
        fontSize: 16 * qF(),
        stroke: 0,
        strokeThickness: 1.5 * qF(),
        dropShadow: !0,
        dropShadowColor: 0,
        dropShadowDistance: 1.5 * qF(),
        dropShadowAngle: 90,
        align: "center"
    })
      , _ = new bP("x ms",E)
      , A = uP.measureText(_.text, _.style);
    _.x = o.x + o.width - A.width,
    _.y = n.y + n.height - 2 * A.height,
    XF.references.ui.level.latencyCount = _,
    t.addChild(_),
    XF.references.ui.pauseMenu = t,
    t.zIndex = 100,
    XF.app.stage.addChild(t)
}
  , GU = ()=>{
    if (!XF.references.ui.level.latencyCount)
        return;
    XF.references.ui.level.latencyCount.text = `${Math.round(XF.latency.history.reduce(((t,e)=>t + e)) / XF.latency.history.length)} ms`
}
  , XU = ()=>{
    XF.app && XF.level && XF.references.ui.pauseMenu && XF.room && (XF.app.stage.removeChild(XF.references.ui.pauseMenu),
    dj(XF.room, !1),
    XF.level.state.paused = !1)
}
  , qU = t=>{
    if (!XF.references.ui.level.scoreCount)
        return;
    const e = XF.references.ui.level.scoreCount
      , n = uP.measureText(`${e.text}`, e.style)
      , r = String(t).length - e.text.length;
    e.text = `${t}`;
    const i = uP.measureText(`${e.text}`, e.style);
    r > 0 && (e.x -= (i.width - n.width) / 2)
}
;
const KU = async t=>{
    if (!XF.app)
        return;
    const e = new EI;
    e.x = 0,
    e.y = 0,
    e.width = QF(),
    e.height = ZF(),
    e.interactive = !0,
    e.on("pointertap", (t=>t.stopPropagation()));
    const n = (new KC).beginFill("#314148").drawRect(0, 0, QF(), ZF()).endFill();
    n.alpha = .5,
    e.addChild(n);
    const r = new lM(XF.resources["normal-popup"])
      , i = QF() / r.width * .95;
    r.scale.set(i, i),
    r.x = .025 * QF(),
    r.y = ZF() / 2 - r.height / 2,
    e.addChild(r);
    const s = new lM(XF.resources["continue-title"])
      , o = r.width / s.width * .55;
    if (s.scale.set(o, o),
    s.x = r.x + r.width / 2 - s.width / 2,
    s.y = r.y - .6 * s.height,
    e.addChild(s),
    XF.external.getNumberOfAvailableNFT && XF.external.useNFTForLife && XF.external.getEstimatedLeaderboard) {
        const n = new lM(XF.resources["life-button"]);
        n.on("pointertap", (async t=>{
            if (XF.room && XF.external.useNFTForLife)
                if (l_.find(gO.GamePlay).play(),
                (XF.level?.state.livesUsed ?? 0) >= 5 && XF.external.showModal)
                    XF.external.showModal({
                        title: "Max number of lives used",
                        text: "You used 5 lives for this game, you can't use more."
                    });
                else {
                    n.interactive = !1,
                    n.alpha = .5;
                    try {
                        if (void 0 !== await XF.external.useNFTForLife() && (JU(),
                        XF.external.showLoading)) {
                            XF.external.showLoading(!0, void 0, "3");
                            let t = 3;
                            const e = setInterval((()=>{
                                XF.room && XF.external.showLoading && (1 === t ? (fj(XF.room),
                                XF.external.showLoading(!1),
                                clearInterval(e)) : XF.external.showLoading(!0, void 0, "" + --t))
                            }
                            ), 1e3)
                        }
                    } catch (t) {
                        XF.external.showModal && XF.external.showModal({
                            title: "No NFT available",
                            text: "Buy a MeeCartridge NFT to get a new life"
                        }),
                        console.error(t)
                    }
                    n.interactive = !0,
                    n.alpha = 1,
                    t.stopPropagation()
                }
        }
        ));
        const i = r.width / n.width * .5;
        n.scale.set(i, i),
        n.x = r.x + r.width / 2 - n.width / 2,
        n.y = r.y + r.height / 2 - n.height / 2,
        n.interactive = !0,
        n.cursor = "pointer";
        const o = new fP({
            fontFamily: "Inter",
            fontWeight: "700",
            fill: 16777215,
            fontSize: 18 * qF(),
            stroke: 0,
            strokeThickness: 1.5 * qF(),
            dropShadow: !0,
            dropShadowColor: 0,
            dropShadowDistance: 1.5 * qF(),
            dropShadowAngle: 90,
            align: "center"
        })
          , a = new bP("Loading rank...",o);
        let l = uP.measureText(a.text, a.style);
        a.x = QF() / 2 - l.width / 2,
        a.y = (n.y - (s.y + s.height)) / 2 + (s.y + s.height) - l.height / 2,
        XF.external.getEstimatedLeaderboard(t).then((t=>{
            if (t) {
                const e = t.data;
                0 === e.nextRank ? a.text = "" : 1 === e.actualRank ? a.text = "Congrats, you are first!\nContinue to distance the top 2 player" : e.nextRank <= 250 ? a.text = `You are ${e.scoreDifference} points away\nto reach the rank #${e.nextRank}` : a.text = `You are ${e.scoreDifference} points away\nto the top 250`
            } else
                a.text = "Impossible to retrieve the leaderboard";
            l = uP.measureText(a.text, a.style),
            a.x = QF() / 2 - l.width / 2
        }
        ));
        const c = new lM(XF.resources["buy-nft-button"]);
        c.on("pointertap", (async t=>{
            XF.external.showModal && (dg.any ? XF.external.showModal({
                title: "Buy on another device",
                text: 'We can\'t open directly the Tensor website or the game will cease to work. Please buy the NFT with another device and make sure to send it to the one connected to play, then click the "use life" button.'
            }) : window.open("https://www.tensor.trade/trade/meecartridge", void 0, "popup"),
            t.stopPropagation())
        }
        ));
        const u = r.width / c.width * .4;
        c.scale.set(u, u),
        c.x = r.x + r.width / 2 - c.width / 2,
        c.y = n.y + n.height + 10 * KF(),
        c.interactive = !0,
        c.cursor = "pointer";
        const h = new fP({
            fontFamily: "Inter",
            fontWeight: "700",
            fill: 16777215,
            fontSize: 10 * qF(),
            stroke: 0,
            strokeThickness: 1.5 * qF(),
            dropShadow: !0,
            dropShadowColor: 0,
            dropShadowDistance: 1 * qF(),
            dropShadowAngle: 90,
            align: "center"
        })
          , d = new bP("1 MeeCartridge NFT = 1 life, max 5 per game",h)
          , f = uP.measureText(d.text, d.style);
        d.x = QF() / 2 - f.width / 2,
        d.y = c.y + c.height + 5 * KF(),
        d.alpha = .6,
        e.addChild(n, d, c, a)
    }
    const a = new fP({
        fontFamily: "Inter",
        fontWeight: "700",
        fill: 16777215,
        fontSize: 18 * qF(),
        stroke: 0,
        strokeThickness: 1.5 * qF(),
        dropShadow: !0,
        dropShadowColor: 0,
        dropShadowDistance: 1.5 * qF(),
        dropShadowAngle: 90,
        align: "center"
    })
      , l = new bP("skip",a)
      , c = uP.measureText(l.text, l.style);
    l.x = r.x + r.width - 1.25 * c.width,
    l.y = r.y + r.height - 1.25 * c.height,
    l.interactive = !0,
    l.cursor = "pointer",
    l.on("pointertap", (async e=>{
        JU(),
        QU(t),
        l_.play(gO.GameOk),
        e.stopPropagation()
    }
    )),
    e.addChild(l);
    const u = new GF(XF.resources.character.spineData)
      , h = r.width / u.width * .9;
    u.scale.set(h, h),
    u.x = r.x + r.width / 2,
    u.y = r.y + r.height + u.height / 7,
    u.skeleton.setSkinByName("Pink/Pink_Scare"),
    u.state.setAnimation(0, "IDLE", !0),
    e.addChild(u),
    XF.references.ui.continueMenu = e,
    e.zIndex = 100,
    XF.app.stage.addChild(e)
}
  , QU = async t=>{
    if (!XF.app)
        return;
    await zU();
    const e = new EI;
    e.x = 0,
    e.y = 0,
    e.width = QF(),
    e.height = ZF(),
    e.interactive = !0,
    e.on("pointertap", (t=>t.stopPropagation()));
    const n = (new KC).beginFill("#314148").drawRect(0, 0, QF(), ZF()).endFill();
    n.alpha = .5,
    e.addChild(n);
    const r = new lM(XF.resources["normal-popup"])
      , i = QF() / r.width * .95;
    r.scale.set(i, i),
    r.x = .025 * QF(),
    r.y = ZF() / 2 - r.height / 2,
    e.addChild(r);
    const s = new lM(XF.resources["score-title"])
      , o = r.width / s.width * .55;
    s.scale.set(o, o),
    s.x = r.x + r.width / 2 - s.width / 2,
    s.y = r.y - .6 * s.height,
    e.addChild(s);
    const a = new fP({
        fontFamily: "Inter",
        fontWeight: "700",
        fill: 16777215,
        fontSize: 36 * qF(),
        stroke: 0,
        strokeThickness: 5 * qF(),
        dropShadow: !0,
        dropShadowColor: 0,
        dropShadowDistance: 5 * qF(),
        dropShadowAngle: 90,
        align: "center"
    })
      , l = new bP(t,a)
      , c = uP.measureText(l.text, l.style);
    l.x = r.x + r.width / 2 - c.width / 2,
    l.y = r.y + r.height / 2 - 2 * c.height,
    e.addChild(l);
    const u = new lM(XF.resources.trophy)
      , h = c.height / u.height * .65;
    u.scale.set(h, h),
    u.x = l.x - 1.3 * u.width,
    u.y = l.y + c.height / 2 - u.height / 2,
    e.addChild(u);
    const d = new lM(XF.resources["tweet-button"])
      , f = c.height / d.height * .75;
    d.scale.set(f, f),
    d.x = l.x + c.width + d.width / 2,
    d.y = l.y + c.height / 2 - d.height / 2,
    d.interactive = !0,
    d.cursor = "pointer",
    d.on("pointertap", (e=>{
        l_.find(gO.GameOk).play();
        window.open(encodeURI(`https://twitter.com/intent/tweet?original_referer=${window.location}&ref_src=twsrc^tfw|twcamp^buttonembed|twterm^share|twgr^url=/&text=I just hit a score of ${t} on MeeJump. Can you do better and earn yourself a whitelist spot? Head over to https://jump.meegos.io/ to play!&hashtags=meegos,meejump`), "Meegos - Twitter", "toolbar=1,scrollbars=1,location=0,statusbar=0,menubar=1,resizable=1,width=800,height=600,left=240,top=212");
        e.stopPropagation()
    }
    )),
    e.addChild(d);
    const p = new lM(XF.resources["retry-button"]);
    p.interactive = !0,
    p.cursor = "pointer",
    p.on("pointertap", (t=>{
        l_.find(gO.GamePlay).play(),
        Yz(),
        t.stopPropagation()
    }
    ));
    const m = r.width / p.width * .5;
    p.scale.set(m, m),
    p.x = r.x + r.width / 2 - p.width / 2,
    p.y = r.y + r.height / 2 - p.height / 2,
    e.addChild(p);
    const g = new lM(XF.resources["homescreen-button"]);
    g.interactive = !0,
    g.cursor = "pointer",
    g.on("pointertap", (t=>{
        XF.level && XF.viewport && XF.app && (l_.play(gO.GameOk),
        Hz(),
        t.stopPropagation())
    }
    ));
    const y = r.width / g.width * .4;
    g.scale.set(y, y),
    g.x = r.x + r.width / 2 - g.width / 2,
    g.y = p.y + p.height + 10 * KF(),
    e.addChild(g);
    const b = new GF(XF.resources.character.spineData)
      , v = r.width / b.width * .9;
    b.scale.set(v, v),
    b.x = r.x + r.width / 2,
    b.y = r.y + r.height + b.height / 7,
    b.skeleton.setSkinByName("Green/Green_Smile"),
    b.state.setAnimation(0, "IDLE", !0),
    e.addChild(b),
    XF.references.ui.scoreMenu = e,
    e.zIndex = 100,
    XF.app.stage.addChild(e)
}
  , ZU = (t,e,n)=>{
    if (!XF.app)
        return;
    const r = XF.references.ui.level.countdowns?.find((e=>e.name === t));
    if (r)
        r.startingTime = (new Date).getTime(),
        r.endingTime = r.startingTime + n;
    else {
        const r = new EI
          , i = new KC;
        i.x = 10 * qF(),
        i.y = 10 * qF(),
        r.x = 20 * qF(),
        r.y = 50 * (XF.references.ui.level.countdowns ?? []).length + .15 * ZF(),
        e.x = 10 * qF() - e.width / 2,
        e.y = 10 * qF() - e.height / 2,
        r.addChild(e),
        r.addChild(i),
        XF.references.ui.level.countdowns || (XF.references.ui.level.countdowns = []),
        XF.references.ui.level.countdowns.push({
            name: t,
            graphics: i,
            startingTime: (new Date).getTime(),
            endingTime: (new Date).getTime() + n,
            container: r
        }),
        XF.app.stage.addChild(r)
    }
}
  , JU = ()=>{
    XF.app && XF.level && XF.references.ui.continueMenu && (clearInterval(undefined),
    XF.app.stage.removeChild(XF.references.ui.continueMenu),
    XF.references.ui.continueMenu = void 0)
}
  , tz = ()=>{
    XF.app && XF.level && XF.references.ui.scoreMenu && (XF.app.stage.removeChild(XF.references.ui.scoreMenu),
    XF.references.ui.scoreMenu = void 0)
}
;
var ez = {};
!function(t) {
    function e(t, e) {
        return e.forEach((function(e) {
            e && "string" != typeof e && !Array.isArray(e) && Object.keys(e).forEach((function(n) {
                if ("default" !== n && !(n in t)) {
                    var r = Object.getOwnPropertyDescriptor(e, n);
                    Object.defineProperty(t, n, r.get ? r : {
                        enumerable: !0,
                        get: function() {
                            return e[n]
                        }
                    })
                }
            }
            ))
        }
        )),
        Object.freeze(t)
    }
    ArrayBuffer.isView || (ArrayBuffer.isView = function(t) {
        return null !== t && "object" == typeof t && t.buffer instanceof ArrayBuffer
    }
    ),
    "undefined" == typeof globalThis && "undefined" != typeof window && (window.globalThis = window);
    var r = function(t, e) {
        return r = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(t, e) {
            t.__proto__ = e
        }
        || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }
        ,
        r(t, e)
    };
    function i(t, e) {
        if ("function" != typeof e && null !== e)
            throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
        function n() {
            this.constructor = t
        }
        r(t, e),
        t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
        new n)
    }
    function s(t, e, n, r) {
        function i(t) {
            return t instanceof n ? t : new n((function(e) {
                e(t)
            }
            ))
        }
        return new (n || (n = Promise))((function(n, s) {
            function o(t) {
                try {
                    l(r.next(t))
                } catch (t) {
                    s(t)
                }
            }
            function a(t) {
                try {
                    l(r.throw(t))
                } catch (t) {
                    s(t)
                }
            }
            function l(t) {
                t.done ? n(t.value) : i(t.value).then(o, a)
            }
            l((r = r.apply(t, e || [])).next())
        }
        ))
    }
    function o(t, e) {
        var n, r, i, s, o = {
            label: 0,
            sent: function() {
                if (1 & i[0])
                    throw i[1];
                return i[1]
            },
            trys: [],
            ops: []
        };
        return s = {
            next: a(0),
            throw: a(1),
            return: a(2)
        },
        "function" == typeof Symbol && (s[Symbol.iterator] = function() {
            return this
        }
        ),
        s;
        function a(t) {
            return function(e) {
                return l([t, e])
            }
        }
        function l(a) {
            if (n)
                throw new TypeError("Generator is already executing.");
            for (; s && (s = 0,
            a[0] && (o = 0)),
            o; )
                try {
                    if (n = 1,
                    r && (i = 2 & a[0] ? r.return : a[0] ? r.throw || ((i = r.return) && i.call(r),
                    0) : r.next) && !(i = i.call(r, a[1])).done)
                        return i;
                    switch (r = 0,
                    i && (a = [2 & a[0], i.value]),
                    a[0]) {
                    case 0:
                    case 1:
                        i = a;
                        break;
                    case 4:
                        return o.label++,
                        {
                            value: a[1],
                            done: !1
                        };
                    case 5:
                        o.label++,
                        r = a[1],
                        a = [0];
                        continue;
                    case 7:
                        a = o.ops.pop(),
                        o.trys.pop();
                        continue;
                    default:
                        if (!((i = (i = o.trys).length > 0 && i[i.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                            o = 0;
                            continue
                        }
                        if (3 === a[0] && (!i || a[1] > i[0] && a[1] < i[3])) {
                            o.label = a[1];
                            break
                        }
                        if (6 === a[0] && o.label < i[1]) {
                            o.label = i[1],
                            i = a;
                            break
                        }
                        if (i && o.label < i[2]) {
                            o.label = i[2],
                            o.ops.push(a);
                            break
                        }
                        i[2] && o.ops.pop(),
                        o.trys.pop();
                        continue
                    }
                    a = e.call(t, o)
                } catch (t) {
                    a = [6, t],
                    r = 0
                } finally {
                    n = i = 0
                }
            if (5 & a[0])
                throw a[1];
            return {
                value: a[0] ? a[1] : void 0,
                done: !0
            }
        }
    }
    function a(t, e) {
        e.headers = t.headers || {},
        e.statusMessage = t.statusText,
        e.statusCode = t.status,
        e.data = t.response
    }
    function l(t, e, n) {
        return new Promise((function(r, i) {
            n = n || {};
            var s, o, l, c = new XMLHttpRequest, u = n.body, h = n.headers || {};
            for (s in n.timeout && (c.timeout = n.timeout),
            c.ontimeout = c.onerror = function(t) {
                t.timeout = "timeout" == t.type,
                i(t)
            }
            ,
            c.open(t, e.href || e),
            c.onload = function() {
                for (l = c.getAllResponseHeaders().trim().split(/[\r\n]+/),
                a(c, c); o = l.shift(); )
                    o = o.split(": "),
                    c.headers[o.shift().toLowerCase()] = o.join(": ");
                if ((o = c.headers["content-type"]) && ~o.indexOf("application/json"))
                    try {
                        c.data = JSON.parse(c.data, n.reviver)
                    } catch (t) {
                        return a(c, t),
                        i(t)
                    }
                (c.status >= 400 ? i : r)(c)
            }
            ,
            typeof FormData < "u" && u instanceof FormData || u && "object" == typeof u && (h["content-type"] = "application/json",
            u = JSON.stringify(u)),
            c.withCredentials = !!n.withCredentials,
            h)
                c.setRequestHeader(s, h[s]);
            c.send(u)
        }
        ))
    }
    var c, u = l.bind(l, "GET"), h = l.bind(l, "POST"), d = l.bind(l, "PATCH"), f = l.bind(l, "DELETE"), p = l.bind(l, "PUT"), m = u, g = h, y = {
        del: f,
        get: m,
        patch: d,
        post: g,
        put: p,
        send: l
    }, b = e({
        __proto__: null,
        default: y,
        del: f,
        get: m,
        patch: d,
        post: g,
        put: p,
        send: l
    }, [y]);
    !function(t) {
        t[t.CONSENTED = 4e3] = "CONSENTED",
        t[t.DEVMODE_RESTART = 4010] = "DEVMODE_RESTART"
    }(c || (c = {}));
    var v = function(t) {
        function e(e, n) {
            var r = t.call(this, n) || this;
            return r.name = "ServerError",
            r.code = e,
            r
        }
        return i(e, t),
        e
    }(Error);
    function w(t, e) {
        if (this._offset = e,
        t instanceof ArrayBuffer)
            this._buffer = t,
            this._view = new DataView(this._buffer);
        else {
            if (!ArrayBuffer.isView(t))
                throw new Error("Invalid argument");
            this._buffer = t.buffer,
            this._view = new DataView(this._buffer,t.byteOffset,t.byteLength)
        }
    }
    function x(t, e, n) {
        for (var r = "", i = 0, s = e, o = e + n; s < o; s++) {
            var a = t.getUint8(s);
            if (0 != (128 & a))
                if (192 != (224 & a))
                    if (224 != (240 & a)) {
                        if (240 != (248 & a))
                            throw new Error("Invalid byte " + a.toString(16));
                        (i = (7 & a) << 18 | (63 & t.getUint8(++s)) << 12 | (63 & t.getUint8(++s)) << 6 | (63 & t.getUint8(++s)) << 0) >= 65536 ? (i -= 65536,
                        r += String.fromCharCode(55296 + (i >>> 10), 56320 + (1023 & i))) : r += String.fromCharCode(i)
                    } else
                        r += String.fromCharCode((15 & a) << 12 | (63 & t.getUint8(++s)) << 6 | (63 & t.getUint8(++s)) << 0);
                else
                    r += String.fromCharCode((31 & a) << 6 | 63 & t.getUint8(++s));
            else
                r += String.fromCharCode(a)
        }
        return r
    }
    function E(t, e) {
        void 0 === e && (e = 0);
        var n = new w(t,e)
          , r = n._parse();
        if (n._offset !== t.byteLength)
            throw new Error(t.byteLength - n._offset + " trailing bytes");
        return r
    }
    w.prototype._array = function(t) {
        for (var e = new Array(t), n = 0; n < t; n++)
            e[n] = this._parse();
        return e
    }
    ,
    w.prototype._map = function(t) {
        for (var e = {}, n = 0; n < t; n++)
            e[this._parse()] = this._parse();
        return e
    }
    ,
    w.prototype._str = function(t) {
        var e = x(this._view, this._offset, t);
        return this._offset += t,
        e
    }
    ,
    w.prototype._bin = function(t) {
        var e = this._buffer.slice(this._offset, this._offset + t);
        return this._offset += t,
        e
    }
    ,
    w.prototype._parse = function() {
        var t, e = this._view.getUint8(this._offset++), n = 0, r = 0, i = 0, s = 0;
        if (e < 192)
            return e < 128 ? e : e < 144 ? this._map(15 & e) : e < 160 ? this._array(15 & e) : this._str(31 & e);
        if (e > 223)
            return -1 * (255 - e + 1);
        switch (e) {
        case 192:
            return null;
        case 194:
            return !1;
        case 195:
            return !0;
        case 196:
            return n = this._view.getUint8(this._offset),
            this._offset += 1,
            this._bin(n);
        case 197:
            return n = this._view.getUint16(this._offset),
            this._offset += 2,
            this._bin(n);
        case 198:
            return n = this._view.getUint32(this._offset),
            this._offset += 4,
            this._bin(n);
        case 199:
            if (n = this._view.getUint8(this._offset),
            r = this._view.getInt8(this._offset + 1),
            this._offset += 2,
            -1 === r) {
                var o = this._view.getUint32(this._offset);
                return i = this._view.getInt32(this._offset + 4),
                s = this._view.getUint32(this._offset + 8),
                this._offset += 12,
                new Date(1e3 * (4294967296 * i + s) + o / 1e6)
            }
            return [r, this._bin(n)];
        case 200:
            return n = this._view.getUint16(this._offset),
            r = this._view.getInt8(this._offset + 2),
            this._offset += 3,
            [r, this._bin(n)];
        case 201:
            return n = this._view.getUint32(this._offset),
            r = this._view.getInt8(this._offset + 4),
            this._offset += 5,
            [r, this._bin(n)];
        case 202:
            return t = this._view.getFloat32(this._offset),
            this._offset += 4,
            t;
        case 203:
            return t = this._view.getFloat64(this._offset),
            this._offset += 8,
            t;
        case 204:
            return t = this._view.getUint8(this._offset),
            this._offset += 1,
            t;
        case 205:
            return t = this._view.getUint16(this._offset),
            this._offset += 2,
            t;
        case 206:
            return t = this._view.getUint32(this._offset),
            this._offset += 4,
            t;
        case 207:
            return i = this._view.getUint32(this._offset) * Math.pow(2, 32),
            s = this._view.getUint32(this._offset + 4),
            this._offset += 8,
            i + s;
        case 208:
            return t = this._view.getInt8(this._offset),
            this._offset += 1,
            t;
        case 209:
            return t = this._view.getInt16(this._offset),
            this._offset += 2,
            t;
        case 210:
            return t = this._view.getInt32(this._offset),
            this._offset += 4,
            t;
        case 211:
            return i = this._view.getInt32(this._offset) * Math.pow(2, 32),
            s = this._view.getUint32(this._offset + 4),
            this._offset += 8,
            i + s;
        case 212:
            return r = this._view.getInt8(this._offset),
            this._offset += 1,
            0 === r ? void (this._offset += 1) : [r, this._bin(1)];
        case 213:
            return r = this._view.getInt8(this._offset),
            this._offset += 1,
            [r, this._bin(2)];
        case 214:
            return r = this._view.getInt8(this._offset),
            this._offset += 1,
            -1 === r ? (t = this._view.getUint32(this._offset),
            this._offset += 4,
            new Date(1e3 * t)) : [r, this._bin(4)];
        case 215:
            return r = this._view.getInt8(this._offset),
            this._offset += 1,
            0 === r ? (i = this._view.getInt32(this._offset) * Math.pow(2, 32),
            s = this._view.getUint32(this._offset + 4),
            this._offset += 8,
            new Date(i + s)) : -1 === r ? (i = this._view.getUint32(this._offset),
            s = this._view.getUint32(this._offset + 4),
            this._offset += 8,
            new Date(1e3 * (4294967296 * (3 & i) + s) + (i >>> 2) / 1e6)) : [r, this._bin(8)];
        case 216:
            return r = this._view.getInt8(this._offset),
            this._offset += 1,
            [r, this._bin(16)];
        case 217:
            return n = this._view.getUint8(this._offset),
            this._offset += 1,
            this._str(n);
        case 218:
            return n = this._view.getUint16(this._offset),
            this._offset += 2,
            this._str(n);
        case 219:
            return n = this._view.getUint32(this._offset),
            this._offset += 4,
            this._str(n);
        case 220:
            return n = this._view.getUint16(this._offset),
            this._offset += 2,
            this._array(n);
        case 221:
            return n = this._view.getUint32(this._offset),
            this._offset += 4,
            this._array(n);
        case 222:
            return n = this._view.getUint16(this._offset),
            this._offset += 2,
            this._map(n);
        case 223:
            return n = this._view.getUint32(this._offset),
            this._offset += 4,
            this._map(n)
        }
        throw new Error("Could not parse")
    }
    ;
    var _ = 4294967295
      , A = 17179869183;
    function S(t, e, n) {
        for (var r = 0, i = 0, s = n.length; i < s; i++)
            (r = n.charCodeAt(i)) < 128 ? t.setUint8(e++, r) : r < 2048 ? (t.setUint8(e++, 192 | r >> 6),
            t.setUint8(e++, 128 | 63 & r)) : r < 55296 || r >= 57344 ? (t.setUint8(e++, 224 | r >> 12),
            t.setUint8(e++, 128 | r >> 6 & 63),
            t.setUint8(e++, 128 | 63 & r)) : (i++,
            r = 65536 + ((1023 & r) << 10 | 1023 & n.charCodeAt(i)),
            t.setUint8(e++, 240 | r >> 18),
            t.setUint8(e++, 128 | r >> 12 & 63),
            t.setUint8(e++, 128 | r >> 6 & 63),
            t.setUint8(e++, 128 | 63 & r))
    }
    function T(t) {
        for (var e = 0, n = 0, r = 0, i = t.length; r < i; r++)
            (e = t.charCodeAt(r)) < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || e >= 57344 ? n += 3 : (r++,
            n += 4);
        return n
    }
    function k(t, e, n) {
        var r = typeof n
          , i = 0
          , s = 0
          , o = 0
          , a = 0
          , l = 0
          , c = 0;
        if ("string" === r) {
            if ((l = T(n)) < 32)
                t.push(160 | l),
                c = 1;
            else if (l < 256)
                t.push(217, l),
                c = 2;
            else if (l < 65536)
                t.push(218, l >> 8, l),
                c = 3;
            else {
                if (!(l < 4294967296))
                    throw new Error("String too long");
                t.push(219, l >> 24, l >> 16, l >> 8, l),
                c = 5
            }
            return e.push({
                _str: n,
                _length: l,
                _offset: t.length
            }),
            c + l
        }
        if ("number" === r)
            return Math.floor(n) === n && isFinite(n) ? n >= 0 ? n < 128 ? (t.push(n),
            1) : n < 256 ? (t.push(204, n),
            2) : n < 65536 ? (t.push(205, n >> 8, n),
            3) : n < 4294967296 ? (t.push(206, n >> 24, n >> 16, n >> 8, n),
            5) : (o = n / Math.pow(2, 32) >> 0,
            a = n >>> 0,
            t.push(207, o >> 24, o >> 16, o >> 8, o, a >> 24, a >> 16, a >> 8, a),
            9) : n >= -32 ? (t.push(n),
            1) : n >= -128 ? (t.push(208, n),
            2) : n >= -32768 ? (t.push(209, n >> 8, n),
            3) : n >= -2147483648 ? (t.push(210, n >> 24, n >> 16, n >> 8, n),
            5) : (o = Math.floor(n / Math.pow(2, 32)),
            a = n >>> 0,
            t.push(211, o >> 24, o >> 16, o >> 8, o, a >> 24, a >> 16, a >> 8, a),
            9) : (t.push(203),
            e.push({
                _float: n,
                _length: 8,
                _offset: t.length
            }),
            9);
        if ("object" === r) {
            if (null === n)
                return t.push(192),
                1;
            if (Array.isArray(n)) {
                if ((l = n.length) < 16)
                    t.push(144 | l),
                    c = 1;
                else if (l < 65536)
                    t.push(220, l >> 8, l),
                    c = 3;
                else {
                    if (!(l < 4294967296))
                        throw new Error("Array too large");
                    t.push(221, l >> 24, l >> 16, l >> 8, l),
                    c = 5
                }
                for (i = 0; i < l; i++)
                    c += k(t, e, n[i]);
                return c
            }
            if (n instanceof Date) {
                var u = n.getTime()
                  , h = Math.floor(u / 1e3)
                  , d = 1e6 * (u - 1e3 * h);
                return h >= 0 && d >= 0 && h <= A ? 0 === d && h <= _ ? (t.push(214, 255, h >> 24, h >> 16, h >> 8, h),
                6) : (o = h / 4294967296,
                a = 4294967295 & h,
                t.push(215, 255, d >> 22, d >> 14, d >> 6, o, a >> 24, a >> 16, a >> 8, a),
                10) : (o = Math.floor(h / 4294967296),
                a = h >>> 0,
                t.push(199, 12, 255, d >> 24, d >> 16, d >> 8, d, o >> 24, o >> 16, o >> 8, o, a >> 24, a >> 16, a >> 8, a),
                15)
            }
            if (n instanceof ArrayBuffer) {
                if ((l = n.byteLength) < 256)
                    t.push(196, l),
                    c = 2;
                else if (l < 65536)
                    t.push(197, l >> 8, l),
                    c = 3;
                else {
                    if (!(l < 4294967296))
                        throw new Error("Buffer too large");
                    t.push(198, l >> 24, l >> 16, l >> 8, l),
                    c = 5
                }
                return e.push({
                    _bin: n,
                    _length: l,
                    _offset: t.length
                }),
                c + l
            }
            if ("function" == typeof n.toJSON)
                return k(t, e, n.toJSON());
            var f = []
              , p = ""
              , m = Object.keys(n);
            for (i = 0,
            s = m.length; i < s; i++)
                void 0 !== n[p = m[i]] && "function" != typeof n[p] && f.push(p);
            if ((l = f.length) < 16)
                t.push(128 | l),
                c = 1;
            else if (l < 65536)
                t.push(222, l >> 8, l),
                c = 3;
            else {
                if (!(l < 4294967296))
                    throw new Error("Object too large");
                t.push(223, l >> 24, l >> 16, l >> 8, l),
                c = 5
            }
            for (i = 0; i < l; i++)
                c += k(t, e, p = f[i]),
                c += k(t, e, n[p]);
            return c
        }
        if ("boolean" === r)
            return t.push(n ? 195 : 194),
            1;
        if ("undefined" === r)
            return t.push(192),
            1;
        if ("function" == typeof n.toJSON)
            return k(t, e, n.toJSON());
        throw new Error("Could not encode")
    }
    function I(t) {
        var e = []
          , n = []
          , r = k(e, n, t)
          , i = new ArrayBuffer(r)
          , s = new DataView(i)
          , o = 0
          , a = 0
          , l = -1;
        n.length > 0 && (l = n[0]._offset);
        for (var c, u = 0, h = 0, d = 0, f = e.length; d < f; d++)
            if (s.setUint8(a + d, e[d]),
            d + 1 === l) {
                if (u = (c = n[o])._length,
                h = a + l,
                c._bin)
                    for (var p = new Uint8Array(c._bin), m = 0; m < u; m++)
                        s.setUint8(h + m, p[m]);
                else
                    c._str ? S(s, h, c._str) : void 0 !== c._float && s.setFloat64(h, c._float);
                a += u,
                n[++o] && (l = n[o]._offset)
            }
        return i
    }
    var M, C, P = function() {
        throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")
    }, O = globalThis.WebSocket || P, N = function() {
        function t(t) {
            this.events = t
        }
        return t.prototype.send = function(t) {
            t instanceof ArrayBuffer ? this.ws.send(t) : Array.isArray(t) && this.ws.send(new Uint8Array(t).buffer)
        }
        ,
        t.prototype.connect = function(t) {
            this.ws = new O(t,this.protocols),
            this.ws.binaryType = "arraybuffer",
            this.ws.onopen = this.events.onopen,
            this.ws.onmessage = this.events.onmessage,
            this.ws.onclose = this.events.onclose,
            this.ws.onerror = this.events.onerror
        }
        ,
        t.prototype.close = function(t, e) {
            this.ws.close(t, e)
        }
        ,
        Object.defineProperty(t.prototype, "isOpen", {
            get: function() {
                return this.ws.readyState === O.OPEN
            },
            enumerable: !1,
            configurable: !0
        }),
        t
    }(), R = function() {
        function t() {
            this.events = {},
            this.transport = new N(this.events)
        }
        return t.prototype.send = function(t) {
            this.transport.send(t)
        }
        ,
        t.prototype.connect = function(t) {
            this.transport.connect(t)
        }
        ,
        t.prototype.close = function(t, e) {
            this.transport.close(t, e)
        }
        ,
        Object.defineProperty(t.prototype, "isOpen", {
            get: function() {
                return this.transport.isOpen
            },
            enumerable: !1,
            configurable: !0
        }),
        t
    }();
    function D(t, e) {
        for (var n = t[e++], r = "", i = 0, s = e, o = e + n; s < o; s++) {
            var a = t[s];
            if (0 != (128 & a))
                if (192 != (224 & a))
                    if (224 != (240 & a)) {
                        if (240 != (248 & a))
                            throw new Error("Invalid byte " + a.toString(16));
                        (i = (7 & a) << 18 | (63 & t[++s]) << 12 | (63 & t[++s]) << 6 | (63 & t[++s]) << 0) >= 65536 ? (i -= 65536,
                        r += String.fromCharCode(55296 + (i >>> 10), 56320 + (1023 & i))) : r += String.fromCharCode(i)
                    } else
                        r += String.fromCharCode((15 & a) << 12 | (63 & t[++s]) << 6 | (63 & t[++s]) << 0);
                else
                    r += String.fromCharCode((31 & a) << 6 | 63 & t[++s]);
            else
                r += String.fromCharCode(a)
        }
        return r
    }
    function B(t) {
        void 0 === t && (t = "");
        for (var e = 0, n = 0, r = 0, i = t.length; r < i; r++)
            (e = t.charCodeAt(r)) < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || e >= 57344 ? n += 3 : (r++,
            n += 4);
        return n + 1
    }
    t.Protocol = void 0,
    (C = t.Protocol || (t.Protocol = {}))[C.HANDSHAKE = 9] = "HANDSHAKE",
    C[C.JOIN_ROOM = 10] = "JOIN_ROOM",
    C[C.ERROR = 11] = "ERROR",
    C[C.LEAVE_ROOM = 12] = "LEAVE_ROOM",
    C[C.ROOM_DATA = 13] = "ROOM_DATA",
    C[C.ROOM_STATE = 14] = "ROOM_STATE",
    C[C.ROOM_STATE_PATCH = 15] = "ROOM_STATE_PATCH",
    C[C.ROOM_DATA_SCHEMA = 16] = "ROOM_DATA_SCHEMA",
    C[C.ROOM_DATA_BYTES = 17] = "ROOM_DATA_BYTES",
    t.ErrorCode = void 0,
    (M = t.ErrorCode || (t.ErrorCode = {}))[M.MATCHMAKE_NO_HANDLER = 4210] = "MATCHMAKE_NO_HANDLER",
    M[M.MATCHMAKE_INVALID_CRITERIA = 4211] = "MATCHMAKE_INVALID_CRITERIA",
    M[M.MATCHMAKE_INVALID_ROOM_ID = 4212] = "MATCHMAKE_INVALID_ROOM_ID",
    M[M.MATCHMAKE_UNHANDLED = 4213] = "MATCHMAKE_UNHANDLED",
    M[M.MATCHMAKE_EXPIRED = 4214] = "MATCHMAKE_EXPIRED",
    M[M.AUTH_FAILED = 4215] = "AUTH_FAILED",
    M[M.APPLICATION_ERROR = 4216] = "APPLICATION_ERROR";
    var L = {};
    function F(t, e) {
        L[t] = e
    }
    function j(t) {
        var e = L[t];
        if (!e)
            throw new Error("missing serializer: " + t);
        return e
    }
    let U = ()=>({
        events: {},
        emit(t, ...e) {
            (this.events[t] || []).forEach((t=>t(...e)))
        },
        on(t, e) {
            return (this.events[t] = this.events[t] || []).push(e),
            ()=>this.events[t] = (this.events[t] || []).filter((t=>t !== e))
        }
    });
    var z = function() {
        function t() {
            this.handlers = []
        }
        return t.prototype.register = function(t, e) {
            return this.handlers.push(t),
            this
        }
        ,
        t.prototype.invoke = function() {
            for (var t = this, e = [], n = 0; n < arguments.length; n++)
                e[n] = arguments[n];
            this.handlers.forEach((function(n) {
                return n.apply(t, e)
            }
            ))
        }
        ,
        t.prototype.invokeAsync = function() {
            for (var t = this, e = [], n = 0; n < arguments.length; n++)
                e[n] = arguments[n];
            return Promise.all(this.handlers.map((function(n) {
                return n.apply(t, e)
            }
            )))
        }
        ,
        t.prototype.remove = function(t) {
            var e = this.handlers.indexOf(t);
            this.handlers[e] = this.handlers[this.handlers.length - 1],
            this.handlers.pop()
        }
        ,
        t.prototype.clear = function() {
            this.handlers = []
        }
        ,
        t
    }();
    function V() {
        var t = new z;
        function e(e) {
            return t.register(e, null === this)
        }
        return e.once = function(e) {
            var n = function() {
                for (var r = [], i = 0; i < arguments.length; i++)
                    r[i] = arguments[i];
                e.apply(this, r),
                t.remove(n)
            };
            t.register(n)
        }
        ,
        e.remove = function(e) {
            return t.remove(e)
        }
        ,
        e.invoke = function() {
            for (var e = [], n = 0; n < arguments.length; n++)
                e[n] = arguments[n];
            return t.invoke.apply(t, e)
        }
        ,
        e.invokeAsync = function() {
            for (var e = [], n = 0; n < arguments.length; n++)
                e[n] = arguments[n];
            return t.invokeAsync.apply(t, e)
        }
        ,
        e.clear = function() {
            return t.clear()
        }
        ,
        e
    }
    function W(t) {
        var e = {
            exports: {}
        };
        return t(e, e.exports),
        e.exports
    }
    "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== n || "undefined" != typeof self && self;
    var Y, H, $ = W((function(t, e) {
        !function(t, n) {
            n(e)
        }(0, (function(t) {
            var e = function(t, n) {
                return e = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(t, e) {
                    t.__proto__ = e
                }
                || function(t, e) {
                    for (var n in e)
                        Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
                }
                ,
                e(t, n)
            };
            function n(t, n) {
                if ("function" != typeof n && null !== n)
                    throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
                function r() {
                    this.constructor = t
                }
                e(t, n),
                t.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype,
                new r)
            }
            function r(t, e, n, r) {
                var i, s = arguments.length, o = s < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
                if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
                    o = Reflect.decorate(t, e, n, r);
                else
                    for (var a = t.length - 1; a >= 0; a--)
                        (i = t[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(e, n, o) : i(e, n)) || o);
                return s > 3 && o && Object.defineProperty(e, n, o),
                o
            }
            function i(t, e, n) {
                if (n || 2 === arguments.length)
                    for (var r, i = 0, s = e.length; i < s; i++)
                        !r && i in e || (r || (r = Array.prototype.slice.call(e, 0, i)),
                        r[i] = e[i]);
                return t.concat(r || Array.prototype.slice.call(e))
            }
            var s, o = 255, a = 213;
            t.OPERATION = void 0,
            (s = t.OPERATION || (t.OPERATION = {}))[s.ADD = 128] = "ADD",
            s[s.REPLACE = 0] = "REPLACE",
            s[s.DELETE = 64] = "DELETE",
            s[s.DELETE_AND_ADD = 192] = "DELETE_AND_ADD",
            s[s.TOUCH = 1] = "TOUCH",
            s[s.CLEAR = 10] = "CLEAR";
            var l = function() {
                function e(t, e, n) {
                    this.changed = !1,
                    this.changes = new Map,
                    this.allChanges = new Set,
                    this.caches = {},
                    this.currentCustomOperation = 0,
                    this.ref = t,
                    this.setParent(e, n)
                }
                return e.prototype.setParent = function(t, e, n) {
                    var r = this;
                    if (this.indexes || (this.indexes = this.ref instanceof Mt ? this.ref._definition.indexes : {}),
                    this.parent = t,
                    this.parentIndex = n,
                    e)
                        if (this.root = e,
                        this.ref instanceof Mt) {
                            var i = this.ref._definition;
                            for (var s in i.schema) {
                                var o = this.ref[s];
                                if (o && o.$changes) {
                                    var a = i.indexes[s];
                                    o.$changes.setParent(this.ref, e, a)
                                }
                            }
                        } else
                            "object" == typeof this.ref && this.ref.forEach((function(t, e) {
                                if (t instanceof Mt) {
                                    var n = t.$changes
                                      , i = r.ref.$changes.indexes[e];
                                    n.setParent(r.ref, r.root, i)
                                }
                            }
                            ))
                }
                ,
                e.prototype.operation = function(t) {
                    this.changes.set(--this.currentCustomOperation, t)
                }
                ,
                e.prototype.change = function(e, n) {
                    void 0 === n && (n = t.OPERATION.ADD);
                    var r = "number" == typeof e ? e : this.indexes[e];
                    this.assertValidIndex(r, e);
                    var i = this.changes.get(r);
                    i && i.op !== t.OPERATION.DELETE && i.op !== t.OPERATION.TOUCH || this.changes.set(r, {
                        op: i && i.op === t.OPERATION.DELETE ? t.OPERATION.DELETE_AND_ADD : n,
                        index: r
                    }),
                    this.allChanges.add(r),
                    this.changed = !0,
                    this.touchParents()
                }
                ,
                e.prototype.touch = function(e) {
                    var n = "number" == typeof e ? e : this.indexes[e];
                    this.assertValidIndex(n, e),
                    this.changes.has(n) || this.changes.set(n, {
                        op: t.OPERATION.TOUCH,
                        index: n
                    }),
                    this.allChanges.add(n),
                    this.touchParents()
                }
                ,
                e.prototype.touchParents = function() {
                    this.parent && this.parent.$changes.touch(this.parentIndex)
                }
                ,
                e.prototype.getType = function(t) {
                    if (this.ref._definition)
                        return (e = this.ref._definition).schema[e.fieldsByIndex[t]];
                    var e, n = (e = this.parent._definition).schema[e.fieldsByIndex[this.parentIndex]];
                    return Object.values(n)[0]
                }
                ,
                e.prototype.getChildrenFilter = function() {
                    var t = this.parent._definition.childFilters;
                    return t && t[this.parentIndex]
                }
                ,
                e.prototype.getValue = function(t) {
                    return this.ref.getByIndex(t)
                }
                ,
                e.prototype.delete = function(e) {
                    var n = "number" == typeof e ? e : this.indexes[e];
                    if (void 0 !== n) {
                        var r = this.getValue(n);
                        this.changes.set(n, {
                            op: t.OPERATION.DELETE,
                            index: n
                        }),
                        this.allChanges.delete(n),
                        delete this.caches[n],
                        r && r.$changes && (r.$changes.parent = void 0),
                        this.changed = !0,
                        this.touchParents()
                    } else
                        console.warn("@colyseus/schema ".concat(this.ref.constructor.name, ": trying to delete non-existing index: ").concat(e, " (").concat(n, ")"))
                }
                ,
                e.prototype.discard = function(e, n) {
                    var r = this;
                    void 0 === e && (e = !1),
                    void 0 === n && (n = !1),
                    this.ref instanceof Mt || this.changes.forEach((function(e) {
                        if (e.op === t.OPERATION.DELETE) {
                            var n = r.ref.getIndex(e.index);
                            delete r.indexes[n]
                        }
                    }
                    )),
                    this.changes.clear(),
                    this.changed = e,
                    n && this.allChanges.clear(),
                    this.currentCustomOperation = 0
                }
                ,
                e.prototype.discardAll = function() {
                    var t = this;
                    this.changes.forEach((function(e) {
                        var n = t.getValue(e.index);
                        n && n.$changes && n.$changes.discardAll()
                    }
                    )),
                    this.discard()
                }
                ,
                e.prototype.cache = function(t, e) {
                    this.caches[t] = e
                }
                ,
                e.prototype.clone = function() {
                    return new e(this.ref,this.parent,this.root)
                }
                ,
                e.prototype.ensureRefId = function() {
                    void 0 === this.refId && (this.refId = this.root.getNextUniqueId())
                }
                ,
                e.prototype.assertValidIndex = function(t, e) {
                    if (void 0 === t)
                        throw new Error('ChangeTree: missing index for field "'.concat(e, '"'))
                }
                ,
                e
            }();
            function c(t, e, n, r) {
                return t[e] || (t[e] = []),
                t[e].push(n),
                null == r || r.forEach((function(t, e) {
                    return n(t, e)
                }
                )),
                function() {
                    return h(t[e], t[e].indexOf(n))
                }
            }
            function u(e) {
                var n = this
                  , r = "string" != typeof this.$changes.getType();
                this.$items.forEach((function(i, s) {
                    e.push({
                        refId: n.$changes.refId,
                        op: t.OPERATION.DELETE,
                        field: s,
                        value: void 0,
                        previousValue: i
                    }),
                    r && n.$changes.root.removeRef(i.$changes.refId)
                }
                ))
            }
            function h(t, e) {
                if (-1 === e || e >= t.length)
                    return !1;
                for (var n = t.length - 1, r = e; r < n; r++)
                    t[r] = t[r + 1];
                return t.length = n,
                !0
            }
            var d = function(t, e) {
                var n = t.toString()
                  , r = e.toString();
                return n < r ? -1 : n > r ? 1 : 0
            };
            function f(t) {
                return t.$proxy = !0,
                t = new Proxy(t,{
                    get: function(t, e) {
                        return "symbol" == typeof e || isNaN(e) ? t[e] : t.at(e)
                    },
                    set: function(t, e, n) {
                        if ("symbol" == typeof e || isNaN(e))
                            t[e] = n;
                        else {
                            var r = Array.from(t.$items.keys())
                              , i = parseInt(r[e] || e);
                            null == n ? t.deleteAt(i) : t.setAt(i, n)
                        }
                        return !0
                    },
                    deleteProperty: function(t, e) {
                        return "number" == typeof e ? t.deleteAt(e) : delete t[e],
                        !0
                    }
                }),
                t
            }
            var p = function() {
                function e() {
                    for (var t = [], e = 0; e < arguments.length; e++)
                        t[e] = arguments[e];
                    this.$changes = new l(this),
                    this.$items = new Map,
                    this.$indexes = new Map,
                    this.$refId = 0,
                    this.push.apply(this, t)
                }
                return e.prototype.onAdd = function(e, n) {
                    return void 0 === n && (n = !0),
                    c(this.$callbacks || (this.$callbacks = []), t.OPERATION.ADD, e, n ? this.$items : void 0)
                }
                ,
                e.prototype.onRemove = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
                }
                ,
                e.prototype.onChange = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
                }
                ,
                e.is = function(t) {
                    return Array.isArray(t) || void 0 !== t.array
                }
                ,
                Object.defineProperty(e.prototype, "length", {
                    get: function() {
                        return this.$items.size
                    },
                    set: function(t) {
                        0 === t ? this.clear() : this.splice(t, this.length - t)
                    },
                    enumerable: !1,
                    configurable: !0
                }),
                e.prototype.push = function() {
                    for (var t, e = this, n = [], r = 0; r < arguments.length; r++)
                        n[r] = arguments[r];
                    return n.forEach((function(n) {
                        t = e.$refId++,
                        e.setAt(t, n)
                    }
                    )),
                    t
                }
                ,
                e.prototype.pop = function() {
                    var t = Array.from(this.$indexes.values()).pop();
                    if (void 0 !== t) {
                        this.$changes.delete(t),
                        this.$indexes.delete(t);
                        var e = this.$items.get(t);
                        return this.$items.delete(t),
                        e
                    }
                }
                ,
                e.prototype.at = function(t) {
                    var e = Array.from(this.$items.keys())[t];
                    return this.$items.get(e)
                }
                ,
                e.prototype.setAt = function(e, n) {
                    var r, i;
                    void 0 !== n.$changes && n.$changes.setParent(this, this.$changes.root, e);
                    var s = null !== (i = null === (r = this.$changes.indexes[e]) || void 0 === r ? void 0 : r.op) && void 0 !== i ? i : t.OPERATION.ADD;
                    this.$changes.indexes[e] = e,
                    this.$indexes.set(e, e),
                    this.$items.set(e, n),
                    this.$changes.change(e, s)
                }
                ,
                e.prototype.deleteAt = function(t) {
                    var e = Array.from(this.$items.keys())[t];
                    return void 0 !== e && this.$deleteAt(e)
                }
                ,
                e.prototype.$deleteAt = function(t) {
                    return this.$changes.delete(t),
                    this.$indexes.delete(t),
                    this.$items.delete(t)
                }
                ,
                e.prototype.clear = function(e) {
                    this.$changes.discard(!0, !0),
                    this.$changes.indexes = {},
                    this.$indexes.clear(),
                    e && u.call(this, e),
                    this.$items.clear(),
                    this.$changes.operation({
                        index: 0,
                        op: t.OPERATION.CLEAR
                    }),
                    this.$changes.touchParents()
                }
                ,
                e.prototype.concat = function() {
                    for (var t, n = [], r = 0; r < arguments.length; r++)
                        n[r] = arguments[r];
                    return new (e.bind.apply(e, i([void 0], (t = Array.from(this.$items.values())).concat.apply(t, n), !1)))
                }
                ,
                e.prototype.join = function(t) {
                    return Array.from(this.$items.values()).join(t)
                }
                ,
                e.prototype.reverse = function() {
                    var t = this
                      , e = Array.from(this.$items.keys());
                    return Array.from(this.$items.values()).reverse().forEach((function(n, r) {
                        t.setAt(e[r], n)
                    }
                    )),
                    this
                }
                ,
                e.prototype.shift = function() {
                    var t = Array.from(this.$items.keys()).shift();
                    if (void 0 !== t) {
                        var e = this.$items.get(t);
                        return this.$deleteAt(t),
                        e
                    }
                }
                ,
                e.prototype.slice = function(t, n) {
                    return new (e.bind.apply(e, i([void 0], Array.from(this.$items.values()).slice(t, n), !1)))
                }
                ,
                e.prototype.sort = function(t) {
                    var e = this;
                    void 0 === t && (t = d);
                    var n = Array.from(this.$items.keys());
                    return Array.from(this.$items.values()).sort(t).forEach((function(t, r) {
                        e.setAt(n[r], t)
                    }
                    )),
                    this
                }
                ,
                e.prototype.splice = function(t, e) {
                    void 0 === e && (e = this.length - t);
                    for (var n = Array.from(this.$items.keys()), r = [], i = t; i < t + e; i++)
                        r.push(this.$items.get(n[i])),
                        this.$deleteAt(n[i]);
                    return r
                }
                ,
                e.prototype.unshift = function() {
                    for (var t = this, e = [], n = 0; n < arguments.length; n++)
                        e[n] = arguments[n];
                    var r = this.length
                      , i = e.length
                      , s = Array.from(this.$items.values());
                    return e.forEach((function(e, n) {
                        t.setAt(n, e)
                    }
                    )),
                    s.forEach((function(e, n) {
                        t.setAt(i + n, e)
                    }
                    )),
                    r + i
                }
                ,
                e.prototype.indexOf = function(t, e) {
                    return Array.from(this.$items.values()).indexOf(t, e)
                }
                ,
                e.prototype.lastIndexOf = function(t, e) {
                    return void 0 === e && (e = this.length - 1),
                    Array.from(this.$items.values()).lastIndexOf(t, e)
                }
                ,
                e.prototype.every = function(t, e) {
                    return Array.from(this.$items.values()).every(t, e)
                }
                ,
                e.prototype.some = function(t, e) {
                    return Array.from(this.$items.values()).some(t, e)
                }
                ,
                e.prototype.forEach = function(t, e) {
                    Array.from(this.$items.values()).forEach(t, e)
                }
                ,
                e.prototype.map = function(t, e) {
                    return Array.from(this.$items.values()).map(t, e)
                }
                ,
                e.prototype.filter = function(t, e) {
                    return Array.from(this.$items.values()).filter(t, e)
                }
                ,
                e.prototype.reduce = function(t, e) {
                    return Array.prototype.reduce.apply(Array.from(this.$items.values()), arguments)
                }
                ,
                e.prototype.reduceRight = function(t, e) {
                    return Array.prototype.reduceRight.apply(Array.from(this.$items.values()), arguments)
                }
                ,
                e.prototype.find = function(t, e) {
                    return Array.from(this.$items.values()).find(t, e)
                }
                ,
                e.prototype.findIndex = function(t, e) {
                    return Array.from(this.$items.values()).findIndex(t, e)
                }
                ,
                e.prototype.fill = function(t, e, n) {
                    throw new Error("ArraySchema#fill() not implemented")
                }
                ,
                e.prototype.copyWithin = function(t, e, n) {
                    throw new Error("ArraySchema#copyWithin() not implemented")
                }
                ,
                e.prototype.toString = function() {
                    return this.$items.toString()
                }
                ,
                e.prototype.toLocaleString = function() {
                    return this.$items.toLocaleString()
                }
                ,
                e.prototype[Symbol.iterator] = function() {
                    return Array.from(this.$items.values())[Symbol.iterator]()
                }
                ,
                e.prototype.entries = function() {
                    return this.$items.entries()
                }
                ,
                e.prototype.keys = function() {
                    return this.$items.keys()
                }
                ,
                e.prototype.values = function() {
                    return this.$items.values()
                }
                ,
                e.prototype.includes = function(t, e) {
                    return Array.from(this.$items.values()).includes(t, e)
                }
                ,
                e.prototype.flatMap = function(t, e) {
                    throw new Error("ArraySchema#flatMap() is not supported.")
                }
                ,
                e.prototype.flat = function(t) {
                    throw new Error("ArraySchema#flat() is not supported.")
                }
                ,
                e.prototype.setIndex = function(t, e) {
                    this.$indexes.set(t, e)
                }
                ,
                e.prototype.getIndex = function(t) {
                    return this.$indexes.get(t)
                }
                ,
                e.prototype.getByIndex = function(t) {
                    return this.$items.get(this.$indexes.get(t))
                }
                ,
                e.prototype.deleteByIndex = function(t) {
                    var e = this.$indexes.get(t);
                    this.$items.delete(e),
                    this.$indexes.delete(t)
                }
                ,
                e.prototype.toArray = function() {
                    return Array.from(this.$items.values())
                }
                ,
                e.prototype.toJSON = function() {
                    return this.toArray().map((function(t) {
                        return "function" == typeof t.toJSON ? t.toJSON() : t
                    }
                    ))
                }
                ,
                e.prototype.clone = function(t) {
                    return t ? new (e.bind.apply(e, i([void 0], Array.from(this.$items.values()), !1))) : new (e.bind.apply(e, i([void 0], this.map((function(t) {
                        return t.$changes ? t.clone() : t
                    }
                    )), !1)))
                }
                ,
                e
            }();
            function m(t) {
                return t.$proxy = !0,
                t = new Proxy(t,{
                    get: function(t, e) {
                        return "symbol" != typeof e && void 0 === t[e] ? t.get(e) : t[e]
                    },
                    set: function(t, e, n) {
                        return "symbol" != typeof e && -1 === e.indexOf("$") && "onAdd" !== e && "onRemove" !== e && "onChange" !== e ? t.set(e, n) : t[e] = n,
                        !0
                    },
                    deleteProperty: function(t, e) {
                        return t.delete(e),
                        !0
                    }
                }),
                t
            }
            var g = function() {
                function e(t) {
                    var n = this;
                    if (this.$changes = new l(this),
                    this.$items = new Map,
                    this.$indexes = new Map,
                    this.$refId = 0,
                    t)
                        if (t instanceof Map || t instanceof e)
                            t.forEach((function(t, e) {
                                return n.set(e, t)
                            }
                            ));
                        else
                            for (var r in t)
                                this.set(r, t[r])
                }
                return e.prototype.onAdd = function(e, n) {
                    return void 0 === n && (n = !0),
                    c(this.$callbacks || (this.$callbacks = []), t.OPERATION.ADD, e, n ? this.$items : void 0)
                }
                ,
                e.prototype.onRemove = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
                }
                ,
                e.prototype.onChange = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
                }
                ,
                e.is = function(t) {
                    return void 0 !== t.map
                }
                ,
                e.prototype[Symbol.iterator] = function() {
                    return this.$items[Symbol.iterator]()
                }
                ,
                Object.defineProperty(e.prototype, Symbol.toStringTag, {
                    get: function() {
                        return this.$items[Symbol.toStringTag]
                    },
                    enumerable: !1,
                    configurable: !0
                }),
                e.prototype.set = function(e, n) {
                    if (null == n)
                        throw new Error("MapSchema#set('".concat(e, "', ").concat(n, "): trying to set ").concat(n, " value on '").concat(e, "'."));
                    var r = void 0 !== this.$changes.indexes[e]
                      , i = r ? this.$changes.indexes[e] : this.$refId++
                      , s = r ? t.OPERATION.REPLACE : t.OPERATION.ADD
                      , o = void 0 !== n.$changes;
                    return o && n.$changes.setParent(this, this.$changes.root, i),
                    r ? o && this.$items.get(e) !== n && (s = t.OPERATION.ADD) : (this.$changes.indexes[e] = i,
                    this.$indexes.set(i, e)),
                    this.$items.set(e, n),
                    this.$changes.change(e, s),
                    this
                }
                ,
                e.prototype.get = function(t) {
                    return this.$items.get(t)
                }
                ,
                e.prototype.delete = function(t) {
                    return this.$changes.delete(t),
                    this.$items.delete(t)
                }
                ,
                e.prototype.clear = function(e) {
                    this.$changes.discard(!0, !0),
                    this.$changes.indexes = {},
                    this.$indexes.clear(),
                    e && u.call(this, e),
                    this.$items.clear(),
                    this.$changes.operation({
                        index: 0,
                        op: t.OPERATION.CLEAR
                    }),
                    this.$changes.touchParents()
                }
                ,
                e.prototype.has = function(t) {
                    return this.$items.has(t)
                }
                ,
                e.prototype.forEach = function(t) {
                    this.$items.forEach(t)
                }
                ,
                e.prototype.entries = function() {
                    return this.$items.entries()
                }
                ,
                e.prototype.keys = function() {
                    return this.$items.keys()
                }
                ,
                e.prototype.values = function() {
                    return this.$items.values()
                }
                ,
                Object.defineProperty(e.prototype, "size", {
                    get: function() {
                        return this.$items.size
                    },
                    enumerable: !1,
                    configurable: !0
                }),
                e.prototype.setIndex = function(t, e) {
                    this.$indexes.set(t, e)
                }
                ,
                e.prototype.getIndex = function(t) {
                    return this.$indexes.get(t)
                }
                ,
                e.prototype.getByIndex = function(t) {
                    return this.$items.get(this.$indexes.get(t))
                }
                ,
                e.prototype.deleteByIndex = function(t) {
                    var e = this.$indexes.get(t);
                    this.$items.delete(e),
                    this.$indexes.delete(t)
                }
                ,
                e.prototype.toJSON = function() {
                    var t = {};
                    return this.forEach((function(e, n) {
                        t[n] = "function" == typeof e.toJSON ? e.toJSON() : e
                    }
                    )),
                    t
                }
                ,
                e.prototype.clone = function(t) {
                    var n;
                    return t ? n = Object.assign(new e, this) : (n = new e,
                    this.forEach((function(t, e) {
                        t.$changes ? n.set(e, t.clone()) : n.set(e, t)
                    }
                    ))),
                    n
                }
                ,
                e
            }()
              , y = {};
            function b(t, e) {
                y[t] = e
            }
            function v(t) {
                return y[t]
            }
            var w = function() {
                function t() {
                    this.indexes = {},
                    this.fieldsByIndex = {},
                    this.deprecated = {},
                    this.descriptors = {}
                }
                return t.create = function(e) {
                    var n = new t;
                    return n.schema = Object.assign({}, e && e.schema || {}),
                    n.indexes = Object.assign({}, e && e.indexes || {}),
                    n.fieldsByIndex = Object.assign({}, e && e.fieldsByIndex || {}),
                    n.descriptors = Object.assign({}, e && e.descriptors || {}),
                    n.deprecated = Object.assign({}, e && e.deprecated || {}),
                    n
                }
                ,
                t.prototype.addField = function(t, e) {
                    var n = this.getNextFieldIndex();
                    this.fieldsByIndex[n] = t,
                    this.indexes[t] = n,
                    this.schema[t] = Array.isArray(e) ? {
                        array: e[0]
                    } : e
                }
                ,
                t.prototype.hasField = function(t) {
                    return void 0 !== this.indexes[t]
                }
                ,
                t.prototype.addFilter = function(t, e) {
                    return this.filters || (this.filters = {},
                    this.indexesWithFilters = []),
                    this.filters[this.indexes[t]] = e,
                    this.indexesWithFilters.push(this.indexes[t]),
                    !0
                }
                ,
                t.prototype.addChildrenFilter = function(t, e) {
                    var n = this.indexes[t]
                      , r = this.schema[t];
                    if (v(Object.keys(r)[0]))
                        return this.childFilters || (this.childFilters = {}),
                        this.childFilters[n] = e,
                        !0;
                    console.warn("@filterChildren: field '".concat(t, "' can't have children. Ignoring filter."))
                }
                ,
                t.prototype.getChildrenFilter = function(t) {
                    return this.childFilters && this.childFilters[this.indexes[t]]
                }
                ,
                t.prototype.getNextFieldIndex = function() {
                    return Object.keys(this.schema || {}).length
                }
                ,
                t
            }();
            function x(t) {
                return t._context && t._context.useFilters
            }
            var E = function() {
                function t() {
                    this.types = {},
                    this.schemas = new Map,
                    this.useFilters = !1
                }
                return t.prototype.has = function(t) {
                    return this.schemas.has(t)
                }
                ,
                t.prototype.get = function(t) {
                    return this.types[t]
                }
                ,
                t.prototype.add = function(t, e) {
                    void 0 === e && (e = this.schemas.size),
                    t._definition = w.create(t._definition),
                    t._typeid = e,
                    this.types[e] = t,
                    this.schemas.set(t, e)
                }
                ,
                t.create = function(e) {
                    return void 0 === e && (e = {}),
                    function(n) {
                        return e.context || (e.context = new t),
                        A(n, e)
                    }
                }
                ,
                t
            }()
              , _ = new E;
            function A(t, e) {
                return void 0 === e && (e = {}),
                function(n, r) {
                    var s = e.context || _
                      , o = n.constructor;
                    if (o._context = s,
                    !t)
                        throw new Error("".concat(o.name, ': @type() reference provided for "').concat(r, "\" is undefined. Make sure you don't have any circular dependencies."));
                    s.has(o) || s.add(o);
                    var a = o._definition;
                    if (a.addField(r, t),
                    a.descriptors[r]) {
                        if (a.deprecated[r])
                            return;
                        try {
                            throw new Error("@colyseus/schema: Duplicate '".concat(r, "' definition on '").concat(o.name, "'.\nCheck @type() annotation"))
                        } catch (t) {
                            var l = t.stack.split("\n")[4].trim();
                            throw new Error("".concat(t.message, " ").concat(l))
                        }
                    }
                    var c = p.is(t)
                      , u = !c && g.is(t);
                    if ("string" != typeof t && !Mt.is(t)) {
                        var h = Object.values(t)[0];
                        "string" == typeof h || s.has(h) || s.add(h)
                    }
                    if (e.manual)
                        a.descriptors[r] = {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        };
                    else {
                        var d = "_".concat(r);
                        a.descriptors[d] = {
                            enumerable: !1,
                            configurable: !1,
                            writable: !0
                        },
                        a.descriptors[r] = {
                            get: function() {
                                return this[d]
                            },
                            set: function(t) {
                                t !== this[d] && (null != t ? (!c || t instanceof p || (t = new (p.bind.apply(p, i([void 0], t, !1)))),
                                !u || t instanceof g || (t = new g(t)),
                                void 0 === t.$proxy && (u ? t = m(t) : c && (t = f(t))),
                                this.$changes.change(r),
                                t.$changes && t.$changes.setParent(this, this.$changes.root, this._definition.indexes[r])) : this[d] && this.$changes.delete(r),
                                this[d] = t)
                            },
                            enumerable: !0,
                            configurable: !0
                        }
                    }
                }
            }
            function S(t) {
                return function(e, n) {
                    var r = e.constructor;
                    r._definition.addFilter(n, t) && (r._context.useFilters = !0)
                }
            }
            function T(t) {
                return function(e, n) {
                    var r = e.constructor;
                    r._definition.addChildrenFilter(n, t) && (r._context.useFilters = !0)
                }
            }
            function k(t) {
                return void 0 === t && (t = !0),
                function(e, n) {
                    var r = e.constructor._definition;
                    r.deprecated[n] = !0,
                    t && (r.descriptors[n] = {
                        get: function() {
                            throw new Error("".concat(n, " is deprecated."))
                        },
                        set: function(t) {},
                        enumerable: !1,
                        configurable: !0
                    })
                }
            }
            function I(t, e, n) {
                for (var r in void 0 === n && (n = {}),
                n.context || (n.context = t._context || n.context || _),
                e)
                    A(e[r], n)(t.prototype, r);
                return t
            }
            function M(t) {
                for (var e = 0, n = 0, r = 0, i = t.length; r < i; r++)
                    (e = t.charCodeAt(r)) < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || e >= 57344 ? n += 3 : (r++,
                    n += 4);
                return n
            }
            function C(t, e, n) {
                for (var r = 0, i = 0, s = n.length; i < s; i++)
                    (r = n.charCodeAt(i)) < 128 ? t[e++] = r : r < 2048 ? (t[e++] = 192 | r >> 6,
                    t[e++] = 128 | 63 & r) : r < 55296 || r >= 57344 ? (t[e++] = 224 | r >> 12,
                    t[e++] = 128 | r >> 6 & 63,
                    t[e++] = 128 | 63 & r) : (i++,
                    r = 65536 + ((1023 & r) << 10 | 1023 & n.charCodeAt(i)),
                    t[e++] = 240 | r >> 18,
                    t[e++] = 128 | r >> 12 & 63,
                    t[e++] = 128 | r >> 6 & 63,
                    t[e++] = 128 | 63 & r)
            }
            function P(t, e) {
                t.push(255 & e)
            }
            function O(t, e) {
                t.push(255 & e)
            }
            function N(t, e) {
                t.push(255 & e),
                t.push(e >> 8 & 255)
            }
            function R(t, e) {
                t.push(255 & e),
                t.push(e >> 8 & 255)
            }
            function D(t, e) {
                t.push(255 & e),
                t.push(e >> 8 & 255),
                t.push(e >> 16 & 255),
                t.push(e >> 24 & 255)
            }
            function B(t, e) {
                var n = e >> 24
                  , r = e >> 16
                  , i = e >> 8
                  , s = e;
                t.push(255 & s),
                t.push(255 & i),
                t.push(255 & r),
                t.push(255 & n)
            }
            function L(t, e) {
                var n = Math.floor(e / Math.pow(2, 32));
                B(t, e >>> 0),
                B(t, n)
            }
            function F(t, e) {
                var n = e / Math.pow(2, 32) >> 0;
                B(t, e >>> 0),
                B(t, n)
            }
            function j(t, e) {
                Y(t, e)
            }
            function U(t, e) {
                H(t, e)
            }
            var z = new Int32Array(2)
              , V = new Float32Array(z.buffer)
              , W = new Float64Array(z.buffer);
            function Y(t, e) {
                V[0] = e,
                D(t, z[0])
            }
            function H(t, e) {
                W[0] = e,
                D(t, z[0]),
                D(t, z[1])
            }
            function $(t, e) {
                return O(t, e ? 1 : 0)
            }
            function G(t, e) {
                e || (e = "");
                var n = M(e)
                  , r = 0;
                if (n < 32)
                    t.push(160 | n),
                    r = 1;
                else if (n < 256)
                    t.push(217),
                    O(t, n),
                    r = 2;
                else if (n < 65536)
                    t.push(218),
                    R(t, n),
                    r = 3;
                else {
                    if (!(n < 4294967296))
                        throw new Error("String too long");
                    t.push(219),
                    B(t, n),
                    r = 5
                }
                return C(t, t.length, e),
                r + n
            }
            function X(t, e) {
                return isNaN(e) ? X(t, 0) : isFinite(e) ? e !== (0 | e) ? (t.push(203),
                H(t, e),
                9) : e >= 0 ? e < 128 ? (O(t, e),
                1) : e < 256 ? (t.push(204),
                O(t, e),
                2) : e < 65536 ? (t.push(205),
                R(t, e),
                3) : e < 4294967296 ? (t.push(206),
                B(t, e),
                5) : (t.push(207),
                F(t, e),
                9) : e >= -32 ? (t.push(224 | e + 32),
                1) : e >= -128 ? (t.push(208),
                P(t, e),
                2) : e >= -32768 ? (t.push(209),
                N(t, e),
                3) : e >= -2147483648 ? (t.push(210),
                D(t, e),
                5) : (t.push(211),
                L(t, e),
                9) : X(t, e > 0 ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER)
            }
            var q = Object.freeze({
                __proto__: null,
                utf8Write: C,
                int8: P,
                uint8: O,
                int16: N,
                uint16: R,
                int32: D,
                uint32: B,
                int64: L,
                uint64: F,
                float32: j,
                float64: U,
                writeFloat32: Y,
                writeFloat64: H,
                boolean: $,
                string: G,
                number: X
            });
            function K(t, e, n) {
                for (var r = "", i = 0, s = e, o = e + n; s < o; s++) {
                    var a = t[s];
                    0 != (128 & a) ? 192 != (224 & a) ? 224 != (240 & a) ? 240 != (248 & a) ? console.error("Invalid byte " + a.toString(16)) : (i = (7 & a) << 18 | (63 & t[++s]) << 12 | (63 & t[++s]) << 6 | (63 & t[++s]) << 0) >= 65536 ? (i -= 65536,
                    r += String.fromCharCode(55296 + (i >>> 10), 56320 + (1023 & i))) : r += String.fromCharCode(i) : r += String.fromCharCode((15 & a) << 12 | (63 & t[++s]) << 6 | (63 & t[++s]) << 0) : r += String.fromCharCode((31 & a) << 6 | 63 & t[++s]) : r += String.fromCharCode(a)
                }
                return r
            }
            function Q(t, e) {
                return Z(t, e) << 24 >> 24
            }
            function Z(t, e) {
                return t[e.offset++]
            }
            function J(t, e) {
                return tt(t, e) << 16 >> 16
            }
            function tt(t, e) {
                return t[e.offset++] | t[e.offset++] << 8
            }
            function et(t, e) {
                return t[e.offset++] | t[e.offset++] << 8 | t[e.offset++] << 16 | t[e.offset++] << 24
            }
            function nt(t, e) {
                return et(t, e) >>> 0
            }
            function rt(t, e) {
                return ut(t, e)
            }
            function it(t, e) {
                return ht(t, e)
            }
            function st(t, e) {
                var n = nt(t, e);
                return et(t, e) * Math.pow(2, 32) + n
            }
            function ot(t, e) {
                var n = nt(t, e);
                return nt(t, e) * Math.pow(2, 32) + n
            }
            var at = new Int32Array(2)
              , lt = new Float32Array(at.buffer)
              , ct = new Float64Array(at.buffer);
            function ut(t, e) {
                return at[0] = et(t, e),
                lt[0]
            }
            function ht(t, e) {
                return at[0] = et(t, e),
                at[1] = et(t, e),
                ct[0]
            }
            function dt(t, e) {
                return Z(t, e) > 0
            }
            function ft(t, e) {
                var n, r = t[e.offset++];
                r < 192 ? n = 31 & r : 217 === r ? n = Z(t, e) : 218 === r ? n = tt(t, e) : 219 === r && (n = nt(t, e));
                var i = K(t, e.offset, n);
                return e.offset += n,
                i
            }
            function pt(t, e) {
                var n = t[e.offset];
                return n < 192 && n > 160 || 217 === n || 218 === n || 219 === n
            }
            function mt(t, e) {
                var n = t[e.offset++];
                return n < 128 ? n : 202 === n ? ut(t, e) : 203 === n ? ht(t, e) : 204 === n ? Z(t, e) : 205 === n ? tt(t, e) : 206 === n ? nt(t, e) : 207 === n ? ot(t, e) : 208 === n ? Q(t, e) : 209 === n ? J(t, e) : 210 === n ? et(t, e) : 211 === n ? st(t, e) : n > 223 ? -1 * (255 - n + 1) : void 0
            }
            function gt(t, e) {
                var n = t[e.offset];
                return n < 128 || n >= 202 && n <= 211
            }
            function yt(t, e) {
                return t[e.offset] < 160
            }
            function bt(t, e) {
                return t[e.offset - 1] === o && (t[e.offset] < 128 || t[e.offset] >= 202 && t[e.offset] <= 211)
            }
            var vt = Object.freeze({
                __proto__: null,
                int8: Q,
                uint8: Z,
                int16: J,
                uint16: tt,
                int32: et,
                uint32: nt,
                float32: rt,
                float64: it,
                int64: st,
                uint64: ot,
                readFloat32: ut,
                readFloat64: ht,
                boolean: dt,
                string: ft,
                stringCheck: pt,
                number: mt,
                numberCheck: gt,
                arrayCheck: yt,
                switchStructureCheck: bt
            })
              , wt = function() {
                function e(t) {
                    var e = this;
                    this.$changes = new l(this),
                    this.$items = new Map,
                    this.$indexes = new Map,
                    this.$refId = 0,
                    t && t.forEach((function(t) {
                        return e.add(t)
                    }
                    ))
                }
                return e.prototype.onAdd = function(e, n) {
                    return void 0 === n && (n = !0),
                    c(this.$callbacks || (this.$callbacks = []), t.OPERATION.ADD, e, n ? this.$items : void 0)
                }
                ,
                e.prototype.onRemove = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
                }
                ,
                e.prototype.onChange = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
                }
                ,
                e.is = function(t) {
                    return void 0 !== t.collection
                }
                ,
                e.prototype.add = function(t) {
                    var e = this.$refId++;
                    return void 0 !== t.$changes && t.$changes.setParent(this, this.$changes.root, e),
                    this.$changes.indexes[e] = e,
                    this.$indexes.set(e, e),
                    this.$items.set(e, t),
                    this.$changes.change(e),
                    e
                }
                ,
                e.prototype.at = function(t) {
                    var e = Array.from(this.$items.keys())[t];
                    return this.$items.get(e)
                }
                ,
                e.prototype.entries = function() {
                    return this.$items.entries()
                }
                ,
                e.prototype.delete = function(t) {
                    for (var e, n, r = this.$items.entries(); (n = r.next()) && !n.done; )
                        if (t === n.value[1]) {
                            e = n.value[0];
                            break
                        }
                    return void 0 !== e && (this.$changes.delete(e),
                    this.$indexes.delete(e),
                    this.$items.delete(e))
                }
                ,
                e.prototype.clear = function(e) {
                    this.$changes.discard(!0, !0),
                    this.$changes.indexes = {},
                    this.$indexes.clear(),
                    e && u.call(this, e),
                    this.$items.clear(),
                    this.$changes.operation({
                        index: 0,
                        op: t.OPERATION.CLEAR
                    }),
                    this.$changes.touchParents()
                }
                ,
                e.prototype.has = function(t) {
                    return Array.from(this.$items.values()).some((function(e) {
                        return e === t
                    }
                    ))
                }
                ,
                e.prototype.forEach = function(t) {
                    var e = this;
                    this.$items.forEach((function(n, r, i) {
                        return t(n, r, e)
                    }
                    ))
                }
                ,
                e.prototype.values = function() {
                    return this.$items.values()
                }
                ,
                Object.defineProperty(e.prototype, "size", {
                    get: function() {
                        return this.$items.size
                    },
                    enumerable: !1,
                    configurable: !0
                }),
                e.prototype.setIndex = function(t, e) {
                    this.$indexes.set(t, e)
                }
                ,
                e.prototype.getIndex = function(t) {
                    return this.$indexes.get(t)
                }
                ,
                e.prototype.getByIndex = function(t) {
                    return this.$items.get(this.$indexes.get(t))
                }
                ,
                e.prototype.deleteByIndex = function(t) {
                    var e = this.$indexes.get(t);
                    this.$items.delete(e),
                    this.$indexes.delete(t)
                }
                ,
                e.prototype.toArray = function() {
                    return Array.from(this.$items.values())
                }
                ,
                e.prototype.toJSON = function() {
                    var t = [];
                    return this.forEach((function(e, n) {
                        t.push("function" == typeof e.toJSON ? e.toJSON() : e)
                    }
                    )),
                    t
                }
                ,
                e.prototype.clone = function(t) {
                    var n;
                    return t ? n = Object.assign(new e, this) : (n = new e,
                    this.forEach((function(t) {
                        t.$changes ? n.add(t.clone()) : n.add(t)
                    }
                    ))),
                    n
                }
                ,
                e
            }()
              , xt = function() {
                function e(t) {
                    var e = this;
                    this.$changes = new l(this),
                    this.$items = new Map,
                    this.$indexes = new Map,
                    this.$refId = 0,
                    t && t.forEach((function(t) {
                        return e.add(t)
                    }
                    ))
                }
                return e.prototype.onAdd = function(e, n) {
                    return void 0 === n && (n = !0),
                    c(this.$callbacks || (this.$callbacks = []), t.OPERATION.ADD, e, n ? this.$items : void 0)
                }
                ,
                e.prototype.onRemove = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
                }
                ,
                e.prototype.onChange = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
                }
                ,
                e.is = function(t) {
                    return void 0 !== t.set
                }
                ,
                e.prototype.add = function(e) {
                    var n, r;
                    if (this.has(e))
                        return !1;
                    var i = this.$refId++;
                    void 0 !== e.$changes && e.$changes.setParent(this, this.$changes.root, i);
                    var s = null !== (r = null === (n = this.$changes.indexes[i]) || void 0 === n ? void 0 : n.op) && void 0 !== r ? r : t.OPERATION.ADD;
                    return this.$changes.indexes[i] = i,
                    this.$indexes.set(i, i),
                    this.$items.set(i, e),
                    this.$changes.change(i, s),
                    i
                }
                ,
                e.prototype.entries = function() {
                    return this.$items.entries()
                }
                ,
                e.prototype.delete = function(t) {
                    for (var e, n, r = this.$items.entries(); (n = r.next()) && !n.done; )
                        if (t === n.value[1]) {
                            e = n.value[0];
                            break
                        }
                    return void 0 !== e && (this.$changes.delete(e),
                    this.$indexes.delete(e),
                    this.$items.delete(e))
                }
                ,
                e.prototype.clear = function(e) {
                    this.$changes.discard(!0, !0),
                    this.$changes.indexes = {},
                    this.$indexes.clear(),
                    e && u.call(this, e),
                    this.$items.clear(),
                    this.$changes.operation({
                        index: 0,
                        op: t.OPERATION.CLEAR
                    }),
                    this.$changes.touchParents()
                }
                ,
                e.prototype.has = function(t) {
                    for (var e, n = this.$items.values(), r = !1; (e = n.next()) && !e.done; )
                        if (t === e.value) {
                            r = !0;
                            break
                        }
                    return r
                }
                ,
                e.prototype.forEach = function(t) {
                    var e = this;
                    this.$items.forEach((function(n, r, i) {
                        return t(n, r, e)
                    }
                    ))
                }
                ,
                e.prototype.values = function() {
                    return this.$items.values()
                }
                ,
                Object.defineProperty(e.prototype, "size", {
                    get: function() {
                        return this.$items.size
                    },
                    enumerable: !1,
                    configurable: !0
                }),
                e.prototype.setIndex = function(t, e) {
                    this.$indexes.set(t, e)
                }
                ,
                e.prototype.getIndex = function(t) {
                    return this.$indexes.get(t)
                }
                ,
                e.prototype.getByIndex = function(t) {
                    return this.$items.get(this.$indexes.get(t))
                }
                ,
                e.prototype.deleteByIndex = function(t) {
                    var e = this.$indexes.get(t);
                    this.$items.delete(e),
                    this.$indexes.delete(t)
                }
                ,
                e.prototype.toArray = function() {
                    return Array.from(this.$items.values())
                }
                ,
                e.prototype.toJSON = function() {
                    var t = [];
                    return this.forEach((function(e, n) {
                        t.push("function" == typeof e.toJSON ? e.toJSON() : e)
                    }
                    )),
                    t
                }
                ,
                e.prototype.clone = function(t) {
                    var n;
                    return t ? n = Object.assign(new e, this) : (n = new e,
                    this.forEach((function(t) {
                        t.$changes ? n.add(t.clone()) : n.add(t)
                    }
                    ))),
                    n
                }
                ,
                e
            }()
              , Et = function() {
                function t() {
                    this.refIds = new WeakSet,
                    this.containerIndexes = new WeakMap
                }
                return t.prototype.addRefId = function(t) {
                    this.refIds.has(t) || (this.refIds.add(t),
                    this.containerIndexes.set(t, new Set))
                }
                ,
                t.get = function(e) {
                    return void 0 === e.$filterState && (e.$filterState = new t),
                    e.$filterState
                }
                ,
                t
            }()
              , _t = function() {
                function t() {
                    this.refs = new Map,
                    this.refCounts = {},
                    this.deletedRefs = new Set,
                    this.nextUniqueId = 0
                }
                return t.prototype.getNextUniqueId = function() {
                    return this.nextUniqueId++
                }
                ,
                t.prototype.addRef = function(t, e, n) {
                    void 0 === n && (n = !0),
                    this.refs.set(t, e),
                    n && (this.refCounts[t] = (this.refCounts[t] || 0) + 1)
                }
                ,
                t.prototype.removeRef = function(t) {
                    this.refCounts[t] = this.refCounts[t] - 1,
                    this.deletedRefs.add(t)
                }
                ,
                t.prototype.clearRefs = function() {
                    this.refs.clear(),
                    this.deletedRefs.clear(),
                    this.refCounts = {}
                }
                ,
                t.prototype.garbageCollectDeletedRefs = function() {
                    var t = this;
                    this.deletedRefs.forEach((function(e) {
                        if (!(t.refCounts[e] > 0)) {
                            var n = t.refs.get(e);
                            if (n instanceof Mt)
                                for (var r in n._definition.schema)
                                    "string" != typeof n._definition.schema[r] && n[r] && n[r].$changes && t.removeRef(n[r].$changes.refId);
                            else {
                                var i = n.$changes.parent._definition
                                  , s = i.schema[i.fieldsByIndex[n.$changes.parentIndex]];
                                "function" == typeof Object.values(s)[0] && Array.from(n.values()).forEach((function(e) {
                                    return t.removeRef(e.$changes.refId)
                                }
                                ))
                            }
                            t.refs.delete(e),
                            delete t.refCounts[e]
                        }
                    }
                    )),
                    this.deletedRefs.clear()
                }
                ,
                t
            }()
              , At = function(t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                return n(e, t),
                e
            }(Error);
            function St(t, e, n, r) {
                var i, s = !1;
                switch (e) {
                case "number":
                case "int8":
                case "uint8":
                case "int16":
                case "uint16":
                case "int32":
                case "uint32":
                case "int64":
                case "uint64":
                case "float32":
                case "float64":
                    i = "number",
                    isNaN(t) && console.log('trying to encode "NaN" in '.concat(n.constructor.name, "#").concat(r));
                    break;
                case "string":
                    i = "string",
                    s = !0;
                    break;
                case "boolean":
                    return
                }
                if (typeof t !== i && (!s || s && null !== t)) {
                    var o = "'".concat(JSON.stringify(t), "'").concat(t && t.constructor && " (".concat(t.constructor.name, ")") || "");
                    throw new At("a '".concat(i, "' was expected, but ").concat(o, " was provided in ").concat(n.constructor.name, "#").concat(r))
                }
            }
            function Tt(t, e, n, r) {
                if (!(t instanceof e))
                    throw new At("a '".concat(e.name, "' was expected, but '").concat(t.constructor.name, "' was provided in ").concat(n.constructor.name, "#").concat(r))
            }
            function kt(t, e, n, r, i) {
                St(n, t, r, i);
                var s = q[t];
                if (!s)
                    throw new At("a '".concat(t, "' was expected, but ").concat(n, " was provided in ").concat(r.constructor.name, "#").concat(i));
                s(e, n)
            }
            function It(t, e, n) {
                return vt[t](e, n)
            }
            var Mt = function() {
                function e() {
                    for (var t = [], e = 0; e < arguments.length; e++)
                        t[e] = arguments[e];
                    Object.defineProperties(this, {
                        $changes: {
                            value: new l(this,void 0,new _t),
                            enumerable: !1,
                            writable: !0
                        },
                        $callbacks: {
                            value: void 0,
                            enumerable: !1,
                            writable: !0
                        }
                    });
                    var n = this._definition.descriptors;
                    n && Object.defineProperties(this, n),
                    t[0] && this.assign(t[0])
                }
                return e.onError = function(t) {
                    console.error(t)
                }
                ,
                e.is = function(t) {
                    return t._definition && void 0 !== t._definition.schema
                }
                ,
                e.prototype.onChange = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
                }
                ,
                e.prototype.onRemove = function(e) {
                    return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
                }
                ,
                e.prototype.assign = function(t) {
                    return Object.assign(this, t),
                    this
                }
                ,
                Object.defineProperty(e.prototype, "_definition", {
                    get: function() {
                        return this.constructor._definition
                    },
                    enumerable: !1,
                    configurable: !0
                }),
                e.prototype.setDirty = function(t, e) {
                    this.$changes.change(t, e)
                }
                ,
                e.prototype.listen = function(t, e) {
                    var n = this;
                    return this.$callbacks || (this.$callbacks = {}),
                    this.$callbacks[t] || (this.$callbacks[t] = []),
                    this.$callbacks[t].push(e),
                    function() {
                        return h(n.$callbacks[t], n.$callbacks[t].indexOf(e))
                    }
                }
                ,
                e.prototype.decode = function(n, r, i) {
                    void 0 === r && (r = {
                        offset: 0
                    }),
                    void 0 === i && (i = this);
                    var s = []
                      , a = this.$changes.root
                      , l = n.length
                      , c = 0;
                    for (a.refs.set(c, this); r.offset < l; ) {
                        var u = n[r.offset++];
                        if (u != o) {
                            var h = i.$changes
                              , d = void 0 !== i._definition
                              , f = d ? u >> 6 << 6 : u;
                            if (f !== t.OPERATION.CLEAR) {
                                var m = d ? u % (f || 255) : mt(n, r)
                                  , y = d ? i._definition.fieldsByIndex[m] : ""
                                  , b = h.getType(m)
                                  , w = void 0
                                  , x = void 0
                                  , E = void 0;
                                if (d ? x = i["_".concat(y)] : (x = i.getByIndex(m),
                                (f & t.OPERATION.ADD) === t.OPERATION.ADD ? (E = i instanceof g ? ft(n, r) : m,
                                i.setIndex(m, E)) : E = i.getIndex(m)),
                                (f & t.OPERATION.DELETE) === t.OPERATION.DELETE && (f !== t.OPERATION.DELETE_AND_ADD && i.deleteByIndex(m),
                                x && x.$changes && a.removeRef(x.$changes.refId),
                                w = null),
                                void 0 !== y) {
                                    if (f === t.OPERATION.DELETE)
                                        ;
                                    else if (e.is(b)) {
                                        var _ = mt(n, r);
                                        if (w = a.refs.get(_),
                                        f !== t.OPERATION.REPLACE) {
                                            var A = this.getSchemaType(n, r, b);
                                            w || ((w = this.createTypeInstance(A)).$changes.refId = _,
                                            x && (w.$callbacks = x.$callbacks,
                                            x.$changes.refId && _ !== x.$changes.refId && a.removeRef(x.$changes.refId))),
                                            a.addRef(_, w, w !== x)
                                        }
                                    } else if ("string" == typeof b)
                                        w = It(b, n, r);
                                    else {
                                        var S = v(Object.keys(b)[0])
                                          , T = mt(n, r)
                                          , k = a.refs.has(T) ? x || a.refs.get(T) : new S.constructor;
                                        if ((w = k.clone(!0)).$changes.refId = T,
                                        x && (w.$callbacks = x.$callbacks,
                                        x.$changes.refId && T !== x.$changes.refId)) {
                                            a.removeRef(x.$changes.refId);
                                            for (var I = x.entries(), M = void 0; (M = I.next()) && !M.done; ) {
                                                var C = M.value
                                                  , P = C[0]
                                                  , O = C[1];
                                                s.push({
                                                    refId: T,
                                                    op: t.OPERATION.DELETE,
                                                    field: P,
                                                    value: void 0,
                                                    previousValue: O
                                                })
                                            }
                                        }
                                        a.addRef(T, w, k !== x)
                                    }
                                    if (null != w)
                                        if (w.$changes && w.$changes.setParent(h.ref, h.root, m),
                                        i instanceof e)
                                            i[y] = w;
                                        else if (i instanceof g)
                                            P = E,
                                            i.$items.set(P, w),
                                            i.$changes.allChanges.add(m);
                                        else if (i instanceof p)
                                            i.setAt(m, w);
                                        else if (i instanceof wt) {
                                            var N = i.add(w);
                                            i.setIndex(m, N)
                                        } else
                                            i instanceof xt && !1 !== (N = i.add(w)) && i.setIndex(m, N);
                                    x !== w && s.push({
                                        refId: c,
                                        op: f,
                                        field: y,
                                        dynamicIndex: E,
                                        value: w,
                                        previousValue: x
                                    })
                                } else {
                                    console.warn("@colyseus/schema: definition mismatch");
                                    for (var R = {
                                        offset: r.offset
                                    }; r.offset < l && (!bt(n, r) || (R.offset = r.offset + 1,
                                    !a.refs.has(mt(n, R)))); )
                                        r.offset++
                                }
                            } else
                                i.clear(s)
                        } else {
                            c = mt(n, r);
                            var D = a.refs.get(c);
                            if (!D)
                                throw new Error('"refId" not found: '.concat(c));
                            i = D
                        }
                    }
                    return this._triggerChanges(s),
                    a.garbageCollectDeletedRefs(),
                    s
                }
                ,
                e.prototype.encode = function(n, r, i) {
                    void 0 === n && (n = !1),
                    void 0 === r && (r = []),
                    void 0 === i && (i = !1);
                    for (var s = this.$changes, a = new WeakSet, l = [s], c = 1, u = 0; u < c; u++) {
                        var h = l[u]
                          , d = h.ref
                          , f = d instanceof e;
                        h.ensureRefId(),
                        a.add(h),
                        h !== s && (h.changed || n) && (O(r, o),
                        X(r, h.refId));
                        for (var p = n ? Array.from(h.allChanges) : Array.from(h.changes.values()), m = 0, y = p.length; m < y; m++) {
                            var b = n ? {
                                op: t.OPERATION.ADD,
                                index: p[m]
                            } : p[m]
                              , w = b.index
                              , x = f ? d._definition.fieldsByIndex && d._definition.fieldsByIndex[w] : w
                              , E = r.length;
                            if (b.op !== t.OPERATION.TOUCH)
                                if (f)
                                    O(r, w | b.op);
                                else {
                                    if (O(r, b.op),
                                    b.op === t.OPERATION.CLEAR)
                                        continue;
                                    X(r, w)
                                }
                            if (f || (b.op & t.OPERATION.ADD) != t.OPERATION.ADD || d instanceof g && G(r, h.ref.$indexes.get(w)),
                            b.op !== t.OPERATION.DELETE) {
                                var _ = h.getType(w)
                                  , A = h.getValue(w);
                                if (A && A.$changes && !a.has(A.$changes) && (l.push(A.$changes),
                                A.$changes.ensureRefId(),
                                c++),
                                b.op !== t.OPERATION.TOUCH) {
                                    if (e.is(_))
                                        Tt(A, _, d, x),
                                        X(r, A.$changes.refId),
                                        (b.op & t.OPERATION.ADD) === t.OPERATION.ADD && this.tryEncodeTypeId(r, _, A.constructor);
                                    else if ("string" == typeof _)
                                        kt(_, r, A, d, x);
                                    else {
                                        var S = v(Object.keys(_)[0]);
                                        Tt(d["_".concat(x)], S.constructor, d, x),
                                        X(r, A.$changes.refId)
                                    }
                                    i && h.cache(w, r.slice(E))
                                }
                            }
                        }
                        n || i || h.discard()
                    }
                    return r
                }
                ,
                e.prototype.encodeAll = function(t) {
                    return this.encode(!0, [], t)
                }
                ,
                e.prototype.applyFilters = function(n, r) {
                    var i, s;
                    void 0 === r && (r = !1);
                    for (var a = this, l = new Set, c = Et.get(n), u = [this.$changes], h = 1, d = [], f = function(f) {
                        var p = u[f];
                        if (l.has(p.refId))
                            return "continue";
                        var m = p.ref
                          , y = m instanceof e;
                        O(d, o),
                        X(d, p.refId);
                        var b = c.refIds.has(p)
                          , v = r || !b;
                        c.addRefId(p);
                        var w = c.containerIndexes.get(p)
                          , x = v ? Array.from(p.allChanges) : Array.from(p.changes.values());
                        !r && y && m._definition.indexesWithFilters && m._definition.indexesWithFilters.forEach((function(e) {
                            !w.has(e) && p.allChanges.has(e) && (v ? x.push(e) : x.push({
                                op: t.OPERATION.ADD,
                                index: e
                            }))
                        }
                        ));
                        for (var E = 0, _ = x.length; E < _; E++) {
                            var A = v ? {
                                op: t.OPERATION.ADD,
                                index: x[E]
                            } : x[E];
                            if (A.op !== t.OPERATION.CLEAR) {
                                var S = A.index;
                                if (A.op !== t.OPERATION.DELETE) {
                                    var T = p.getValue(S)
                                      , k = p.getType(S);
                                    if (y) {
                                        if ((I = m._definition.filters && m._definition.filters[S]) && !I.call(m, n, T, a)) {
                                            T && T.$changes && l.add(T.$changes.refId);
                                            continue
                                        }
                                    } else {
                                        var I, M = p.parent;
                                        if ((I = p.getChildrenFilter()) && !I.call(M, n, m.$indexes.get(S), T, a)) {
                                            T && T.$changes && l.add(T.$changes.refId);
                                            continue
                                        }
                                    }
                                    if (T.$changes && (u.push(T.$changes),
                                    h++),
                                    A.op !== t.OPERATION.TOUCH)
                                        if (A.op === t.OPERATION.ADD || y)
                                            d.push.apply(d, null !== (i = p.caches[S]) && void 0 !== i ? i : []),
                                            w.add(S);
                                        else if (w.has(S))
                                            d.push.apply(d, null !== (s = p.caches[S]) && void 0 !== s ? s : []);
                                        else {
                                            if (w.add(S),
                                            O(d, t.OPERATION.ADD),
                                            X(d, S),
                                            m instanceof g) {
                                                var C = p.ref.$indexes.get(S);
                                                G(d, C)
                                            }
                                            T.$changes ? X(d, T.$changes.refId) : q[k](d, T)
                                        }
                                    else
                                        T.$changes && !y && (O(d, t.OPERATION.ADD),
                                        X(d, S),
                                        m instanceof g && (C = p.ref.$indexes.get(S),
                                        G(d, C)),
                                        X(d, T.$changes.refId))
                                } else
                                    y ? O(d, A.op | S) : (O(d, A.op),
                                    X(d, S))
                            } else
                                O(d, A.op)
                        }
                    }, p = 0; p < h; p++)
                        f(p);
                    return d
                }
                ,
                e.prototype.clone = function() {
                    var t, e = new this.constructor, n = this._definition.schema;
                    for (var r in n)
                        "object" == typeof this[r] && "function" == typeof (null === (t = this[r]) || void 0 === t ? void 0 : t.clone) ? e[r] = this[r].clone() : e[r] = this[r];
                    return e
                }
                ,
                e.prototype.toJSON = function() {
                    var t = this._definition.schema
                      , e = this._definition.deprecated
                      , n = {};
                    for (var r in t)
                        e[r] || null === this[r] || void 0 === this[r] || (n[r] = "function" == typeof this[r].toJSON ? this[r].toJSON() : this["_".concat(r)]);
                    return n
                }
                ,
                e.prototype.discardAllChanges = function() {
                    this.$changes.discardAll()
                }
                ,
                e.prototype.getByIndex = function(t) {
                    return this[this._definition.fieldsByIndex[t]]
                }
                ,
                e.prototype.deleteByIndex = function(t) {
                    this[this._definition.fieldsByIndex[t]] = void 0
                }
                ,
                e.prototype.tryEncodeTypeId = function(t, e, n) {
                    e._typeid !== n._typeid && (O(t, a),
                    X(t, n._typeid))
                }
                ,
                e.prototype.getSchemaType = function(t, e, n) {
                    var r;
                    return t[e.offset] === a && (e.offset++,
                    r = this.constructor._context.get(mt(t, e))),
                    r || n
                }
                ,
                e.prototype.createTypeInstance = function(t) {
                    var e = new t;
                    return e.$changes.root = this.$changes.root,
                    e
                }
                ,
                e.prototype._triggerChanges = function(n) {
                    for (var r, i, s, o, a, l, c, u, h, d = new Set, f = this.$changes.root.refs, p = function(p) {
                        var m = n[p]
                          , g = m.refId
                          , y = f.get(g)
                          , b = y.$callbacks;
                        if ((m.op & t.OPERATION.DELETE) === t.OPERATION.DELETE && m.previousValue instanceof e && (null === (i = null === (r = m.previousValue.$callbacks) || void 0 === r ? void 0 : r[t.OPERATION.DELETE]) || void 0 === i || i.forEach((function(t) {
                            return t()
                        }
                        ))),
                        !b)
                            return "continue";
                        if (y instanceof e) {
                            if (!d.has(g))
                                try {
                                    null === (s = null == b ? void 0 : b[t.OPERATION.REPLACE]) || void 0 === s || s.forEach((function(t) {
                                        return t(n)
                                    }
                                    ))
                                } catch (t) {
                                    e.onError(t)
                                }
                            try {
                                b.hasOwnProperty(m.field) && (null === (o = b[m.field]) || void 0 === o || o.forEach((function(t) {
                                    return t(m.value, m.previousValue)
                                }
                                )))
                            } catch (t) {
                                e.onError(t)
                            }
                        } else
                            m.op === t.OPERATION.ADD && void 0 === m.previousValue ? null === (a = b[t.OPERATION.ADD]) || void 0 === a || a.forEach((function(t) {
                                var e;
                                return t(m.value, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                            }
                            )) : m.op === t.OPERATION.DELETE ? void 0 !== m.previousValue && (null === (l = b[t.OPERATION.DELETE]) || void 0 === l || l.forEach((function(t) {
                                var e;
                                return t(m.previousValue, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                            }
                            ))) : m.op === t.OPERATION.DELETE_AND_ADD && (void 0 !== m.previousValue && (null === (c = b[t.OPERATION.DELETE]) || void 0 === c || c.forEach((function(t) {
                                var e;
                                return t(m.previousValue, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                            }
                            ))),
                            null === (u = b[t.OPERATION.ADD]) || void 0 === u || u.forEach((function(t) {
                                var e;
                                return t(m.value, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                            }
                            ))),
                            m.value !== m.previousValue && (null === (h = b[t.OPERATION.REPLACE]) || void 0 === h || h.forEach((function(t) {
                                var e;
                                return t(m.value, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                            }
                            )));
                        d.add(g)
                    }, m = 0; m < n.length; m++)
                        p(m)
                }
                ,
                e._definition = w.create(),
                e
            }();
            function Ct(t) {
                for (var e = [t.$changes], n = 1, r = {}, i = r, s = function(t) {
                    var n = e[t];
                    n.changes.forEach((function(t) {
                        var e = n.ref
                          , r = t.index
                          , s = e._definition ? e._definition.fieldsByIndex[r] : e.$indexes.get(r);
                        i[s] = n.getValue(r)
                    }
                    ))
                }, o = 0; o < n; o++)
                    s(o);
                return r
            }
            var Pt = {
                context: new E
            }
              , Ot = function(t) {
                function e() {
                    return null !== t && t.apply(this, arguments) || this
                }
                return n(e, t),
                r([A("string", Pt)], e.prototype, "name", void 0),
                r([A("string", Pt)], e.prototype, "type", void 0),
                r([A("number", Pt)], e.prototype, "referencedType", void 0),
                e
            }(Mt)
              , Nt = function(t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.fields = new p,
                    e
                }
                return n(e, t),
                r([A("number", Pt)], e.prototype, "id", void 0),
                r([A([Ot], Pt)], e.prototype, "fields", void 0),
                e
            }(Mt)
              , Rt = function(t) {
                function e() {
                    var e = null !== t && t.apply(this, arguments) || this;
                    return e.types = new p,
                    e
                }
                return n(e, t),
                e.encode = function(t) {
                    var n = t.constructor
                      , r = new e;
                    r.rootType = n._typeid;
                    var i = function(t, e) {
                        for (var n in e) {
                            var i = new Ot;
                            i.name = n;
                            var s = void 0;
                            if ("string" == typeof e[n])
                                s = e[n];
                            else {
                                var o = e[n]
                                  , a = void 0;
                                Mt.is(o) ? (s = "ref",
                                a = e[n]) : "string" == typeof o[s = Object.keys(o)[0]] ? s += ":" + o[s] : a = o[s],
                                i.referencedType = a ? a._typeid : -1
                            }
                            i.type = s,
                            t.fields.push(i)
                        }
                        r.types.push(t)
                    }
                      , s = n._context.types;
                    for (var o in s) {
                        var a = new Nt;
                        a.id = Number(o),
                        i(a, s[o]._definition.schema)
                    }
                    return r.encodeAll()
                }
                ,
                e.decode = function(t, r) {
                    var i = new E
                      , s = new e;
                    s.decode(t, r);
                    var o = s.types.reduce((function(t, e) {
                        var r = function(t) {
                            function e() {
                                return null !== t && t.apply(this, arguments) || this
                            }
                            return n(e, t),
                            e
                        }(Mt)
                          , s = e.id;
                        return t[s] = r,
                        i.add(r, s),
                        t
                    }
                    ), {});
                    s.types.forEach((function(t) {
                        var e = o[t.id];
                        t.fields.forEach((function(t) {
                            var n;
                            if (void 0 !== t.referencedType) {
                                var r = t.type
                                  , s = o[t.referencedType];
                                if (!s) {
                                    var a = t.type.split(":");
                                    r = a[0],
                                    s = a[1]
                                }
                                "ref" === r ? A(s, {
                                    context: i
                                })(e.prototype, t.name) : A(((n = {})[r] = s,
                                n), {
                                    context: i
                                })(e.prototype, t.name)
                            } else
                                A(t.type, {
                                    context: i
                                })(e.prototype, t.name)
                        }
                        ))
                    }
                    ));
                    var a = o[s.rootType]
                      , l = new a;
                    for (var c in a._definition.schema) {
                        var u = a._definition.schema[c];
                        "string" != typeof u && (l[c] = "function" == typeof u ? new u : new (v(Object.keys(u)[0]).constructor))
                    }
                    return l
                }
                ,
                r([A([Nt], Pt)], e.prototype, "types", void 0),
                r([A("number", Pt)], e.prototype, "rootType", void 0),
                e
            }(Mt);
            b("map", {
                constructor: g
            }),
            b("array", {
                constructor: p
            }),
            b("set", {
                constructor: xt
            }),
            b("collection", {
                constructor: wt
            }),
            t.ArraySchema = p,
            t.CollectionSchema = wt,
            t.Context = E,
            t.MapSchema = g,
            t.Reflection = Rt,
            t.ReflectionField = Ot,
            t.ReflectionType = Nt,
            t.Schema = Mt,
            t.SchemaDefinition = w,
            t.SetSchema = xt,
            t.decode = vt,
            t.defineTypes = I,
            t.deprecated = k,
            t.dumpChanges = Ct,
            t.encode = q,
            t.filter = S,
            t.filterChildren = T,
            t.hasFilter = x,
            t.registerType = b,
            t.type = A,
            Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }
        ))
    }
    )), G = function() {
        function e(t, e) {
            var n = this;
            this.onStateChange = V(),
            this.onError = V(),
            this.onLeave = V(),
            this.onJoin = V(),
            this.hasJoined = !1,
            this.onMessageHandlers = U(),
            this.roomId = null,
            this.name = t,
            e && (this.serializer = new (j("schema")),
            this.rootSchema = e,
            this.serializer.state = new e),
            this.onError((function(t, e) {
                return console.warn("colyseus.js - onError => (".concat(t, ") ").concat(e))
            }
            )),
            this.onLeave((function() {
                return n.removeAllListeners()
            }
            ))
        }
        return Object.defineProperty(e.prototype, "id", {
            get: function() {
                return this.roomId
            },
            enumerable: !1,
            configurable: !0
        }),
        e.prototype.connect = function(t, n, r) {
            void 0 === r && (r = this);
            var i = new R;
            r.connection = i,
            i.events.onmessage = e.prototype.onMessageCallback.bind(r),
            i.events.onclose = function(t) {
                if (!r.hasJoined)
                    return console.warn("Room connection was closed unexpectedly (".concat(t.code, "): ").concat(t.reason)),
                    void r.onError.invoke(t.code, t.reason);
                t.code === c.DEVMODE_RESTART && n ? n() : (r.onLeave.invoke(t.code),
                r.destroy())
            }
            ,
            i.events.onerror = function(t) {
                console.warn("Room, onError (".concat(t.code, "): ").concat(t.reason)),
                r.onError.invoke(t.code, t.reason)
            }
            ,
            i.connect(t)
        }
        ,
        e.prototype.leave = function(e) {
            var n = this;
            return void 0 === e && (e = !0),
            new Promise((function(r) {
                n.onLeave((function(t) {
                    return r(t)
                }
                )),
                n.connection ? e ? n.connection.send([t.Protocol.LEAVE_ROOM]) : n.connection.close() : n.onLeave.invoke(c.CONSENTED)
            }
            ))
        }
        ,
        e.prototype.onMessage = function(t, e) {
            return this.onMessageHandlers.on(this.getMessageHandlerKey(t), e)
        }
        ,
        e.prototype.send = function(e, n) {
            var r, i = [t.Protocol.ROOM_DATA];
            if ("string" == typeof e ? $.encode.string(i, e) : $.encode.number(i, e),
            void 0 !== n) {
                var s = I(n);
                (r = new Uint8Array(i.length + s.byteLength)).set(new Uint8Array(i), 0),
                r.set(new Uint8Array(s), i.length)
            } else
                r = new Uint8Array(i);
            this.connection.send(r.buffer)
        }
        ,
        e.prototype.sendBytes = function(e, n) {
            var r, i = [t.Protocol.ROOM_DATA_BYTES];
            "string" == typeof e ? $.encode.string(i, e) : $.encode.number(i, e),
            (r = new Uint8Array(i.length + (n.byteLength || n.length))).set(new Uint8Array(i), 0),
            r.set(new Uint8Array(n), i.length),
            this.connection.send(r.buffer)
        }
        ,
        Object.defineProperty(e.prototype, "state", {
            get: function() {
                return this.serializer.getState()
            },
            enumerable: !1,
            configurable: !0
        }),
        e.prototype.removeAllListeners = function() {
            this.onJoin.clear(),
            this.onStateChange.clear(),
            this.onError.clear(),
            this.onLeave.clear(),
            this.onMessageHandlers.events = {}
        }
        ,
        e.prototype.onMessageCallback = function(e) {
            var n = Array.from(new Uint8Array(e.data))
              , r = n[0];
            if (r === t.Protocol.JOIN_ROOM) {
                var i = 1
                  , s = D(n, i);
                if (i += B(s),
                this.serializerId = D(n, i),
                i += B(this.serializerId),
                !this.serializer) {
                    var o = j(this.serializerId);
                    this.serializer = new o
                }
                n.length > i && this.serializer.handshake && this.serializer.handshake(n, {
                    offset: i
                }),
                this.reconnectionToken = "".concat(this.roomId, ":").concat(s),
                this.hasJoined = !0,
                this.onJoin.invoke(),
                this.connection.send([t.Protocol.JOIN_ROOM])
            } else if (r === t.Protocol.ERROR) {
                var a = {
                    offset: 1
                }
                  , l = $.decode.number(n, a)
                  , c = $.decode.string(n, a);
                this.onError.invoke(l, c)
            } else if (r === t.Protocol.LEAVE_ROOM)
                this.leave();
            else if (r === t.Protocol.ROOM_DATA_SCHEMA) {
                var u = {
                    offset: 1
                };
                (c = new (d = this.serializer.getState().constructor._context.get($.decode.number(n, u)))).decode(n, u),
                this.dispatchMessage(d, c)
            } else if (r === t.Protocol.ROOM_STATE)
                n.shift(),
                this.setState(n);
            else if (r === t.Protocol.ROOM_STATE_PATCH)
                n.shift(),
                this.patch(n);
            else if (r === t.Protocol.ROOM_DATA) {
                var h = {
                    offset: 1
                }
                  , d = $.decode.stringCheck(n, h) ? $.decode.string(n, h) : $.decode.number(n, h);
                c = n.length > h.offset ? E(e.data, h.offset) : void 0,
                this.dispatchMessage(d, c)
            } else if (r === t.Protocol.ROOM_DATA_BYTES) {
                var f = {
                    offset: 1
                };
                d = $.decode.stringCheck(n, f) ? $.decode.string(n, f) : $.decode.number(n, f),
                this.dispatchMessage(d, new Uint8Array(n.slice(f.offset)))
            }
        }
        ,
        e.prototype.setState = function(t) {
            this.serializer.setState(t),
            this.onStateChange.invoke(this.serializer.getState())
        }
        ,
        e.prototype.patch = function(t) {
            this.serializer.patch(t),
            this.onStateChange.invoke(this.serializer.getState())
        }
        ,
        e.prototype.dispatchMessage = function(t, e) {
            var n = this.getMessageHandlerKey(t);
            this.onMessageHandlers.events[n] ? this.onMessageHandlers.emit(n, e) : this.onMessageHandlers.events["*"] ? this.onMessageHandlers.emit("*", t, e) : console.warn("colyseus.js: onMessage() not registered for type '".concat(t, "'."))
        }
        ,
        e.prototype.destroy = function() {
            this.serializer && this.serializer.teardown()
        }
        ,
        e.prototype.getMessageHandlerKey = function(t) {
            switch (typeof t) {
            case "function":
                return "$".concat(t._typeid);
            case "string":
                return t;
            case "number":
                return "i".concat(t);
            default:
                throw new Error("invalid message type.")
            }
        }
        ,
        e
    }(), X = function(t) {
        function e(n, r) {
            var i = t.call(this, n) || this;
            return i.code = r,
            Object.setPrototypeOf(i, e.prototype),
            i
        }
        return i(e, t),
        e
    }(Error), q = "undefined" != typeof window && void 0 !== (null === (Y = null === window || void 0 === window ? void 0 : window.location) || void 0 === Y ? void 0 : Y.hostname) ? "".concat(window.location.protocol.replace("http", "ws"), "//").concat(window.location.hostname).concat(window.location.port && ":".concat(window.location.port)) : "ws://127.0.0.1:2567", K = function() {
        function t(t) {
            if (void 0 === t && (t = q),
            "string" == typeof t) {
                var e = new URL(t)
                  , n = "https:" === e.protocol || "wss:" === e.protocol
                  , r = Number(e.port || (n ? 443 : 80));
                this.settings = {
                    hostname: e.hostname,
                    pathname: "/" !== e.pathname ? e.pathname : "",
                    port: r,
                    secure: n
                }
            } else
                void 0 === t.port && (t.port = t.secure ? 443 : 80),
                void 0 === t.pathname && (t.pathname = ""),
                this.settings = t
        }
        return t.prototype.joinOrCreate = function(t, e, n) {
            return void 0 === e && (e = {}),
            s(this, void 0, void 0, (function() {
                return o(this, (function(r) {
                    switch (r.label) {
                    case 0:
                        return [4, this.createMatchMakeRequest("joinOrCreate", t, e, n)];
                    case 1:
                        return [2, r.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.create = function(t, e, n) {
            return void 0 === e && (e = {}),
            s(this, void 0, void 0, (function() {
                return o(this, (function(r) {
                    switch (r.label) {
                    case 0:
                        return [4, this.createMatchMakeRequest("create", t, e, n)];
                    case 1:
                        return [2, r.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.join = function(t, e, n) {
            return void 0 === e && (e = {}),
            s(this, void 0, void 0, (function() {
                return o(this, (function(r) {
                    switch (r.label) {
                    case 0:
                        return [4, this.createMatchMakeRequest("join", t, e, n)];
                    case 1:
                        return [2, r.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.joinById = function(t, e, n) {
            return void 0 === e && (e = {}),
            s(this, void 0, void 0, (function() {
                return o(this, (function(r) {
                    switch (r.label) {
                    case 0:
                        return [4, this.createMatchMakeRequest("joinById", t, e, n)];
                    case 1:
                        return [2, r.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.reconnect = function(t, e) {
            return s(this, void 0, void 0, (function() {
                var n, r, i;
                return o(this, (function(s) {
                    switch (s.label) {
                    case 0:
                        if ("string" == typeof t && "string" == typeof e)
                            throw new Error("DEPRECATED: .reconnect() now only accepts 'reconnectionToken' as argument.\nYou can get this token from previously connected `room.reconnectionToken`");
                        return n = t.split(":"),
                        r = n[0],
                        i = n[1],
                        [4, this.createMatchMakeRequest("reconnect", r, {
                            reconnectionToken: i
                        }, e)];
                    case 1:
                        return [2, s.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.getAvailableRooms = function(t) {
            return void 0 === t && (t = ""),
            s(this, void 0, void 0, (function() {
                return o(this, (function(e) {
                    switch (e.label) {
                    case 0:
                        return [4, m(this.getHttpEndpoint("".concat(t)), {
                            headers: {
                                Accept: "application/json"
                            }
                        })];
                    case 1:
                        return [2, e.sent().data]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.consumeSeatReservation = function(t, e, n) {
            return s(this, void 0, void 0, (function() {
                var r, i, a, l = this;
                return o(this, (function(c) {
                    return (r = this.createRoom(t.room.name, e)).roomId = t.room.roomId,
                    r.sessionId = t.sessionId,
                    i = {
                        sessionId: r.sessionId
                    },
                    t.reconnectionToken && (i.reconnectionToken = t.reconnectionToken),
                    a = n || r,
                    r.connect(this.buildEndpoint(t.room, i), t.devMode && function() {
                        return s(l, void 0, void 0, (function() {
                            var n, i, l, c = this;
                            return o(this, (function(u) {
                                return console.info("[Colyseus devMode]: ".concat(String.fromCodePoint(128260), " Re-establishing connection with room id '").concat(r.roomId, "'...")),
                                n = 0,
                                i = 8,
                                l = function() {
                                    return s(c, void 0, void 0, (function() {
                                        return o(this, (function(s) {
                                            switch (s.label) {
                                            case 0:
                                                n++,
                                                s.label = 1;
                                            case 1:
                                                return s.trys.push([1, 3, , 4]),
                                                [4, this.consumeSeatReservation(t, e, a)];
                                            case 2:
                                                return s.sent(),
                                                console.info("[Colyseus devMode]: ".concat(String.fromCodePoint(9989), " Successfully re-established connection with room '").concat(r.roomId, "'")),
                                                [3, 4];
                                            case 3:
                                                return s.sent(),
                                                n < i ? (console.info("[Colyseus devMode]: ".concat(String.fromCodePoint(128260), " retrying... (").concat(n, " out of ").concat(i, ")")),
                                                setTimeout(l, 2e3)) : console.info("[Colyseus devMode]: ".concat(String.fromCodePoint(10060), " Failed to reconnect. Is your server running? Please check server logs.")),
                                                [3, 4];
                                            case 4:
                                                return [2]
                                            }
                                        }
                                        ))
                                    }
                                    ))
                                }
                                ,
                                setTimeout(l, 2e3),
                                [2]
                            }
                            ))
                        }
                        ))
                    }
                    , a),
                    [2, new Promise((function(t, e) {
                        var n = function(t, n) {
                            return e(new v(t,n))
                        };
                        a.onError.once(n),
                        a.onJoin.once((function() {
                            a.onError.remove(n),
                            t(a)
                        }
                        ))
                    }
                    ))]
                }
                ))
            }
            ))
        }
        ,
        t.prototype.createMatchMakeRequest = function(t, e, n, r) {
            return void 0 === n && (n = {}),
            s(this, void 0, void 0, (function() {
                var i;
                return o(this, (function(s) {
                    switch (s.label) {
                    case 0:
                        return [4, g(this.getHttpEndpoint("".concat(t, "/").concat(e)), {
                            headers: {
                                Accept: "application/json",
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify(n)
                        })];
                    case 1:
                        if ((i = s.sent().data).error)
                            throw new X(i.error,i.code);
                        return "reconnect" === t && (i.reconnectionToken = n.reconnectionToken),
                        [4, this.consumeSeatReservation(i, r)];
                    case 2:
                        return [2, s.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.createRoom = function(t, e) {
            return new G(t,e)
        }
        ,
        t.prototype.buildEndpoint = function(t, e) {
            void 0 === e && (e = {});
            var n = [];
            for (var r in e)
                e.hasOwnProperty(r) && n.push("".concat(r, "=").concat(e[r]));
            var i = this.settings.secure ? "wss://" : "ws://";
            return t.publicAddress ? i += "".concat(t.publicAddress) : i += "".concat(this.settings.hostname).concat(this.getEndpointPort()).concat(this.settings.pathname),
            "".concat(i, "/").concat(t.processId, "/").concat(t.roomId, "?").concat(n.join("&"))
        }
        ,
        t.prototype.getHttpEndpoint = function(t) {
            return void 0 === t && (t = ""),
            "".concat(this.settings.secure ? "https" : "http", "://").concat(this.settings.hostname).concat(this.getEndpointPort()).concat(this.settings.pathname, "/matchmake/").concat(t)
        }
        ,
        t.prototype.getEndpointPort = function() {
            return 80 !== this.settings.port && 443 !== this.settings.port ? ":".concat(this.settings.port) : ""
        }
        ,
        t
    }();
    function Q() {
        return H || (H = "undefined" != typeof cc && cc.sys && cc.sys.localStorage ? cc.sys.localStorage : "undefined" != typeof window && window.localStorage ? window.localStorage : {
            cache: {},
            setItem: function(t, e) {
                this.cache[t] = e
            },
            getItem: function(t) {
                this.cache[t]
            },
            removeItem: function(t) {
                delete this.cache[t]
            }
        }),
        H
    }
    function Z(t, e) {
        Q().setItem(t, e)
    }
    function J(t) {
        Q().removeItem(t)
    }
    function tt(t, e) {
        var n = Q().getItem(t);
        "undefined" != typeof Promise && n instanceof Promise ? n.then((function(t) {
            return e(t)
        }
        )) : e(n)
    }
    var et, nt = "colyseus-auth-token";
    t.Platform = void 0,
    (et = t.Platform || (t.Platform = {})).ios = "ios",
    et.android = "android";
    var rt = function() {
        function t(t) {
            var e = this;
            this._id = void 0,
            this.username = void 0,
            this.displayName = void 0,
            this.avatarUrl = void 0,
            this.isAnonymous = void 0,
            this.email = void 0,
            this.lang = void 0,
            this.location = void 0,
            this.timezone = void 0,
            this.metadata = void 0,
            this.devices = void 0,
            this.facebookId = void 0,
            this.twitterId = void 0,
            this.googleId = void 0,
            this.gameCenterId = void 0,
            this.steamId = void 0,
            this.friendIds = void 0,
            this.blockedUserIds = void 0,
            this.createdAt = void 0,
            this.updatedAt = void 0,
            this.token = void 0,
            this.endpoint = t.replace("ws", "http"),
            tt(nt, (function(t) {
                return e.token = t
            }
            ))
        }
        return Object.defineProperty(t.prototype, "hasToken", {
            get: function() {
                return !!this.token
            },
            enumerable: !1,
            configurable: !0
        }),
        t.prototype.login = function(t) {
            return void 0 === t && (t = {}),
            s(this, void 0, void 0, (function() {
                var e, n, r;
                return o(this, (function(i) {
                    switch (i.label) {
                    case 0:
                        return e = Object.assign({}, t),
                        this.hasToken && (e.token = this.token),
                        [4, this.request("post", "/auth", e)];
                    case 1:
                        for (r in n = i.sent(),
                        this.token = n.token,
                        Z(nt, this.token),
                        n)
                            this.hasOwnProperty(r) && (this[r] = n[r]);
                        return this.registerPingService(),
                        [2, this]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.save = function() {
            return s(this, void 0, void 0, (function() {
                return o(this, (function(t) {
                    switch (t.label) {
                    case 0:
                        return [4, this.request("put", "/auth", {}, {
                            username: this.username,
                            displayName: this.displayName,
                            avatarUrl: this.avatarUrl,
                            lang: this.lang,
                            location: this.location,
                            timezone: this.timezone
                        })];
                    case 1:
                        return t.sent(),
                        [2, this]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.getFriends = function() {
            return s(this, void 0, void 0, (function() {
                return o(this, (function(t) {
                    switch (t.label) {
                    case 0:
                        return [4, this.request("get", "/friends/all")];
                    case 1:
                        return [2, t.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.getOnlineFriends = function() {
            return s(this, void 0, void 0, (function() {
                return o(this, (function(t) {
                    switch (t.label) {
                    case 0:
                        return [4, this.request("get", "/friends/online")];
                    case 1:
                        return [2, t.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.getFriendRequests = function() {
            return s(this, void 0, void 0, (function() {
                return o(this, (function(t) {
                    switch (t.label) {
                    case 0:
                        return [4, this.request("get", "/friends/requests")];
                    case 1:
                        return [2, t.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.sendFriendRequest = function(t) {
            return s(this, void 0, void 0, (function() {
                return o(this, (function(e) {
                    switch (e.label) {
                    case 0:
                        return [4, this.request("post", "/friends/requests", {
                            userId: t
                        })];
                    case 1:
                        return [2, e.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.acceptFriendRequest = function(t) {
            return s(this, void 0, void 0, (function() {
                return o(this, (function(e) {
                    switch (e.label) {
                    case 0:
                        return [4, this.request("put", "/friends/requests", {
                            userId: t
                        })];
                    case 1:
                        return [2, e.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.declineFriendRequest = function(t) {
            return s(this, void 0, void 0, (function() {
                return o(this, (function(e) {
                    switch (e.label) {
                    case 0:
                        return [4, this.request("del", "/friends/requests", {
                            userId: t
                        })];
                    case 1:
                        return [2, e.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.blockUser = function(t) {
            return s(this, void 0, void 0, (function() {
                return o(this, (function(e) {
                    switch (e.label) {
                    case 0:
                        return [4, this.request("post", "/friends/block", {
                            userId: t
                        })];
                    case 1:
                        return [2, e.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.unblockUser = function(t) {
            return s(this, void 0, void 0, (function() {
                return o(this, (function(e) {
                    switch (e.label) {
                    case 0:
                        return [4, this.request("put", "/friends/block", {
                            userId: t
                        })];
                    case 1:
                        return [2, e.sent()]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.request = function(t, e, n, r, i) {
            return void 0 === n && (n = {}),
            void 0 === i && (i = {}),
            s(this, void 0, void 0, (function() {
                var s, a, l, c;
                return o(this, (function(o) {
                    switch (o.label) {
                    case 0:
                        for (a in i.Accept = "application/json",
                        this.hasToken && (i.Authorization = "Bearer " + this.token),
                        s = [],
                        n)
                            s.push("".concat(a, "=").concat(n[a]));
                        return l = s.length > 0 ? "?".concat(s.join("&")) : "",
                        c = {
                            headers: i
                        },
                        r && (c.body = r),
                        [4, b[t]("".concat(this.endpoint).concat(e).concat(l), c)];
                    case 1:
                        return [2, o.sent().data]
                    }
                }
                ))
            }
            ))
        }
        ,
        t.prototype.logout = function() {
            this.token = void 0,
            J(nt),
            this.unregisterPingService()
        }
        ,
        t.prototype.registerPingService = function(t) {
            var e = this;
            void 0 === t && (t = 15e3),
            this.unregisterPingService(),
            this.keepOnlineInterval = setInterval((function() {
                return e.request("get", "/auth")
            }
            ), t)
        }
        ,
        t.prototype.unregisterPingService = function() {
            clearInterval(this.keepOnlineInterval)
        }
        ,
        t
    }()
      , it = function() {
        function t() {}
        return t.prototype.setState = function(t) {
            return this.state.decode(t)
        }
        ,
        t.prototype.getState = function() {
            return this.state
        }
        ,
        t.prototype.patch = function(t) {
            return this.state.decode(t)
        }
        ,
        t.prototype.teardown = function() {
            var t, e;
            null === (e = null === (t = this.state) || void 0 === t ? void 0 : t.$changes) || void 0 === e || e.root.clearRefs()
        }
        ,
        t.prototype.handshake = function(t, e) {
            this.state ? (new $.Reflection).decode(t, e) : this.state = $.Reflection.decode(t, e)
        }
        ,
        t
    }()
      , st = function() {
        function t() {}
        return t.prototype.setState = function(t) {}
        ,
        t.prototype.getState = function() {
            return null
        }
        ,
        t.prototype.patch = function(t) {}
        ,
        t.prototype.teardown = function() {}
        ,
        t.prototype.handshake = function(t) {}
        ,
        t
    }();
    F("schema", it),
    F("none", st),
    t.Auth = rt,
    t.Client = K,
    t.Room = G,
    t.SchemaSerializer = it,
    t.registerSerializer = F,
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}(ez);
function nz(t, e, n, r) {
    var i, s = arguments.length, o = s < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        o = Reflect.decorate(t, e, n, r);
    else
        for (var a = t.length - 1; a >= 0; a--)
            (i = t[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(e, n, o) : i(e, n)) || o);
    return s > 3 && o && Object.defineProperty(e, n, o),
    o
}
Object.create;
Object.create;
var rz = {};
!function(t) {
    var e = function(t, n) {
        return e = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(t, e) {
            t.__proto__ = e
        }
        || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }
        ,
        e(t, n)
    };
    function n(t, n) {
        if ("function" != typeof n && null !== n)
            throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        function r() {
            this.constructor = t
        }
        e(t, n),
        t.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype,
        new r)
    }
    function r(t, e, n, r) {
        var i, s = arguments.length, o = s < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o = Reflect.decorate(t, e, n, r);
        else
            for (var a = t.length - 1; a >= 0; a--)
                (i = t[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(e, n, o) : i(e, n)) || o);
        return s > 3 && o && Object.defineProperty(e, n, o),
        o
    }
    function i(t, e, n) {
        if (n || 2 === arguments.length)
            for (var r, i = 0, s = e.length; i < s; i++)
                !r && i in e || (r || (r = Array.prototype.slice.call(e, 0, i)),
                r[i] = e[i]);
        return t.concat(r || Array.prototype.slice.call(e))
    }
    var s, o = 255, a = 213;
    t.OPERATION = void 0,
    (s = t.OPERATION || (t.OPERATION = {}))[s.ADD = 128] = "ADD",
    s[s.REPLACE = 0] = "REPLACE",
    s[s.DELETE = 64] = "DELETE",
    s[s.DELETE_AND_ADD = 192] = "DELETE_AND_ADD",
    s[s.TOUCH = 1] = "TOUCH",
    s[s.CLEAR = 10] = "CLEAR";
    var l = function() {
        function e(t, e, n) {
            this.changed = !1,
            this.changes = new Map,
            this.allChanges = new Set,
            this.caches = {},
            this.currentCustomOperation = 0,
            this.ref = t,
            this.setParent(e, n)
        }
        return e.prototype.setParent = function(t, e, n) {
            var r = this;
            if (this.indexes || (this.indexes = this.ref instanceof Mt ? this.ref._definition.indexes : {}),
            this.parent = t,
            this.parentIndex = n,
            e)
                if (this.root = e,
                this.ref instanceof Mt) {
                    var i = this.ref._definition;
                    for (var s in i.schema) {
                        var o = this.ref[s];
                        if (o && o.$changes) {
                            var a = i.indexes[s];
                            o.$changes.setParent(this.ref, e, a)
                        }
                    }
                } else
                    "object" == typeof this.ref && this.ref.forEach((function(t, e) {
                        if (t instanceof Mt) {
                            var n = t.$changes
                              , i = r.ref.$changes.indexes[e];
                            n.setParent(r.ref, r.root, i)
                        }
                    }
                    ))
        }
        ,
        e.prototype.operation = function(t) {
            this.changes.set(--this.currentCustomOperation, t)
        }
        ,
        e.prototype.change = function(e, n) {
            void 0 === n && (n = t.OPERATION.ADD);
            var r = "number" == typeof e ? e : this.indexes[e];
            this.assertValidIndex(r, e);
            var i = this.changes.get(r);
            i && i.op !== t.OPERATION.DELETE && i.op !== t.OPERATION.TOUCH || this.changes.set(r, {
                op: i && i.op === t.OPERATION.DELETE ? t.OPERATION.DELETE_AND_ADD : n,
                index: r
            }),
            this.allChanges.add(r),
            this.changed = !0,
            this.touchParents()
        }
        ,
        e.prototype.touch = function(e) {
            var n = "number" == typeof e ? e : this.indexes[e];
            this.assertValidIndex(n, e),
            this.changes.has(n) || this.changes.set(n, {
                op: t.OPERATION.TOUCH,
                index: n
            }),
            this.allChanges.add(n),
            this.touchParents()
        }
        ,
        e.prototype.touchParents = function() {
            this.parent && this.parent.$changes.touch(this.parentIndex)
        }
        ,
        e.prototype.getType = function(t) {
            if (this.ref._definition)
                return (e = this.ref._definition).schema[e.fieldsByIndex[t]];
            var e, n = (e = this.parent._definition).schema[e.fieldsByIndex[this.parentIndex]];
            return Object.values(n)[0]
        }
        ,
        e.prototype.getChildrenFilter = function() {
            var t = this.parent._definition.childFilters;
            return t && t[this.parentIndex]
        }
        ,
        e.prototype.getValue = function(t) {
            return this.ref.getByIndex(t)
        }
        ,
        e.prototype.delete = function(e) {
            var n = "number" == typeof e ? e : this.indexes[e];
            if (void 0 !== n) {
                var r = this.getValue(n);
                this.changes.set(n, {
                    op: t.OPERATION.DELETE,
                    index: n
                }),
                this.allChanges.delete(n),
                delete this.caches[n],
                r && r.$changes && (r.$changes.parent = void 0),
                this.changed = !0,
                this.touchParents()
            } else
                console.warn("@colyseus/schema ".concat(this.ref.constructor.name, ": trying to delete non-existing index: ").concat(e, " (").concat(n, ")"))
        }
        ,
        e.prototype.discard = function(e, n) {
            var r = this;
            void 0 === e && (e = !1),
            void 0 === n && (n = !1),
            this.ref instanceof Mt || this.changes.forEach((function(e) {
                if (e.op === t.OPERATION.DELETE) {
                    var n = r.ref.getIndex(e.index);
                    delete r.indexes[n]
                }
            }
            )),
            this.changes.clear(),
            this.changed = e,
            n && this.allChanges.clear(),
            this.currentCustomOperation = 0
        }
        ,
        e.prototype.discardAll = function() {
            var t = this;
            this.changes.forEach((function(e) {
                var n = t.getValue(e.index);
                n && n.$changes && n.$changes.discardAll()
            }
            )),
            this.discard()
        }
        ,
        e.prototype.cache = function(t, e) {
            this.caches[t] = e
        }
        ,
        e.prototype.clone = function() {
            return new e(this.ref,this.parent,this.root)
        }
        ,
        e.prototype.ensureRefId = function() {
            void 0 === this.refId && (this.refId = this.root.getNextUniqueId())
        }
        ,
        e.prototype.assertValidIndex = function(t, e) {
            if (void 0 === t)
                throw new Error('ChangeTree: missing index for field "'.concat(e, '"'))
        }
        ,
        e
    }();
    function c(t, e, n, r) {
        return t[e] || (t[e] = []),
        t[e].push(n),
        null == r || r.forEach((function(t, e) {
            return n(t, e)
        }
        )),
        function() {
            return h(t[e], t[e].indexOf(n))
        }
    }
    function u(e) {
        var n = this
          , r = "string" != typeof this.$changes.getType();
        this.$items.forEach((function(i, s) {
            e.push({
                refId: n.$changes.refId,
                op: t.OPERATION.DELETE,
                field: s,
                value: void 0,
                previousValue: i
            }),
            r && n.$changes.root.removeRef(i.$changes.refId)
        }
        ))
    }
    function h(t, e) {
        if (-1 === e || e >= t.length)
            return !1;
        for (var n = t.length - 1, r = e; r < n; r++)
            t[r] = t[r + 1];
        return t.length = n,
        !0
    }
    var d = function(t, e) {
        var n = t.toString()
          , r = e.toString();
        return n < r ? -1 : n > r ? 1 : 0
    };
    function f(t) {
        return t.$proxy = !0,
        t = new Proxy(t,{
            get: function(t, e) {
                return "symbol" == typeof e || isNaN(e) ? t[e] : t.at(e)
            },
            set: function(t, e, n) {
                if ("symbol" == typeof e || isNaN(e))
                    t[e] = n;
                else {
                    var r = Array.from(t.$items.keys())
                      , i = parseInt(r[e] || e);
                    null == n ? t.deleteAt(i) : t.setAt(i, n)
                }
                return !0
            },
            deleteProperty: function(t, e) {
                return "number" == typeof e ? t.deleteAt(e) : delete t[e],
                !0
            }
        }),
        t
    }
    var p = function() {
        function e() {
            for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
            this.$changes = new l(this),
            this.$items = new Map,
            this.$indexes = new Map,
            this.$refId = 0,
            this.push.apply(this, t)
        }
        return e.prototype.onAdd = function(e, n) {
            return void 0 === n && (n = !0),
            c(this.$callbacks || (this.$callbacks = []), t.OPERATION.ADD, e, n ? this.$items : void 0)
        }
        ,
        e.prototype.onRemove = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
        }
        ,
        e.prototype.onChange = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
        }
        ,
        e.is = function(t) {
            return Array.isArray(t) || void 0 !== t.array
        }
        ,
        Object.defineProperty(e.prototype, "length", {
            get: function() {
                return this.$items.size
            },
            set: function(t) {
                0 === t ? this.clear() : this.splice(t, this.length - t)
            },
            enumerable: !1,
            configurable: !0
        }),
        e.prototype.push = function() {
            for (var t, e = this, n = [], r = 0; r < arguments.length; r++)
                n[r] = arguments[r];
            return n.forEach((function(n) {
                t = e.$refId++,
                e.setAt(t, n)
            }
            )),
            t
        }
        ,
        e.prototype.pop = function() {
            var t = Array.from(this.$indexes.values()).pop();
            if (void 0 !== t) {
                this.$changes.delete(t),
                this.$indexes.delete(t);
                var e = this.$items.get(t);
                return this.$items.delete(t),
                e
            }
        }
        ,
        e.prototype.at = function(t) {
            var e = Array.from(this.$items.keys())[t];
            return this.$items.get(e)
        }
        ,
        e.prototype.setAt = function(e, n) {
            var r, i;
            void 0 !== n.$changes && n.$changes.setParent(this, this.$changes.root, e);
            var s = null !== (i = null === (r = this.$changes.indexes[e]) || void 0 === r ? void 0 : r.op) && void 0 !== i ? i : t.OPERATION.ADD;
            this.$changes.indexes[e] = e,
            this.$indexes.set(e, e),
            this.$items.set(e, n),
            this.$changes.change(e, s)
        }
        ,
        e.prototype.deleteAt = function(t) {
            var e = Array.from(this.$items.keys())[t];
            return void 0 !== e && this.$deleteAt(e)
        }
        ,
        e.prototype.$deleteAt = function(t) {
            return this.$changes.delete(t),
            this.$indexes.delete(t),
            this.$items.delete(t)
        }
        ,
        e.prototype.clear = function(e) {
            this.$changes.discard(!0, !0),
            this.$changes.indexes = {},
            this.$indexes.clear(),
            e && u.call(this, e),
            this.$items.clear(),
            this.$changes.operation({
                index: 0,
                op: t.OPERATION.CLEAR
            }),
            this.$changes.touchParents()
        }
        ,
        e.prototype.concat = function() {
            for (var t, n = [], r = 0; r < arguments.length; r++)
                n[r] = arguments[r];
            return new (e.bind.apply(e, i([void 0], (t = Array.from(this.$items.values())).concat.apply(t, n), !1)))
        }
        ,
        e.prototype.join = function(t) {
            return Array.from(this.$items.values()).join(t)
        }
        ,
        e.prototype.reverse = function() {
            var t = this
              , e = Array.from(this.$items.keys());
            return Array.from(this.$items.values()).reverse().forEach((function(n, r) {
                t.setAt(e[r], n)
            }
            )),
            this
        }
        ,
        e.prototype.shift = function() {
            var t = Array.from(this.$items.keys()).shift();
            if (void 0 !== t) {
                var e = this.$items.get(t);
                return this.$deleteAt(t),
                e
            }
        }
        ,
        e.prototype.slice = function(t, n) {
            var r = new e;
            return r.push.apply(r, Array.from(this.$items.values()).slice(t, n)),
            r
        }
        ,
        e.prototype.sort = function(t) {
            var e = this;
            void 0 === t && (t = d);
            var n = Array.from(this.$items.keys());
            return Array.from(this.$items.values()).sort(t).forEach((function(t, r) {
                e.setAt(n[r], t)
            }
            )),
            this
        }
        ,
        e.prototype.splice = function(t, e) {
            void 0 === e && (e = this.length - t);
            for (var n = Array.from(this.$items.keys()), r = [], i = t; i < t + e; i++)
                r.push(this.$items.get(n[i])),
                this.$deleteAt(n[i]);
            return r
        }
        ,
        e.prototype.unshift = function() {
            for (var t = this, e = [], n = 0; n < arguments.length; n++)
                e[n] = arguments[n];
            var r = this.length
              , i = e.length
              , s = Array.from(this.$items.values());
            return e.forEach((function(e, n) {
                t.setAt(n, e)
            }
            )),
            s.forEach((function(e, n) {
                t.setAt(i + n, e)
            }
            )),
            r + i
        }
        ,
        e.prototype.indexOf = function(t, e) {
            return Array.from(this.$items.values()).indexOf(t, e)
        }
        ,
        e.prototype.lastIndexOf = function(t, e) {
            return void 0 === e && (e = this.length - 1),
            Array.from(this.$items.values()).lastIndexOf(t, e)
        }
        ,
        e.prototype.every = function(t, e) {
            return Array.from(this.$items.values()).every(t, e)
        }
        ,
        e.prototype.some = function(t, e) {
            return Array.from(this.$items.values()).some(t, e)
        }
        ,
        e.prototype.forEach = function(t, e) {
            Array.from(this.$items.values()).forEach(t, e)
        }
        ,
        e.prototype.map = function(t, e) {
            return Array.from(this.$items.values()).map(t, e)
        }
        ,
        e.prototype.filter = function(t, e) {
            return Array.from(this.$items.values()).filter(t, e)
        }
        ,
        e.prototype.reduce = function(t, e) {
            return Array.prototype.reduce.apply(Array.from(this.$items.values()), arguments)
        }
        ,
        e.prototype.reduceRight = function(t, e) {
            return Array.prototype.reduceRight.apply(Array.from(this.$items.values()), arguments)
        }
        ,
        e.prototype.find = function(t, e) {
            return Array.from(this.$items.values()).find(t, e)
        }
        ,
        e.prototype.findIndex = function(t, e) {
            return Array.from(this.$items.values()).findIndex(t, e)
        }
        ,
        e.prototype.fill = function(t, e, n) {
            throw new Error("ArraySchema#fill() not implemented")
        }
        ,
        e.prototype.copyWithin = function(t, e, n) {
            throw new Error("ArraySchema#copyWithin() not implemented")
        }
        ,
        e.prototype.toString = function() {
            return this.$items.toString()
        }
        ,
        e.prototype.toLocaleString = function() {
            return this.$items.toLocaleString()
        }
        ,
        e.prototype[Symbol.iterator] = function() {
            return Array.from(this.$items.values())[Symbol.iterator]()
        }
        ,
        e.prototype.entries = function() {
            return this.$items.entries()
        }
        ,
        e.prototype.keys = function() {
            return this.$items.keys()
        }
        ,
        e.prototype.values = function() {
            return this.$items.values()
        }
        ,
        e.prototype.includes = function(t, e) {
            return Array.from(this.$items.values()).includes(t, e)
        }
        ,
        e.prototype.flatMap = function(t, e) {
            throw new Error("ArraySchema#flatMap() is not supported.")
        }
        ,
        e.prototype.flat = function(t) {
            throw new Error("ArraySchema#flat() is not supported.")
        }
        ,
        e.prototype.findLast = function() {
            var t = Array.from(this.$items.values());
            return t.findLast.apply(t, arguments)
        }
        ,
        e.prototype.findLastIndex = function() {
            var t = Array.from(this.$items.values());
            return t.findLastIndex.apply(t, arguments)
        }
        ,
        e.prototype.setIndex = function(t, e) {
            this.$indexes.set(t, e)
        }
        ,
        e.prototype.getIndex = function(t) {
            return this.$indexes.get(t)
        }
        ,
        e.prototype.getByIndex = function(t) {
            return this.$items.get(this.$indexes.get(t))
        }
        ,
        e.prototype.deleteByIndex = function(t) {
            var e = this.$indexes.get(t);
            this.$items.delete(e),
            this.$indexes.delete(t)
        }
        ,
        e.prototype.toArray = function() {
            return Array.from(this.$items.values())
        }
        ,
        e.prototype.toJSON = function() {
            return this.toArray().map((function(t) {
                return "function" == typeof t.toJSON ? t.toJSON() : t
            }
            ))
        }
        ,
        e.prototype.clone = function(t) {
            return t ? new (e.bind.apply(e, i([void 0], Array.from(this.$items.values()), !1))) : new (e.bind.apply(e, i([void 0], this.map((function(t) {
                return t.$changes ? t.clone() : t
            }
            )), !1)))
        }
        ,
        e
    }();
    function m(t) {
        return t.$proxy = !0,
        t = new Proxy(t,{
            get: function(t, e) {
                return "symbol" != typeof e && void 0 === t[e] ? t.get(e) : t[e]
            },
            set: function(t, e, n) {
                return "symbol" != typeof e && -1 === e.indexOf("$") && "onAdd" !== e && "onRemove" !== e && "onChange" !== e ? t.set(e, n) : t[e] = n,
                !0
            },
            deleteProperty: function(t, e) {
                return t.delete(e),
                !0
            }
        }),
        t
    }
    var g = function() {
        function e(t) {
            var n = this;
            if (this.$changes = new l(this),
            this.$items = new Map,
            this.$indexes = new Map,
            this.$refId = 0,
            t)
                if (t instanceof Map || t instanceof e)
                    t.forEach((function(t, e) {
                        return n.set(e, t)
                    }
                    ));
                else
                    for (var r in t)
                        this.set(r, t[r])
        }
        return e.prototype.onAdd = function(e, n) {
            return void 0 === n && (n = !0),
            c(this.$callbacks || (this.$callbacks = []), t.OPERATION.ADD, e, n ? this.$items : void 0)
        }
        ,
        e.prototype.onRemove = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
        }
        ,
        e.prototype.onChange = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
        }
        ,
        e.is = function(t) {
            return void 0 !== t.map
        }
        ,
        e.prototype[Symbol.iterator] = function() {
            return this.$items[Symbol.iterator]()
        }
        ,
        Object.defineProperty(e.prototype, Symbol.toStringTag, {
            get: function() {
                return this.$items[Symbol.toStringTag]
            },
            enumerable: !1,
            configurable: !0
        }),
        e.prototype.set = function(e, n) {
            if (null == n)
                throw new Error("MapSchema#set('".concat(e, "', ").concat(n, "): trying to set ").concat(n, " value on '").concat(e, "'."));
            var r = void 0 !== this.$changes.indexes[e]
              , i = r ? this.$changes.indexes[e] : this.$refId++
              , s = r ? t.OPERATION.REPLACE : t.OPERATION.ADD
              , o = void 0 !== n.$changes;
            return o && n.$changes.setParent(this, this.$changes.root, i),
            r ? o && this.$items.get(e) !== n && (s = t.OPERATION.ADD) : (this.$changes.indexes[e] = i,
            this.$indexes.set(i, e)),
            this.$items.set(e, n),
            this.$changes.change(e, s),
            this
        }
        ,
        e.prototype.get = function(t) {
            return this.$items.get(t)
        }
        ,
        e.prototype.delete = function(t) {
            return this.$changes.delete(t),
            this.$items.delete(t)
        }
        ,
        e.prototype.clear = function(e) {
            this.$changes.discard(!0, !0),
            this.$changes.indexes = {},
            this.$indexes.clear(),
            e && u.call(this, e),
            this.$items.clear(),
            this.$changes.operation({
                index: 0,
                op: t.OPERATION.CLEAR
            }),
            this.$changes.touchParents()
        }
        ,
        e.prototype.has = function(t) {
            return this.$items.has(t)
        }
        ,
        e.prototype.forEach = function(t) {
            this.$items.forEach(t)
        }
        ,
        e.prototype.entries = function() {
            return this.$items.entries()
        }
        ,
        e.prototype.keys = function() {
            return this.$items.keys()
        }
        ,
        e.prototype.values = function() {
            return this.$items.values()
        }
        ,
        Object.defineProperty(e.prototype, "size", {
            get: function() {
                return this.$items.size
            },
            enumerable: !1,
            configurable: !0
        }),
        e.prototype.setIndex = function(t, e) {
            this.$indexes.set(t, e)
        }
        ,
        e.prototype.getIndex = function(t) {
            return this.$indexes.get(t)
        }
        ,
        e.prototype.getByIndex = function(t) {
            return this.$items.get(this.$indexes.get(t))
        }
        ,
        e.prototype.deleteByIndex = function(t) {
            var e = this.$indexes.get(t);
            this.$items.delete(e),
            this.$indexes.delete(t)
        }
        ,
        e.prototype.toJSON = function() {
            var t = {};
            return this.forEach((function(e, n) {
                t[n] = "function" == typeof e.toJSON ? e.toJSON() : e
            }
            )),
            t
        }
        ,
        e.prototype.clone = function(t) {
            var n;
            return t ? n = Object.assign(new e, this) : (n = new e,
            this.forEach((function(t, e) {
                t.$changes ? n.set(e, t.clone()) : n.set(e, t)
            }
            ))),
            n
        }
        ,
        e
    }()
      , y = {};
    function b(t, e) {
        y[t] = e
    }
    function v(t) {
        return y[t]
    }
    var w = function() {
        function t() {
            this.indexes = {},
            this.fieldsByIndex = {},
            this.deprecated = {},
            this.descriptors = {}
        }
        return t.create = function(e) {
            var n = new t;
            return n.schema = Object.assign({}, e && e.schema || {}),
            n.indexes = Object.assign({}, e && e.indexes || {}),
            n.fieldsByIndex = Object.assign({}, e && e.fieldsByIndex || {}),
            n.descriptors = Object.assign({}, e && e.descriptors || {}),
            n.deprecated = Object.assign({}, e && e.deprecated || {}),
            n
        }
        ,
        t.prototype.addField = function(t, e) {
            var n = this.getNextFieldIndex();
            this.fieldsByIndex[n] = t,
            this.indexes[t] = n,
            this.schema[t] = Array.isArray(e) ? {
                array: e[0]
            } : e
        }
        ,
        t.prototype.hasField = function(t) {
            return void 0 !== this.indexes[t]
        }
        ,
        t.prototype.addFilter = function(t, e) {
            return this.filters || (this.filters = {},
            this.indexesWithFilters = []),
            this.filters[this.indexes[t]] = e,
            this.indexesWithFilters.push(this.indexes[t]),
            !0
        }
        ,
        t.prototype.addChildrenFilter = function(t, e) {
            var n = this.indexes[t]
              , r = this.schema[t];
            if (v(Object.keys(r)[0]))
                return this.childFilters || (this.childFilters = {}),
                this.childFilters[n] = e,
                !0;
            console.warn("@filterChildren: field '".concat(t, "' can't have children. Ignoring filter."))
        }
        ,
        t.prototype.getChildrenFilter = function(t) {
            return this.childFilters && this.childFilters[this.indexes[t]]
        }
        ,
        t.prototype.getNextFieldIndex = function() {
            return Object.keys(this.schema || {}).length
        }
        ,
        t
    }();
    function x(t) {
        return t._context && t._context.useFilters
    }
    var E = function() {
        function t() {
            this.types = {},
            this.schemas = new Map,
            this.useFilters = !1
        }
        return t.prototype.has = function(t) {
            return this.schemas.has(t)
        }
        ,
        t.prototype.get = function(t) {
            return this.types[t]
        }
        ,
        t.prototype.add = function(t, e) {
            void 0 === e && (e = this.schemas.size),
            t._definition = w.create(t._definition),
            t._typeid = e,
            this.types[e] = t,
            this.schemas.set(t, e)
        }
        ,
        t.create = function(e) {
            return void 0 === e && (e = {}),
            function(n) {
                return e.context || (e.context = new t),
                A(n, e)
            }
        }
        ,
        t
    }()
      , _ = new E;
    function A(t, e) {
        return void 0 === e && (e = {}),
        function(n, r) {
            var s = e.context || _
              , o = n.constructor;
            if (o._context = s,
            !t)
                throw new Error("".concat(o.name, ': @type() reference provided for "').concat(r, "\" is undefined. Make sure you don't have any circular dependencies."));
            s.has(o) || s.add(o);
            var a = o._definition;
            if (a.addField(r, t),
            a.descriptors[r]) {
                if (a.deprecated[r])
                    return;
                try {
                    throw new Error("@colyseus/schema: Duplicate '".concat(r, "' definition on '").concat(o.name, "'.\nCheck @type() annotation"))
                } catch (t) {
                    var l = t.stack.split("\n")[4].trim();
                    throw new Error("".concat(t.message, " ").concat(l))
                }
            }
            var c = p.is(t)
              , u = !c && g.is(t);
            if ("string" != typeof t && !Mt.is(t)) {
                var h = Object.values(t)[0];
                "string" == typeof h || s.has(h) || s.add(h)
            }
            if (e.manual)
                a.descriptors[r] = {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                };
            else {
                var d = "_".concat(r);
                a.descriptors[d] = {
                    enumerable: !1,
                    configurable: !1,
                    writable: !0
                },
                a.descriptors[r] = {
                    get: function() {
                        return this[d]
                    },
                    set: function(t) {
                        t !== this[d] && (null != t ? (!c || t instanceof p || (t = new (p.bind.apply(p, i([void 0], t, !1)))),
                        !u || t instanceof g || (t = new g(t)),
                        void 0 === t.$proxy && (u ? t = m(t) : c && (t = f(t))),
                        this.$changes.change(r),
                        t.$changes && t.$changes.setParent(this, this.$changes.root, this._definition.indexes[r])) : this[d] && this.$changes.delete(r),
                        this[d] = t)
                    },
                    enumerable: !0,
                    configurable: !0
                }
            }
        }
    }
    function S(t) {
        return function(e, n) {
            var r = e.constructor;
            r._definition.addFilter(n, t) && (r._context.useFilters = !0)
        }
    }
    function T(t) {
        return function(e, n) {
            var r = e.constructor;
            r._definition.addChildrenFilter(n, t) && (r._context.useFilters = !0)
        }
    }
    function k(t) {
        return void 0 === t && (t = !0),
        function(e, n) {
            var r = e.constructor._definition;
            r.deprecated[n] = !0,
            t && (r.descriptors[n] = {
                get: function() {
                    throw new Error("".concat(n, " is deprecated."))
                },
                set: function(t) {},
                enumerable: !1,
                configurable: !0
            })
        }
    }
    function I(t, e, n) {
        for (var r in void 0 === n && (n = {}),
        n.context || (n.context = t._context || n.context || _),
        e)
            A(e[r], n)(t.prototype, r);
        return t
    }
    function M(t) {
        for (var e = 0, n = 0, r = 0, i = t.length; r < i; r++)
            (e = t.charCodeAt(r)) < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || e >= 57344 ? n += 3 : (r++,
            n += 4);
        return n
    }
    function C(t, e, n) {
        for (var r = 0, i = 0, s = n.length; i < s; i++)
            (r = n.charCodeAt(i)) < 128 ? t[e++] = r : r < 2048 ? (t[e++] = 192 | r >> 6,
            t[e++] = 128 | 63 & r) : r < 55296 || r >= 57344 ? (t[e++] = 224 | r >> 12,
            t[e++] = 128 | r >> 6 & 63,
            t[e++] = 128 | 63 & r) : (i++,
            r = 65536 + ((1023 & r) << 10 | 1023 & n.charCodeAt(i)),
            t[e++] = 240 | r >> 18,
            t[e++] = 128 | r >> 12 & 63,
            t[e++] = 128 | r >> 6 & 63,
            t[e++] = 128 | 63 & r)
    }
    function P(t, e) {
        t.push(255 & e)
    }
    function O(t, e) {
        t.push(255 & e)
    }
    function N(t, e) {
        t.push(255 & e),
        t.push(e >> 8 & 255)
    }
    function R(t, e) {
        t.push(255 & e),
        t.push(e >> 8 & 255)
    }
    function D(t, e) {
        t.push(255 & e),
        t.push(e >> 8 & 255),
        t.push(e >> 16 & 255),
        t.push(e >> 24 & 255)
    }
    function B(t, e) {
        var n = e >> 24
          , r = e >> 16
          , i = e >> 8
          , s = e;
        t.push(255 & s),
        t.push(255 & i),
        t.push(255 & r),
        t.push(255 & n)
    }
    function L(t, e) {
        var n = Math.floor(e / Math.pow(2, 32));
        B(t, e >>> 0),
        B(t, n)
    }
    function F(t, e) {
        var n = e / Math.pow(2, 32) >> 0;
        B(t, e >>> 0),
        B(t, n)
    }
    function j(t, e) {
        Y(t, e)
    }
    function U(t, e) {
        H(t, e)
    }
    var z = new Int32Array(2)
      , V = new Float32Array(z.buffer)
      , W = new Float64Array(z.buffer);
    function Y(t, e) {
        V[0] = e,
        D(t, z[0])
    }
    function H(t, e) {
        W[0] = e,
        D(t, z[0]),
        D(t, z[1])
    }
    function $(t, e) {
        return O(t, e ? 1 : 0)
    }
    function G(t, e) {
        e || (e = "");
        var n = M(e)
          , r = 0;
        if (n < 32)
            t.push(160 | n),
            r = 1;
        else if (n < 256)
            t.push(217),
            O(t, n),
            r = 2;
        else if (n < 65536)
            t.push(218),
            R(t, n),
            r = 3;
        else {
            if (!(n < 4294967296))
                throw new Error("String too long");
            t.push(219),
            B(t, n),
            r = 5
        }
        return C(t, t.length, e),
        r + n
    }
    function X(t, e) {
        return isNaN(e) ? X(t, 0) : isFinite(e) ? e !== (0 | e) ? (t.push(203),
        H(t, e),
        9) : e >= 0 ? e < 128 ? (O(t, e),
        1) : e < 256 ? (t.push(204),
        O(t, e),
        2) : e < 65536 ? (t.push(205),
        R(t, e),
        3) : e < 4294967296 ? (t.push(206),
        B(t, e),
        5) : (t.push(207),
        F(t, e),
        9) : e >= -32 ? (t.push(224 | e + 32),
        1) : e >= -128 ? (t.push(208),
        P(t, e),
        2) : e >= -32768 ? (t.push(209),
        N(t, e),
        3) : e >= -2147483648 ? (t.push(210),
        D(t, e),
        5) : (t.push(211),
        L(t, e),
        9) : X(t, e > 0 ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER)
    }
    var q = Object.freeze({
        __proto__: null,
        utf8Write: C,
        int8: P,
        uint8: O,
        int16: N,
        uint16: R,
        int32: D,
        uint32: B,
        int64: L,
        uint64: F,
        float32: j,
        float64: U,
        writeFloat32: Y,
        writeFloat64: H,
        boolean: $,
        string: G,
        number: X
    });
    function K(t, e, n) {
        for (var r = "", i = 0, s = e, o = e + n; s < o; s++) {
            var a = t[s];
            0 != (128 & a) ? 192 != (224 & a) ? 224 != (240 & a) ? 240 != (248 & a) ? console.error("Invalid byte " + a.toString(16)) : (i = (7 & a) << 18 | (63 & t[++s]) << 12 | (63 & t[++s]) << 6 | (63 & t[++s]) << 0) >= 65536 ? (i -= 65536,
            r += String.fromCharCode(55296 + (i >>> 10), 56320 + (1023 & i))) : r += String.fromCharCode(i) : r += String.fromCharCode((15 & a) << 12 | (63 & t[++s]) << 6 | (63 & t[++s]) << 0) : r += String.fromCharCode((31 & a) << 6 | 63 & t[++s]) : r += String.fromCharCode(a)
        }
        return r
    }
    function Q(t, e) {
        return Z(t, e) << 24 >> 24
    }
    function Z(t, e) {
        return t[e.offset++]
    }
    function J(t, e) {
        return tt(t, e) << 16 >> 16
    }
    function tt(t, e) {
        return t[e.offset++] | t[e.offset++] << 8
    }
    function et(t, e) {
        return t[e.offset++] | t[e.offset++] << 8 | t[e.offset++] << 16 | t[e.offset++] << 24
    }
    function nt(t, e) {
        return et(t, e) >>> 0
    }
    function rt(t, e) {
        return ut(t, e)
    }
    function it(t, e) {
        return ht(t, e)
    }
    function st(t, e) {
        var n = nt(t, e);
        return et(t, e) * Math.pow(2, 32) + n
    }
    function ot(t, e) {
        var n = nt(t, e);
        return nt(t, e) * Math.pow(2, 32) + n
    }
    var at = new Int32Array(2)
      , lt = new Float32Array(at.buffer)
      , ct = new Float64Array(at.buffer);
    function ut(t, e) {
        return at[0] = et(t, e),
        lt[0]
    }
    function ht(t, e) {
        return at[0] = et(t, e),
        at[1] = et(t, e),
        ct[0]
    }
    function dt(t, e) {
        return Z(t, e) > 0
    }
    function ft(t, e) {
        var n, r = t[e.offset++];
        r < 192 ? n = 31 & r : 217 === r ? n = Z(t, e) : 218 === r ? n = tt(t, e) : 219 === r && (n = nt(t, e));
        var i = K(t, e.offset, n);
        return e.offset += n,
        i
    }
    function pt(t, e) {
        var n = t[e.offset];
        return n < 192 && n > 160 || 217 === n || 218 === n || 219 === n
    }
    function mt(t, e) {
        var n = t[e.offset++];
        return n < 128 ? n : 202 === n ? ut(t, e) : 203 === n ? ht(t, e) : 204 === n ? Z(t, e) : 205 === n ? tt(t, e) : 206 === n ? nt(t, e) : 207 === n ? ot(t, e) : 208 === n ? Q(t, e) : 209 === n ? J(t, e) : 210 === n ? et(t, e) : 211 === n ? st(t, e) : n > 223 ? -1 * (255 - n + 1) : void 0
    }
    function gt(t, e) {
        var n = t[e.offset];
        return n < 128 || n >= 202 && n <= 211
    }
    function yt(t, e) {
        return t[e.offset] < 160
    }
    function bt(t, e) {
        return t[e.offset - 1] === o && (t[e.offset] < 128 || t[e.offset] >= 202 && t[e.offset] <= 211)
    }
    var vt = Object.freeze({
        __proto__: null,
        int8: Q,
        uint8: Z,
        int16: J,
        uint16: tt,
        int32: et,
        uint32: nt,
        float32: rt,
        float64: it,
        int64: st,
        uint64: ot,
        readFloat32: ut,
        readFloat64: ht,
        boolean: dt,
        string: ft,
        stringCheck: pt,
        number: mt,
        numberCheck: gt,
        arrayCheck: yt,
        switchStructureCheck: bt
    })
      , wt = function() {
        function e(t) {
            var e = this;
            this.$changes = new l(this),
            this.$items = new Map,
            this.$indexes = new Map,
            this.$refId = 0,
            t && t.forEach((function(t) {
                return e.add(t)
            }
            ))
        }
        return e.prototype.onAdd = function(e, n) {
            return void 0 === n && (n = !0),
            c(this.$callbacks || (this.$callbacks = []), t.OPERATION.ADD, e, n ? this.$items : void 0)
        }
        ,
        e.prototype.onRemove = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
        }
        ,
        e.prototype.onChange = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
        }
        ,
        e.is = function(t) {
            return void 0 !== t.collection
        }
        ,
        e.prototype.add = function(t) {
            var e = this.$refId++;
            return void 0 !== t.$changes && t.$changes.setParent(this, this.$changes.root, e),
            this.$changes.indexes[e] = e,
            this.$indexes.set(e, e),
            this.$items.set(e, t),
            this.$changes.change(e),
            e
        }
        ,
        e.prototype.at = function(t) {
            var e = Array.from(this.$items.keys())[t];
            return this.$items.get(e)
        }
        ,
        e.prototype.entries = function() {
            return this.$items.entries()
        }
        ,
        e.prototype.delete = function(t) {
            for (var e, n, r = this.$items.entries(); (n = r.next()) && !n.done; )
                if (t === n.value[1]) {
                    e = n.value[0];
                    break
                }
            return void 0 !== e && (this.$changes.delete(e),
            this.$indexes.delete(e),
            this.$items.delete(e))
        }
        ,
        e.prototype.clear = function(e) {
            this.$changes.discard(!0, !0),
            this.$changes.indexes = {},
            this.$indexes.clear(),
            e && u.call(this, e),
            this.$items.clear(),
            this.$changes.operation({
                index: 0,
                op: t.OPERATION.CLEAR
            }),
            this.$changes.touchParents()
        }
        ,
        e.prototype.has = function(t) {
            return Array.from(this.$items.values()).some((function(e) {
                return e === t
            }
            ))
        }
        ,
        e.prototype.forEach = function(t) {
            var e = this;
            this.$items.forEach((function(n, r, i) {
                return t(n, r, e)
            }
            ))
        }
        ,
        e.prototype.values = function() {
            return this.$items.values()
        }
        ,
        Object.defineProperty(e.prototype, "size", {
            get: function() {
                return this.$items.size
            },
            enumerable: !1,
            configurable: !0
        }),
        e.prototype.setIndex = function(t, e) {
            this.$indexes.set(t, e)
        }
        ,
        e.prototype.getIndex = function(t) {
            return this.$indexes.get(t)
        }
        ,
        e.prototype.getByIndex = function(t) {
            return this.$items.get(this.$indexes.get(t))
        }
        ,
        e.prototype.deleteByIndex = function(t) {
            var e = this.$indexes.get(t);
            this.$items.delete(e),
            this.$indexes.delete(t)
        }
        ,
        e.prototype.toArray = function() {
            return Array.from(this.$items.values())
        }
        ,
        e.prototype.toJSON = function() {
            var t = [];
            return this.forEach((function(e, n) {
                t.push("function" == typeof e.toJSON ? e.toJSON() : e)
            }
            )),
            t
        }
        ,
        e.prototype.clone = function(t) {
            var n;
            return t ? n = Object.assign(new e, this) : (n = new e,
            this.forEach((function(t) {
                t.$changes ? n.add(t.clone()) : n.add(t)
            }
            ))),
            n
        }
        ,
        e
    }()
      , xt = function() {
        function e(t) {
            var e = this;
            this.$changes = new l(this),
            this.$items = new Map,
            this.$indexes = new Map,
            this.$refId = 0,
            t && t.forEach((function(t) {
                return e.add(t)
            }
            ))
        }
        return e.prototype.onAdd = function(e, n) {
            return void 0 === n && (n = !0),
            c(this.$callbacks || (this.$callbacks = []), t.OPERATION.ADD, e, n ? this.$items : void 0)
        }
        ,
        e.prototype.onRemove = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
        }
        ,
        e.prototype.onChange = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
        }
        ,
        e.is = function(t) {
            return void 0 !== t.set
        }
        ,
        e.prototype.add = function(e) {
            var n, r;
            if (this.has(e))
                return !1;
            var i = this.$refId++;
            void 0 !== e.$changes && e.$changes.setParent(this, this.$changes.root, i);
            var s = null !== (r = null === (n = this.$changes.indexes[i]) || void 0 === n ? void 0 : n.op) && void 0 !== r ? r : t.OPERATION.ADD;
            return this.$changes.indexes[i] = i,
            this.$indexes.set(i, i),
            this.$items.set(i, e),
            this.$changes.change(i, s),
            i
        }
        ,
        e.prototype.entries = function() {
            return this.$items.entries()
        }
        ,
        e.prototype.delete = function(t) {
            for (var e, n, r = this.$items.entries(); (n = r.next()) && !n.done; )
                if (t === n.value[1]) {
                    e = n.value[0];
                    break
                }
            return void 0 !== e && (this.$changes.delete(e),
            this.$indexes.delete(e),
            this.$items.delete(e))
        }
        ,
        e.prototype.clear = function(e) {
            this.$changes.discard(!0, !0),
            this.$changes.indexes = {},
            this.$indexes.clear(),
            e && u.call(this, e),
            this.$items.clear(),
            this.$changes.operation({
                index: 0,
                op: t.OPERATION.CLEAR
            }),
            this.$changes.touchParents()
        }
        ,
        e.prototype.has = function(t) {
            for (var e, n = this.$items.values(), r = !1; (e = n.next()) && !e.done; )
                if (t === e.value) {
                    r = !0;
                    break
                }
            return r
        }
        ,
        e.prototype.forEach = function(t) {
            var e = this;
            this.$items.forEach((function(n, r, i) {
                return t(n, r, e)
            }
            ))
        }
        ,
        e.prototype.values = function() {
            return this.$items.values()
        }
        ,
        Object.defineProperty(e.prototype, "size", {
            get: function() {
                return this.$items.size
            },
            enumerable: !1,
            configurable: !0
        }),
        e.prototype.setIndex = function(t, e) {
            this.$indexes.set(t, e)
        }
        ,
        e.prototype.getIndex = function(t) {
            return this.$indexes.get(t)
        }
        ,
        e.prototype.getByIndex = function(t) {
            return this.$items.get(this.$indexes.get(t))
        }
        ,
        e.prototype.deleteByIndex = function(t) {
            var e = this.$indexes.get(t);
            this.$items.delete(e),
            this.$indexes.delete(t)
        }
        ,
        e.prototype.toArray = function() {
            return Array.from(this.$items.values())
        }
        ,
        e.prototype.toJSON = function() {
            var t = [];
            return this.forEach((function(e, n) {
                t.push("function" == typeof e.toJSON ? e.toJSON() : e)
            }
            )),
            t
        }
        ,
        e.prototype.clone = function(t) {
            var n;
            return t ? n = Object.assign(new e, this) : (n = new e,
            this.forEach((function(t) {
                t.$changes ? n.add(t.clone()) : n.add(t)
            }
            ))),
            n
        }
        ,
        e
    }()
      , Et = function() {
        function t() {
            this.refIds = new WeakSet,
            this.containerIndexes = new WeakMap
        }
        return t.prototype.addRefId = function(t) {
            this.refIds.has(t) || (this.refIds.add(t),
            this.containerIndexes.set(t, new Set))
        }
        ,
        t.get = function(e) {
            return void 0 === e.$filterState && (e.$filterState = new t),
            e.$filterState
        }
        ,
        t
    }()
      , _t = function() {
        function t() {
            this.refs = new Map,
            this.refCounts = {},
            this.deletedRefs = new Set,
            this.nextUniqueId = 0
        }
        return t.prototype.getNextUniqueId = function() {
            return this.nextUniqueId++
        }
        ,
        t.prototype.addRef = function(t, e, n) {
            void 0 === n && (n = !0),
            this.refs.set(t, e),
            n && (this.refCounts[t] = (this.refCounts[t] || 0) + 1)
        }
        ,
        t.prototype.removeRef = function(t) {
            this.refCounts[t] = this.refCounts[t] - 1,
            this.deletedRefs.add(t)
        }
        ,
        t.prototype.clearRefs = function() {
            this.refs.clear(),
            this.deletedRefs.clear(),
            this.refCounts = {}
        }
        ,
        t.prototype.garbageCollectDeletedRefs = function() {
            var t = this;
            this.deletedRefs.forEach((function(e) {
                if (!(t.refCounts[e] > 0)) {
                    var n = t.refs.get(e);
                    if (n instanceof Mt)
                        for (var r in n._definition.schema)
                            "string" != typeof n._definition.schema[r] && n[r] && n[r].$changes && t.removeRef(n[r].$changes.refId);
                    else {
                        var i = n.$changes.parent._definition
                          , s = i.schema[i.fieldsByIndex[n.$changes.parentIndex]];
                        "function" == typeof Object.values(s)[0] && Array.from(n.values()).forEach((function(e) {
                            return t.removeRef(e.$changes.refId)
                        }
                        ))
                    }
                    t.refs.delete(e),
                    delete t.refCounts[e]
                }
            }
            )),
            this.deletedRefs.clear()
        }
        ,
        t
    }()
      , At = function(t) {
        function e() {
            return null !== t && t.apply(this, arguments) || this
        }
        return n(e, t),
        e
    }(Error);
    function St(t, e, n, r) {
        var i, s = !1;
        switch (e) {
        case "number":
        case "int8":
        case "uint8":
        case "int16":
        case "uint16":
        case "int32":
        case "uint32":
        case "int64":
        case "uint64":
        case "float32":
        case "float64":
            i = "number",
            isNaN(t) && console.log('trying to encode "NaN" in '.concat(n.constructor.name, "#").concat(r));
            break;
        case "string":
            i = "string",
            s = !0;
            break;
        case "boolean":
            return
        }
        if (typeof t !== i && (!s || s && null !== t)) {
            var o = "'".concat(JSON.stringify(t), "'").concat(t && t.constructor && " (".concat(t.constructor.name, ")") || "");
            throw new At("a '".concat(i, "' was expected, but ").concat(o, " was provided in ").concat(n.constructor.name, "#").concat(r))
        }
    }
    function Tt(t, e, n, r) {
        if (!(t instanceof e))
            throw new At("a '".concat(e.name, "' was expected, but '").concat(t.constructor.name, "' was provided in ").concat(n.constructor.name, "#").concat(r))
    }
    function kt(t, e, n, r, i) {
        St(n, t, r, i);
        var s = q[t];
        if (!s)
            throw new At("a '".concat(t, "' was expected, but ").concat(n, " was provided in ").concat(r.constructor.name, "#").concat(i));
        s(e, n)
    }
    function It(t, e, n) {
        return vt[t](e, n)
    }
    var Mt = function() {
        function e() {
            for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
            Object.defineProperties(this, {
                $changes: {
                    value: new l(this,void 0,new _t),
                    enumerable: !1,
                    writable: !0
                },
                $callbacks: {
                    value: void 0,
                    enumerable: !1,
                    writable: !0
                }
            });
            var n = this._definition.descriptors;
            n && Object.defineProperties(this, n),
            t[0] && this.assign(t[0])
        }
        return e.onError = function(t) {
            console.error(t)
        }
        ,
        e.is = function(t) {
            return t._definition && void 0 !== t._definition.schema
        }
        ,
        e.prototype.onChange = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.REPLACE, e)
        }
        ,
        e.prototype.onRemove = function(e) {
            return c(this.$callbacks || (this.$callbacks = []), t.OPERATION.DELETE, e)
        }
        ,
        e.prototype.assign = function(t) {
            return Object.assign(this, t),
            this
        }
        ,
        Object.defineProperty(e.prototype, "_definition", {
            get: function() {
                return this.constructor._definition
            },
            enumerable: !1,
            configurable: !0
        }),
        e.prototype.setDirty = function(t, e) {
            this.$changes.change(t, e)
        }
        ,
        e.prototype.listen = function(t, e, n) {
            var r = this;
            return void 0 === n && (n = !0),
            this.$callbacks || (this.$callbacks = {}),
            this.$callbacks[t] || (this.$callbacks[t] = []),
            this.$callbacks[t].push(e),
            n && void 0 !== this[t] && e(this[t], void 0),
            function() {
                return h(r.$callbacks[t], r.$callbacks[t].indexOf(e))
            }
        }
        ,
        e.prototype.decode = function(n, r, i) {
            var s;
            void 0 === r && (r = {
                offset: 0
            }),
            void 0 === i && (i = this);
            var a = []
              , l = this.$changes.root
              , c = n.length
              , u = 0;
            for (l.refs.set(u, this); r.offset < c; ) {
                var h = n[r.offset++];
                if (h != o) {
                    var d = i.$changes
                      , f = void 0 !== i._definition
                      , m = f ? h >> 6 << 6 : h;
                    if (m !== t.OPERATION.CLEAR) {
                        var y = f ? h % (m || 255) : mt(n, r)
                          , b = f ? i._definition.fieldsByIndex[y] : ""
                          , w = d.getType(y)
                          , x = void 0
                          , E = void 0
                          , _ = void 0;
                        if (f ? E = i["_".concat(b)] : (E = i.getByIndex(y),
                        (m & t.OPERATION.ADD) === t.OPERATION.ADD ? (_ = i instanceof g ? ft(n, r) : y,
                        i.setIndex(y, _)) : _ = i.getIndex(y)),
                        (m & t.OPERATION.DELETE) === t.OPERATION.DELETE && (m !== t.OPERATION.DELETE_AND_ADD && i.deleteByIndex(y),
                        E && E.$changes && l.removeRef(E.$changes.refId),
                        x = null),
                        void 0 !== b) {
                            if (m === t.OPERATION.DELETE)
                                ;
                            else if (e.is(w)) {
                                var A = mt(n, r);
                                if (x = l.refs.get(A),
                                m !== t.OPERATION.REPLACE) {
                                    var S = this.getSchemaType(n, r, w);
                                    x || ((x = this.createTypeInstance(S)).$changes.refId = A,
                                    E && (x.$callbacks = E.$callbacks,
                                    E.$changes.refId && A !== E.$changes.refId && l.removeRef(E.$changes.refId))),
                                    l.addRef(A, x, x !== E)
                                }
                            } else if ("string" == typeof w)
                                x = It(w, n, r);
                            else {
                                var T = v(Object.keys(w)[0])
                                  , k = mt(n, r)
                                  , I = l.refs.has(k) ? E || l.refs.get(k) : new T.constructor;
                                if ((x = I.clone(!0)).$changes.refId = k,
                                E && (x.$callbacks = E.$callbacks,
                                E.$changes.refId && k !== E.$changes.refId)) {
                                    l.removeRef(E.$changes.refId);
                                    for (var M = E.entries(), C = void 0; (C = M.next()) && !C.done; ) {
                                        var P = (s = C.value)[0]
                                          , O = s[1];
                                        a.push({
                                            refId: k,
                                            op: t.OPERATION.DELETE,
                                            field: P,
                                            value: void 0,
                                            previousValue: O
                                        })
                                    }
                                }
                                l.addRef(k, x, I !== E)
                            }
                            if (null != x)
                                if (x.$changes && x.$changes.setParent(d.ref, d.root, y),
                                i instanceof e)
                                    i[b] = x;
                                else if (i instanceof g)
                                    P = _,
                                    i.$items.set(P, x),
                                    i.$changes.allChanges.add(y);
                                else if (i instanceof p)
                                    i.setAt(y, x);
                                else if (i instanceof wt) {
                                    var N = i.add(x);
                                    i.setIndex(y, N)
                                } else
                                    i instanceof xt && !1 !== (N = i.add(x)) && i.setIndex(y, N);
                            E !== x && a.push({
                                refId: u,
                                op: m,
                                field: b,
                                dynamicIndex: _,
                                value: x,
                                previousValue: E
                            })
                        } else {
                            console.warn("@colyseus/schema: definition mismatch");
                            for (var R = {
                                offset: r.offset
                            }; r.offset < c && (!bt(n, r) || (R.offset = r.offset + 1,
                            !l.refs.has(mt(n, R)))); )
                                r.offset++
                        }
                    } else
                        i.clear(a)
                } else {
                    u = mt(n, r);
                    var D = l.refs.get(u);
                    if (!D)
                        throw new Error('"refId" not found: '.concat(u));
                    i = D
                }
            }
            return this._triggerChanges(a),
            l.garbageCollectDeletedRefs(),
            a
        }
        ,
        e.prototype.encode = function(n, r, i) {
            void 0 === n && (n = !1),
            void 0 === r && (r = []),
            void 0 === i && (i = !1);
            for (var s = this.$changes, a = new WeakSet, l = [s], c = 1, u = 0; u < c; u++) {
                var h = l[u]
                  , d = h.ref
                  , f = d instanceof e;
                h.ensureRefId(),
                a.add(h),
                h !== s && (h.changed || n) && (O(r, o),
                X(r, h.refId));
                for (var p = n ? Array.from(h.allChanges) : Array.from(h.changes.values()), m = 0, y = p.length; m < y; m++) {
                    var b = n ? {
                        op: t.OPERATION.ADD,
                        index: p[m]
                    } : p[m]
                      , w = b.index
                      , x = f ? d._definition.fieldsByIndex && d._definition.fieldsByIndex[w] : w
                      , E = r.length;
                    if (b.op !== t.OPERATION.TOUCH)
                        if (f)
                            O(r, w | b.op);
                        else {
                            if (O(r, b.op),
                            b.op === t.OPERATION.CLEAR)
                                continue;
                            X(r, w)
                        }
                    if (f || (b.op & t.OPERATION.ADD) != t.OPERATION.ADD || d instanceof g && G(r, h.ref.$indexes.get(w)),
                    b.op !== t.OPERATION.DELETE) {
                        var _ = h.getType(w)
                          , A = h.getValue(w);
                        if (A && A.$changes && !a.has(A.$changes) && (l.push(A.$changes),
                        A.$changes.ensureRefId(),
                        c++),
                        b.op !== t.OPERATION.TOUCH) {
                            if (e.is(_))
                                Tt(A, _, d, x),
                                X(r, A.$changes.refId),
                                (b.op & t.OPERATION.ADD) === t.OPERATION.ADD && this.tryEncodeTypeId(r, _, A.constructor);
                            else if ("string" == typeof _)
                                kt(_, r, A, d, x);
                            else {
                                var S = v(Object.keys(_)[0]);
                                Tt(d["_".concat(x)], S.constructor, d, x),
                                X(r, A.$changes.refId)
                            }
                            i && h.cache(w, r.slice(E))
                        }
                    }
                }
                n || i || h.discard()
            }
            return r
        }
        ,
        e.prototype.encodeAll = function(t) {
            return this.encode(!0, [], t)
        }
        ,
        e.prototype.applyFilters = function(n, r) {
            var i, s;
            void 0 === r && (r = !1);
            for (var a = this, l = new Set, c = Et.get(n), u = [this.$changes], h = 1, d = [], f = function(f) {
                var p = u[f];
                if (l.has(p.refId))
                    return "continue";
                var m = p.ref
                  , y = m instanceof e;
                O(d, o),
                X(d, p.refId);
                var b = c.refIds.has(p)
                  , v = r || !b;
                c.addRefId(p);
                var w = c.containerIndexes.get(p)
                  , x = v ? Array.from(p.allChanges) : Array.from(p.changes.values());
                !r && y && m._definition.indexesWithFilters && m._definition.indexesWithFilters.forEach((function(e) {
                    !w.has(e) && p.allChanges.has(e) && (v ? x.push(e) : x.push({
                        op: t.OPERATION.ADD,
                        index: e
                    }))
                }
                ));
                for (var E = 0, _ = x.length; E < _; E++) {
                    var A = v ? {
                        op: t.OPERATION.ADD,
                        index: x[E]
                    } : x[E];
                    if (A.op !== t.OPERATION.CLEAR) {
                        var S = A.index;
                        if (A.op !== t.OPERATION.DELETE) {
                            var T = p.getValue(S)
                              , k = p.getType(S);
                            if (y) {
                                if ((I = m._definition.filters && m._definition.filters[S]) && !I.call(m, n, T, a)) {
                                    T && T.$changes && l.add(T.$changes.refId);
                                    continue
                                }
                            } else {
                                var I, M = p.parent;
                                if ((I = p.getChildrenFilter()) && !I.call(M, n, m.$indexes.get(S), T, a)) {
                                    T && T.$changes && l.add(T.$changes.refId);
                                    continue
                                }
                            }
                            if (T.$changes && (u.push(T.$changes),
                            h++),
                            A.op !== t.OPERATION.TOUCH)
                                if (A.op === t.OPERATION.ADD || y)
                                    d.push.apply(d, null !== (i = p.caches[S]) && void 0 !== i ? i : []),
                                    w.add(S);
                                else if (w.has(S))
                                    d.push.apply(d, null !== (s = p.caches[S]) && void 0 !== s ? s : []);
                                else {
                                    if (w.add(S),
                                    O(d, t.OPERATION.ADD),
                                    X(d, S),
                                    m instanceof g) {
                                        var C = p.ref.$indexes.get(S);
                                        G(d, C)
                                    }
                                    T.$changes ? X(d, T.$changes.refId) : q[k](d, T)
                                }
                            else
                                T.$changes && !y && (O(d, t.OPERATION.ADD),
                                X(d, S),
                                m instanceof g && (C = p.ref.$indexes.get(S),
                                G(d, C)),
                                X(d, T.$changes.refId))
                        } else
                            y ? O(d, A.op | S) : (O(d, A.op),
                            X(d, S))
                    } else
                        O(d, A.op)
                }
            }, p = 0; p < h; p++)
                f(p);
            return d
        }
        ,
        e.prototype.clone = function() {
            var t, e = new this.constructor, n = this._definition.schema;
            for (var r in n)
                "object" == typeof this[r] && "function" == typeof (null === (t = this[r]) || void 0 === t ? void 0 : t.clone) ? e[r] = this[r].clone() : e[r] = this[r];
            return e
        }
        ,
        e.prototype.toJSON = function() {
            var t = this._definition.schema
              , e = this._definition.deprecated
              , n = {};
            for (var r in t)
                e[r] || null === this[r] || void 0 === this[r] || (n[r] = "function" == typeof this[r].toJSON ? this[r].toJSON() : this["_".concat(r)]);
            return n
        }
        ,
        e.prototype.discardAllChanges = function() {
            this.$changes.discardAll()
        }
        ,
        e.prototype.getByIndex = function(t) {
            return this[this._definition.fieldsByIndex[t]]
        }
        ,
        e.prototype.deleteByIndex = function(t) {
            this[this._definition.fieldsByIndex[t]] = void 0
        }
        ,
        e.prototype.tryEncodeTypeId = function(t, e, n) {
            e._typeid !== n._typeid && (O(t, a),
            X(t, n._typeid))
        }
        ,
        e.prototype.getSchemaType = function(t, e, n) {
            var r;
            return t[e.offset] === a && (e.offset++,
            r = this.constructor._context.get(mt(t, e))),
            r || n
        }
        ,
        e.prototype.createTypeInstance = function(t) {
            var e = new t;
            return e.$changes.root = this.$changes.root,
            e
        }
        ,
        e.prototype._triggerChanges = function(n) {
            for (var r, i, s, o, a, l, c, u, h, d = new Set, f = this.$changes.root.refs, p = function(p) {
                var m = n[p]
                  , g = m.refId
                  , y = f.get(g)
                  , b = y.$callbacks;
                if ((m.op & t.OPERATION.DELETE) === t.OPERATION.DELETE && m.previousValue instanceof e && (null === (i = null === (r = m.previousValue.$callbacks) || void 0 === r ? void 0 : r[t.OPERATION.DELETE]) || void 0 === i || i.forEach((function(t) {
                    return t()
                }
                ))),
                !b)
                    return "continue";
                if (y instanceof e) {
                    if (!d.has(g))
                        try {
                            null === (s = null == b ? void 0 : b[t.OPERATION.REPLACE]) || void 0 === s || s.forEach((function(t) {
                                return t(n)
                            }
                            ))
                        } catch (t) {
                            e.onError(t)
                        }
                    try {
                        b.hasOwnProperty(m.field) && (null === (o = b[m.field]) || void 0 === o || o.forEach((function(t) {
                            return t(m.value, m.previousValue)
                        }
                        )))
                    } catch (t) {
                        e.onError(t)
                    }
                } else
                    m.op === t.OPERATION.ADD && void 0 === m.previousValue ? null === (a = b[t.OPERATION.ADD]) || void 0 === a || a.forEach((function(t) {
                        var e;
                        return t(m.value, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                    }
                    )) : m.op === t.OPERATION.DELETE ? void 0 !== m.previousValue && (null === (l = b[t.OPERATION.DELETE]) || void 0 === l || l.forEach((function(t) {
                        var e;
                        return t(m.previousValue, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                    }
                    ))) : m.op === t.OPERATION.DELETE_AND_ADD && (void 0 !== m.previousValue && (null === (c = b[t.OPERATION.DELETE]) || void 0 === c || c.forEach((function(t) {
                        var e;
                        return t(m.previousValue, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                    }
                    ))),
                    null === (u = b[t.OPERATION.ADD]) || void 0 === u || u.forEach((function(t) {
                        var e;
                        return t(m.value, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                    }
                    ))),
                    m.value !== m.previousValue && (null === (h = b[t.OPERATION.REPLACE]) || void 0 === h || h.forEach((function(t) {
                        var e;
                        return t(m.value, null !== (e = m.dynamicIndex) && void 0 !== e ? e : m.field)
                    }
                    )));
                d.add(g)
            }, m = 0; m < n.length; m++)
                p(m)
        }
        ,
        e._definition = w.create(),
        e
    }();
    function Ct(t) {
        for (var e = [t.$changes], n = 1, r = {}, i = r, s = function(t) {
            var n = e[t];
            n.changes.forEach((function(t) {
                var e = n.ref
                  , r = t.index
                  , s = e._definition ? e._definition.fieldsByIndex[r] : e.$indexes.get(r);
                i[s] = n.getValue(r)
            }
            ))
        }, o = 0; o < n; o++)
            s(o);
        return r
    }
    var Pt = {
        context: new E
    }
      , Ot = function(t) {
        function e() {
            return null !== t && t.apply(this, arguments) || this
        }
        return n(e, t),
        r([A("string", Pt)], e.prototype, "name", void 0),
        r([A("string", Pt)], e.prototype, "type", void 0),
        r([A("number", Pt)], e.prototype, "referencedType", void 0),
        e
    }(Mt)
      , Nt = function(t) {
        function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.fields = new p,
            e
        }
        return n(e, t),
        r([A("number", Pt)], e.prototype, "id", void 0),
        r([A([Ot], Pt)], e.prototype, "fields", void 0),
        e
    }(Mt)
      , Rt = function(t) {
        function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.types = new p,
            e
        }
        return n(e, t),
        e.encode = function(t) {
            var n = t.constructor
              , r = new e;
            r.rootType = n._typeid;
            var i = function(t, e) {
                for (var n in e) {
                    var i = new Ot;
                    i.name = n;
                    var s = void 0;
                    if ("string" == typeof e[n])
                        s = e[n];
                    else {
                        var o = e[n]
                          , a = void 0;
                        Mt.is(o) ? (s = "ref",
                        a = e[n]) : "string" == typeof o[s = Object.keys(o)[0]] ? s += ":" + o[s] : a = o[s],
                        i.referencedType = a ? a._typeid : -1
                    }
                    i.type = s,
                    t.fields.push(i)
                }
                r.types.push(t)
            }
              , s = n._context.types;
            for (var o in s) {
                var a = new Nt;
                a.id = Number(o),
                i(a, s[o]._definition.schema)
            }
            return r.encodeAll()
        }
        ,
        e.decode = function(t, r) {
            var i = new E
              , s = new e;
            s.decode(t, r);
            var o = s.types.reduce((function(t, e) {
                var r = function(t) {
                    function e() {
                        return null !== t && t.apply(this, arguments) || this
                    }
                    return n(e, t),
                    e
                }(Mt)
                  , s = e.id;
                return t[s] = r,
                i.add(r, s),
                t
            }
            ), {});
            s.types.forEach((function(t) {
                var e = o[t.id];
                t.fields.forEach((function(t) {
                    var n;
                    if (void 0 !== t.referencedType) {
                        var r = t.type
                          , s = o[t.referencedType];
                        if (!s) {
                            var a = t.type.split(":");
                            r = a[0],
                            s = a[1]
                        }
                        "ref" === r ? A(s, {
                            context: i
                        })(e.prototype, t.name) : A(((n = {})[r] = s,
                        n), {
                            context: i
                        })(e.prototype, t.name)
                    } else
                        A(t.type, {
                            context: i
                        })(e.prototype, t.name)
                }
                ))
            }
            ));
            var a = o[s.rootType]
              , l = new a;
            for (var c in a._definition.schema) {
                var u = a._definition.schema[c];
                "string" != typeof u && (l[c] = "function" == typeof u ? new u : new (v(Object.keys(u)[0]).constructor))
            }
            return l
        }
        ,
        r([A([Nt], Pt)], e.prototype, "types", void 0),
        r([A("number", Pt)], e.prototype, "rootType", void 0),
        e
    }(Mt);
    b("map", {
        constructor: g
    }),
    b("array", {
        constructor: p
    }),
    b("set", {
        constructor: xt
    }),
    b("collection", {
        constructor: wt
    }),
    t.ArraySchema = p,
    t.CollectionSchema = wt,
    t.Context = E,
    t.MapSchema = g,
    t.Reflection = Rt,
    t.ReflectionField = Ot,
    t.ReflectionType = Nt,
    t.Schema = Mt,
    t.SchemaDefinition = w,
    t.SetSchema = xt,
    t.decode = vt,
    t.defineTypes = I,
    t.deprecated = k,
    t.dumpChanges = Ct,
    t.encode = q,
    t.filter = S,
    t.filterChildren = T,
    t.hasFilter = x,
    t.registerType = b,
    t.type = A,
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}(rz);
class iz extends rz.Schema {
}
nz([(0,
rz.type)("number")], iz.prototype, "x", void 0),
nz([(0,
rz.type)("number")], iz.prototype, "y", void 0),
nz([(0,
rz.type)("number")], iz.prototype, "width", void 0),
nz([(0,
rz.type)("number")], iz.prototype, "height", void 0);
class sz extends iz {
}
nz([(0,
rz.type)("number")], sz.prototype, "dx", void 0),
nz([(0,
rz.type)("number")], sz.prototype, "dy", void 0);
class oz extends sz {
}
nz([(0,
rz.type)("string")], oz.prototype, "uid", void 0);
class az extends sz {
}
nz([(0,
rz.type)("boolean")], az.prototype, "moving", void 0),
nz([(0,
rz.type)("boolean")], az.prototype, "movingWithRotation", void 0),
nz([(0,
rz.type)("number")], az.prototype, "speed", void 0);
class lz extends sz {
}
nz([(0,
rz.type)("string")], lz.prototype, "uid", void 0),
nz([(0,
rz.type)("string")], lz.prototype, "type", void 0);
class cz extends sz {
}
nz([(0,
rz.type)("string")], cz.prototype, "uid", void 0),
nz([(0,
rz.type)("string")], cz.prototype, "type", void 0),
nz([(0,
rz.type)("number")], cz.prototype, "life", void 0);
class uz extends sz {
}
nz([(0,
rz.type)("string")], uz.prototype, "uid", void 0),
nz([(0,
rz.type)("string")], uz.prototype, "type", void 0);
class hz extends rz.Schema {
    constructor(...t) {
        super(...t),
        this.platforms = new (0,
        rz.ArraySchema),
        this.items = new (0,
        rz.ArraySchema),
        this.bullets = new (0,
        rz.ArraySchema),
        this.monsters = new (0,
        rz.ArraySchema),
        this.character = new az
    }
}
nz([(0,
rz.type)([uz])], hz.prototype, "platforms", void 0),
nz([(0,
rz.type)([lz])], hz.prototype, "items", void 0),
nz([(0,
rz.type)([oz])], hz.prototype, "bullets", void 0),
nz([(0,
rz.type)([cz])], hz.prototype, "monsters", void 0),
nz([(0,
rz.type)(az)], hz.prototype, "character", void 0),
nz([(0,
rz.type)("number")], hz.prototype, "score", void 0),
nz([(0,
rz.type)("number")], hz.prototype, "bonusScore", void 0),
nz([(0,
rz.type)("number")], hz.prototype, "lives", void 0),
nz([(0,
rz.type)("number")], hz.prototype, "livesUsed", void 0),
nz([(0,
rz.type)("boolean")], hz.prototype, "paused", void 0),
nz([(0,
rz.type)("boolean")], hz.prototype, "ended", void 0),
nz([(0,
rz.type)("boolean")], hz.prototype, "canMove", void 0);
class dz extends rz.Schema {
    constructor(...t) {
        super(...t),
        this.level = new hz
    }
}
nz([(0,
rz.type)(hz)], dz.prototype, "level", void 0);
const fz = async({options: t, onConnect: e, onLeave: n, onJoinError: r})=>{
    try {
        let r = "wss://jump-test-s1.meegos.io/meegos";
        if (XF.external.getLoadBalancerRequest) {
            const t = await XF.external.getLoadBalancerRequest()
              , e = t?.data.server;
            e && (r = r.replace("s1", e))
        }
        const i = new (0,
        ez.Client)(r)
          , s = await i.joinOrCreate("solo", t, dz);
        return console.log(s.sessionId, "joined", s.name),
        s.onStateChange.once((t=>{
            e(s, t.level)
        }
        )),
        s.onLeave((t=>{
            n(t),
            4e3 !== t && XF.external.showModal && (zU(),
            XF.external.showModal({
                title: "Disconnected",
                text: "You have been disconnected from the server, check your connection"
            }),
            Hz()),
            console.log("leave", t)
        }
        )),
        s.onError(((t,e)=>{
            console.log("ERROR: ", t, " [", e, "]")
        }
        )),
        s
    } catch (t) {
        r(t)
    }
}
;
function pz(t) {
    const e = Math.PI / 180;
    let n = t.beta * e
      , r = t.gamma * e
      , i = t.alpha * e;
    const s = Math.cos(n / 2)
      , o = Math.cos(r / 2)
      , a = Math.cos(i / 2)
      , l = Math.sin(n / 2)
      , c = Math.sin(r / 2)
      , u = Math.sin(i / 2);
    return n = l * o * a - s * c * u,
    r = s * c * a + l * o * u,
    i = s * o * u + l * c * a,
    {
        x: n,
        y: r,
        z: i,
        w: s * o * a - l * c * u
    }
}
function mz(t, e) {
    return {
        w: t.w * e.w - t.x * e.x - t.y * e.y - t.z * e.z,
        x: t.w * e.x + t.x * e.w + t.y * e.z - t.z * e.y,
        y: t.w * e.y - t.x * e.z + t.y * e.w + t.z * e.x,
        z: t.w * e.z + t.x * e.y - t.y * e.x + t.z * e.w
    }
}
function gz(t, e) {
    return t = mz(e, {
        x: t.x,
        y: t.y,
        z: t.z,
        w: 0
    }),
    {
        x: (t = mz(t, {
            w: e.w,
            x: -e.x,
            y: -e.y,
            z: -e.z
        })).x,
        y: t.y,
        z: t.z
    }
}
function yz(t) {
    const e = 180 / Math.PI
      , n = gz({
        x: 0,
        y: 1,
        z: 0
    }, t);
    let r = 0 == n.x && 0 == n.y ? 0 : -Math.atan2(n.x, n.y)
      , i = Math.atan2(n.z, Math.sqrt(n.x * n.x + n.y * n.y));
    const s = {
        x: Math.cos(r),
        y: Math.sin(r),
        z: 0
    }
      , o = {
        x: Math.sin(r) * Math.sin(i),
        y: -Math.cos(r) * Math.sin(i),
        z: Math.cos(i)
    }
      , a = gz({
        x: 0,
        y: 0,
        z: 1
    }, t);
    let l = Math.atan2(bz(a, s), bz(a, o));
    return r < 0 && (r += 2 * Math.PI),
    l >= .5 * Math.PI ? (l -= Math.PI,
    r += Math.PI,
    i = i > 0 ? Math.PI - i : -Math.PI - i) : l < -.5 * Math.PI && (l += Math.PI,
    r += Math.PI,
    i = i > 0 ? Math.PI - i : -Math.PI - i),
    r >= 2 * Math.PI && (r -= 2 * Math.PI),
    {
        alpha: r * e,
        beta: i * e,
        gamma: l * e
    }
}
function bz(t, e) {
    return t.x * e.x + t.y * e.y + t.z * e.z
}
const vz = async t=>{
    XF.loading || (Az(),
    XF.loading = !0,
    XF.app && (t ? XF.room = t : (XF.external.showLoading && XF.external.showLoading(!0, void 0, "Connecting..."),
    zU(),
    XF.room = await fz({
        options: {
            clientWidth: QF(),
            clientHeight: ZF(),
            sessionToken: XF.external.getSessionToken ? XF.external.getSessionToken() : void 0
        },
        onConnect: (t,e)=>BU(t, e),
        onJoinError: jU,
        onLeave: UU
    }))))
}
  , wz = t=>{
    XF.level && (Xz(),
    Sz(),
    JF(),
    VU(),
    jz(),
    oj(),
    _z(),
    xz(),
    Ez(),
    XF.viewport.moveCenter(QF() / 2, -ZF() / 2),
    XF.external.showLoading && XF.external.showLoading(!1),
    XF.loading = !1)
}
  , xz = ()=>{
    XF.references.items && XF.references.items.forEach((t=>{
        XF.viewport && t?.spine && XF.viewport.addChild(t.spine)
    }
    ))
}
  , Ez = ()=>{
    XF.references.monsters && XF.references.monsters.forEach((t=>{
        XF.viewport && t?.spine && XF.viewport.addChild(t.spine)
    }
    ))
}
  , _z = ()=>{
    XF.references.platforms && XF.references.platforms.forEach((t=>{
        XF.viewport && t?.sprite && XF.viewport.addChild(t.sprite)
    }
    ))
}
  , Az = ()=>{
    try {
        XF.references.character && XF.references.character.destroy()
    } catch {}
    XF.references.monsters?.forEach((t=>{
        if (t)
            try {
                t.spine.destroy()
            } catch {}
    }
    )),
    XF.references.platforms?.forEach((t=>{
        if (t)
            try {
                t.sprite.destroy()
            } catch {}
    }
    )),
    XF.references.items?.forEach((t=>{
        if (t)
            try {
                t.spine.destroy()
            } catch {}
    }
    )),
    XF.references.monsters = [],
    XF.references.bullets = [],
    XF.references.platforms = [],
    XF.references.items = []
}
  , Sz = ()=>{
    XF.level && _j(gO.Music1)
}
  , Tz = t=>{
    if (!XF.viewport || !XF.level)
        return;
    XF.references.items || (XF.references.items = []);
    const e = XF.references.items
      , n = lj(t);
    if (n) {
        n.zIndex = 11;
        const r = {
            uid: t.uid,
            x: t.x,
            y: t.y,
            dx: t.dx,
            dy: t.dy,
            width: t.width,
            height: t.height,
            spine: n
        };
        return e.push(r),
        XF.viewport.addChild(n),
        r
    }
}
  , kz = t=>{
    if (!XF.viewport || !XF.level)
        return;
    XF.references.monsters || (XF.references.monsters = []);
    const e = XF.references.monsters
      , n = gj(t);
    if (n) {
        n.zIndex = 11;
        const r = {
            uid: t.uid,
            x: t.x,
            y: t.y,
            dx: t.dx,
            dy: t.dy,
            width: t.width,
            height: t.height,
            life: t.life,
            spine: n
        };
        return e.push(r),
        XF.viewport.addChild(n),
        r
    }
}
  , Iz = (t,e=!0)=>{
    if (!XF.viewport || !XF.level)
        return;
    XF.references.platforms || (XF.references.platforms = []);
    const n = XF.references.platforms
      , r = bj(t);
    if (r) {
        r.zIndex = 10;
        const i = {
            uid: t.uid,
            x: t.x,
            y: t.y,
            dx: t.dx,
            dy: t.dy,
            width: t.width,
            height: t.height,
            sprite: r,
            type: t.type
        };
        return e && n.push(i),
        XF.viewport.addChild(r),
        i
    }
}
  , Mz = t=>{
    const e = XF.level?.state.character;
    if (!XF.viewport || !XF.level || !e)
        return;
    XF.references.bullets || (XF.references.bullets = []);
    const n = XF.references.bullets
      , r = sj(t);
    r.zIndex = 10,
    r.x = e.x + e.width / 2,
    r.y = e.y + e.height / 2;
    const i = {
        uid: t.uid,
        x: t.x,
        y: t.y,
        dx: t.dx,
        dy: t.dy,
        width: t.width,
        height: t.height,
        graphics: r
    };
    return n.push(i),
    XF.viewport.addChild(r),
    i
}
  , Cz = t=>{
    const e = XF.references.character;
    if (!XF.viewport || !XF.level || !e || XF.level.state.ended)
        return;
    const n = XF.level.state.character
      , {x: r, y: i} = e
      , {dx: s, dy: o, width: a, height: l} = n;
    let {x: c, y: u} = n;
    c += a / 2,
    u += l,
    o > 0 && e.skeleton.skin?.name.includes("Surprise") && e.skeleton.setSkinByName((e.skeleton.skin?.name ?? "").split("_")[0] + "_Normal");
    let h = r + s * t
      , d = i + o * t;
    const f = c - h;
    h += f * t * .1,
    d += (u - d) * t * .1,
    (Math.abs(f) > 100 || Math.abs(f) < .01) && (h = c),
    d - l < -XF.viewport.y + .5 * XF.viewport.screenHeight && XF.viewport.moveCenter(QF() / 2, d - l);
    const p = Math.abs(XF.level.state.character.y);
    p < bO.Blue * KF() && e.skeleton.setSkinByName(`Blue/Blue_${e.skeleton.skin?.name.split("_")[1]}`),
    p >= bO.Blue * KF() && p < bO.Green * KF() && (_j(gO.Music2),
    e.skeleton.setSkinByName(`Green/Green_${e.skeleton.skin?.name.split("_")[1]}`)),
    p >= bO.Green * KF() && p < bO.Pink * KF() && (_j(gO.Music3),
    e.skeleton.setSkinByName(`Pink/Pink_${e.skeleton.skin?.name.split("_")[1]}`)),
    p >= bO.Pink * KF() && p < bO.Teal * KF() && (_j(gO.Music4),
    e.skeleton.setSkinByName(`Teal/Teal_${e.skeleton.skin?.name.split("_")[1]}`)),
    p >= bO.Teal * KF() && (_j(gO.Music5),
    e.skeleton.setSkinByName(`Yellow/Yellow_${e.skeleton.skin?.name.split("_")[1]}`)),
    e.position.set(h, d)
}
  , Pz = t=>{
    const e = XF.references.bullets;
    XF.viewport && XF.level && e && e.forEach((e=>{
        if (!e)
            return;
        let {x: n, y: r} = e.graphics;
        n += e.dx * t,
        r += e.dy * t;
        const {x: i, y: s} = e
          , o = i - n
          , a = s - r;
        e.graphics.position.set(Math.abs(o) > 100 ? i : n + .2 * o, r + .2 * a)
    }
    ))
}
  , Oz = t=>{
    if (!XF.viewport || !XF.level)
        return;
    const e = XF.references.platforms;
    XF.viewport && XF.level && e && e.forEach((e=>{
        if (!e)
            return;
        let {x: n, y: r} = e.sprite;
        n += e.dx * t,
        r += e.dy * t;
        let {x: i, y: s} = e;
        e.type === cO.Rock || e.type === cO.Rock2 ? (i += .42 * e.sprite.width,
        s += e.sprite.height / 2) : e.type !== cO.Jumper && e.type !== cO.Jumper2 || (i += .46 * e.sprite.width,
        s += 20);
        const o = i - n
          , a = s - r;
        e.sprite.position.set(Math.abs(o) > 100 ? i : n + .2 * o, r + .2 * a)
    }
    ))
}
;
let Nz, Rz = !1, Dz = !1;
const Bz = {
    x: 0,
    y: 0,
    z: 0,
    alpha: 0,
    beta: 0,
    gamma: 0,
    rawAlpha: 0,
    rawBeta: 0,
    rawGamma: 0
};
let Lz = !1
  , Fz = Date.now();
const jz = ()=>{
    if (!XF.viewport || !XF.room)
        return;
    const t = XF.room;
    Rz = !1,
    Dz = !1,
    XF.viewport.on("pointertap", (e=>{
        if (0 === e.button) {
            const n = XF.level?.state.character
              , r = XF.references.character;
            if (XF.level?.state.ended || !n || !r)
                return;
            const {x: i, y: s} = e.global
              , o = {
                x: n.x + n.width / 2,
                y: n.y + n.height / 2
            }
              , a = {
                x: dg.any ? o.x : i,
                y: dg.any ? o.y - 1e3 : s + (XF.viewport?.top ?? 0)
            };
            r.skeleton.setSkinByName((r.skeleton.skin?.name ?? "").split("_")[0] + "_Angry"),
            Nz && clearTimeout(Nz),
            Nz = setTimeout((()=>{
                r.skeleton.skin?.name.includes("Angry") && r.skeleton.setSkinByName((r.skeleton.skin?.name ?? "").split("_")[0] + "_Normal")
            }
            ), 1e3),
            l_.play(gO.Shoot),
            pj(t, o, a)
        }
    }
    )),
    dg.any && window.DeviceOrientationEvent ? window.addEventListener("deviceorientation", Uz, !0) : (document.addEventListener("keydown", zz),
    document.addEventListener("keyup", Vz))
}
  , Uz = t=>{
    if (!XF.room)
        return;
    const e = XF.room;
    if (Date.now() - Fz < 50)
        return;
    const n = pz({
        alpha: Bz.rawAlpha,
        beta: Bz.rawBeta,
        gamma: Bz.rawGamma
    });
    n.x *= -1,
    n.y *= -1,
    n.z *= -1;
    const r = yz(mz(n, pz({
        alpha: t.alpha,
        beta: t.beta,
        gamma: t.gamma
    })));
    XF.orientation.alpha = r.alpha,
    XF.orientation.beta = r.beta,
    XF.orientation.gamma = r.gamma,
    XF.orientation.rawAlpha = t.alpha ?? void 0,
    XF.orientation.rawBeta = t.beta ?? void 0,
    XF.orientation.rawGamma = t.gamma ?? void 0;
    const i = XF.orientation.gamma
      , s = i < 180 ? -1 : 1;
    let o = 0;
    o = -1 === s ? Math.min(40, i) / 40 * s : (40 - Math.max(0, i - 320)) / 40 * s,
    o = -Math.round(2e3 * o) / 1e3,
    hj(e, o),
    Fz = Date.now(),
    Lz || (Lz = !0,
    Object.keys(XF.orientation).forEach((t=>{
        const e = t;
        Bz[e] = XF.orientation[e] ?? 0
    }
    )))
}
  , zz = t=>{
    if (!XF.room || !XF.level)
        return;
    const e = XF.room;
    switch (t.code) {
    case "KeyA":
    case "ArrowLeft":
        Rz || uj(e, "left"),
        Rz = !0;
        break;
    case "KeyD":
    case "ArrowRight":
        Dz || uj(e, "right"),
        Dz = !0
    }
}
  , Vz = t=>{
    if (!XF.level || !XF.room)
        return;
    const e = XF.room
      , n = Rz
      , r = Dz;
    let i = !1;
    switch (t.code) {
    case "KeyA":
    case "ArrowLeft":
        Rz = !1;
        break;
    case "KeyD":
    case "ArrowRight":
        Dz = !1;
        break;
    case "Space":
        Wz(),
        i = !0;
        break;
    case "Escape":
        XF.level.state.paused ? XU() : $U()
    }
    i || uj(e, n && !Rz && Dz ? "right" : r && Rz && !Dz ? "left" : "none")
}
  , Wz = ()=>{
    if (!XF.room || XF.level?.state.paused)
        return;
    const t = XF.room
      , e = XF.level?.state.character
      , n = XF.references.character;
    if (XF.level?.state.ended || !e || !n)
        return;
    const r = {
        x: e.x + e.width / 2,
        y: e.y + e.height / 2
    }
      , i = {
        x: r.x,
        y: r.y - 1e3
    };
    n.skeleton.setSkinByName((n.skeleton.skin?.name ?? "").split("_")[0] + "_Angry"),
    Nz && clearTimeout(Nz),
    Nz = setTimeout((()=>{
        n.skeleton.skin?.name.includes("Angry") && n.skeleton.setSkinByName((n.skeleton.skin?.name ?? "").split("_")[0] + "_Normal")
    }
    ), 1e3),
    l_.play(gO.Shoot),
    pj(t, r, i)
}
  , Yz = async()=>{
    XF.level && XF.viewport && XF.app && (await zU(),
    XF.app.stage.removeAllListeners(),
    XF.app.stage.removeChildren(),
    XF.viewport.destroy(),
    document.removeEventListener("keydown", zz),
    document.removeEventListener("keyup", Vz),
    window.removeEventListener("deviceorientation", Uz),
    clearTimeout(Nz),
    vz())
}
  , Hz = async()=>{
    if (zU(),
    Xz(),
    !XF.viewport || !XF.resources)
        return;
    XF.level = void 0,
    $z();
    const t = (new KC).beginFill(10996218).drawRect(0, 0, QF(), ZF()).endFill()
      , e = new lM(XF.resources["bg-top"])
      , n = .5 * ZF() / e.height;
    e.position.set(0, 0),
    e.scale.set(n, n);
    const r = new lM(XF.resources["bg-bottom"])
      , i = .5 * ZF() / r.height;
    r.scale.set(i, i),
    r.position.set(0, ZF() - r.height);
    const s = new lM(XF.resources.logo)
      , o = .7 * QF() / s.width;
    s.scale.set(o, o),
    s.position.set(QF() / 2 - s.width / 2, .12 * ZF());
    const a = new GF(XF.resources.earth.spineData);
    a.position.set(.5 * QF(), ZF()),
    a.scale.set(qF(), qF()),
    a.state.setAnimation(0, "IDLE", !0),
    a.state.timeScale = .5;
    const l = new GF(XF.resources.character.spineData);
    l.scale.set(qF() / 2.5, qF() / 2.5),
    l.position.set(QF() / 2, ZF() - .5 * a.height),
    l.skeleton.setSkinByName("Blue/Blue_Normal"),
    l.state.setAnimation(0, "IDLE", !0);
    const c = new lM(XF.resources["play-button"])
      , u = .75 * QF() / c.width;
    c.scale.set(u, u),
    c.x = QF() / 2 - c.width / 2,
    c.y = ZF() / 2;
    const h = new KC;
    h.beginFill(0, 1e-10).drawRect(0, 0, QF(), ZF()),
    h.interactive = !0,
    h.cursor = "pointer",
    h.on("pointertap", (()=>{
        XF.viewport && (l_.find(gO.GamePlay).play(),
        vz())
    }
    ));
    const d = new lM(XF.resources.ranking)
      , f = .9 * qF();
    d.scale.set(f, f),
    d.position.set(QF() - 20 - d.width, ZF() - 20 - d.height),
    d.interactive = !0,
    d.cursor = "pointer",
    d.on("pointertap", (t=>{
        XF.external.openLeaderboard && (l_.find(gO.GameOk).play(),
        XF.external.openLeaderboard(),
        t.stopImmediatePropagation())
    }
    ));
    const p = new lM(XF.resources.profile)
      , m = .9 * qF();
    if (p.scale.set(m, m),
    p.position.set(20, ZF() - 20 - p.height),
    p.interactive = !0,
    p.cursor = "pointer",
    p.on("pointertap", (t=>{
        XF.external.openProfile && (l_.find(gO.GameOk).play(),
        XF.external.openProfile(),
        t.stopImmediatePropagation())
    }
    )),
    XF.viewport.addChild(t, e, r, s, a, l, c, h, d, p),
    XF.external.getWhitelistAvailableRequest && (await XF.external.getWhitelistAvailableRequest()).whitelistAvailable) {
        const t = new lM(XF.resources["claim-wl-button"])
          , e = c.width / t.width * .65;
        t.scale.set(e, e),
        t.x = QF() / 2 - t.width / 2,
        t.y = ZF() / 2 - c.height,
        t.interactive = !0,
        t.cursor = "pointer",
        t.on("pointertap", (t=>{
            XF.viewport && XF.external.openClaim && (l_.find(gO.GameOk).play(),
            XF.external.openClaim(),
            t.stopImmediatePropagation())
        }
        )),
        MO.add(t, {
            alpha: .5
        }, {
            repeat: -1,
            ease: "easeInOutQuad",
            reverse: !0
        }),
        XF.viewport.addChild(t)
    }
}
  , $z = ()=>{
    l_.stopAll(),
    _j(gO.Music1)
}
  , Gz = async(t,n,r)=>{
    if (!t)
        return;
    XF.external = {
        ...n
    },
    XF.exited = !1,
    Xm.PREFER_ENV = Mm.WEBGL2,
    KC.curves.maxLength = 3;
    const i = t.parentElement
      , s = new RM({
        view: t,
        resolution: Math.max(2, window.devicePixelRatio),
        autoDensity: !0,
        antialias: !0,
        resizeTo: i,
        backgroundAlpha: 0
    });
    XF.app = s,
    s.stage.interactive = !0,
    s.ticker.stop();
    const o = JE
      , a = ()=>{
        s.ticker.update()
    }
    ;
    mI.ticker.add(a),
    XF.external.clearGame = async()=>{
        XF.exited = !0,
        mI.ticker.remove(a),
        o.unloadBundle("meegos"),
        l_.removeAll(),
        s.destroy(),
        XF.room && await zU(),
        XF.external.clearGame = void 0
    }
    ;
    const l = new (e(h_))("Inter");
    let c;
    o.addBundle("meegos", {
        [`platform-${cO.Blue}`]: `${xj}/platforms/${cO.Blue}.png`,
        [`platform-${cO.Green}`]: `${xj}/platforms/${cO.Green}.png`,
        [`platform-${cO.Pink}`]: `${xj}/platforms/${cO.Pink}.png`,
        [`platform-${cO.Teal}`]: `${xj}/platforms/${cO.Teal}.png`,
        [`platform-${cO.Yellow}`]: `${xj}/platforms/${cO.Yellow}.png`,
        [`platform-${cO.Spike}`]: `${xj}/platforms/${cO.Spike}.png`,
        [`platform-${cO.Lava}`]: `${xj}/platforms/${cO.Lava}.png`,
        [`platform-${cO.Grass}`]: `${xj}/platforms/${cO.Grass}.png`,
        "bg-cloud": `${xj}/bg/cloud.png`,
        "bg-heart": `${xj}/bg/heart.png`,
        "bg-polygon": `${xj}/bg/polygon.png`,
        "bg-polygon-yellow": `${xj}/bg/polygon-yellow.png`,
        "bg-water-drop": `${xj}/bg/water-drop.png`,
        logo: `${xj}/ui/logo.png`,
        "yellow-reverted-button": `${xj}/ui/yellow-reverted-button.png`,
        "blue-button": `${xj}/ui/blue-button.png`,
        "red-button": `${xj}/ui/red-button.png`,
        "claim-wl-button": `${xj}/ui/claim-wl-button.png`,
        "homescreen-button": `${xj}/ui/homescreen-button.png`,
        "retry-button": `${xj}/ui/retry-button.png`,
        "life-button": `${xj}/ui/life-button.png`,
        "buy-nft-button": `${xj}/ui/buy-nft-button.png`,
        "play-button": `${xj}/ui/play-button.png`,
        "tweet-button": `${xj}/ui/tweet-button.png`,
        score: `${xj}/ui/score.png`,
        pause: `${xj}/ui/pause-button.png`,
        ranking: `${xj}/ui/ranking.png`,
        refresh: `${xj}/ui/refresh.png`,
        heart: `${xj}/ui/heart.png`,
        top1: `${xj}/ui/top-1.png`,
        "score-title": `${xj}/ui/score-title.png`,
        "continue-title": `${xj}/ui/continue-title.png`,
        "pause-title": `${xj}/ui/pause-title.png`,
        "pause-text": `${xj}/ui/pause-text.png`,
        trophy: `${xj}/ui/trophy.png`,
        profile: `${xj}/ui/profile.png`,
        rocket: `${xj}/ui/rocket.png`,
        shield: `${xj}/ui/shield.png`,
        "small-popup": `${xj}/ui/small-popup.png`,
        "normal-popup": `${xj}/ui/normal-popup.png`,
        "volume-on": `${xj}/ui/volume-on.png`,
        "volume-off": `${xj}/ui/volume-off.png`,
        "bg-top": `${xj}/ui/main-bg-top.jpg`,
        "bg-bottom": `${xj}/ui/main-bg-bottom.jpg`,
        earth: `${Ej}/earth/Earth.json`,
        character: `${Ej}/character/Characters.json`,
        bat: `${Ej}/monsters/Bat.json`,
        ghost: `${Ej}/monsters/Ghost.json`,
        octopus: `${Ej}/monsters/Octopus.json`,
        monster: `${Ej}/monsters/Monster.json`,
        items: `${Ej}/items/Items.json`,
        blackhole: `${Ej}/blackhole/Blackhole.json`,
        life: `${Ej}/heart/Heart.json`,
        "platform-rock": `${Ej}/platforms/rock/Platform_Rock.json`,
        "platform-jumper": `${Ej}/platforms/jumper/Platform_Jumper.json`,
        fireParticle: `${xj}/particles/fire.png`,
        circleParticle: `${xj}/particles/circle.png`
    });
    try {
        if (r) {
            r(0);
            let t = 0
              , e = 0;
            const n = (n,i)=>{
                void 0 !== n && (t = n),
                void 0 !== i && (e = i),
                r(.5 * t + .5 * e, XF.exited)
            }
            ;
            Mj((t=>{
                n(t)
            }
            ), (()=>{
                n(100)
            }
            )),
            c = await o.loadBundle("meegos", (t=>n(void 0, t))),
            n(void 0, 100)
        } else
            Mj(),
            c = await o.loadBundle("meegos")
    } catch (t) {
        return console.error(t),
        void (!XF.exited && XF.external.clearGame && (XF.exited = !0,
        XF.external.clearGame(),
        XF.external.showLoading && XF.external.showLoading(!1),
        XF.external.showModal && XF.external.showModal({
            title: "Error",
            text: "Impossible to load the graphic resources, please check your internet connection and refresh the page"
        })))
    }
    return XF.resources = c,
    Promise.all([l.load()]).then((()=>{
        r && r(100),
        s.resize(),
        Hz(),
        s.ticker.add((t=>{
            const n = new (e(u_))(t).mul(10).round().div(10).toNumber();
            qz(n)
        }
        ))
    }
    )).catch((t=>{
        console.error("loading failed", t)
    }
    )),
    XF.external.clearGame
}
  , Xz = ()=>{
    if (!XF.app || !XF.resources)
        return;
    if (XF.viewport)
        try {
            XF.viewport.destroy()
        } catch (t) {
            console.error(t)
        }
    XF.app.stage.removeChildren(),
    XF.app.stage.removeAllListeners();
    const t = new sM({
        screenWidth: QF(),
        screenHeight: ZF(),
        events: XF.app.renderer.events
    });
    XF.app.renderer.on("resize", (()=>{
        XF.external.showModal && XF.external.showModal({
            title: "Do not change the size of the game",
            text: "Changing the size of the game can create visual bugs. Please, put the size back to previous one or refresh the page with the desired size."
        })
    }
    )),
    t.sortableChildren = !0,
    XF.app.stage.addChild(t),
    XF.viewport = t;
    const e = new EI;
    e.zIndex = 95,
    XF.particles.container = e,
    t.addChild(e)
}
  , qz = t=>{
    XF.level?.state.paused || (Kz(t),
    !XF.level || XF.level.state.paused || XF.level.state.ended || (Pz(t),
    Oz(t),
    Cz(t),
    (XF.references.ui.level.countdowns ?? []).forEach((({container: t, startingTime: e, endingTime: n, graphics: r},i)=>{
        if (!XF.app)
            return;
        const s = ((new Date).getTime() - e) / (n - e);
        s >= 1 ? (XF.app.stage.removeChild(t),
        XF.references.ui.level.countdowns?.splice(i, 1)) : r.clear().lineStyle(4 * qF(), 6298133).arc(0, 0, 20 * qF(), 0, 360 * (1 - s) * Math.PI / 180, !1)
    }
    )),
    (XF.references.ui.level.countdowns ?? []).forEach((({container: t},e)=>{
        t.y = 50 * e + .15 * ZF()
    }
    ))))
}
  , Kz = t=>{
    XF.particles.emitters?.forEach((e=>{
        e.update(.01 * t)
    }
    ))
}
;
d = o("acw62"),
d = o("acw62");
var Qz, Zz, Jz, tV, eV, nV, rV, iV, sV, oV, aV, lV, cV, uV, hV, dV, fV, pV, mV, gV, yV, bV, vV = {};
t(vV, "loader", (()=>Qz), (t=>Qz = t)),
t(vV, "my-score", (()=>Zz), (t=>Zz = t)),
t(vV, "tabs", (()=>Jz), (t=>Jz = t)),
t(vV, "container", (()=>tV), (t=>tV = t)),
t(vV, "close", (()=>eV), (t=>eV = t)),
t(vV, "score", (()=>nV), (t=>nV = t)),
t(vV, "list", (()=>rV), (t=>rV = t)),
t(vV, "third", (()=>iV), (t=>iV = t)),
t(vV, "my-stats", (()=>sV), (t=>sV = t)),
t(vV, "title", (()=>oV), (t=>oV = t)),
t(vV, "leaderboard", (()=>aV), (t=>aV = t)),
t(vV, "key", (()=>lV), (t=>lV = t)),
t(vV, "rank", (()=>cV), (t=>cV = t)),
t(vV, "entry", (()=>uV), (t=>uV = t)),
t(vV, "my-rank", (()=>hV), (t=>hV = t)),
t(vV, "active", (()=>dV), (t=>dV = t)),
t(vV, "first", (()=>fV), (t=>fV = t)),
t(vV, "list-container", (()=>pV), (t=>pV = t)),
t(vV, "info", (()=>mV), (t=>mV = t)),
t(vV, "second", (()=>gV), (t=>gV = t)),
t(vV, "tab-title", (()=>yV), (t=>yV = t)),
t(vV, "tab", (()=>bV), (t=>bV = t)),
Qz = "iE725G_loader",
Zz = "iE725G_my-score",
Jz = "iE725G_tabs",
tV = "iE725G_container",
eV = "iE725G_close",
nV = "iE725G_score",
rV = "iE725G_list",
iV = "iE725G_third",
sV = "iE725G_my-stats",
oV = "iE725G_title",
aV = "iE725G_leaderboard",
lV = "iE725G_key",
cV = "iE725G_rank",
uV = "iE725G_entry",
hV = "iE725G_my-rank",
dV = "iE725G_active",
fV = "iE725G_first",
pV = "iE725G_list-container",
mV = "iE725G_info",
gV = "iE725G_second",
yV = "iE725G_tab-title",
bV = "iE725G_tab";
const wV = ({className: t, onClose: n, ...r})=>{
    const [i,s] = (0,
    d.useState)("weekly")
      , [o,l] = (0,
    d.useState)()
      , [c,u] = (0,
    d.useState)(!1);
    (0,
    d.useEffect)((()=>{
        u(!0),
        "global" === i ? gd().then((t=>{
            l(t),
            u(!1)
        }
        )).catch(console.error) : "weekly" === i && yd().then((t=>{
            l(t),
            u(!1)
        }
        )).catch(console.error)
    }
    ), [i]);
    const h = t=>1 === t ? "first" : 2 === t ? "second" : 3 === t ? "third" : void 0;
    return (0,
    a.jsx)("div", {
        className: Tr(e(vV), `leaderboard ${t}`),
        ...r,
        children: (0,
        a.jsxs)("div", {
            className: Tr(e(vV), "container"),
            children: [(0,
            a.jsx)("img", {
                className: Tr(e(vV), "title"),
                src: "https://cdn.piratesquadnft.com/clients/meegos/game/visual/ui/ranking-title.png",
                alt: "ranking"
            }), (0,
            a.jsx)("img", {
                className: Tr(e(vV), "close"),
                src: "https://cdn.piratesquadnft.com/clients/meegos/game/visual/ui/exit-button.png",
                alt: "close",
                onClick: ()=>{
                    n()
                }
            }), (0,
            a.jsxs)("div", {
                className: Tr(e(vV), "entry"),
                children: [(0,
                a.jsx)("div", {
                    className: Tr(e(vV), `rank ${h(o?.data?.rank)}`),
                    children: 0 === o?.data?.rank ? "-" : o?.data?.rank
                }), (0,
                a.jsx)("div", {
                    className: Tr(e(vV), "key"),
                    children: "You"
                }), (0,
                a.jsx)("div", {
                    className: Tr(e(vV), "score"),
                    children: 0 === o?.data?.score ? "no score" : o?.data?.score.toLocaleString()
                })]
            }), (0,
            a.jsxs)("div", {
                className: Tr(e(vV), "tabs"),
                children: [(0,
                a.jsx)("div", {
                    className: Tr(e(vV), "tab " + ("weekly" === i ? "active" : "")),
                    onClick: ()=>{
                        s("weekly")
                    }
                    ,
                    children: (0,
                    a.jsx)("div", {
                        className: Tr(e(vV), "tab-title"),
                        children: "Weekly"
                    })
                }), (0,
                a.jsx)("div", {
                    className: Tr(e(vV), "tab " + ("global" === i ? "active" : "")),
                    onClick: ()=>{
                        s("global")
                    }
                    ,
                    children: (0,
                    a.jsx)("div", {
                        className: Tr(e(vV), "tab-title"),
                        children: "Global"
                    })
                })]
            }), (0,
            a.jsx)("div", {
                className: Tr(e(vV), "list-container"),
                children: (0,
                a.jsx)("div", {
                    className: Tr(e(vV), "list"),
                    children: !c && o ? (o.data?.top250 ?? []).map(((t,n)=>(0,
                    a.jsxs)("div", {
                        className: Tr(e(vV), "entry"),
                        children: [(0,
                        a.jsx)("div", {
                            className: Tr(e(vV), `rank ${h(n + 1)}`),
                            children: n + 1
                        }, `${t.publicKey}-rank`), (0,
                        a.jsx)("div", {
                            className: Tr(e(vV), "key"),
                            children: t.discord ? t.discord.split("#")[0] : t.publicKey
                        }, `${t.publicKey}-key`), (0,
                        a.jsx)("div", {
                            className: Tr(e(vV), "score"),
                            children: t.score.toLocaleString()
                        }, `${t.publicKey}-score`)]
                    }, t.publicKey))) : (0,
                    a.jsx)("div", {
                        className: Tr(e(vV), "loader"),
                        children: "Loading..."
                    })
                })
            }), (0,
            a.jsx)("div", {
                className: Tr(e(vV), "info"),
                children: "the leaderboard is computed each minute"
            })]
        })
    })
}
;
var xV, EV, _V, AV, SV, TV = {};
t(TV, "hidden", (()=>xV), (t=>xV = t)),
t(TV, "screen-size", (()=>EV), (t=>EV = t)),
t(TV, "player", (()=>_V), (t=>_V = t)),
t(TV, "desktop", (()=>AV), (t=>AV = t)),
t(TV, "game", (()=>SV), (t=>SV = t)),
xV = "_1njKOG_hidden",
EV = "_1njKOG_screen-size",
_V = "_1njKOG_player",
AV = "_1njKOG_desktop",
SV = "_1njKOG_game";
var kV = {}
  , IV = kV && kV.__createBinding || (Object.create ? function(t, e, n, r) {
    void 0 === r && (r = n);
    var i = Object.getOwnPropertyDescriptor(e, n);
    i && !("get"in i ? !e.__esModule : i.writable || i.configurable) || (i = {
        enumerable: !0,
        get: function() {
            return e[n]
        }
    }),
    Object.defineProperty(t, r, i)
}
: function(t, e, n, r) {
    void 0 === r && (r = n),
    t[r] = e[n]
}
)
  , MV = kV && kV.__exportStar || function(t, e) {
    for (var n in t)
        "default" === n || Object.prototype.hasOwnProperty.call(e, n) || IV(e, t, n)
}
;
Object.defineProperty(kV, "__esModule", {
    value: !0
}),
MV(o("5dlKa"), kV),
MV(o("l0Lrl"), kV),
MV(o("3JSSJ"), kV);
const CV = async(t,e)=>{
    const n = await or.post("https://rpc.helius.xyz/?api-key=0d21c3b6-4281-4904-a588-03ba49bc33f1", {
        jsonrpc: "2.0",
        id: "get-compressed-nfts",
        method: "searchAssets",
        params: {
            ownerAddress: t,
            page: 1,
            limit: 1e3,
            compressed: !0,
            grouping: ["collection", e]
        }
    }, {
        headers: {
            "Content-Type": "application/json"
        }
    })
      , {result: r} = await n.data;
    return r.items ?? []
}
;
d = o("acw62");
const PV = async()=>{
    const t = await ud({
        method: "GET",
        url: "/api/v1/discord/me"
    });
    if (t && 200 === t.status)
        return t.data
}
  , OV = async()=>{
    const t = await ud({
        method: "GET",
        url: "/api/v1/discord/server-joined"
    });
    return !(!t || 200 !== t.status) && t.data
}
  , NV = async()=>{
    const t = await ud({
        method: "GET",
        url: "/api/v1/discord/pkce"
    });
    if (t && 200 === t.status)
        return t.data
}
  , RV = async t=>await ud({
    url: "/api/v1/discord/unlink",
    method: "POST"
}, t);
o("acw62");
var DV, BV, LV, FV, jV = {};
t(jV, "retweet", (()=>DV), (t=>DV = t)),
t(jV, "like", (()=>BV), (t=>BV = t)),
t(jV, "twitter-intent-button", (()=>LV), (t=>LV = t)),
t(jV, "follow", (()=>FV), (t=>FV = t)),
DV = "Nsao0W_retweet",
BV = "Nsao0W_like",
LV = "Nsao0W_twitter-intent-button",
FV = "Nsao0W_follow";
const UV = ({className: t, intentProperty: n, intentValue: r, icon: i, intent: s, text: o, url: l, hashtags: c, related: u, onClick: h, ...d})=>(0,
a.jsx)(Xa, {
    icon: i,
    className: Tr(e(jV), `twitter-intent-button no-color ${t}`),
    onClick: t=>{
        h && h(t),
        (async()=>{
            null === window.open(encodeURI(`https://twitter.com/intent/${s}?original_referer=${window.location}&ref_src=twsrc^tfw|twcamp^buttonembed|twterm^share|twgr^url=/${n ? `&${n}=${r}` : ""}${o ? `&text=${o}` : ""}${l ? `&url=${l}` : ""}${c ? `&hashtags=${c}` : ""}${u ? `&related=${u}` : ""}`), "Meegos - Twitter", "toolbar=1,scrollbars=1,location=0,statusbar=0,menubar=1,resizable=1,width=800,height=600,left=240,top=212") && pe.info("Please disable your adblock to open the Twitter pages")
        }
        )()
    }
    ,
    ...d
})
  , zV = ({className: t, text: n, url: r, hashtags: i, related: s, ...o})=>(0,
a.jsx)(UV, {
    title: "tweet",
    icon: ["fab", "twitter"],
    intent: "tweet",
    text: n,
    url: r,
    hashtags: i,
    related: s,
    className: Tr(e(jV), `tweet ${t}`),
    ...o
});
var VV, WV, YV, HV, $V, GV, XV, qV, KV, QV = {};
t(QV, "twitter", (()=>VV), (t=>VV = t)),
t(QV, "claim", (()=>WV), (t=>WV = t)),
t(QV, "title", (()=>YV), (t=>YV = t)),
t(QV, "step", (()=>HV), (t=>HV = t)),
t(QV, "close", (()=>$V), (t=>$V = t)),
t(QV, "valid", (()=>GV), (t=>GV = t)),
t(QV, "invalid", (()=>XV), (t=>XV = t)),
t(QV, "name", (()=>qV), (t=>qV = t)),
t(QV, "container", (()=>KV), (t=>KV = t)),
VV = "yWOFnq_twitter",
WV = "yWOFnq_claim",
YV = "yWOFnq_title",
HV = "yWOFnq_step",
$V = "yWOFnq_close",
GV = "yWOFnq_valid",
XV = "yWOFnq_invalid",
qV = "yWOFnq_name",
KV = "yWOFnq_container";
const ZV = ({className: t, onClose: n, ...r})=>{
    const {state: {twitterUsername: i, discordUsername: s, discordServerJoined: o}, dispatch: l} = Al()
      , [c,u] = (0,
    d.useState)(!1)
      , [h,f] = (0,
    d.useState)(!1)
      , [p,m] = (0,
    d.useState)(!1)
      , [g,y] = (0,
    d.useState)(!1)
      , b = i && s && o
      , v = g;
    return (0,
    d.useEffect)((()=>{
        o || (async()=>{
            u(!0),
            l({
                type: "SET_DISCORD_SERVER_JOINED",
                discordServerJoined: await OV()
            }),
            u(!1)
        }
        )()
    }
    ), [o]),
    (0,
    a.jsx)("div", {
        className: Tr(e(QV), `claim ${t}`),
        ...r,
        children: (0,
        a.jsxs)("div", {
            className: Tr(e(QV), "container"),
            children: [(0,
            a.jsx)("img", {
                className: Tr(e(QV), "title"),
                src: "https://cdn.piratesquadnft.com/clients/meegos/game/visual/ui/claim-wl-title.png",
                alt: "claim"
            }), (0,
            a.jsx)("img", {
                className: Tr(e(QV), "close"),
                src: "https://cdn.piratesquadnft.com/clients/meegos/game/visual/ui/exit-button.png",
                alt: "close",
                onClick: ()=>{
                    n()
                }
            }), (0,
            a.jsxs)("div", {
                className: Tr(e(QV), "step"),
                children: [(0,
                a.jsxs)("div", {
                    className: Tr(e(QV), "name"),
                    children: [(0,
                    a.jsx)("span", {
                        children: "Step 1:"
                    }), " Connect your Twitter and Discord accounts"]
                }), (0,
                a.jsxs)("ul", {
                    children: [(0,
                    a.jsxs)("li", {
                        children: ["Twitter: ", i ? (0,
                        a.jsx)("span", {
                            className: Tr(e(QV), "valid"),
                            children: "Connected"
                        }) : (0,
                        a.jsx)("span", {
                            className: Tr(e(QV), "invalid"),
                            children: "Not connected"
                        })]
                    }), (0,
                    a.jsxs)("li", {
                        children: ["Discord: ", s ? o ? (0,
                        a.jsx)("span", {
                            className: Tr(e(QV), "valid"),
                            children: "Connected"
                        }) : c ? (0,
                        a.jsx)("span", {
                            children: "Loading..."
                        }) : (0,
                        a.jsx)("span", {
                            className: Tr(e(QV), "invalid"),
                            children: "Join the Meegos Discord server open again this claim page when done"
                        }) : (0,
                        a.jsx)("span", {
                            className: Tr(e(QV), "invalid"),
                            children: "Not connected"
                        })]
                    })]
                }), !b && "Close this screen and go to your profile page to connect your accounts"]
            }), b && (0,
            a.jsxs)("div", {
                className: Tr(e(QV), "step"),
                children: [(0,
                a.jsxs)("div", {
                    className: Tr(e(QV), "name"),
                    children: [(0,
                    a.jsx)("span", {
                        children: "Step 2:"
                    }), " Tweet"]
                }), (0,
                a.jsx)(zV, {
                    iconProps: {
                        stroke: "black",
                        strokeWidth: "32"
                    },
                    className: Tr(e(QV), "twitter"),
                    text: "I just won a @MeegosNFT whitelist spot for placing in the top 250 players this week. Head over to https://jump.meegos.io/ to play and join the fun!",
                    related: "meegosNFT",
                    hashtags: "meegos,meejump",
                    onClick: ()=>{
                        m(!0),
                        setTimeout((()=>{
                            y(!0),
                            m(!1)
                        }
                        ), 15e3)
                    }
                    ,
                    loading: p,
                    children: "Tweet"
                })]
            }), b && v && (0,
            a.jsxs)("div", {
                className: Tr(e(QV), "step"),
                children: [(0,
                a.jsxs)("div", {
                    className: Tr(e(QV), "name"),
                    children: [(0,
                    a.jsx)("span", {
                        children: "Step 3:"
                    }), " Claim"]
                }), (0,
                a.jsx)(Xa, {
                    icon: "gift",
                    iconProps: {
                        stroke: "black",
                        strokeWidth: "32"
                    },
                    onClick: async()=>{
                        f(!0);
                        const t = await vd();
                        200 === t?.status && pe.success("Congrats! You successfully claimed your WL role on Discord (visible on Discord in max 1 minute)"),
                        f(!1)
                    }
                    ,
                    loading: h,
                    children: "Claim"
                })]
            })]
        })
    })
}
;
o("acw62");
const JV = async()=>{
    const t = await ud({
        method: "GET",
        url: "/api/v1/twitter/me"
    });
    if (t && 200 === t.status)
        return t.data
}
  , tW = async()=>{
    const t = await ud({
        method: "GET",
        url: "/api/v1/twitter/pkce"
    });
    if (t && 200 === t.status)
        return t.data
}
  , eW = async t=>await ud({
    url: "/api/v1/twitter/unlink",
    method: "POST"
}, t);
d = o("acw62");
var nW, rW = {};
t(rW, "discord-link-button", (()=>nW), (t=>nW = t)),
nW = "_D2RDa_discord-link-button";
const iW = async()=>{
    const t = await NV();
    if (!t)
        return void pe.error("Impossible to connect with Twitter, please try again later or contact the support team");
    const {state: e} = t
      , n = {
        redirect_uri: `${window.location.origin}/api/v1/discord/oauth`,
        client_id: "1114256991817314305",
        state: e,
        response_type: "code",
        scope: ["identify", "guilds"].join(" ")
    };
    return `https://discord.com/api/oauth2/authorize?${new URLSearchParams(n).toString()}`
}
;
let sW, oW = 1;
const aW = ({className: t, value: n, ...r})=>{
    const {dispatch: i, state: {discordUsername: s}} = Al()
      , [o,l] = (0,
    d.useState)(!1)
      , [c,u] = (0,
    d.useState)()
      , [h,f] = (0,
    d.useState)(1)
      , p = async()=>{
        const t = await PV();
        if (t?.discordUsername)
            return l(!1),
            i({
                type: "SET_DISCORD_USERNAME",
                discordUsername: t.discordUsername
            }),
            i({
                type: "SET_DISCORD_SERVER_JOINED",
                discordServerJoined: t.serverJoined
            }),
            t.discordUsername
    }
    ;
    return (0,
    a.jsx)(a.Fragment, {
        children: s ? (0,
        a.jsx)(Xa, {
            icon: ["fab", "discord"],
            className: Tr(e(rW), `discord-link-button no-color ${t}`),
            disabled: o,
            iconProps: {
                stroke: "black",
                strokeWidth: "32"
            },
            ...r,
            children: (0,
            a.jsx)("span", {
                children: n ?? s
            })
        }) : (0,
        a.jsx)(Xa, {
            icon: ["fab", "discord"],
            className: Tr(e(rW), `discord-link-button ${t}`),
            onClick: async()=>{
                let t;
                if (l(!0),
                i({
                    type: "SET_DISCORD_USERNAME",
                    discordUsername: void 0
                }),
                i({
                    type: "SET_DISCORD_SERVER_JOINED",
                    discordServerJoined: void 0
                }),
                f(1),
                oW = 1,
                (kd.isIOS || kd.isAndroid) && Ar && bl.showLoading && bl.showLoading(!0),
                c)
                    t = c;
                else if (t = await iW(),
                !t)
                    return void l(!1);
                if ((kd.isIOS || kd.isAndroid) && Ar)
                    return void window.location.replace(t);
                null === window.open(t, "MeeJump - Discord Link", "toolbar=1,scrollbars=1,location=0,statusbar=0,menubar=1,resizable=1,width=800,height=600,left=240,top=212") ? (l(!1),
                c || pe.info("Please click again on the Discord button (normal process if you have an adblock 😉)"),
                u(t)) : (bl.showLoading && bl.showLoading(!0, void 0, "Linking Discord, please wait..."),
                u(void 0),
                sW = setInterval((async()=>{
                    if (++oW,
                    f(oW),
                    oW >= 5)
                        l(!1),
                        clearInterval(sW),
                        bl.showLoading && bl.showLoading(!1),
                        pe.error("Impossible to refresh the Discord user, if you successfully authorized the connection, please refresh this page and reconnect");
                    else
                        try {
                            await p() && (clearInterval(sW),
                            bl.showLoading && bl.showLoading(!1),
                            pe.success("Discord successfully connected to your account"))
                        } catch (t) {
                            console.error(t),
                            l(!1),
                            clearInterval(sW),
                            bl.showLoading && bl.showLoading(!1),
                            pe.error("Impossible to refresh the Discord user, if you successfully authorized the connection, please refresh this page and reconnect")
                        }
                }
                ), 1e4))
            }
            ,
            disabled: o,
            iconProps: {
                stroke: "black",
                strokeWidth: "32"
            },
            ...r,
            children: (0,
            a.jsx)("span", {
                children: o ? `Checking... (${h}/5)` : n ?? "Link Discord"
            })
        })
    })
}
;
d = o("acw62");
var lW, cW = {};
t(cW, "twitter-link-button", (()=>lW), (t=>lW = t)),
lW = "_7m9WEq_twitter-link-button";
const uW = async()=>{
    const t = await tW();
    if (!t)
        return void pe.error("Impossible to connect with Twitter, please try again later or contact the support team");
    const {state: e, codeChallenge: n} = t
      , r = {
        redirect_uri: `${window.location.origin}/api/v1/twitter/oauth`,
        client_id: "NU5RVXhJWFVWaFo3dWdmXzNIazE6MTpjaQ",
        state: e,
        response_type: "code",
        code_challenge: n,
        code_challenge_method: "S256",
        scope: ["users.read", "tweet.read", "follows.read"].join(" ")
    };
    return `https://twitter.com/i/oauth2/authorize?${new URLSearchParams(r).toString()}`
}
;
let hW, dW = 1;
const fW = ({className: t, value: n, ...r})=>{
    const {dispatch: i, state: {twitterUsername: s}} = Al()
      , [o,l] = (0,
    d.useState)(!1)
      , [c,u] = (0,
    d.useState)()
      , [h,f] = (0,
    d.useState)(1)
      , p = async()=>{
        const t = await JV();
        if (t?.twitterUsername)
            return l(!1),
            i({
                type: "SET_TWITTER_USERNAME",
                twitterUsername: t.twitterUsername
            }),
            t.twitterUsername
    }
    ;
    return (0,
    a.jsx)(a.Fragment, {
        children: s ? (0,
        a.jsx)(Xa, {
            icon: ["fab", "twitter"],
            className: Tr(e(cW), `twitter-link-button no-color ${t}`),
            disabled: o,
            iconProps: {
                stroke: "black",
                strokeWidth: "32"
            },
            ...r,
            children: (0,
            a.jsx)("span", {
                children: n ?? s
            })
        }) : (0,
        a.jsx)(Xa, {
            icon: ["fab", "twitter"],
            className: Tr(e(cW), `twitter-link-button no-color ${t}`),
            onClick: async()=>{
                let t;
                if (l(!0),
                i({
                    type: "SET_TWITTER_USERNAME",
                    twitterUsername: void 0
                }),
                f(1),
                dW = 1,
                (kd.isIOS || kd.isAndroid) && Ar && bl.showLoading && bl.showLoading(!0),
                c)
                    t = c;
                else if (t = await uW(),
                !t)
                    return void l(!1);
                if ((kd.isIOS || kd.isAndroid) && Ar)
                    return void window.location.replace(t);
                null === window.open(t, "MeeJump - Twitter Link", "toolbar=1,scrollbars=1,location=0,statusbar=0,menubar=1,resizable=1,width=800,height=600,left=240,top=212") ? (l(!1),
                c || pe.info("Please click again on the Twitter button (normal process if you have an adblock 😉)"),
                u(t)) : (bl.showLoading && bl.showLoading(!0, void 0, "Linking Twitter, please wait..."),
                u(void 0),
                hW = setInterval((async()=>{
                    if (++dW,
                    f(dW),
                    dW >= 5)
                        l(!1),
                        clearInterval(hW),
                        bl.showLoading && bl.showLoading(!1),
                        pe.error("Impossible to refresh the Twitter user, if you successfully authorized the connection, please refresh this page and reconnect");
                    else
                        try {
                            await p() && (clearInterval(hW),
                            bl.showLoading && bl.showLoading(!1),
                            pe.success("Twitter successfully connected to your account"))
                        } catch (t) {
                            console.error(t),
                            l(!1),
                            clearInterval(hW),
                            bl.showLoading && bl.showLoading(!1),
                            pe.error("Impossible to refresh the Twitter user, if you successfully authorized the connection, please refresh this page and reconnect")
                        }
                }
                ), 1e4))
            }
            ,
            disabled: o,
            iconProps: {
                stroke: "black",
                strokeWidth: "32"
            },
            ...r,
            children: (0,
            a.jsx)("span", {
                children: o ? `Please wait... (${h}/5)` : n ?? "Link Twitter"
            })
        })
    })
}
;
var pW, mW, gW, yW, bW, vW = {};
t(vW, "close", (()=>pW), (t=>pW = t)),
t(vW, "title", (()=>mW), (t=>mW = t)),
t(vW, "container", (()=>gW), (t=>gW = t)),
t(vW, "profile", (()=>yW), (t=>yW = t)),
t(vW, "line", (()=>bW), (t=>bW = t)),
pW = "yelJSa_close",
mW = "yelJSa_title",
gW = "yelJSa_container",
yW = "yelJSa_profile",
bW = "yelJSa_line";
const wW = ({className: t, onClose: n, ...r})=>{
    const {dispatch: i, state: {twitterUsername: s, discordUsername: o}} = Al()
      , l = ()=>{
        eW(),
        i({
            type: "SET_TWITTER_USERNAME",
            twitterUsername: void 0
        })
    }
      , c = ()=>{
        RV(),
        i({
            type: "SET_DISCORD_USERNAME",
            discordUsername: void 0
        }),
        i({
            type: "SET_DISCORD_SERVER_JOINED",
            discordServerJoined: void 0
        })
    }
    ;
    return (0,
    a.jsx)("div", {
        className: Tr(e(vW), `profile ${t}`),
        ...r,
        children: (0,
        a.jsxs)("div", {
            className: Tr(e(vW), "container"),
            children: [(0,
            a.jsx)("img", {
                className: Tr(e(vW), "title"),
                src: "https://cdn.piratesquadnft.com/clients/meegos/game/visual/ui/profile-title.png",
                alt: "profile"
            }), (0,
            a.jsx)("img", {
                className: Tr(e(vW), "close"),
                src: "https://cdn.piratesquadnft.com/clients/meegos/game/visual/ui/exit-button.png",
                alt: "close",
                onClick: ()=>{
                    n()
                }
            }), (0,
            a.jsx)("p", {
                children: "Connect your accounts"
            }), (0,
            a.jsxs)("div", {
                className: Tr(e(vW), "line"),
                children: [(0,
                a.jsx)("div", {}), (0,
                a.jsx)(fW, {}), s && (0,
                a.jsx)("img", {
                    src: "https://cdn.piratesquadnft.com/clients/meegos/game/visual/ui/delete-button.png",
                    alt: "disconnect twitter",
                    onClick: ()=>{
                        bl.showConfirm && bl.showConfirm({
                            title: "Are you sure you want to remove the linked Twitter account?",
                            onAccept: l,
                            acceptText: "yes",
                            refuseText: "cancel"
                        })
                    }
                })]
            }), (0,
            a.jsxs)("div", {
                className: Tr(e(vW), "line"),
                children: [(0,
                a.jsx)("div", {}), (0,
                a.jsx)(aW, {}), o && (0,
                a.jsx)("img", {
                    src: "https://cdn.piratesquadnft.com/clients/meegos/game/visual/ui/delete-button.png",
                    alt: "disconnect discord",
                    onClick: ()=>{
                        bl.showConfirm && bl.showConfirm({
                            title: "Are you sure you want to remove the linked Discord account?",
                            onAccept: c,
                            acceptText: "yes",
                            refuseText: "cancel"
                        })
                    }
                })]
            })]
        })
    })
}
  , xW = ({className: t, ...n})=>{
    const {game: r} = mt()
      , {state: {publicKey: i}} = Al()
      , {connection: s} = Rl()
      , o = (0,
    d.useRef)(null)
      , l = (0,
    d.useRef)(null)
      , [c,u] = (0,
    d.useState)(!1)
      , [h,f] = (0,
    d.useState)()
      , [p,m] = (0,
    d.useState)(!1)
      , [g,y] = (0,
    d.useState)()
      , [b,v] = (0,
    d.useState)(!1)
      , [w,x] = (0,
    d.useState)()
      , [E,_] = (0,
    d.useState)(!1)
      , [A,S] = (0,
    d.useState)(!1)
      , [T,k] = (0,
    d.useState)(!1)
      , [I,M] = (0,
    d.useState)(!1)
      , C = async()=>{
        if (!i)
            return;
        return (await CV(i, "HPyb9JaYa6xHK28pgxek7cad9i1GwUK7JaFgRqGBa1HG") ?? []).length
    }
      , P = async()=>{
        if (!i || !bl.sendTransaction)
            return;
        pe.info("Creating the transaction...");
        const t = await wd()
          , e = t?.data;
        if (e) {
            const t = {
                accounts: {
                    merkleTree: new (0,
                    Er.PublicKey)(e.accounts.merkleTree),
                    treeAuthority: new (0,
                    Er.PublicKey)(e.accounts.treeAuthority),
                    leafOwner: new (0,
                    Er.PublicKey)(e.accounts.leafOwner),
                    leafDelegate: new (0,
                    Er.PublicKey)(e.accounts.leafDelegate),
                    newLeafOwner: new (0,
                    Er.PublicKey)(e.accounts.newLeafOwner),
                    logWrapper: new (0,
                    Er.PublicKey)(e.accounts.logWrapper),
                    compressionProgram: new (0,
                    Er.PublicKey)(e.accounts.compressionProgram),
                    anchorRemainingAccounts: e.accounts.anchorRemainingAccounts.map((t=>({
                        ...t,
                        pubkey: new (0,
                        Er.PublicKey)(t.pubkey)
                    })))
                },
                args: e.args,
                programId: new (0,
                Er.PublicKey)(e.programId)
            }
              , n = (0,
            kV.createTransferInstruction)(t.accounts, t.args, t.programId)
              , {context: {slot: r}, value: {blockhash: o, lastValidBlockHeight: a}} = await s.getLatestBlockhashAndContext()
              , l = (new (0,
            Er.Transaction)).add(n);
            l.feePayer = new (0,
            Er.PublicKey)(i);
            const c = await bl.sendTransaction(l, s, {
                minContextSlot: r
            });
            pe.info("Confirming the transaction..."),
            await s.confirmTransaction({
                blockhash: o,
                lastValidBlockHeight: a,
                signature: c
            }, "confirmed");
            const u = await xd(c, (()=>{
                bl.showModal && bl.showModal({
                    title: "Impossible to validate the transaction",
                    text: "Due to a slow Solana network, it was impossible to validate the transaction. Please click again in 2 minutes"
                })
            }
            ));
            if (u?.data.id)
                return pe.success("MeeJump NFT used!"),
                e.availableNFT
        }
    }
      , O = ()=>{
        l.current && (l.current.offsetWidth > l.current.offsetHeight && kd.isMobile ? S(!0) : S(!1),
        l.current.offsetWidth < 200 || l.current.offsetHeight < 350 || l.current.offsetWidth > 1e4 || l.current.offsetHeight > 1e4 ? _(!0) : _(!1),
        k(!0))
    }
    ;
    return (0,
    d.useEffect)((()=>(bl.clearGame && bl.clearGame(),
    window.addEventListener("resize", O),
    O(),
    ()=>{
        window.removeEventListener("resize", O)
    }
    )), []),
    (0,
    d.useEffect)((()=>{
        if (!o.current || !T || A || E || I)
            return;
        bl.showLoading && bl.showLoading(!0, 0);
        const t = ()=>{
            u(!1),
            f(void 0)
        }
          , e = ()=>{
            m(!1),
            y(void 0)
        }
          , n = ()=>{
            v(!1),
            x(void 0)
        }
        ;
        Gz(o.current, {
            showLoading: bl.showLoading,
            showModal: bl.showModal,
            openLeaderboard: ()=>{
                u(!0),
                f((0,
                a.jsx)(wV, {
                    onClose: t
                }))
            }
            ,
            openProfile: ()=>{
                m(!0),
                y((0,
                a.jsx)(wW, {
                    onClose: e
                }))
            }
            ,
            openClaim: ()=>{
                v(!0),
                x((0,
                a.jsx)(ZV, {
                    onClose: n
                }))
            }
            ,
            tryOrReconnect: ud,
            getSessionToken: ()=>bl.sessionToken,
            getLoadBalancerRequest: pd,
            useNFTForLife: P,
            getNumberOfAvailableNFT: C,
            getEstimatedLeaderboard: md,
            getWhitelistAvailableRequest: bd
        }, ((t,e)=>{
            bl.showLoading && !e && (100 === t ? bl.showLoading(!1) : bl.showLoading(!0, Math.floor(t)))
        }
        )).then((t=>{
            bl.clearGame = ()=>{
                t && t(),
                bl.clearGame = void 0
            }
        }
        )).catch((t=>{
            pe.error("Error while retreiving the game state, please try again later or contact the support team"),
            console.error(t)
        }
        )),
        M(!0)
    }
    ), [o, r, A, E, T, I]),
    (0,
    a.jsxs)("div", {
        className: Tr(e(TV), `player ${kd.isDesktop ? "desktop" : ""} ${t}`),
        ...n,
        onContextMenu: t=>{
            t.preventDefault()
        }
        ,
        children: [(0,
        a.jsx)(dl, {
            show: A,
            children: (0,
            a.jsx)("div", {
                className: Tr(e(TV), "screen-size"),
                children: (0,
                a.jsx)("p", {
                    children: "Please use your mobile in portrait orientation to play the game"
                })
            })
        }), (0,
        a.jsx)(dl, {
            show: E && !A,
            children: (0,
            a.jsxs)("div", {
                className: Tr(e(TV), "screen-size"),
                children: [(0,
                a.jsx)("p", {
                    children: "You screen is too small (width < 200px or height < 350px) or too big (width > 10000px, height > 10000px)."
                }), (0,
                a.jsx)("p", {
                    children: "To play the game, please modify the size of your window (desktop) or connect with a compatible device (mobile)."
                })]
            })
        }), (0,
        a.jsxs)("div", {
            ref: l,
            className: Tr(e(TV), "game " + (E ? "hidden" : "")),
            children: [c && h, p && g, b && w, (0,
            a.jsx)("canvas", {
                ref: o
            })]
        })]
    })
}
  , EW = ()=>(0,
a.jsx)(_l, {
    children: (0,
    a.jsx)(Dt, {
        children: (0,
        a.jsx)(Ct, {
            children: (0,
            a.jsxs)(It, {
                element: (0,
                a.jsx)(Ol, {}),
                children: [(0,
                a.jsx)(It, {
                    element: (0,
                    a.jsx)(cd, {}),
                    children: (0,
                    a.jsxs)(It, {
                        path: "dashboard",
                        element: (0,
                        a.jsx)(Tm, {}),
                        children: [(0,
                        a.jsx)(It, {
                            path: "game",
                            element: (0,
                            a.jsx)(xW, {})
                        }), (0,
                        a.jsx)(It, {
                            path: "*",
                            element: (0,
                            a.jsx)(Tt, {
                                to: "game",
                                replace: !0
                            })
                        }), (0,
                        a.jsx)(It, {
                            index: !0,
                            element: (0,
                            a.jsx)(Tt, {
                                to: "game",
                                replace: !0
                            })
                        })]
                    })
                }), (0,
                a.jsx)(It, {
                    path: "*",
                    element: (0,
                    a.jsx)(Tt, {
                        to: "dashboard"
                    })
                })]
            })
        })
    })
});
var _W = {
    prefix: "fab",
    iconName: "discord",
    icon: [640, 512, [], "f392", "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"]
}
  , AW = {
    prefix: "fab",
    iconName: "twitter",
    icon: [512, 512, [], "f099", "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"]
}
  , SW = {
    prefix: "fas",
    iconName: "right-from-bracket",
    icon: [512, 512, ["sign-out-alt"], "f2f5", "M377.9 105.9L500.7 228.7c7.2 7.2 11.3 17.1 11.3 27.3s-4.1 20.1-11.3 27.3L377.9 406.1c-6.4 6.4-15 9.9-24 9.9c-18.7 0-33.9-15.2-33.9-33.9l0-62.1-128 0c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32l128 0 0-62.1c0-18.7 15.2-33.9 33.9-33.9c9 0 17.6 3.6 24 9.9zM160 96L96 96c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-64 0c-53 0-96-43-96-96L0 128C0 75 43 32 96 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32z"]
}
  , TW = {
    prefix: "fas",
    iconName: "pencil",
    icon: [512, 512, [9999, 61504, "pencil-alt"], "f303", "M410.3 231l11.3-11.3-33.9-33.9-62.1-62.1L291.7 89.8l-11.3 11.3-22.6 22.6L58.6 322.9c-10.4 10.4-18 23.3-22.2 37.4L1 480.7c-2.5 8.4-.2 17.5 6.1 23.7s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L387.7 253.7 410.3 231zM160 399.4l-9.1 22.7c-4 3.1-8.5 5.4-13.3 6.9L59.4 452l23-78.1c1.4-4.9 3.8-9.4 6.9-13.3l22.7-9.1v32c0 8.8 7.2 16 16 16h32zM362.7 18.7L348.3 33.2 325.7 55.8 314.3 67.1l33.9 33.9 62.1 62.1 33.9 33.9 11.3-11.3 22.6-22.6 14.5-14.5c25-25 25-65.5 0-90.5L453.3 18.7c-25-25-65.5-25-90.5 0zm-47.4 168l-144 144c-6.2 6.2-16.4 6.2-22.6 0s-6.2-16.4 0-22.6l144-144c6.2-6.2 16.4-6.2 22.6 0s6.2 16.4 0 22.6z"]
}
  , kW = {
    prefix: "fas",
    iconName: "comments",
    icon: [640, 512, [128490, 61670], "f086", "M208 352c114.9 0 208-78.8 208-176S322.9 0 208 0S0 78.8 0 176c0 38.6 14.7 74.3 39.6 103.4c-3.5 9.4-8.7 17.7-14.2 24.7c-4.8 6.2-9.7 11-13.3 14.3c-1.8 1.6-3.3 2.9-4.3 3.7c-.5 .4-.9 .7-1.1 .8l-.2 .2 0 0 0 0C1 327.2-1.4 334.4 .8 340.9S9.1 352 16 352c21.8 0 43.8-5.6 62.1-12.5c9.2-3.5 17.8-7.4 25.3-11.4C134.1 343.3 169.8 352 208 352zM448 176c0 112.3-99.1 196.9-216.5 207C255.8 457.4 336.4 512 432 512c38.2 0 73.9-8.7 104.7-23.9c7.5 4 16 7.9 25.2 11.4c18.3 6.9 40.3 12.5 62.1 12.5c6.9 0 13.1-4.5 15.2-11.1c2.1-6.6-.2-13.8-5.8-17.9l0 0 0 0-.2-.2c-.2-.2-.6-.4-1.1-.8c-1-.8-2.5-2-4.3-3.7c-3.6-3.3-8.5-8.1-13.3-14.3c-5.5-7-10.7-15.4-14.2-24.7c24.9-29 39.6-64.7 39.6-103.4c0-92.8-84.9-168.9-192.6-175.5c.4 5.1 .6 10.3 .6 15.5z"]
}
  , IW = {
    prefix: "fas",
    iconName: "clipboard-list",
    icon: [384, 512, [], "f46d", "M192 0c-41.8 0-77.4 26.7-90.5 64H64C28.7 64 0 92.7 0 128V448c0 35.3 28.7 64 64 64H320c35.3 0 64-28.7 64-64V128c0-35.3-28.7-64-64-64H282.5C269.4 26.7 233.8 0 192 0zm0 64a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM72 272a24 24 0 1 1 48 0 24 24 0 1 1 -48 0zm104-16H304c8.8 0 16 7.2 16 16s-7.2 16-16 16H176c-8.8 0-16-7.2-16-16s7.2-16 16-16zM72 368a24 24 0 1 1 48 0 24 24 0 1 1 -48 0zm88 0c0-8.8 7.2-16 16-16H304c8.8 0 16 7.2 16 16s-7.2 16-16 16H176c-8.8 0-16-7.2-16-16z"]
}
  , MW = {
    prefix: "fas",
    iconName: "circle-notch",
    icon: [512, 512, [], "f1ce", "M222.7 32.1c5 16.9-4.6 34.8-21.5 39.8C121.8 95.6 64 169.1 64 256c0 106 86 192 192 192s192-86 192-192c0-86.9-57.8-160.4-137.1-184.1c-16.9-5-26.6-22.9-21.5-39.8s22.9-26.6 39.8-21.5C434.9 42.1 512 140 512 256c0 141.4-114.6 256-256 256S0 397.4 0 256C0 140 77.1 42.1 182.9 10.6c16.9-5 34.8 4.6 39.8 21.5z"]
}
  , CW = {
    prefix: "fas",
    iconName: "reply",
    icon: [512, 512, [61714, "mail-reply"], "f3e5", "M205 34.8c11.5 5.1 19 16.6 19 29.2v64H336c97.2 0 176 78.8 176 176c0 113.3-81.5 163.9-100.2 174.1c-2.5 1.4-5.3 1.9-8.1 1.9c-10.9 0-19.7-8.9-19.7-19.7c0-7.5 4.3-14.4 9.8-19.5c9.4-8.8 22.2-26.4 22.2-56.7c0-53-43-96-96-96H224v64c0 12.6-7.4 24.1-19 29.2s-25 3-34.4-5.4l-160-144C3.9 225.7 0 217.1 0 208s3.9-17.7 10.6-23.8l160-144c9.4-8.5 22.9-10.6 34.4-5.4z"]
}
  , PW = {
    prefix: "fas",
    iconName: "bars",
    icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"]
}
  , OW = {
    prefix: "fas",
    iconName: "circle-exclamation",
    icon: [512, 512, ["exclamation-circle"], "f06a", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c13.3 0 24 10.7 24 24V264c0 13.3-10.7 24-24 24s-24-10.7-24-24V152c0-13.3 10.7-24 24-24zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"]
}
  , NW = {
    prefix: "fas",
    iconName: "volume-low",
    icon: [448, 512, [128264, "volume-down"], "f027", "M301.1 34.8C312.6 40 320 51.4 320 64V448c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h67.8L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3zM412.6 181.5C434.1 199.1 448 225.9 448 256s-13.9 56.9-35.4 74.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C393.1 284.4 400 271 400 256s-6.9-28.4-17.7-37.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5z"]
}
  , RW = {
    prefix: "fas",
    iconName: "gamepad",
    icon: [640, 512, [], "f11b", "M192 64C86 64 0 150 0 256S86 448 192 448H448c106 0 192-86 192-192s-86-192-192-192H192zM496 248c-22.1 0-40-17.9-40-40s17.9-40 40-40s40 17.9 40 40s-17.9 40-40 40zm-24 56c0 22.1-17.9 40-40 40s-40-17.9-40-40s17.9-40 40-40s40 17.9 40 40zM168 200c0-13.3 10.7-24 24-24s24 10.7 24 24v32h32c13.3 0 24 10.7 24 24s-10.7 24-24 24H216v32c0 13.3-10.7 24-24 24s-24-10.7-24-24V280H136c-13.3 0-24-10.7-24-24s10.7-24 24-24h32V200z"]
}
  , DW = {
    prefix: "fas",
    iconName: "angle-right",
    icon: [256, 512, [8250], "f105", "M246.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L178.7 256 41.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"]
}
  , BW = {
    prefix: "fas",
    iconName: "user",
    icon: [448, 512, [128100, 62144], "f007", "M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512H418.3c16.4 0 29.7-13.3 29.7-29.7C448 383.8 368.2 304 269.7 304H178.3z"]
}
  , LW = {
    prefix: "fas",
    iconName: "ban",
    icon: [512, 512, [128683, "cancel"], "f05e", "M367.2 412.5L99.5 144.8C77.1 176.1 64 214.5 64 256c0 106 86 192 192 192c41.5 0 79.9-13.1 111.2-35.5zm45.3-45.3C434.9 335.9 448 297.5 448 256c0-106-86-192-192-192c-41.5 0-79.9 13.1-111.2 35.5L412.5 367.2zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256z"]
}
  , FW = {
    prefix: "fas",
    iconName: "repeat",
    icon: [512, 512, [128257], "f363", "M0 224c0 17.7 14.3 32 32 32s32-14.3 32-32c0-53 43-96 96-96H320v32c0 12.9 7.8 24.6 19.8 29.6s25.7 2.2 34.9-6.9l64-64c12.5-12.5 12.5-32.8 0-45.3l-64-64c-9.2-9.2-22.9-11.9-34.9-6.9S320 19.1 320 32V64H160C71.6 64 0 135.6 0 224zm512 64c0-17.7-14.3-32-32-32s-32 14.3-32 32c0 53-43 96-96 96H192V352c0-12.9-7.8-24.6-19.8-29.6s-25.7-2.2-34.9 6.9l-64 64c-12.5 12.5-12.5 32.8 0 45.3l64 64c9.2 9.2 22.9 11.9 34.9 6.9s19.8-16.6 19.8-29.6V448H352c88.4 0 160-71.6 160-160z"]
}
  , jW = {
    prefix: "fas",
    iconName: "shuffle",
    icon: [512, 512, [128256, "random"], "f074", "M403.8 34.4c12-5 25.7-2.2 34.9 6.9l64 64c6 6 9.4 14.1 9.4 22.6s-3.4 16.6-9.4 22.6l-64 64c-9.2 9.2-22.9 11.9-34.9 6.9s-19.8-16.6-19.8-29.6V160H352c-10.1 0-19.6 4.7-25.6 12.8L284 229.3 244 176l31.2-41.6C293.3 110.2 321.8 96 352 96h32V64c0-12.9 7.8-24.6 19.8-29.6zM164 282.7L204 336l-31.2 41.6C154.7 401.8 126.2 416 96 416H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H96c10.1 0 19.6-4.7 25.6-12.8L164 282.7zm274.6 188c-9.2 9.2-22.9 11.9-34.9 6.9s-19.8-16.6-19.8-29.6V416H352c-30.2 0-58.7-14.2-76.8-38.4L121.6 172.8c-6-8.1-15.5-12.8-25.6-12.8H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H96c30.2 0 58.7 14.2 76.8 38.4L326.4 339.2c6 8.1 15.5 12.8 25.6 12.8h32V320c0-12.9 7.8-24.6 19.8-29.6s25.7-2.2 34.9 6.9l64 64c6 6 9.4 14.1 9.4 22.6s-3.4 16.6-9.4 22.6l-64 64z"]
}
  , UW = {
    prefix: "fas",
    iconName: "right-to-bracket",
    icon: [512, 512, ["sign-in-alt"], "f2f6", "M217.9 105.9L340.7 228.7c7.2 7.2 11.3 17.1 11.3 27.3s-4.1 20.1-11.3 27.3L217.9 406.1c-6.4 6.4-15 9.9-24 9.9c-18.7 0-33.9-15.2-33.9-33.9l0-62.1L32 320c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32l128 0 0-62.1c0-18.7 15.2-33.9 33.9-33.9c9 0 17.6 3.6 24 9.9zM352 416l64 0c17.7 0 32-14.3 32-32l0-256c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l64 0c53 0 96 43 96 96l0 256c0 53-43 96-96 96l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z"]
}
  , zW = {
    prefix: "fas",
    iconName: "gift",
    icon: [512, 512, [127873], "f06b", "M190.5 68.8L225.3 128H224 152c-22.1 0-40-17.9-40-40s17.9-40 40-40h2.2c14.9 0 28.8 7.9 36.3 20.8zM64 88c0 14.4 3.5 28 9.6 40H32c-17.7 0-32 14.3-32 32v64c0 17.7 14.3 32 32 32H480c17.7 0 32-14.3 32-32V160c0-17.7-14.3-32-32-32H438.4c6.1-12 9.6-25.6 9.6-40c0-48.6-39.4-88-88-88h-2.2c-31.9 0-61.5 16.9-77.7 44.4L256 85.5l-24.1-41C215.7 16.9 186.1 0 154.2 0H152C103.4 0 64 39.4 64 88zm336 0c0 22.1-17.9 40-40 40H288h-1.3l34.8-59.2C329.1 55.9 342.9 48 357.8 48H360c22.1 0 40 17.9 40 40zM32 288V464c0 26.5 21.5 48 48 48H224V288H32zM288 512H432c26.5 0 48-21.5 48-48V288H288V512z"]
}
  , VW = {
    prefix: "fas",
    iconName: "circle-check",
    icon: [512, 512, [61533, "check-circle"], "f058", "M256 512c141.4 0 256-114.6 256-256S397.4 0 256 0S0 114.6 0 256S114.6 512 256 512zM369 209L241 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L335 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z"]
}
  , WW = {
    prefix: "fas",
    iconName: "circle-stop",
    icon: [512, 512, [62094, "stop-circle"], "f28d", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM192 160H320c17.7 0 32 14.3 32 32V320c0 17.7-14.3 32-32 32H192c-17.7 0-32-14.3-32-32V192c0-17.7 14.3-32 32-32z"]
}
  , YW = {
    prefix: "fas",
    iconName: "arrows-rotate",
    icon: [512, 512, [128472, "refresh", "sync"], "f021", "M89.1 202.6c7.7-21.8 20.2-42.3 37.8-59.8c62.5-62.5 163.8-62.5 226.3 0L370.3 160H320c-17.7 0-32 14.3-32 32s14.3 32 32 32H447.5c0 0 0 0 0 0h.4c17.7 0 32-14.3 32-32V64c0-17.7-14.3-32-32-32s-32 14.3-32 32v51.2L398.4 97.6c-87.5-87.5-229.3-87.5-316.8 0C57.2 122 39.6 150.7 28.8 181.4c-5.9 16.7 2.9 34.9 19.5 40.8s34.9-2.9 40.8-19.5zM23 289.3c-5 1.5-9.8 4.2-13.7 8.2c-4 4-6.7 8.8-8.1 14c-.3 1.2-.6 2.5-.8 3.8c-.3 1.7-.4 3.4-.4 5.1V448c0 17.7 14.3 32 32 32s32-14.3 32-32V396.9l17.6 17.5 0 0c87.5 87.4 229.3 87.4 316.7 0c24.4-24.4 42.1-53.1 52.9-83.7c5.9-16.7-2.9-34.9-19.5-40.8s-34.9 2.9-40.8 19.5c-7.7 21.8-20.2 42.3-37.8 59.8c-62.5 62.5-163.8 62.5-226.3 0l-.1-.1L109.6 352H160c17.7 0 32-14.3 32-32s-14.3-32-32-32H32.4c-1.6 0-3.2 .1-4.8 .3s-3.1 .5-4.6 1z"]
}
  , HW = YW
  , $W = {
    prefix: "fas",
    iconName: "arrow-right",
    icon: [448, 512, [8594], "f061", "M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"]
}
  , GW = {
    prefix: "fas",
    iconName: "heart",
    icon: [512, 512, [128153, 128154, 128155, 128156, 128420, 129293, 129294, 129505, 9829, 10084, 61578], "f004", "M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"]
}
  , XW = {
    prefix: "fas",
    iconName: "circle-question",
    icon: [512, 512, [62108, "question-circle"], "f059", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM169.8 165.3c7.9-22.3 29.1-37.3 52.8-37.3h58.3c34.9 0 63.1 28.3 63.1 63.1c0 22.6-12.1 43.5-31.7 54.8L280 264.4c-.2 13-10.9 23.6-24 23.6c-13.3 0-24-10.7-24-24V250.5c0-8.6 4.6-16.5 12.1-20.8l44.3-25.4c4.7-2.7 7.6-7.7 7.6-13.1c0-8.4-6.8-15.1-15.1-15.1H222.6c-3.4 0-6.4 2.1-7.5 5.3l-.4 1.2c-4.4 12.5-18.2 19-30.6 14.6s-19-18.2-14.6-30.6l.4-1.2zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"]
}
  , qW = {
    prefix: "fas",
    iconName: "code-branch",
    icon: [448, 512, [], "f126", "M80 104c13.3 0 24-10.7 24-24s-10.7-24-24-24S56 66.7 56 80s10.7 24 24 24zm80-24c0 32.8-19.7 61-48 73.3v87.8c18.8-10.9 40.7-17.1 64-17.1h96c35.3 0 64-28.7 64-64v-6.7C307.7 141 288 112.8 288 80c0-44.2 35.8-80 80-80s80 35.8 80 80c0 32.8-19.7 61-48 73.3V160c0 70.7-57.3 128-128 128H176c-35.3 0-64 28.7-64 64v6.7c28.3 12.3 48 40.5 48 73.3c0 44.2-35.8 80-80 80s-80-35.8-80-80c0-32.8 19.7-61 48-73.3V352 153.3C19.7 141 0 112.8 0 80C0 35.8 35.8 0 80 0s80 35.8 80 80zm232 0c0-13.3-10.7-24-24-24s-24 10.7-24 24s10.7 24 24 24s24-10.7 24-24zM80 456c13.3 0 24-10.7 24-24s-10.7-24-24-24s-24 10.7-24 24s10.7 24 24 24z"]
}
  , KW = {
    prefix: "fas",
    iconName: "hand-holding-dollar",
    icon: [576, 512, ["hand-holding-usd"], "f4c0", "M312 24V34.5c6.4 1.2 12.6 2.7 18.2 4.2c12.8 3.4 20.4 16.6 17 29.4s-16.6 20.4-29.4 17c-10.9-2.9-21.1-4.9-30.2-5c-7.3-.1-14.7 1.7-19.4 4.4c-2.1 1.3-3.1 2.4-3.5 3c-.3 .5-.7 1.2-.7 2.8c0 .3 0 .5 0 .6c.2 .2 .9 1.2 3.3 2.6c5.8 3.5 14.4 6.2 27.4 10.1l.9 .3 0 0c11.1 3.3 25.9 7.8 37.9 15.3c13.7 8.6 26.1 22.9 26.4 44.9c.3 22.5-11.4 38.9-26.7 48.5c-6.7 4.1-13.9 7-21.3 8.8V232c0 13.3-10.7 24-24 24s-24-10.7-24-24V220.6c-9.5-2.3-18.2-5.3-25.6-7.8c-2.1-.7-4.1-1.4-6-2c-12.6-4.2-19.4-17.8-15.2-30.4s17.8-19.4 30.4-15.2c2.6 .9 5 1.7 7.3 2.5c13.6 4.6 23.4 7.9 33.9 8.3c8 .3 15.1-1.6 19.2-4.1c1.9-1.2 2.8-2.2 3.2-2.9c.4-.6 .9-1.8 .8-4.1l0-.2c0-1 0-2.1-4-4.6c-5.7-3.6-14.3-6.4-27.1-10.3l-1.9-.6c-10.8-3.2-25-7.5-36.4-14.4c-13.5-8.1-26.5-22-26.6-44.1c-.1-22.9 12.9-38.6 27.7-47.4c6.4-3.8 13.3-6.4 20.2-8.2V24c0-13.3 10.7-24 24-24s24 10.7 24 24zM568.2 336.3c13.1 17.8 9.3 42.8-8.5 55.9L433.1 485.5c-23.4 17.2-51.6 26.5-80.7 26.5H192 32c-17.7 0-32-14.3-32-32V416c0-17.7 14.3-32 32-32H68.8l44.9-36c22.7-18.2 50.9-28 80-28H272h16 64c17.7 0 32 14.3 32 32s-14.3 32-32 32H288 272c-8.8 0-16 7.2-16 16s7.2 16 16 16H392.6l119.7-88.2c17.8-13.1 42.8-9.3 55.9 8.5zM193.6 384l0 0-.9 0c.3 0 .6 0 .9 0z"]
}
  , QW = {
    prefix: "fas",
    iconName: "trash",
    icon: [448, 512, [], "f1f8", "M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 46.3-19.7 47.9-45L416 128z"]
}
  , ZW = {
    prefix: "fas",
    iconName: "cubes",
    icon: [640, 512, [], "f1b3", "M273.8 45.8l73.7 28L271.2 103 194.8 73.7l73.7-28c1.7-.7 3.6-.7 5.3 0zM128.1 87.1V192.6c-1.2 .4-2.4 .8-3.6 1.2L34.1 228.1c-20.5 7.8-34 27.4-34 49.3V389.5c0 20.9 12.4 39.8 31.5 48.3L122 477.5c13.5 5.9 28.9 5.9 42.4 0l106.8-46.9L378 477.5c13.5 5.9 28.9 5.9 42.4 0l90.4-39.7c19.1-8.4 31.5-27.3 31.5-48.3V277.4c0-21.9-13.5-41.5-34-49.3l-90.4-34.3c-1.2-.5-2.4-.9-3.6-1.2V87.1c0-21.9-13.5-41.5-34-49.3L289.9 3.5c-12-4.6-25.3-4.6-37.4 0L162.1 37.8c-20.5 7.8-34 27.4-34 49.3zM369.1 198.2l-77.5 29.4v-84l77.5-29.7v84.3zM145.8 236.1l73.7 28-76.4 29.3L66.8 264.1l73.7-28c1.7-.7 3.6-.7 5.3 0zm17.7 192.4V333.9l77.5-29.7v90.2l-77.5 34.1zm233-192.4c1.7-.7 3.6-.7 5.3 0l73.7 28-76.4 29.3-76.4-29.3 73.7-28zm96.1 160.3l-73 32.1V333.9l77.5-29.7v85.3c0 3-1.8 5.7-4.5 6.9z"]
}
  , JW = {
    prefix: "fas",
    iconName: "arrow-left",
    icon: [448, 512, [8592], "f060", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"]
}
  , tY = {
    prefix: "fas",
    iconName: "align-left",
    icon: [448, 512, [], "f036", "M288 64c0 17.7-14.3 32-32 32H32C14.3 96 0 81.7 0 64S14.3 32 32 32H256c17.7 0 32 14.3 32 32zm0 256c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H256c17.7 0 32 14.3 32 32zM0 192c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 448c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"]
}
  , eY = {
    prefix: "fas",
    iconName: "circle-info",
    icon: [512, 512, ["info-circle"], "f05a", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336h24V272H216c-13.3 0-24-10.7-24-24s10.7-24 24-24h48c13.3 0 24 10.7 24 24v88h8c13.3 0 24 10.7 24 24s-10.7 24-24 24H216c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"]
}
  , nY = {
    prefix: "fas",
    iconName: "gear",
    icon: [512, 512, [9881, "cog"], "f013", "M481.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-30.9 28.1c-7.7 7.1-11.4 17.5-10.9 27.9c.1 2.9 .2 5.8 .2 8.8s-.1 5.9-.2 8.8c-.5 10.5 3.1 20.9 10.9 27.9l30.9 28.1c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-39.7-12.6c-10-3.2-20.8-1.1-29.7 4.6c-4.9 3.1-9.9 6.1-15.1 8.7c-9.3 4.8-16.5 13.2-18.8 23.4l-8.9 40.7c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-8.9-40.7c-2.2-10.2-9.5-18.6-18.8-23.4c-5.2-2.7-10.2-5.6-15.1-8.7c-8.8-5.7-19.7-7.8-29.7-4.6L69.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l30.9-28.1c7.7-7.1 11.4-17.5 10.9-27.9c-.1-2.9-.2-5.8-.2-8.8s.1-5.9 .2-8.8c.5-10.5-3.1-20.9-10.9-27.9L8.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l39.7 12.6c10 3.2 20.8 1.1 29.7-4.6c4.9-3.1 9.9-6.1 15.1-8.7c9.3-4.8 16.5-13.2 18.8-23.4l8.9-40.7c2-9.1 9-16.3 18.2-17.8C213.3 1.2 227.5 0 242 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l8.9 40.7c2.2 10.2 9.4 18.6 18.8 23.4c5.2 2.7 10.2 5.6 15.1 8.7c8.8 5.7 19.7 7.7 29.7 4.6l39.7-12.6c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM242 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"]
}
  , rY = nY
  , iY = {
    prefix: "fas",
    iconName: "coins",
    icon: [512, 512, [], "f51e", "M512 80c0 18-14.3 34.6-38.4 48c-29.1 16.1-72.5 27.5-122.3 30.9c-3.7-1.8-7.4-3.5-11.3-5C300.6 137.4 248.2 128 192 128c-8.3 0-16.4 .2-24.5 .6l-1.1-.6C142.3 114.6 128 98 128 80c0-44.2 86-80 192-80S512 35.8 512 80zM160.7 161.1c10.2-.7 20.7-1.1 31.3-1.1c62.2 0 117.4 12.3 152.5 31.4C369.3 204.9 384 221.7 384 240c0 4-.7 7.9-2.1 11.7c-4.6 13.2-17 25.3-35 35.5c0 0 0 0 0 0c-.1 .1-.3 .1-.4 .2l0 0 0 0c-.3 .2-.6 .3-.9 .5c-35 19.4-90.8 32-153.6 32c-59.6 0-112.9-11.3-148.2-29.1c-1.9-.9-3.7-1.9-5.5-2.9C14.3 274.6 0 258 0 240c0-34.8 53.4-64.5 128-75.4c10.5-1.5 21.4-2.7 32.7-3.5zM416 240c0-21.9-10.6-39.9-24.1-53.4c28.3-4.4 54.2-11.4 76.2-20.5c16.3-6.8 31.5-15.2 43.9-25.5V176c0 19.3-16.5 37.1-43.8 50.9c-14.6 7.4-32.4 13.7-52.4 18.5c.1-1.8 .2-3.5 .2-5.3zm-32 96c0 18-14.3 34.6-38.4 48c-1.8 1-3.6 1.9-5.5 2.9C304.9 404.7 251.6 416 192 416c-62.8 0-118.6-12.6-153.6-32C14.3 370.6 0 354 0 336V300.6c12.5 10.3 27.6 18.7 43.9 25.5C83.4 342.6 135.8 352 192 352s108.6-9.4 148.1-25.9c7.8-3.2 15.3-6.9 22.4-10.9c6.1-3.4 11.8-7.2 17.2-11.2c1.5-1.1 2.9-2.3 4.3-3.4V304v5.7V336zm32 0V304 278.1c19-4.2 36.5-9.5 52.1-16c16.3-6.8 31.5-15.2 43.9-25.5V272c0 10.5-5 21-14.9 30.9c-16.3 16.3-45 29.7-81.3 38.4c.1-1.7 .2-3.5 .2-5.3zM192 448c56.2 0 108.6-9.4 148.1-25.9c16.3-6.8 31.5-15.2 43.9-25.5V432c0 44.2-86 80-192 80S0 476.2 0 432V396.6c12.5 10.3 27.6 18.7 43.9 25.5C83.4 438.6 135.8 448 192 448z"]
}
  , sY = {
    prefix: "fas",
    iconName: "book-skull",
    icon: [448, 512, ["book-dead"], "f6b7", "M0 96C0 43 43 0 96 0H384h32c17.7 0 32 14.3 32 32V352c0 17.7-14.3 32-32 32v64c17.7 0 32 14.3 32 32s-14.3 32-32 32H384 96c-53 0-96-43-96-96V96zM64 416c0 17.7 14.3 32 32 32H352V384H96c-17.7 0-32 14.3-32 32zM320 112c0-35.3-35.8-64-80-64s-80 28.7-80 64c0 20.9 12.6 39.5 32 51.2V176c0 8.8 7.2 16 16 16h64c8.8 0 16-7.2 16-16V163.2c19.4-11.7 32-30.3 32-51.2zM208 96a16 16 0 1 1 0 32 16 16 0 1 1 0-32zm48 16a16 16 0 1 1 32 0 16 16 0 1 1 -32 0zM134.3 209.3c-8.1-3.5-17.5 .3-21 8.4s.3 17.5 8.4 21L199.4 272l-77.7 33.3c-8.1 3.5-11.9 12.9-8.4 21s12.9 11.9 21 8.4L240 289.4l105.7 45.3c8.1 3.5 17.5-.3 21-8.4s-.3-17.5-8.4-21L280.6 272l77.7-33.3c8.1-3.5 11.9-12.9 8.4-21s-12.9-11.9-21-8.4L240 254.6 134.3 209.3z"]
}
  , oY = {
    prefix: "fas",
    iconName: "house",
    icon: [576, 512, [127968, 63498, 63500, "home", "home-alt", "home-lg-alt"], "f015", "M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"]
}
  , aY = {
    prefix: "fas",
    iconName: "skull",
    icon: [512, 512, [128128], "f54c", "M416 398.9c58.5-41.1 96-104.1 96-174.9C512 100.3 397.4 0 256 0S0 100.3 0 224c0 70.7 37.5 133.8 96 174.9c0 .4 0 .7 0 1.1v64c0 26.5 21.5 48 48 48h48V464c0-8.8 7.2-16 16-16s16 7.2 16 16v48h64V464c0-8.8 7.2-16 16-16s16 7.2 16 16v48h48c26.5 0 48-21.5 48-48V400c0-.4 0-.7 0-1.1zM96 256a64 64 0 1 1 128 0A64 64 0 1 1 96 256zm256-64a64 64 0 1 1 0 128 64 64 0 1 1 0-128z"]
}
  , lY = {
    prefix: "fas",
    iconName: "volume-xmark",
    icon: [576, 512, ["volume-mute", "volume-times"], "f6a9", "M301.1 34.8C312.6 40 320 51.4 320 64V448c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h67.8L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3zM425 167l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0z"]
}
  , cY = {
    prefix: "fas",
    iconName: "xmark",
    icon: [320, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M310.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L160 210.7 54.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L114.7 256 9.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 301.3 265.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L205.3 256 310.6 150.6z"]
}
  , uY = {
    prefix: "fas",
    iconName: "retweet",
    icon: [576, 512, [], "f079", "M272 416c17.7 0 32-14.3 32-32s-14.3-32-32-32H160c-17.7 0-32-14.3-32-32V192h32c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-64-64c-12.5-12.5-32.8-12.5-45.3 0l-64 64c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l32 0 0 128c0 53 43 96 96 96H272zM304 96c-17.7 0-32 14.3-32 32s14.3 32 32 32l112 0c17.7 0 32 14.3 32 32l0 128H416c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l64 64c12.5 12.5 32.8 12.5 45.3 0l64-64c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8l-32 0V192c0-53-43-96-96-96L304 96z"]
}
  , hY = {
    prefix: "fas",
    iconName: "trophy",
    icon: [576, 512, [127942], "f091", "M400 0H176c-26.5 0-48.1 21.8-47.1 48.2c.2 5.3 .4 10.6 .7 15.8H24C10.7 64 0 74.7 0 88c0 92.6 33.5 157 78.5 200.7c44.3 43.1 98.3 64.8 138.1 75.8c23.4 6.5 39.4 26 39.4 45.6c0 20.9-17 37.9-37.9 37.9H192c-17.7 0-32 14.3-32 32s14.3 32 32 32H384c17.7 0 32-14.3 32-32s-14.3-32-32-32H357.9C337 448 320 431 320 410.1c0-19.6 15.9-39.2 39.4-45.6c39.9-11 93.9-32.7 138.2-75.8C542.5 245 576 180.6 576 88c0-13.3-10.7-24-24-24H446.4c.3-5.2 .5-10.4 .7-15.8C448.1 21.8 426.5 0 400 0zM48.9 112h84.4c9.1 90.1 29.2 150.3 51.9 190.6c-24.9-11-50.8-26.5-73.2-48.3c-32-31.1-58-76-63-142.3zM464.1 254.3c-22.4 21.8-48.3 37.3-73.2 48.3c22.7-40.3 42.8-100.5 51.9-190.6h84.4c-5.1 66.3-31.1 111.2-63 142.3z"]
}
  , dY = {
    prefix: "fas",
    iconName: "award",
    icon: [384, 512, [], "f559", "M173.8 5.5c11-7.3 25.4-7.3 36.4 0L228 17.2c6 3.9 13 5.8 20.1 5.4l21.3-1.3c13.2-.8 25.6 6.4 31.5 18.2l9.6 19.1c3.2 6.4 8.4 11.5 14.7 14.7L344.5 83c11.8 5.9 19 18.3 18.2 31.5l-1.3 21.3c-.4 7.1 1.5 14.2 5.4 20.1l11.8 17.8c7.3 11 7.3 25.4 0 36.4L366.8 228c-3.9 6-5.8 13-5.4 20.1l1.3 21.3c.8 13.2-6.4 25.6-18.2 31.5l-19.1 9.6c-6.4 3.2-11.5 8.4-14.7 14.7L301 344.5c-5.9 11.8-18.3 19-31.5 18.2l-21.3-1.3c-7.1-.4-14.2 1.5-20.1 5.4l-17.8 11.8c-11 7.3-25.4 7.3-36.4 0L156 366.8c-6-3.9-13-5.8-20.1-5.4l-21.3 1.3c-13.2 .8-25.6-6.4-31.5-18.2l-9.6-19.1c-3.2-6.4-8.4-11.5-14.7-14.7L39.5 301c-11.8-5.9-19-18.3-18.2-31.5l1.3-21.3c.4-7.1-1.5-14.2-5.4-20.1L5.5 210.2c-7.3-11-7.3-25.4 0-36.4L17.2 156c3.9-6 5.8-13 5.4-20.1l-1.3-21.3c-.8-13.2 6.4-25.6 18.2-31.5l19.1-9.6C65 70.2 70.2 65 73.4 58.6L83 39.5c5.9-11.8 18.3-19 31.5-18.2l21.3 1.3c7.1 .4 14.2-1.5 20.1-5.4L173.8 5.5zM272 192a80 80 0 1 0 -160 0 80 80 0 1 0 160 0zM1.3 441.8L44.4 339.3c.2 .1 .3 .2 .4 .4l9.6 19.1c11.7 23.2 36 37.3 62 35.8l21.3-1.3c.2 0 .5 0 .7 .2l17.8 11.8c5.1 3.3 10.5 5.9 16.1 7.7l-37.6 89.3c-2.3 5.5-7.4 9.2-13.3 9.7s-11.6-2.2-14.8-7.2L74.4 455.5l-56.1 8.3c-5.7 .8-11.4-1.5-15-6s-4.3-10.7-2.1-16zm248 60.4L211.7 413c5.6-1.8 11-4.3 16.1-7.7l17.8-11.8c.2-.1 .4-.2 .7-.2l21.3 1.3c26 1.5 50.3-12.6 62-35.8l9.6-19.1c.1-.2 .2-.3 .4-.4l43.2 102.5c2.2 5.3 1.4 11.4-2.1 16s-9.3 6.9-15 6l-56.1-8.3-32.2 49.2c-3.2 5-8.9 7.7-14.8 7.2s-11-4.3-13.3-9.7z"]
}
  , fY = {
    prefix: "fas",
    iconName: "broom",
    icon: [576, 512, [129529], "f51a", "M566.6 54.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192-34.7-34.7c-4.2-4.2-10-6.6-16-6.6c-12.5 0-22.6 10.1-22.6 22.6v29.1L364.3 320h29.1c12.5 0 22.6-10.1 22.6-22.6c0-6-2.4-11.8-6.6-16l-34.7-34.7 192-192zM341.1 353.4L222.6 234.9c-42.7-3.7-85.2 11.7-115.8 42.3l-8 8C76.5 307.5 64 337.7 64 369.2c0 6.8 7.1 11.2 13.2 8.2l51.1-25.5c5-2.5 9.5 4.1 5.4 7.9L7.3 473.4C2.7 477.6 0 483.6 0 489.9C0 502.1 9.9 512 22.1 512l173.3 0c38.8 0 75.9-15.4 103.4-42.8c30.6-30.6 45.9-73.1 42.3-115.8z"]
}
  , pY = {
    prefix: "fas",
    iconName: "infinity",
    icon: [640, 512, [8734, 9854], "f534", "M0 241.1C0 161 65 96 145.1 96c38.5 0 75.4 15.3 102.6 42.5L320 210.7l72.2-72.2C419.5 111.3 456.4 96 494.9 96C575 96 640 161 640 241.1v29.7C640 351 575 416 494.9 416c-38.5 0-75.4-15.3-102.6-42.5L320 301.3l-72.2 72.2C220.5 400.7 183.6 416 145.1 416C65 416 0 351 0 270.9V241.1zM274.7 256l-72.2-72.2c-15.2-15.2-35.9-23.8-57.4-23.8C100.3 160 64 196.3 64 241.1v29.7c0 44.8 36.3 81.1 81.1 81.1c21.5 0 42.2-8.5 57.4-23.8L274.7 256zm90.5 0l72.2 72.2c15.2 15.2 35.9 23.8 57.4 23.8c44.8 0 81.1-36.3 81.1-81.1V241.1c0-44.8-36.3-81.1-81.1-81.1c-21.5 0-42.2 8.5-57.4 23.8L365.3 256z"]
}
  , mY = {
    prefix: "fas",
    iconName: "up-down",
    icon: [256, 512, [8597, 11021, "arrows-alt-v"], "f338", "M145.6 7.7C141 2.8 134.7 0 128 0s-13 2.8-17.6 7.7l-104 112c-6.5 7-8.2 17.2-4.4 25.9S14.5 160 24 160H80V352H24c-9.5 0-18.2 5.7-22 14.4s-2.1 18.9 4.4 25.9l104 112c4.5 4.9 10.9 7.7 17.6 7.7s13-2.8 17.6-7.7l104-112c6.5-7 8.2-17.2 4.4-25.9s-12.5-14.4-22-14.4H176V160h56c9.5 0 18.2-5.7 22-14.4s2.1-18.9-4.4-25.9l-104-112z"]
}
  , gY = {
    prefix: "fas",
    iconName: "circle-plus",
    icon: [512, 512, ["plus-circle"], "f055", "M256 512c141.4 0 256-114.6 256-256S397.4 0 256 0S0 114.6 0 256S114.6 512 256 512zM232 344V280H168c-13.3 0-24-10.7-24-24s10.7-24 24-24h64V168c0-13.3 10.7-24 24-24s24 10.7 24 24v64h64c13.3 0 24 10.7 24 24s-10.7 24-24 24H280v64c0 13.3-10.7 24-24 24s-24-10.7-24-24z"]
}
  , yY = {
    prefix: "fas",
    iconName: "user-plus",
    icon: [640, 512, [], "f234", "M96 128a128 128 0 1 1 256 0A128 128 0 1 1 96 128zM0 482.3C0 383.8 79.8 304 178.3 304h91.4C368.2 304 448 383.8 448 482.3c0 16.4-13.3 29.7-29.7 29.7H29.7C13.3 512 0 498.7 0 482.3zM504 312V248H440c-13.3 0-24-10.7-24-24s10.7-24 24-24h64V136c0-13.3 10.7-24 24-24s24 10.7 24 24v64h64c13.3 0 24 10.7 24 24s-10.7 24-24 24H552v64c0 13.3-10.7 24-24 24s-24-10.7-24-24z"]
}
  , bY = {
    prefix: "fas",
    iconName: "paper-plane",
    icon: [512, 512, [61913], "f1d8", "M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480V396.4c0-4 1.5-7.8 4.2-10.7L331.8 202.8c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8 17.7 316.6C7.1 311.3 .3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4z"]
}
  , vY = {
    prefix: "fas",
    iconName: "handshake-simple",
    icon: [640, 512, [129309, "handshake-alt"], "f4c6", "M323.4 85.2l-96.8 78.4c-16.1 13-19.2 36.4-7 53.1c12.9 17.8 38 21.3 55.3 7.8l99.3-77.2c7-5.4 17-4.2 22.5 2.8s4.2 17-2.8 22.5l-20.9 16.2L550.2 352H592c26.5 0 48-21.5 48-48V176c0-26.5-21.5-48-48-48H516h-4-.7l-3.9-2.5L434.8 79c-15.3-9.8-33.2-15-51.4-15c-21.8 0-43 7.5-60 21.2zm22.8 124.4l-51.7 40.2C263 274.4 217.3 268 193.7 235.6c-22.2-30.5-16.6-73.1 12.7-96.8l83.2-67.3c-11.6-4.9-24.1-7.4-36.8-7.4C234 64 215.7 69.6 200 80l-72 48H48c-26.5 0-48 21.5-48 48V304c0 26.5 21.5 48 48 48H156.2l91.4 83.4c19.6 17.9 49.9 16.5 67.8-3.1c5.5-6.1 9.2-13.2 11.1-20.6l17 15.6c19.5 17.9 49.9 16.6 67.8-2.9c4.5-4.9 7.8-10.6 9.9-16.5c19.4 13 45.8 10.3 62.1-7.5c17.9-19.5 16.6-49.9-2.9-67.8l-134.2-123z"]
};
ya.add(RW, PW, ZW, sY, vY, oY, AW, GW, uY, zW, IW, rY, SW, VW, OW, eY, cY, MW, yY, XW, zW, tY, gY, SW, kW, DW, bY, CW, HW, iY, QW, lY, NW, mY, BW, $W, hY, JW, UW, LW, FW, pY, qW, jW, fY, WW, dY, aY, TW, KW, _W);
const wY = document.getElementById("react");
if (wY) {
    l(wY).render((0,
    a.jsx)(EW, {}))
}
//# sourceMappingURL=index.2b7070b3.js.map
